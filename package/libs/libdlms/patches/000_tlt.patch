diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2024-01-23 14:13:59.000000000 +0000
+++ src/.gitignore	2024-06-19 13:37:18.000000000 +0000
@@ -251,3 +251,6 @@
 *.raw
 *.vsidx
 *.lock
+development/VS/.vs/
+GuruxDLMSClientExample/VS/.vs/
+*.json
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSClientExample/src/communication.c src/GuruxDLMSClientExample/src/communication.c
--- upstream/GuruxDLMSClientExample/src/communication.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSClientExample/src/communication.c	2024-06-19 13:37:18.000000000 +0000
@@ -919,10 +919,6 @@
     {
         message messages;
         gxReplyData reply;
-        if (dlms_usePreEstablishedConnection(&connection->settings) != NULL)
-        {
-            connection->settings.negotiatedConformance |= DLMS_CONFORMANCE_GENERAL_PROTECTION;
-        }
         unsigned short add = connection->settings.clientAddress;
         DLMS_AUTHENTICATION auth = connection->settings.authentication;
         DLMS_SECURITY security = connection->settings.cipher.security;
@@ -1008,6 +1004,10 @@
             bb_set(&connection->settings.ctoSChallenge, challenge.data, challenge.size);
             bb_clear(&challenge);
             connection->settings.preEstablishedSystemTitle = preEstablishedSystemTitle;
+            if (dlms_usePreEstablishedConnection(&connection->settings) != NULL)
+            {
+                connection->settings.negotiatedConformance |= DLMS_CONFORMANCE_GENERAL_PROTECTION;
+            }
         }
     }
     return ret;
@@ -1256,6 +1256,7 @@
                     (ret = cosem_init2(pObj, obj.objectType, obj.logicalName)) == 0)
                 {
                     pObj->shortName = obj.shortName;
+                    pObj->version = obj.version;
                     oa_push(&connection->settings.objects, pObj);
                 }
             }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSClientExample/src/main.c src/GuruxDLMSClientExample/src/main.c
--- upstream/GuruxDLMSClientExample/src/main.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSClientExample/src/main.c	2024-06-19 13:37:18.000000000 +0000
@@ -135,6 +135,37 @@
     return ret;
 }
 
+/**
+* Activates and strengthens the security policy
+  for the security setup object
+*/
+int SecurityActivate(connection* connection,
+    DLMS_SECURITY_POLICY policy)
+{
+    int ret;
+    gxSecuritySetup ss;
+    unsigned char ln[] = { 0,0,43,0,0,255 };
+    INIT_OBJECT(ss, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln);
+    //Invokes capture action.
+    dlmsVARIANT param;
+    var_setEnum(&param, policy);
+    GX_ENUM(param) = policy;
+    ret = com_method(connection, BASE(ss), 1, &param);
+    return ret;
+}
+
+// Show PDU before it's encrypted or 
+// after it's decrypted when DLMS_TRACE_PDU
+// is defined.
+void cip_tracePdu(
+    unsigned char encrypt,
+    gxByteBuffer* pdu)
+{
+    const char* direction = encrypt ? "TX" : "RX";
+    char* str = bb_toHexString(pdu);
+    printf("\r\n%s PDU: %s\r\n", direction, str);
+    free(str);
+}
 
 /**
 * Executes selected script.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/include/exampleserver.h src/GuruxDLMSServerExample/include/exampleserver.h
--- upstream/GuruxDLMSServerExample/include/exampleserver.h	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/include/exampleserver.h	2024-06-19 13:37:18.000000000 +0000
@@ -22,7 +22,7 @@
 
 #include "../../development/include/server.h"
 
-#if defined(_WIN32) | defined(_WIN64) || defined(__linux__)
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 #include "connection.h"
 char DATAFILE[FILENAME_MAX];
 char IMAGEFILE[FILENAME_MAX];
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/src/exampleserver.c src/GuruxDLMSServerExample/src/exampleserver.c
--- upstream/GuruxDLMSServerExample/src/exampleserver.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/src/exampleserver.c	2024-06-19 13:37:18.000000000 +0000
@@ -120,6 +120,7 @@
 static gxAssociationLogicalName associationLow;
 static gxAssociationLogicalName associationHigh;
 static gxAssociationLogicalName associationHighGMac;
+static gxAssociationLogicalName associationHighGMacPreEstablished;
 static gxRegister activePowerL1;
 static gxScriptTable scriptTableGlobalMeterReset;
 static gxScriptTable scriptTableDisconnectControl;
@@ -138,6 +139,8 @@
 static gxSecuritySetup securitySetupHigh;
 //Security Setup HighGMac is for GMac authentication.
 static gxSecuritySetup securitySetupHighGMac;
+//Security Setup HighGMac is for pre-established GMac authentication.
+static gxSecuritySetup securitySetupHighGMacPreEstablished;
 
 gxImageTransfer imageTransfer;
 gxAutoConnect autoConnect;
@@ -158,11 +161,16 @@
 gxLimiter limiter;
 gxG3PlcMacLayerCounters g3plcMacLayerCounters;
 gxG3PlcMacSetup g3PlcMacSetup;
+gxG3Plc6LoWPAN g3Plc6LoWPAN;
+gxArrayManager arrayManager;
 
 //static gxObject* NONE_OBJECTS[] = { BASE(associationNone), BASE(ldn) };
 
 static gxObject* ALL_OBJECTS[] = {
-    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac), BASE(securitySetupHigh), BASE(securitySetupHighGMac),
+    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac),
+    BASE(associationHighGMacPreEstablished),
+    BASE(securitySetupHigh), BASE(securitySetupHighGMac),BASE(securitySetupHighGMacPreEstablished),
+
     BASE(ldn), BASE(sapAssignment), BASE(eventCode),
     BASE(clock1), BASE(activePowerL1), BASE(pushSetup), BASE(scriptTableGlobalMeterReset), BASE(scriptTableDisconnectControl),
     BASE(scriptTableActivateTestMode), BASE(scriptTableActivateNormalMode), BASE(loadProfile), BASE(eventLog), BASE(hdlc),
@@ -171,7 +179,7 @@
     BASE(registerMonitor), BASE(autoAnswer), BASE(modemConfiguration), BASE(macAddressSetup), BASE(ip4Setup), BASE(pppSetup), BASE(gprsSetup),
     BASE(tarifficationScriptTable), BASE(registerActivation), BASE(limiter),
     BASE(mbusDiagnostic), BASE(mbusPortSetup),
-    BASE(g3plcMacLayerCounters), BASE(g3PlcMacSetup)
+    BASE(g3plcMacLayerCounters), BASE(g3PlcMacSetup), BASE(g3Plc6LoWPAN), BASE(arrayManager)
 };
 
 ////////////////////////////////////////////////////
@@ -760,6 +768,38 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
+//This method adds pre-established example 
+// Logical Name Association object for GMAC High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighGMacPreEstablished()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 5, 255 };
+    if ((ret = INIT_OBJECT(associationHighGMacPreEstablished, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighGMacPreEstablished.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
+        OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
+        associationHighGMacPreEstablished.clientSAP = 0x2;
+        associationHighGMacPreEstablished.xDLMSContextInfo.maxSendPduSize = associationHighGMacPreEstablished.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighGMacPreEstablished.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+            DLMS_CONFORMANCE_SET |
+            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+            DLMS_CONFORMANCE_ACTION |
+            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+            DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighGMacPreEstablished.securitySetup = &securitySetupHighGMacPreEstablished;
+#else
+        memcpy(associationHighGMacPreEstablished.securitySetupReference, securitySetupHigh.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
 //This method adds security setup object for High authentication.
 ///////////////////////////////////////////////////////////////////////
 int addSecuritySetupHigh()
@@ -799,6 +839,27 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for pre-established GMAC authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupPreEstablishedHighGMac()
+{
+    int ret;
+    //Define client system title for the pre-established connection.
+    //Pre-establiched system title is Gurux123
+    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0x47, 0x75, 0x72, 0x75, 0x78, 0x31, 0x32, 0x33 };
+    const unsigned char ln[6] = { 0, 0, 43, 0, 3, 255 };
+    if ((ret = INIT_OBJECT(securitySetupHighGMacPreEstablished, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighGMacPreEstablished.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        BB_ATTACH(securitySetupHighGMacPreEstablished.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
+        //Only Authenticated encrypted connections are allowed.
+        securitySetupHighGMacPreEstablished.securityPolicy = DLMS_SECURITY_POLICY_AUTHENTICATED_ENCRYPTED;
+        securitySetupHighGMacPreEstablished.securitySuite = DLMS_SECURITY_SUITE_V0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
 //This method adds example register object.
 ///////////////////////////////////////////////////////////////////////
 int addRegisterObject()
@@ -921,7 +982,7 @@
 
         GX_UINT16(limiter.thresholdActive) = 1000;
         GX_UINT16(limiter.thresholdEmergency) = 2000;
-        GX_UINT16(limiter.thresholdNormal) = 1000;        
+        GX_UINT16(limiter.thresholdNormal) = 1000;
         limiter.minOverThresholdDuration = 60;
         limiter.minUnderThresholdDuration = 60;
         //////////////////////
@@ -1624,7 +1685,7 @@
     //If no OS get IP.
 #endif
     return ret;
-}
+    }
 
 ///////////////////////////////////////////////////////////////////////
 //Add IP4 Setup object.
@@ -1780,7 +1841,7 @@
         g3PlcMacSetup.shortAddress = 1;
         g3PlcMacSetup.rcCoord = 2;
         g3PlcMacSetup.panId = 3;
-        gxG3MacKeyTable* key = (gxG3MacKeyTable*) malloc(sizeof(gxG3MacKeyTable));
+        gxG3MacKeyTable* key = (gxG3MacKeyTable*)malloc(sizeof(gxG3MacKeyTable));
         key->id = 1;
         memcpy(key->key, GMK_KEY, sizeof(GMK_KEY));
         arr_push(&g3PlcMacSetup.keyTable, key);
@@ -1840,6 +1901,129 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
+//Add G3 PLC 6LoWPAN object.
+///////////////////////////////////////////////////////////////////////
+int addG3Plc6LoWPAN()
+{
+    int ret;
+    //The maximum Context field length is 16 bytes (128 bits).
+    static unsigned char PREFIX_TABLE[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
+    const unsigned char ln[6] = { 0,0,29,2,0,255 };
+    if ((ret = INIT_OBJECT(g3Plc6LoWPAN, DLMS_OBJECT_TYPE_G3_PLC_6LO_WPAN, ln)) == 0)
+    {
+        g3Plc6LoWPAN.maxHops = 1;
+        g3Plc6LoWPAN.weakLqiValue = 2;
+        g3Plc6LoWPAN.securityLevel = 3;
+        bb_set(&g3Plc6LoWPAN.prefixTable, PREFIX_TABLE, 16);
+        gxRoutingConfiguration* rg = (gxRoutingConfiguration*)malloc(sizeof(gxRoutingConfiguration));
+        rg->netTraversalTime = 1;
+        rg->routingTableEntryTtl = 2;
+        rg->kr = 3;
+        rg->km = 4;
+        rg->kc = 5;
+        rg->kq = 6;
+        rg->kh = 7;
+        rg->krt = 8;
+        rg->rReqRetries = 9;
+        rg->rReqReqWait = 10;
+        rg->blacklistTableEntryTtl = 11;
+        rg->unicastRreqGenEnable = 1;
+        rg->rlcEnabled = 1;
+        rg->addRevLinkCost = 14;
+        arr_push(&g3Plc6LoWPAN.routingConfiguration, rg);
+
+        gxRoutingTable* rt = (gxRoutingTable*)malloc(sizeof(gxRoutingTable));
+        rt->destinationAddress = 1;
+        rt->nextHopAddress = 2;
+        rt->routeCost = 3;
+        rt->hopCount = 4;
+        rt->weakLinkCount = 5;
+        rt->validTime = 6;
+        arr_push(&g3Plc6LoWPAN.routingTable, rt);
+
+        gxContextInformationTable* cit = (gxContextInformationTable*)malloc(sizeof(gxContextInformationTable));
+        bb_init(&cit->context);
+        cit->cid = 0xF;
+        bb_setUInt8(&cit->context, 0xFF);
+        bb_setUInt8(&cit->context, 0);
+        bb_setUInt8(&cit->context, 0xFF);
+        bb_setUInt8(&cit->context, 0);
+        cit->compression = 1;
+        cit->validLifetime = 4;
+        arr_push(&g3Plc6LoWPAN.contextInformationTable, cit);
+
+        gxBlacklistTable* blt = (gxBlacklistTable*)malloc(sizeof(gxBlacklistTable));
+        blt->neighbourAddress = 1;
+        blt->validTime = 2;
+        arr_push(&g3Plc6LoWPAN.blacklistTable, blt);
+        blt = (gxBlacklistTable*)malloc(sizeof(gxBlacklistTable));
+        blt->neighbourAddress = 3;
+        blt->validTime = 4;
+        arr_push(&g3Plc6LoWPAN.blacklistTable, blt);
+
+        dlmsVARIANT* it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+
+        g3Plc6LoWPAN.broadcastLogTableEntryTtl = 6;
+        g3Plc6LoWPAN.maxJoinWaitTime = 12;
+        g3Plc6LoWPAN.pathDiscoveryTime = 13;
+        g3Plc6LoWPAN.activeKeyIndex = 14;
+        g3Plc6LoWPAN.metricType = 15;
+        g3Plc6LoWPAN.coordShortAddress = 16;
+        g3Plc6LoWPAN.disableDefaultRouting = 1;
+        g3Plc6LoWPAN.deviceType = DLMS_PAN_DEVICE_TYPE_NOT_DEFINED;
+        g3Plc6LoWPAN.defaultCoordRouteEnabled = 1;
+
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add array manager object.
+///////////////////////////////////////////////////////////////////////
+int addArrayManager()
+{
+    int ret;
+    const unsigned char ln[6] = { 0,0,18,0,0,255 };
+    if ((ret = INIT_OBJECT(arrayManager, DLMS_OBJECT_TYPE_ARRAY_MANAGER, ln)) == 0)
+    {
+        gxArrayManagerItem* it = (gxArrayManagerItem*)malloc(sizeof(gxArrayManagerItem));
+        it->id = 1;
+        it->element.target = BASE(loadProfile);
+        it->element.attributeIndex = 2;
+        arr_push(&arrayManager.elements, it);
+        it = (gxArrayManagerItem*)malloc(sizeof(gxArrayManagerItem));
+        it->id = 2;
+        it->element.target = BASE(loadProfile);
+        it->element.attributeIndex = 3;
+        arr_push(&arrayManager.elements, it);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
 //Add push setup object. (On Connectivity)
 ///////////////////////////////////////////////////////////////////////
 int addPushSetup()
@@ -2018,10 +2202,14 @@
         (ret = addAssociationHighGMac()) != 0 ||
         (ret = addSecuritySetupHigh()) != 0 ||
         (ret = addSecuritySetupHighGMac()) != 0 ||
+        (ret = addAssociationHighGMacPreEstablished()) != 0 ||
+        (ret = addSecuritySetupPreEstablishedHighGMac()) != 0 ||
         (ret = addMbusDiagnostic()) != 0 ||
         (ret = addMbusPortSetup()) != 0 ||
         (ret = addG3PlcMacLayerCounters()) != 0 ||
         (ret = addG3PlcMacSetup()) != 0 ||
+        (ret = addG3Plc6LoWPAN()) != 0 ||
+        (ret = addArrayManager()) != 0 ||
         (ret = addPushSetup()) != 0 ||
         (ret = addscriptTableGlobalMeterReset()) != 0 ||
         (ret = addscriptTableDisconnectControl()) != 0 ||
@@ -2442,6 +2630,11 @@
                     pduSize = (uint16_t)e->value.byteArr->size;
                     if ((ret = cosem_setStructure(e->value.byteArr, pg->captureObjects.size)) != 0)
                     {
+                        //Don't set error if PDU is full.
+                        if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
+                        {
+                            e->value.byteArr->size = pduSize;
+                        }
                         break;
                     }
                     uint8_t colIndex;
@@ -2471,29 +2664,42 @@
                             else
                             {
                                 //Append data type.
+                                if ((ret = bb_setUInt8(e->value.byteArr, dataTypes[colIndex])) != 0)
+                                {
+                                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                                    break;
+                                }
+                                if (bb_getCapacity(e->value.byteArr) < bb_size(e->value.byteArr) + columnSizes[colIndex])
+                                {
+                                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                                    break;
+                                }
+                                //Read data.
+                                fread(&e->value.byteArr->data[e->value.byteArr->size], columnSizes[colIndex], 1, f);
+                                e->value.byteArr->size += columnSizes[colIndex];
+                                /*
                                 e->value.byteArr->data[e->value.byteArr->size] = dataTypes[colIndex];
                                 ++e->value.byteArr->size;
                                 //Read data.
                                 fread(&e->value.byteArr->data[e->value.byteArr->size], columnSizes[colIndex], 1, f);
                                 e->value.byteArr->size += columnSizes[colIndex];
+                                */
                             }
                         }
                         if (ret != 0)
                         {
-                            //Don't set error if PDU is full.
-                            if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
-                            {
-                                --e->transactionStartIndex;
-                                e->value.byteArr->size = pduSize;
-                                ret = 0;
-                            }
-                            else
-                            {
-                                break;
-                            }
                             break;
                         }
                     }
+                    if (ret != 0)
+                    {
+                        //Don't set error if PDU is full.
+                        if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
+                        {
+                            e->value.byteArr->size = pduSize;
+                        }
+                        break;
+                    }
                     ++e->transactionStartIndex;
                 }
                 fclose(f);
@@ -2505,6 +2711,10 @@
             }
         }
     }
+    if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
+    {
+        ret = 0;
+    }
     return ret;
 }
 
@@ -3129,9 +3339,9 @@
             close(*s);
 #endif
             return err;
-        };
-        add.sin_addr = *(struct in_addr*)(void*)Hostent->h_addr_list[0];
     };
+        add.sin_addr = *(struct in_addr*)(void*)Hostent->h_addr_list[0];
+};
 
     //Connect to the meter.
     ret = connect(*s, (struct sockaddr*)&add, sizeof(struct sockaddr_in));
@@ -3180,11 +3390,11 @@
 #else
         close(s);
 #endif
-    }
+        }
     mes_clear(&messages);
     free(host);
     return 0;
-}
+    }
 #endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 
 unsigned char svr_isTarget(
@@ -3235,10 +3445,17 @@
                     settings->expectedSecurityPolicy = 0xFF;
                     if (a->securitySetup != NULL)
                     {
-                        //Set expected client system title. If this is set only client that is using expected client system title can connect to the meter.
+                        //Set expected client system title. If this is set only client that is 
+                        // using expected client system title can connect to the meter.
                         if (a->securitySetup->clientSystemTitle.size == 8)
                         {
                             settings->expectedClientSystemTitle = a->securitySetup->clientSystemTitle.data;
+                            settings->preEstablishedSystemTitle = &a->securitySetup->clientSystemTitle;
+                            settings->cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
+                        }
+                        else
+                        {
+                            settings->preEstablishedSystemTitle = NULL;
                         }
                         //GMac authentication uses innocation counter.
                         if (a->securitySetup == &securitySetupHighGMac)
@@ -3506,8 +3723,7 @@
     return DLMS_ACCESS_MODE_READ;
 }
 
-
-//Get attribute access level for security setup.
+//Get attribute access level for activity calendar.
 DLMS_ACCESS_MODE getActivityCalendarAttributeAccess(
     dlmsSettings* settings,
     unsigned char index)
@@ -3520,6 +3736,18 @@
     return DLMS_ACCESS_MODE_READ;
 }
 
+//Get attribute access level for array manager.
+DLMS_ACCESS_MODE getArrayManagerAttributeAccess(
+    dlmsSettings* settings,
+    unsigned char index)
+{
+    if (settings->authentication > DLMS_AUTHENTICATION_LOW && index == 2)
+    {
+        return DLMS_ACCESS_MODE_READ_WRITE;
+    }
+    return DLMS_ACCESS_MODE_READ;
+}
+
 /**
 * Get attribute access level.
 */
@@ -3582,6 +3810,10 @@
     {
         return getActivityCalendarAttributeAccess(settings, index);
     }
+    if (obj->objectType == DLMS_OBJECT_TYPE_ARRAY_MANAGER)
+    {
+        return getArrayManagerAttributeAccess(settings, index);
+    }
     // Only clock write is allowed.
     if (settings->authentication == DLMS_AUTHENTICATION_LOW)
     {
@@ -3645,7 +3877,7 @@
             }
             bb_addString(settings->base.preEstablishedSystemTitle, "ABCDEFGH");
             settings->base.cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
-        }
+}
         else
         {
             //Return error if client can connect only using pre-established connnection.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample2/src/main.c src/GuruxDLMSServerExample2/src/main.c
--- upstream/GuruxDLMSServerExample2/src/main.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample2/src/main.c	2024-06-19 13:37:18.000000000 +0000
@@ -197,10 +197,14 @@
 static gxSecuritySetup securitySetupHigh;
 //Security Setup HighGMac is for GMac authentication.
 static gxSecuritySetup securitySetupHighGMac;
+//Security Setup HighGMac is for pre-established GMac authentication.
+static gxSecuritySetup securitySetupHighGMacPreEstablished;
+static gxAssociationLogicalName associationHighGMacPreEstablished;
 
 gxImageTransfer imageTransfer;
 gxAutoConnect autoConnect;
 gxActivityCalendar activityCalendar;
+gxLocalPortSetup localPortSetup;
 gxSpecialDaysTable specialDaysTable;
 gxDemandRegister demandRegister;
 gxRegisterMonitor registerMonitor;
@@ -228,12 +232,14 @@
 
 //Append new COSEM object to the end so serialization will work correctly.
 static gxObject* ALL_OBJECTS[] = {
-    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac), BASE(securitySetupHigh), BASE(securitySetupHighGMac),
+    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac),
+    BASE(associationHighGMacPreEstablished),
+    BASE(securitySetupHigh), BASE(securitySetupHighGMac),BASE(securitySetupHighGMacPreEstablished),
     BASE(ldn), BASE(eeprom), BASE(testMode), BASE(sapAssignment), BASE(eventCode),
     BASE(clock1), BASE(activePowerL1), BASE(pushSetup), BASE(scriptTableGlobalMeterReset), BASE(scriptTableDisconnectControl),
     BASE(scriptTableActivateTestMode), BASE(scriptTableActivateNormalMode), BASE(loadProfile), BASE(eventLog), BASE(hdlc),
     BASE(disconnectControl), BASE(actionScheduleDisconnectOpen), BASE(actionScheduleDisconnectClose), BASE(unixTime), BASE(invocationCounter),
-    BASE(imageTransfer), BASE(udpSetup), BASE(autoConnect), BASE(activityCalendar), BASE(demandRegister),
+    BASE(imageTransfer), BASE(udpSetup), BASE(autoConnect), BASE(activityCalendar), BASE(localPortSetup), BASE(demandRegister),
     BASE(registerMonitor), BASE(autoAnswer), BASE(modemConfiguration), BASE(macAddressSetup), BASE(ip4Setup), BASE(pppSetup), BASE(gprsSetup),
     BASE(tarifficationScriptTable), BASE(registerActivation), BASE(primeNbOfdmPlcMacFunctionalParameters), BASE(primeNbOfdmPlcMacNetworkAdministrationData),
     BASE(twistedPairSetup), BASE(specialDaysTable), BASE(currentlyActiveTariff),
@@ -852,6 +858,39 @@
     return ret;
 }
 
+
+///////////////////////////////////////////////////////////////////////
+//This method adds pre-established example 
+// Logical Name Association object for GMAC High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighGMacPreEstablished()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 5, 255 };
+    if ((ret = INIT_OBJECT(associationHighGMacPreEstablished, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighGMacPreEstablished.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
+        OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
+        associationHighGMacPreEstablished.clientSAP = 0x2;
+        associationHighGMacPreEstablished.xDLMSContextInfo.maxSendPduSize = associationHighGMacPreEstablished.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighGMacPreEstablished.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+            DLMS_CONFORMANCE_SET |
+            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+            DLMS_CONFORMANCE_ACTION |
+            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+            DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighGMacPreEstablished.securitySetup = &securitySetupHighGMacPreEstablished;
+#else
+        memcpy(associationHighGMacPreEstablished.securitySetupReference, securitySetupHigh.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
 ///////////////////////////////////////////////////////////////////////
 //This method adds security setup object for High authentication.
 ///////////////////////////////////////////////////////////////////////
@@ -891,6 +930,28 @@
     return ret;
 }
 
+
+///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for pre-established GMAC authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupPreEstablishedHighGMac()
+{
+    int ret;
+    //Define client system title for the pre-established connection.
+    //Pre-establiched system title is Gurux123
+    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0x47, 0x75, 0x72, 0x75, 0x78, 0x31, 0x32, 0x33 };
+    const unsigned char ln[6] = { 0, 0, 43, 0, 3, 255 };
+    if ((ret = INIT_OBJECT(securitySetupHighGMacPreEstablished, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighGMacPreEstablished.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        BB_ATTACH(securitySetupHighGMacPreEstablished.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
+        //Only Authenticated encrypted connections are allowed.
+        securitySetupHighGMacPreEstablished.securityPolicy = DLMS_SECURITY_POLICY_AUTHENTICATED_ENCRYPTED;
+        securitySetupHighGMacPreEstablished.securitySuite = DLMS_SECURITY_SUITE_V0;
+    }
+    return ret;
+}
+
 ///////////////////////////////////////////////////////////////////////
 //Add SAP Assignment object.
 ///////////////////////////////////////////////////////////////////////
@@ -1236,6 +1297,39 @@
 ///////////////////////////////////////////////////////////////////////
 //Add Optical Port Setup object.
 ///////////////////////////////////////////////////////////////////////
+int addOpticalPortSetup()
+{
+    const unsigned char ln[6] = { 0,0,20,0,0,255 };
+    //Define device address.
+    static unsigned char DEVICE_ADDRESS[10] = { 0 };
+    //Define password 1.
+    static unsigned char PASSWORD_1[10] = { 0 };
+    //Define password 2.
+    static unsigned char PASSWORD_2[10] = { 0 };
+    //Define password 5.
+    static unsigned char PASSWORD_5[10] = { 0 };
+    INIT_OBJECT(localPortSetup, DLMS_OBJECT_TYPE_IEC_LOCAL_PORT_SETUP, ln);
+    localPortSetup.defaultMode = DLMS_OPTICAL_PROTOCOL_MODE_DEFAULT;
+    localPortSetup.proposedBaudrate = DLMS_BAUD_RATE_9600;
+    localPortSetup.defaultBaudrate = DLMS_BAUD_RATE_300;
+    localPortSetup.responseTime = DLMS_LOCAL_PORT_RESPONSE_TIME_200_MS;
+    BB_ATTACH(localPortSetup.deviceAddress, DEVICE_ADDRESS, 0);
+    bb_addString(&localPortSetup.deviceAddress, "12345678");
+    BB_ATTACH(localPortSetup.password1, PASSWORD_1, 0);
+    bb_addString(&localPortSetup.password1, "Gurux1");
+    BB_ATTACH(localPortSetup.password2, PASSWORD_2, 0);
+    bb_addString(&localPortSetup.password2, "Gurux2");
+    BB_ATTACH(localPortSetup.password5, PASSWORD_5, 0);
+    bb_addString(&localPortSetup.password5, "Gurux5");
+    //Set flag id.
+    memcpy(settings.flagId, "GRX", 3);
+    settings.localPortSetup = &localPortSetup;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Optical Port Setup object.
+///////////////////////////////////////////////////////////////////////
 int addSpecialDaysTable()
 {
     int ret;
@@ -1287,14 +1381,6 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
-//Add Optical Port Setup object.
-///////////////////////////////////////////////////////////////////////
-int addOpticalPortSetup()
-{
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
 //Add Demand Register object.
 ///////////////////////////////////////////////////////////////////////
 int addDemandRegister()
@@ -1815,9 +1901,9 @@
 {
     int ret;
     //Function statuc must initialize to zero.
-    static functionStatus FUNCTION_STATUS[2] = {0};
+    static functionStatus FUNCTION_STATUS[2] = { 0 };
     //Function block must initialize to zero.
-    static functionalBlock FUNCTION_BLOCKS[2] = { 0 };    
+    static functionalBlock FUNCTION_BLOCKS[2] = { 0 };
     const unsigned char ln[6] = { 0,0,44,1,0,255 };
     if ((ret = INIT_OBJECT(functionControl, DLMS_OBJECT_TYPE_FUNCTION_CONTROL, ln)) == 0)
     {
@@ -2375,6 +2461,8 @@
         (ret = addAssociationLow()) != 0 ||
         (ret = addAssociationHigh()) != 0 ||
         (ret = addAssociationHighGMac()) != 0 ||
+        (ret = addAssociationHighGMacPreEstablished()) != 0 ||
+        (ret = addSecuritySetupPreEstablishedHighGMac()) != 0 ||
         (ret = addSecuritySetupHigh()) != 0 ||
         (ret = addSecuritySetupHighGMac()) != 0 ||
         (ret = addMbusDiagnostic()) != 0 ||
@@ -2402,10 +2490,10 @@
         (ret = addTcpUdpSetup()) != 0 ||
         (ret = addAutoConnect()) != 0 ||
         (ret = addActivityCalendar()) != 0 ||
+        (ret = addOpticalPortSetup()) != 0 ||
         (ret = addSpecialDaysTable()) != 0 ||
         (ret = addCurrentlyActiveTariff()) != 0 ||
         (ret = addPrimeNbOfdmPlcMacCounters()) != 0 ||
-        (ret = addOpticalPortSetup()) != 0 ||
         (ret = addDemandRegister()) != 0 ||
         (ret = addRegisterMonitor()) != 0 ||
         (ret = addAutoAnswer()) != 0 ||
@@ -3559,6 +3647,8 @@
                         if (a->securitySetup->clientSystemTitle.size == 8)
                         {
                             settings->expectedClientSystemTitle = a->securitySetup->clientSystemTitle.data;
+                            memcpy(settings->preEstablishedSystemTitle, a->securitySetup->clientSystemTitle.data, 8);
+                            settings->cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
                         }
                         //GMac authentication uses innocation counter.
                         if (a->securitySetup == &securitySetupHighGMac)
@@ -4051,7 +4141,7 @@
         break;
     default:
         return B9600;
-    }
+}
     return br;
 }
 #endif //!defined(_WIN32) && !defined(_WIN64)//Windows
@@ -4138,7 +4228,7 @@
         ret = errno;
         printf("Failed to Open port. tcsetattr failed.\r");
         return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    }
+}
 #endif
     return 0;
 }
@@ -4283,7 +4373,7 @@
                 socket1 = -1;
 #endif
                 break;
-            }
+        }
             //If client closes the connection.
             if (ret == 0)
             {
@@ -4295,11 +4385,11 @@
                 socket1 = -1;
 #endif
                 break;
-            }
+    }
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
             if (trace > GX_TRACE_LEVEL_WARNING)
             {
-                if (first)
+                // if (first)
                 {
                     printf("\nRX:\t");
                     first = 0;
@@ -4342,7 +4432,7 @@
                     socket1 = -1;
 #endif
                     break;
-                }
+            }
                 if (settings.base.interfaceType == DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E && sr.newBaudRate != 0)
                 {
                     if (settings.base.connected == DLMS_CONNECTION_STATE_IEC)
@@ -4712,7 +4802,7 @@
         ret = pthread_create(&receiverThread, NULL, UnixSerialPortThread, &comPort);
 #endif
 
-    }
+        }
     else
     {
         printf("TCP/IP server started in port: %d\n", port);
@@ -4831,5 +4921,5 @@
 #endif
 
     return 0;
-}
+    }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/ciphering.h src/development/include/ciphering.h
--- upstream/development/include/ciphering.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/ciphering.h	2024-06-19 13:37:18.000000000 +0000
@@ -170,6 +170,21 @@
     gxByteBuffer* data,
     gxByteBuffer* output);
 
+//Show decoded PDU. 
+// This can be used to show decoded PDU. 
+//In default this is not used.
+//It's used after DLMS_TRACE_PDU is defined.
+#ifdef DLMS_TRACE_PDU
+/*
+* Show send or received PDU without ciphering. This can be use in debugging.
+* encrypt: If true, the data is encrypt (send) and if false, it's decrypted (received).
+* pdu: decrypted Pdu.
+*/
+extern void cip_tracePdu(
+    unsigned char encrypt,
+    gxByteBuffer* pdu);
+#endif //DLMS_TRACE_PDU
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/date.h src/development/include/date.h
--- upstream/development/include/date.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/date.h	2024-06-19 13:37:18.000000000 +0000
@@ -83,6 +83,8 @@
 #else
         struct tm value;
 #endif
+        /*Milliseconds.*/
+        uint16_t millisecond;
         int16_t deviation;
         DATETIME_SKIPS skip : 16;
         DLMS_DATE_TIME_EXTRA_INFO extraInfo : 8;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/dlms.h src/development/include/dlms.h
--- upstream/development/include/dlms.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/dlms.h	2024-06-19 13:37:18.000000000 +0000
@@ -48,7 +48,6 @@
 #include "replydata.h"
 #include "datainfo.h"
 #include "parameters.h"
-
     //Makes sure that the basic settings are set.
     int dlms_checkInit(
         dlmsSettings* settings);
@@ -102,22 +101,22 @@
     int dlms_setData(
         gxByteBuffer* data,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 
 #if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
     //Set data from DLMS Varuant to DLMS byte stream.
     int dlms_setData2(
-        unsigned char *buff,
+        unsigned char* buff,
         uint32_t length,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 #else
     //Set data from DLMS Varuant to DLMS byte stream.
     int dlms_setData2(
-        unsigned char *buff,
+        unsigned char* buff,
         uint16_t length,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 #endif
 
     int dlms_receiverReady(
@@ -141,7 +140,7 @@
     int dlms_getData(
         gxByteBuffer* data,
         gxDataInfo* info,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 
 #ifndef DLMS_IGNORE_ASSOCIATION_SHORT_NAME
     /**
@@ -181,14 +180,14 @@
 #endif //DLMS_IGNORE_WRAPPER
 
     int dlms_changeType2(
-        dlmsVARIANT *value,
+        dlmsVARIANT* value,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *newValue);
+        dlmsVARIANT* newValue);
 
     int dlms_changeType(
         gxByteBuffer* value,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *newValue);
+        dlmsVARIANT* newValue);
 
 
     int dlms_getPdu(
@@ -220,7 +219,7 @@
          * @return    Status code.
          */
     int dlms_getLnMessages(
-        gxLNParameters *p,
+        gxLNParameters* p,
         message* reply);
 
 #ifndef DLMS_IGNORE_HDLC
@@ -249,13 +248,13 @@
     * @return    Status code.
     */
     int dlms_getSnMessages(
-        gxSNParameters *p,
+        gxSNParameters* p,
         message* reply);
 
     int dlms_getActionInfo(
         DLMS_OBJECT_TYPE objectType,
-        unsigned char *value,
-        unsigned char *count);
+        unsigned char* value,
+        unsigned char* count);
 #endif // DLMS_IGNORE_ASSOCIATION_SHORT_NAME
 
     int dlms_generateChallenge(
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/enums.h src/development/include/enums.h
--- upstream/development/include/enums.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/enums.h	2024-06-19 13:37:18.000000000 +0000
@@ -159,7 +159,7 @@
         */
         DLMS_SECURITY_SUITE_V1 = 1,
         /*
-            AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap        
+            AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap
         */
         DLMS_SECURITY_SUITE_V2 = 2
     } DLMS_SECURITY_SUITE;
@@ -173,7 +173,13 @@
         DLMS_SERVICE_TYPE_SMS = 4,
         DLMS_SERVICE_TYPE_HDLC = 5,
         DLMS_SERVICE_TYPE_M_BUS = 6,
-        DLMS_SERVICE_TYPE_ZIG_BEE = 7
+        DLMS_SERVICE_TYPE_ZIG_BEE = 7,
+        /*DLMS Gateway.*/
+        DLMS_SERVICE_TYPE_DLMS_GATEWAY = 8,
+        /*Reliable CoAP.*/
+        DLMS_SERVICE_TYPE_RELIABLE_COAP = 9,
+        /*Unreliable CoAP.*/
+        DLMS_SERVICE_TYPE_UNRELIABLE_COAP = 10
     } DLMS_SERVICE_TYPE;
 
     typedef enum
@@ -183,6 +189,50 @@
         DLMS_MESSAGE_TYPE_MANUFACTURER_SPESIFIC = 128
     } DLMS_MESSAGE_TYPE;
 
+    /*Push operation method defines what service class is used with push messages.*/
+    typedef enum
+    {
+        /**
+        * Unconfirmed, retry on supporting protocol layer failure.
+        */
+        DLMS_PUSH_OPERATION_METHOD_UNCONFIRMED_FAILURE = 0,
+        /**
+         * Unconfirmed, retry on missing supporting protocol layer confirmation.
+         */
+        DLMS_PUSH_OPERATION_METHOD_UNCONFIRMED_MISSING,
+        /**
+         * Confirmed, retry on missing confirmation.
+         */
+        DLMS_PUSH_OPERATION_METHOD_CONFIRMED
+    } DLMS_PUSH_OPERATION_METHOD;
+
+    /*Data protection identified key types.*/
+    typedef enum
+    {
+        /*Global unicast encryption key.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE_UNICAST_ENCRYPTION,
+        /*Global broadcast encryption key.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE_BROADCAST_ENCRYPTION
+    }DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE;
+
+    /*Data protection wrapped key types.*/
+    typedef enum
+    {
+        /*Master key.*/
+        DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE_MASTER_KEY = 0
+    }DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE;
+
+    /*Enumerates data protection key types.*/
+    typedef enum
+    {
+        /*Identified key.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED,
+        /*Wrapped key.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED,
+        /*Agreed.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_AGREED
+    }DLMS_DATA_PROTECTION_KEY_TYPE;
+    
     typedef enum
     {
         DLMS_CLOCK_STATUS_OK = 0x0,
@@ -395,7 +445,7 @@
         * Function control.
         */
         DLMS_OBJECT_TYPE_FUNCTION_CONTROL = 122,
-            
+
         /*
         * Configure a ZigBee PRO device with information necessary to create or
         * join the network.
@@ -1998,489 +2048,489 @@
     /*
     * Enumerates all Unit constants.
     */
-    typedef enum 
+    typedef enum
     {
-    /*
-    * No Unit.
-    */
-    DLMS_UNIT_NONE = 0,
-    /*
-    * Year.
-    */
-    DLMS_UNIT_YEAR = 1,
+        /*
+        * No Unit.
+        */
+        DLMS_UNIT_NONE = 0,
+        /*
+        * Year.
+        */
+        DLMS_UNIT_YEAR = 1,
 
-    /*
-    * Month.
-    */
-    DLMS_UNIT_MONTH = 2,
+        /*
+        * Month.
+        */
+        DLMS_UNIT_MONTH = 2,
 
-    /*
-    * Week.
-    */
-    DLMS_UNIT_WEEK = 3,
+        /*
+        * Week.
+        */
+        DLMS_UNIT_WEEK = 3,
 
-    /*
-    * Day.
-    */
-    DLMS_UNIT_DAY = 4,
+        /*
+        * Day.
+        */
+        DLMS_UNIT_DAY = 4,
 
-    /*
-    * Hour.
-    */
-    DLMS_UNIT_HOUR = 5,
+        /*
+        * Hour.
+        */
+        DLMS_UNIT_HOUR = 5,
 
-    /*
-    * Minute.
-    */
-    DLMS_UNIT_MINUTE = 6,
+        /*
+        * Minute.
+        */
+        DLMS_UNIT_MINUTE = 6,
 
-    /*
-    * Second.
-    */
-    DLMS_UNIT_SECOND = 7,
+        /*
+        * Second.
+        */
+        DLMS_UNIT_SECOND = 7,
 
-    /*
-    * Phase angle degree.
-    */
-    DLMS_UNIT_PHASE_ANGLE_DEGREE = 8,
-    /*
-    * Temperature T degree centigrade, rad*180/p.
-    */
-    DLMS_UNIT_TEMPERATURE = 9,
-    /*
-    * Local currency.
-    */
-    DLMS_UNIT_LOCAL_CURRENCY = 10,
-    /*
-    * Length l meter m.
-    */
-    DLMS_UNIT_LENGTH = 11,
-    /*
-    * Speed v m/s.
-    */
-    DLMS_UNIT_SPEED = 12,
-    /*
-    * Volume V m3.
-    */
-    DLMS_UNIT_VOLUME_CUBIC_METER = 13,
-    /*
-    * Corrected volume m3.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME = 14,
-    /*
-    * Volume flux m3/60*60s.
-    */
-    DLMS_UNIT_VOLUME_FLUX_HOUR = 15,
-    /*
-    * Corrected volume flux m3/60*60s.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME_FLUX_HOUR = 16,
-    /*
-    * Volume flux m3/24*60*60s.
-    */
-    DLMS_UNIT_VOLUME_FLUX_DAY = 17,
-    /*
-    * Corrected volume flux m3/24*60*60s.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME_FLUX_DAY = 18,
-    /*
-    * Volume 10-3 m3.
-    */
-    DLMS_UNIT_VOLUME_LITER = 19,
-    /*
-    * Mass m kilogram kg.
-    */
-    DLMS_UNIT_MASS_KG = 20,
-    /*
-    * return "Force F newton N.
-    */
-    DLMS_UNIT_FORCE = 21,
-    /*
-    * Energy newtonmeter J = Nm = Ws.
-    */
-    DLMS_UNIT_ENERGY = 22,
-    /*
-    * Pressure p pascal N/m2.
-    */
-    DLMS_UNIT_PRESSURE_PASCAL = 23,
-    /*
-    * Pressure p bar 10-5 N/m2.
-    */
-    DLMS_UNIT_PRESSURE_BAR = 24,
-    /*
-    * Energy joule J = Nm = Ws.
-    */
-    DLMS_UNIT_ENERGY_JOULE = 25,
-    /*
-    * Thermal power J/60*60s.
-    */
-    DLMS_UNIT_THERMAL_POWER = 26,
-    /*
-    * Active power P watt W = J/s.
-    */
-    DLMS_UNIT_ACTIVE_POWER = 27,
-    /*
-    * Apparent power S.
-    */
-    DLMS_UNIT_APPARENT_POWER = 28,
-    /*
-    * Reactive power Q.
-    */
-    DLMS_UNIT_REACTIVE_POWER = 29,
-    /*
-    * Active energy W*60*60s.
-    */
-    DLMS_UNIT_ACTIVE_ENERGY = 30,
-    /*
-    * Apparent energy VA*60*60s.
-    */
-    DLMS_UNIT_APPARENT_ENERGY = 31,
-    /*
-    * Reactive energy var*60*60s.
-    */
-    DLMS_UNIT_REACTIVE_ENERGY = 32,
-    /*
-    * Current I ampere A.
-    */
-    DLMS_UNIT_CURRENT = 33,
-    /*
-    * Electrical charge Q coulomb C = As.
-    */
-    DLMS_UNIT_ELECTRICAL_CHARGE = 34,
-    /*
-    * Voltage.
-    */
-    DLMS_UNIT_VOLTAGE = 35,
-    /*
-    * Electrical field strength E V/m.
-    */
-    DLMS_UNIT_ELECTRICAL_FIELD_STRENGTH = 36,
-    /*
-    * Capacity C farad C/V = As/V.
-    */
-    DLMS_UNIT_CAPACITY = 37,
-    /*
-    * Resistance R ohm = V/A.
-    */
-    DLMS_UNIT_RESISTANCE = 38,
-    /*
-    * Resistivity.
-    */
-    DLMS_UNIT_RESISTIVITY = 39,
-    /*
-    * Magnetic flux F weber Wb = Vs.
-    */
-    DLMS_UNIT_MAGNETIC_FLUX = 40,
-    /*
-    * Induction T tesla Wb/m2.
-    */
-    DLMS_UNIT_INDUCTION = 41,
-    /*
-    * Magnetic field strength H A/m.
-    */
-    DLMS_UNIT_MAGNETIC = 42,
-    /*
-    * Inductivity L henry H = Wb/A.
-    */
-    DLMS_UNIT_INDUCTIVITY = 43,
-    /*
-    * Frequency f.
-    */
-    DLMS_UNIT_FREQUENCY = 44,
-    /*
-    * Active energy meter constant 1/Wh.
-    */
-    DLMS_UNIT_ACTIVE = 45,
-    /*
-    * Reactive energy meter constant.
-    */
-    DLMS_UNIT_REACTIVE = 46,
-    /*
-    * Apparent energy meter constant.
-    */
-    DLMS_UNIT_APPARENT = 47,
-    /*
-    * V260*60s.
-    */
-    DLMS_UNIT_V260 = 48,
-    /*
-    * A260*60s.
-    */
-    DLMS_UNIT_A260 = 49,
-    /*
-    * Mass flux kg/s.
-    */
-    DLMS_UNIT_MASS_KG_PER_SECOND = 50,
-    /*
-    * Unit is Conductance siemens 1/ohm.
-    */
-    DLMS_UNIT_CONDUCTANCE = 51,
-    /*
-    * Temperature in Kelvin.
-    */
-    DLMS_UNIT_KELVIN = 52,
-    /*
-    * 1/(V2h) RU2h , volt-squared hour meter constant or pulse value.
-    */
-    DLMS_UNIT_RU2H = 53,
-    /*
-    * 1/(A2h) RI2h , ampere-squared hour meter constant or pulse value.
-    */
-    DLMS_UNIT_RI2H = 54,
-    /*
-    * 1/m3 RV , meter constant or pulse value  = volume).
-    */
-    DLMS_UNIT_CUBIC_METER_RV = 55,
-    /*
-    * Percentage.
-    */
-    DLMS_UNIT_PERCENTAGE = 56,
-    /*
-    * Ah ampere hours.
-    */
-    DLMS_UNIT_AMPERE_HOURS = 57,
-    /*
-    * Wh/m3 energy per volume 3,6*103 J/m3.
-    */
-    DLMS_UNIT_ENERGY_PER_VOLUME = 60,
-    /*
-    * J/m3 calorific value, wobbe.
-    */
-    DLMS_UNIT_WOBBE = 61,
-    /*
-    * Mol % molar fraction of gas composition mole percent  = Basic gas
-    * composition unit).
-    */
-    DLMS_UNIT_MOLE_PERCENT = 62,
-    /*
-    * g/m3 mass density, quantity of material.
-    */
-    DLMS_UNIT_MASS_DENSITY = 63,
-    /*
-    * Dynamic viscosity pascal second  = Characteristic of gas stream).
-    */
-    DLMS_UNIT_PASCAL_SECOND = 64,
-    /*
-    * J/kg Specific energy NOTE The amount of energy per unit of mass of a
-    * substance Joule / kilogram m2 . kg . s -2 / kg = m2.
-    */
-    DLMS_UNIT_JOULE_KILOGRAM = 65,
-    /*
-    * Pressure, gram per square centimeter.
-    */
-    DLMS_UNIT_PRESSURE_GRAM_PER_SQUARE_CENTIMETER = 66,
-    /*
-    * Pressure, atmosphere.
-    */
-    DLMS_UNIT_PRESSURE_ATMOSPHERE = 67,
-    /*
-    * Signal strength, dB milliwatt (e.g. of GSM radio systems)
-    */
-    DLMS_UNIT_SIGNAL_STRENGTH_MILLI_WATT = 70,
-    /*
-    * Signal strength, dB microvolt.
-    */
-    DLMS_UNIT_SIGNAL_STRENGTH_MICRO_VOLT = 71,
-    /*
-    * Logarithmic unit that expresses the ratio between two values of a physical quantity
-    */
-    DLMS_UNIT_DB = 72,
-    /*
-    * Length in inches.
-    */
-    DLMS_UNIT_INCH = 128,
-    /*
-    * Foot (Length).
-    */
-    DLMS_UNIT_FOOT = 129,
-    /*
-    * Pound (mass).
-    */
-    DLMS_UNIT_POUND = 130,
-    /*
-    * Fahrenheit.
-    */
-    DLMS_UNIT_FAHRENHEIT = 131,
-    /*
-    * Rankine.
-    */
-    DLMS_UNIT_RANKINE = 132,
-    /*
-    * Square inch.
-    */
-    DLMS_UNIT_SQUARE_INCH = 133,
-    /*
-    * Square foot.
-    */
-    DLMS_UNIT_SQUARE_FOOT = 134,
-    /*
-    * Acre.
-    */
-    DLMS_UNIT_ACRE = 135,
-    /*
-    * Cubic inch.
-    */
-    DLMS_UNIT_CUBIC_INCH = 136,
-    /*
-    * Cubic foot.
-    */
-    DLMS_UNIT_CUBIC_FOOT = 137,
-    /*
-    * Acre foot.
-    */
-    DLMS_UNIT_ACRE_FOOT = 138,
-    /*
-    * Gallon (imperial).
-    */
-    DLMS_UNIT_GALLON_IMPERIAL = 139,
-    /*
-    *  Gallon (US).
-    */
-    DLMS_UNIT_GALLON_US = 140,
-    /*
-    * Pound force.
-    */
-    DLMS_UNIT_POUND_FORCE = 141,
-    /*
-    * Pound force per square inch.
-    */
-    DLMS_UNIT_POUND_FORCE_PER_SQUARE_INCH = 142,
-    /*
-    * Pound per cubic foot.
-    */
-    DLMS_UNIT_POUND_PER_CUBIC_FOOT = 143,
-    /*
-    * Pound per (foot second).
-    */
-    DLMS_UNIT_POUND_PER_FOOT_SECOND = 144,
-    /*
-    * Square foot per second.
-    */
-    DLMS_UNIT_SQUARE_FOOT_PER_SECOND = 145,
-    /*
-    * British thermal unit.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT = 146,
-    /*
-    * Therm EU.
-    */
-    DLMS_UNIT_THERM_EU = 147,
-    /*
-    * Therm US.
-    */
-    DLMS_UNIT_THERM_US = 148,
-    /*
-    * British thermal unit per pound.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_POUND = 149,
-    /*
-    * British thermal unit per cubic foot.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_CUBIC_FOOT = 150,
-    /*
-    * Cubic feet.
-    */
-    DLMS_UNIT_CUBIC_FEET = 151,
-    /*
-    * Foot per second.
-    */
-    DLMS_UNIT_FOOT_PER_SECOND = 152,
-    /*
-    * Cubic foot per second.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_SECOND = 153,
-    /*
-    * Cubic foot per min.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_MIN = 154,
-    /*
-    * Cubic foot per hour.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_HOUR = 155,
-    /*
-    * Cubic foot per day
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_DAY = 156,
-    /*
-    * Acre foot per second.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_SECOND = 157,
-    /*
-    * Acre foot per min.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_MIN = 158,
-    /*
-    *  Acre foot per hour.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_HOUR = 159,
-    /*
-    *  Acre foot per day.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_DAY = 160,
-    /*
-    * Imperial gallon.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON = 161,
-    /*
-    * Imperial gallon per second.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_SECOND = 162,
-    /*
-    * Imperial gallon per min.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_MIN = 163,
-    /*
-    * Imperial gallon per hour.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_HOUR = 164,
-    /*
-    * Imperial gallon per day.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_DAY = 165,
-    /*
-    * US gallon.
-    */
-    DLMS_UNIT_US_GALLON = 166,
-    /*
-    * US gallon per second.
-    */
-    DLMS_UNIT_US_GALLON_PER_SECOND = 167,
-    /*
-    * US gallon per min.
-    */
-    DLMS_UNIT_US_GALLON_PER_MIN = 168,
-    /*
-    * US gallon per hour.
-    */
-    DLMS_UNIT_US_GALLON_PER_HOUR = 169,
-    /*
-    * US gallon per day.
-    */
-    DLMS_UNIT_US_GALLON_PER_DAY = 170,
-    /*
-    * British thermal unit per second.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_SECOND = 171,
-    /*
-    * British thermal unit per minute.
-    */        
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_MIN = 172,
-    /*
-    * British thermal unit per hour.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_HOUR = 173,
-    /*
-    * British thermal unit per day.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_DAY = 174,
-    /*
-    * Other Unit.
-    */
-    DLMS_UNIT_OTHER = 254,
-    /*
-    * No Unit.
-    */
-    DLMS_UNIT_NO_UNIT = 255
+        /*
+        * Phase angle degree.
+        */
+        DLMS_UNIT_PHASE_ANGLE_DEGREE = 8,
+        /*
+        * Temperature T degree centigrade, rad*180/p.
+        */
+        DLMS_UNIT_TEMPERATURE = 9,
+        /*
+        * Local currency.
+        */
+        DLMS_UNIT_LOCAL_CURRENCY = 10,
+        /*
+        * Length l meter m.
+        */
+        DLMS_UNIT_LENGTH = 11,
+        /*
+        * Speed v m/s.
+        */
+        DLMS_UNIT_SPEED = 12,
+        /*
+        * Volume V m3.
+        */
+        DLMS_UNIT_VOLUME_CUBIC_METER = 13,
+        /*
+        * Corrected volume m3.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME = 14,
+        /*
+        * Volume flux m3/60*60s.
+        */
+        DLMS_UNIT_VOLUME_FLUX_HOUR = 15,
+        /*
+        * Corrected volume flux m3/60*60s.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME_FLUX_HOUR = 16,
+        /*
+        * Volume flux m3/24*60*60s.
+        */
+        DLMS_UNIT_VOLUME_FLUX_DAY = 17,
+        /*
+        * Corrected volume flux m3/24*60*60s.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME_FLUX_DAY = 18,
+        /*
+        * Volume 10-3 m3.
+        */
+        DLMS_UNIT_VOLUME_LITER = 19,
+        /*
+        * Mass m kilogram kg.
+        */
+        DLMS_UNIT_MASS_KG = 20,
+        /*
+        * return "Force F newton N.
+        */
+        DLMS_UNIT_FORCE = 21,
+        /*
+        * Energy newtonmeter J = Nm = Ws.
+        */
+        DLMS_UNIT_ENERGY = 22,
+        /*
+        * Pressure p pascal N/m2.
+        */
+        DLMS_UNIT_PRESSURE_PASCAL = 23,
+        /*
+        * Pressure p bar 10-5 N/m2.
+        */
+        DLMS_UNIT_PRESSURE_BAR = 24,
+        /*
+        * Energy joule J = Nm = Ws.
+        */
+        DLMS_UNIT_ENERGY_JOULE = 25,
+        /*
+        * Thermal power J/60*60s.
+        */
+        DLMS_UNIT_THERMAL_POWER = 26,
+        /*
+        * Active power P watt W = J/s.
+        */
+        DLMS_UNIT_ACTIVE_POWER = 27,
+        /*
+        * Apparent power S.
+        */
+        DLMS_UNIT_APPARENT_POWER = 28,
+        /*
+        * Reactive power Q.
+        */
+        DLMS_UNIT_REACTIVE_POWER = 29,
+        /*
+        * Active energy W*60*60s.
+        */
+        DLMS_UNIT_ACTIVE_ENERGY = 30,
+        /*
+        * Apparent energy VA*60*60s.
+        */
+        DLMS_UNIT_APPARENT_ENERGY = 31,
+        /*
+        * Reactive energy var*60*60s.
+        */
+        DLMS_UNIT_REACTIVE_ENERGY = 32,
+        /*
+        * Current I ampere A.
+        */
+        DLMS_UNIT_CURRENT = 33,
+        /*
+        * Electrical charge Q coulomb C = As.
+        */
+        DLMS_UNIT_ELECTRICAL_CHARGE = 34,
+        /*
+        * Voltage.
+        */
+        DLMS_UNIT_VOLTAGE = 35,
+        /*
+        * Electrical field strength E V/m.
+        */
+        DLMS_UNIT_ELECTRICAL_FIELD_STRENGTH = 36,
+        /*
+        * Capacity C farad C/V = As/V.
+        */
+        DLMS_UNIT_CAPACITY = 37,
+        /*
+        * Resistance R ohm = V/A.
+        */
+        DLMS_UNIT_RESISTANCE = 38,
+        /*
+        * Resistivity.
+        */
+        DLMS_UNIT_RESISTIVITY = 39,
+        /*
+        * Magnetic flux F weber Wb = Vs.
+        */
+        DLMS_UNIT_MAGNETIC_FLUX = 40,
+        /*
+        * Induction T tesla Wb/m2.
+        */
+        DLMS_UNIT_INDUCTION = 41,
+        /*
+        * Magnetic field strength H A/m.
+        */
+        DLMS_UNIT_MAGNETIC = 42,
+        /*
+        * Inductivity L henry H = Wb/A.
+        */
+        DLMS_UNIT_INDUCTIVITY = 43,
+        /*
+        * Frequency f.
+        */
+        DLMS_UNIT_FREQUENCY = 44,
+        /*
+        * Active energy meter constant 1/Wh.
+        */
+        DLMS_UNIT_ACTIVE = 45,
+        /*
+        * Reactive energy meter constant.
+        */
+        DLMS_UNIT_REACTIVE = 46,
+        /*
+        * Apparent energy meter constant.
+        */
+        DLMS_UNIT_APPARENT = 47,
+        /*
+        * V260*60s.
+        */
+        DLMS_UNIT_V260 = 48,
+        /*
+        * A260*60s.
+        */
+        DLMS_UNIT_A260 = 49,
+        /*
+        * Mass flux kg/s.
+        */
+        DLMS_UNIT_MASS_KG_PER_SECOND = 50,
+        /*
+        * Unit is Conductance siemens 1/ohm.
+        */
+        DLMS_UNIT_CONDUCTANCE = 51,
+        /*
+        * Temperature in Kelvin.
+        */
+        DLMS_UNIT_KELVIN = 52,
+        /*
+        * 1/(V2h) RU2h , volt-squared hour meter constant or pulse value.
+        */
+        DLMS_UNIT_RU2H = 53,
+        /*
+        * 1/(A2h) RI2h , ampere-squared hour meter constant or pulse value.
+        */
+        DLMS_UNIT_RI2H = 54,
+        /*
+        * 1/m3 RV , meter constant or pulse value  = volume).
+        */
+        DLMS_UNIT_CUBIC_METER_RV = 55,
+        /*
+        * Percentage.
+        */
+        DLMS_UNIT_PERCENTAGE = 56,
+        /*
+        * Ah ampere hours.
+        */
+        DLMS_UNIT_AMPERE_HOURS = 57,
+        /*
+        * Wh/m3 energy per volume 3,6*103 J/m3.
+        */
+        DLMS_UNIT_ENERGY_PER_VOLUME = 60,
+        /*
+        * J/m3 calorific value, wobbe.
+        */
+        DLMS_UNIT_WOBBE = 61,
+        /*
+        * Mol % molar fraction of gas composition mole percent  = Basic gas
+        * composition unit).
+        */
+        DLMS_UNIT_MOLE_PERCENT = 62,
+        /*
+        * g/m3 mass density, quantity of material.
+        */
+        DLMS_UNIT_MASS_DENSITY = 63,
+        /*
+        * Dynamic viscosity pascal second  = Characteristic of gas stream).
+        */
+        DLMS_UNIT_PASCAL_SECOND = 64,
+        /*
+        * J/kg Specific energy NOTE The amount of energy per unit of mass of a
+        * substance Joule / kilogram m2 . kg . s -2 / kg = m2.
+        */
+        DLMS_UNIT_JOULE_KILOGRAM = 65,
+        /*
+        * Pressure, gram per square centimeter.
+        */
+        DLMS_UNIT_PRESSURE_GRAM_PER_SQUARE_CENTIMETER = 66,
+        /*
+        * Pressure, atmosphere.
+        */
+        DLMS_UNIT_PRESSURE_ATMOSPHERE = 67,
+        /*
+        * Signal strength, dB milliwatt (e.g. of GSM radio systems)
+        */
+        DLMS_UNIT_SIGNAL_STRENGTH_MILLI_WATT = 70,
+        /*
+        * Signal strength, dB microvolt.
+        */
+        DLMS_UNIT_SIGNAL_STRENGTH_MICRO_VOLT = 71,
+        /*
+        * Logarithmic unit that expresses the ratio between two values of a physical quantity
+        */
+        DLMS_UNIT_DB = 72,
+        /*
+        * Length in inches.
+        */
+        DLMS_UNIT_INCH = 128,
+        /*
+        * Foot (Length).
+        */
+        DLMS_UNIT_FOOT = 129,
+        /*
+        * Pound (mass).
+        */
+        DLMS_UNIT_POUND = 130,
+        /*
+        * Fahrenheit.
+        */
+        DLMS_UNIT_FAHRENHEIT = 131,
+        /*
+        * Rankine.
+        */
+        DLMS_UNIT_RANKINE = 132,
+        /*
+        * Square inch.
+        */
+        DLMS_UNIT_SQUARE_INCH = 133,
+        /*
+        * Square foot.
+        */
+        DLMS_UNIT_SQUARE_FOOT = 134,
+        /*
+        * Acre.
+        */
+        DLMS_UNIT_ACRE = 135,
+        /*
+        * Cubic inch.
+        */
+        DLMS_UNIT_CUBIC_INCH = 136,
+        /*
+        * Cubic foot.
+        */
+        DLMS_UNIT_CUBIC_FOOT = 137,
+        /*
+        * Acre foot.
+        */
+        DLMS_UNIT_ACRE_FOOT = 138,
+        /*
+        * Gallon (imperial).
+        */
+        DLMS_UNIT_GALLON_IMPERIAL = 139,
+        /*
+        *  Gallon (US).
+        */
+        DLMS_UNIT_GALLON_US = 140,
+        /*
+        * Pound force.
+        */
+        DLMS_UNIT_POUND_FORCE = 141,
+        /*
+        * Pound force per square inch.
+        */
+        DLMS_UNIT_POUND_FORCE_PER_SQUARE_INCH = 142,
+        /*
+        * Pound per cubic foot.
+        */
+        DLMS_UNIT_POUND_PER_CUBIC_FOOT = 143,
+        /*
+        * Pound per (foot second).
+        */
+        DLMS_UNIT_POUND_PER_FOOT_SECOND = 144,
+        /*
+        * Square foot per second.
+        */
+        DLMS_UNIT_SQUARE_FOOT_PER_SECOND = 145,
+        /*
+        * British thermal unit.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT = 146,
+        /*
+        * Therm EU.
+        */
+        DLMS_UNIT_THERM_EU = 147,
+        /*
+        * Therm US.
+        */
+        DLMS_UNIT_THERM_US = 148,
+        /*
+        * British thermal unit per pound.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_POUND = 149,
+        /*
+        * British thermal unit per cubic foot.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_CUBIC_FOOT = 150,
+        /*
+        * Cubic feet.
+        */
+        DLMS_UNIT_CUBIC_FEET = 151,
+        /*
+        * Foot per second.
+        */
+        DLMS_UNIT_FOOT_PER_SECOND = 152,
+        /*
+        * Cubic foot per second.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_SECOND = 153,
+        /*
+        * Cubic foot per min.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_MIN = 154,
+        /*
+        * Cubic foot per hour.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_HOUR = 155,
+        /*
+        * Cubic foot per day
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_DAY = 156,
+        /*
+        * Acre foot per second.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_SECOND = 157,
+        /*
+        * Acre foot per min.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_MIN = 158,
+        /*
+        *  Acre foot per hour.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_HOUR = 159,
+        /*
+        *  Acre foot per day.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_DAY = 160,
+        /*
+        * Imperial gallon.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON = 161,
+        /*
+        * Imperial gallon per second.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_SECOND = 162,
+        /*
+        * Imperial gallon per min.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_MIN = 163,
+        /*
+        * Imperial gallon per hour.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_HOUR = 164,
+        /*
+        * Imperial gallon per day.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_DAY = 165,
+        /*
+        * US gallon.
+        */
+        DLMS_UNIT_US_GALLON = 166,
+        /*
+        * US gallon per second.
+        */
+        DLMS_UNIT_US_GALLON_PER_SECOND = 167,
+        /*
+        * US gallon per min.
+        */
+        DLMS_UNIT_US_GALLON_PER_MIN = 168,
+        /*
+        * US gallon per hour.
+        */
+        DLMS_UNIT_US_GALLON_PER_HOUR = 169,
+        /*
+        * US gallon per day.
+        */
+        DLMS_UNIT_US_GALLON_PER_DAY = 170,
+        /*
+        * British thermal unit per second.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_SECOND = 171,
+        /*
+        * British thermal unit per minute.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_MIN = 172,
+        /*
+        * British thermal unit per hour.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_HOUR = 173,
+        /*
+        * British thermal unit per day.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_DAY = 174,
+        /*
+        * Other Unit.
+        */
+        DLMS_UNIT_OTHER = 254,
+        /*
+        * No Unit.
+        */
+        DLMS_UNIT_NO_UNIT = 255
     }DLMS_UNIT;
 
 
@@ -3386,7 +3436,7 @@
         // Not Defined.
         DLMS_PAN_DEVICE_TYPE_NOT_DEFINED
     }DLMS_PAN_DEVICE_TYPE;
-    
+
 
     // Defines the ZigBee status enumeration values.
     typedef enum
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxignore.h src/development/include/gxignore.h
--- upstream/development/include/gxignore.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxignore.h	2024-06-19 13:37:18.000000000 +0000
@@ -36,146 +36,150 @@
 extern "C" {
 #endif
 
-/* Uncomment defines to ignore non-needed parts to make image size smaller. */
+    /* Uncomment defines to ignore non-needed parts to make image size smaller. */
 
-// #define DLMS_IGNORE_HDLC
-// #define DLMS_IGNORE_WRAPPER
-// #define DLMS_IGNORE_PLC
-// #define DLMS_IGNORE_IEC
-// #define DLMS_IGNORE_NOTIFY
-// #define DLMS_IGNORE_SERVER
-// #define DLMS_IGNORE_CLIENT
-// #define GX_DLMS_MICROCONTROLLER
-// #define DLMS_IGNORE_HIGH_SHA256
-// #define DLMS_IGNORE_HIGH_SHA1
-// #define DLMS_IGNORE_HIGH_MD5
-// #define DLMS_IGNORE_AES
-// #define DLMS_IGNORE_HIGH_GMAC
-// #define DLMS_IGNORE_DATA
-// #define DLMS_IGNORE_REGISTER
-// #define DLMS_IGNORE_EXTENDED_REGISTER
-// #define DLMS_IGNORE_DEMAND_REGISTER
-// #define DLMS_IGNORE_REGISTER_ACTIVATION
-// #define DLMS_IGNORE_PROFILE_GENERIC
-// #define DLMS_IGNORE_CLOCK
-// #define DLMS_IGNORE_SCRIPT_TABLE
-// #define DLMS_IGNORE_SCHEDULE
-// #define DLMS_IGNORE_SPECIAL_DAYS_TABLE
-// #define DLMS_IGNORE_ASSOCIATION_SHORT_NAME
-// #define DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
-// #define DLMS_IGNORE_SAP_ASSIGNMENT
-// #define DLMS_IGNORE_IMAGE_TRANSFER
-// #define DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
-// #define DLMS_IGNORE_ACTIVITY_CALENDAR
-// #define DLMS_IGNORE_REGISTER_MONITOR
-// #define DLMS_IGNORE_ACTION_SCHEDULE
-// #define DLMS_IGNORE_IEC_HDLC_SETUP
-// #define DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
-// #define DLMS_IGNORE_MBUS_SLAVE_PORT_SETUP
-// #define DLMS_IGNORE_UTILITY_TABLES
-// #define DLMS_IGNORE_MODEM_CONFIGURATION
-// #define DLMS_IGNORE_AUTO_ANSWER
-// #define DLMS_IGNORE_AUTO_CONNECT
-// #define DLMS_IGNORE_TCP_UDP_SETUP
-// #define DLMS_IGNORE_IP4_SETUP
-// #define DLMS_IGNORE_IP6_SETUP
-// #define DLMS_IGNORE_MAC_ADDRESS_SETUP
-// #define DLMS_IGNORE_PPP_SETUP
-// #define DLMS_IGNORE_GPRS_SETUP
-// #define DLMS_IGNORE_SMTP_SETUP
-// #define DLMS_IGNORE_GSM_DIAGNOSTIC
-// #define DLMS_IGNORE_REGISTER_TABLE
-// #define DLMS_IGNORE_STATUS_MAPPING
-// #define DLMS_IGNORE_SECURITY_SETUP
-// #define DLMS_IGNORE_DISCONNECT_CONTROL
-// #define DLMS_IGNORE_LIMITER
-// #define DLMS_IGNORE_MBUS_CLIENT
-// #define DLMS_IGNORE_PUSH_SETUP
-// #define DLMS_IGNORE_PARAMETER_MONITOR
-// #define DLMS_IGNORE_WIRELESS_MODE_Q_CHANNEL
-// #define DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
-// #define DLMS_IGNORE_ZIG_BEE_SAS_STARTUP
-// #define DLMS_IGNORE_ZIG_BEE_SAS_JOIN
-// #define DLMS_IGNORE_ZIG_BEE_SAS_APS_FRAGMENTATION
-// #define DLMS_IGNORE_ZIG_BEE_NETWORK_CONTROL
-// #define DLMS_IGNORE_DATA_PROTECTION
-// #define DLMS_IGNORE_ACCOUNT
-// #define DLMS_IGNORE_CREDIT
-// #define DLMS_IGNORE_CHARGE
-// #define DLMS_IGNORE_TOKEN_GATEWAY
-// #define DLMS_IGNORE_COMPACT_DATA
-// #define DLMS_IGNORE_LLC_SSCS_SETUP
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_PHYSICAL_LAYER_COUNTERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_SETUP
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_FUNCTIONAL_PARAMETERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_COUNTERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_NETWORK_ADMINISTRATION_DATA
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_APPLICATIONS_IDENTIFICATION
-// #define DLMS_IGNORE_ARBITRATOR
-// #define DLMS_IGNORE_G3_PLC_MAC_LAYER_COUNTERS
-// #define DLMS_IGNORE_G3_PLC_MAC_SETUP
-// #define DLMS_IGNORE_G3_PLC_6LO_WPAN
-// #define DLMS_IGNORE_FUNCTION_CONTROL
-// #define DLMS_IGNORE_ARRAY_MANAGER
-
-// #define DLMS_IGNORE_MALLOC
-// #define DLMS_USE_CUSTOM_MALLOC
-
-// #define DLMS_IGNORE_OBJECT_POINTERS
-
-// #define DLMS_IGNORE_FLOAT32
-// #define DLMS_IGNORE_FLOAT64
-
-//Use EPOCH time. This can be used to improve memory usage.
-// #define DLMS_USE_EPOCH_TIME
-
-//Use UTC time zone. Read more: https://www.gurux.fi/Gurux.DLMS.Objects.GXDLMSClock
-// #define DLMS_USE_UTC_TIME_ZONE
-
-// #define DLMS_IGNORE_SET
-// #define DLMS_IGNORE_ACTION
-
-// String converters are not used.
-// #define DLMS_IGNORE_STRING_CONVERTER
-
-//Framework send debug information that can be used in debugging.
-// #define DLMS_DEBUG
-
-//Defined if AVR is used.
-// #define USE_AVR
-
-//Defined if program memory (flash) is used instead of SRAM.
-// #define USE_PROGMEM
-
-// COSEM objects are using DLMS standard data types.
-// Using exact data types will save memory, but reading failes if meter returns wrong data type,
-// ex. Int8 when data type should be UInt8.
-// #define DLMS_COSEM_EXACT_DATA_TYPES
-
-// If innovation counter size is UInt64 and not default UInt32.
-// #define DLMS_COSEM_INVOCATION_COUNTER_SIZE64
-
-// Use 32 bit max size bytebuffer instead of 16 bit.
-// This might be used in client side if a lot of data is read from the meter.
-// #define GX_DLMS_BYTE_BUFFER_SIZE_32
-
-//Serializer is not used.
-//DLMS_IGNORE_SERIALIZER
-//Serializer is used instead of file system.
-//#define GX_DLMS_SERIALIZER
-
-//GENERAL_CIPHERING is not used.
-//#define DLMS_IGNORE_GENERAL_CIPHERING
-
-/**
-*  Ignore HDLC Control field check.
-Some meters are sending invalid control field.
-Note! It's not recommended to use this.
-*/
-//#define DLMS_IGNORE_HDLC_CHECK
-
-// #define DLMS_ITALIAN_STANDARD
-// #define DLMS_INDONESIA_STANDARD
+    // #define DLMS_IGNORE_HDLC
+    // #define DLMS_IGNORE_WRAPPER
+    // #define DLMS_IGNORE_PLC
+    // #define DLMS_IGNORE_IEC
+    // #define DLMS_IGNORE_NOTIFY
+    // #define DLMS_IGNORE_SERVER
+    // #define DLMS_IGNORE_CLIENT
+    // #define GX_DLMS_MICROCONTROLLER
+    // #define DLMS_IGNORE_HIGH_SHA256
+    // #define DLMS_IGNORE_HIGH_SHA1
+    // #define DLMS_IGNORE_HIGH_MD5
+    // #define DLMS_IGNORE_AES
+    // #define DLMS_IGNORE_HIGH_GMAC
+    // #define DLMS_IGNORE_DATA
+    // #define DLMS_IGNORE_REGISTER
+    // #define DLMS_IGNORE_EXTENDED_REGISTER
+    // #define DLMS_IGNORE_DEMAND_REGISTER
+    // #define DLMS_IGNORE_REGISTER_ACTIVATION
+    // #define DLMS_IGNORE_PROFILE_GENERIC
+    // #define DLMS_IGNORE_CLOCK
+    // #define DLMS_IGNORE_SCRIPT_TABLE
+    // #define DLMS_IGNORE_SCHEDULE
+    // #define DLMS_IGNORE_SPECIAL_DAYS_TABLE
+    // #define DLMS_IGNORE_ASSOCIATION_SHORT_NAME
+    // #define DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+    // #define DLMS_IGNORE_SAP_ASSIGNMENT
+    // #define DLMS_IGNORE_IMAGE_TRANSFER
+    // #define DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+    // #define DLMS_IGNORE_ACTIVITY_CALENDAR
+    // #define DLMS_IGNORE_REGISTER_MONITOR
+    // #define DLMS_IGNORE_ACTION_SCHEDULE
+    // #define DLMS_IGNORE_IEC_HDLC_SETUP
+    // #define DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+    // #define DLMS_IGNORE_MBUS_SLAVE_PORT_SETUP
+    // #define DLMS_IGNORE_UTILITY_TABLES
+    // #define DLMS_IGNORE_MODEM_CONFIGURATION
+    // #define DLMS_IGNORE_AUTO_ANSWER
+    // #define DLMS_IGNORE_AUTO_CONNECT
+    // #define DLMS_IGNORE_TCP_UDP_SETUP
+    // #define DLMS_IGNORE_IP4_SETUP
+    // #define DLMS_IGNORE_IP6_SETUP
+    // #define DLMS_IGNORE_MAC_ADDRESS_SETUP
+    // #define DLMS_IGNORE_PPP_SETUP
+    // #define DLMS_IGNORE_GPRS_SETUP
+    // #define DLMS_IGNORE_SMTP_SETUP
+    // #define DLMS_IGNORE_GSM_DIAGNOSTIC
+    // #define DLMS_IGNORE_REGISTER_TABLE
+    // #define DLMS_IGNORE_STATUS_MAPPING
+    // #define DLMS_IGNORE_SECURITY_SETUP
+    // #define DLMS_IGNORE_DISCONNECT_CONTROL
+    // #define DLMS_IGNORE_LIMITER
+    // #define DLMS_IGNORE_MBUS_CLIENT
+    // #define DLMS_IGNORE_PUSH_SETUP
+    // #define DLMS_IGNORE_PARAMETER_MONITOR
+    // #define DLMS_IGNORE_WIRELESS_MODE_Q_CHANNEL
+    // #define DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_STARTUP
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_JOIN
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_APS_FRAGMENTATION
+    // #define DLMS_IGNORE_ZIG_BEE_NETWORK_CONTROL
+    // #define DLMS_IGNORE_DATA_PROTECTION
+    // #define DLMS_IGNORE_ACCOUNT
+    // #define DLMS_IGNORE_CREDIT
+    // #define DLMS_IGNORE_CHARGE
+    // #define DLMS_IGNORE_TOKEN_GATEWAY
+    // #define DLMS_IGNORE_COMPACT_DATA
+    // #define DLMS_IGNORE_LLC_SSCS_SETUP
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_PHYSICAL_LAYER_COUNTERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_SETUP
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_FUNCTIONAL_PARAMETERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_COUNTERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_NETWORK_ADMINISTRATION_DATA
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_APPLICATIONS_IDENTIFICATION
+    // #define DLMS_IGNORE_ARBITRATOR
+    // #define DLMS_IGNORE_G3_PLC_MAC_LAYER_COUNTERS
+    // #define DLMS_IGNORE_G3_PLC_MAC_SETUP
+    // #define DLMS_IGNORE_G3_PLC_6LO_WPAN
+    // #define DLMS_IGNORE_FUNCTION_CONTROL
+    // #define DLMS_IGNORE_ARRAY_MANAGER
+
+    // #define DLMS_IGNORE_MALLOC
+    // #define DLMS_USE_CUSTOM_MALLOC
+
+    // #define DLMS_IGNORE_OBJECT_POINTERS
+
+    // #define DLMS_IGNORE_FLOAT32
+    // #define DLMS_IGNORE_FLOAT64
+
+    //Use EPOCH time. This can be used to improve memory usage.
+    // #define DLMS_USE_EPOCH_TIME
+
+    //Use UTC time zone. Read more: https://www.gurux.fi/Gurux.DLMS.Objects.GXDLMSClock
+    // #define DLMS_USE_UTC_TIME_ZONE
+
+    // #define DLMS_IGNORE_SET
+    // #define DLMS_IGNORE_ACTION
+
+    // String converters are not used.
+    // #define DLMS_IGNORE_STRING_CONVERTER
+
+    //Framework send debug information that can be used in debugging.
+    // #define DLMS_DEBUG
+
+    //Defined if AVR is used.
+    // #define USE_AVR
+
+    //Defined if program memory (flash) is used instead of SRAM.
+    // #define USE_PROGMEM
+
+    // COSEM objects are using DLMS standard data types.
+    // Using exact data types will save memory, but reading failes if meter returns wrong data type,
+    // ex. Int8 when data type should be UInt8.
+    // #define DLMS_COSEM_EXACT_DATA_TYPES
+
+    // If innovation counter size is UInt64 and not default UInt32.
+    // #define DLMS_COSEM_INVOCATION_COUNTER_SIZE64
+
+    // Use 32 bit max size bytebuffer instead of 16 bit.
+    // This might be used in client side if a lot of data is read from the meter.
+    // #define GX_DLMS_BYTE_BUFFER_SIZE_32
+
+    //Serializer is not used.
+    //DLMS_IGNORE_SERIALIZER
+    //Serializer is used instead of file system.
+    //#define GX_DLMS_SERIALIZER
+
+    //GENERAL_CIPHERING is not used.
+    //#define DLMS_IGNORE_GENERAL_CIPHERING
+
+    /**
+    *  Ignore HDLC Control field check.
+    Some meters are sending invalid control field.
+    Note! It's not recommended to use this.
+    */
+    //#define DLMS_IGNORE_HDLC_CHECK
+
+    // #define DLMS_ITALIAN_STANDARD
+    // #define DLMS_INDONESIA_STANDARD
+
+    // Show decoded PDU. 
+    // This can be used to show decoded PDU.
+    // #define DLMS_TRACE_PDU
 
 #ifdef ARDUINO
 /////////////////////////////////////////////////////////////////////////////
@@ -228,7 +232,6 @@
 /////////////////////////////////////////////////////////////////////////////
 #endif //ARDUINO_ARCH_ESP8266
 
-
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxint.h src/development/include/gxint.h
--- upstream/development/include/gxint.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxint.h	2024-06-19 13:37:18.000000000 +0000
@@ -34,7 +34,7 @@
 #define GXINT_H
 
 #include <stdint.h>
-
+#if !defined(_WIN32) && !defined(_WIN64) && !defined(__linux__)
 #ifdef  __cplusplus
 extern "C" {
 #endif
@@ -42,7 +42,7 @@
 #define uint16_t unsigned short
 #endif //!(defined uint16_t) && !(defined _UINT16_T_DECLARED)
 #if !(defined uint32_t) && !(defined _UINT32_T_DECLARED)
-#define uint32_t unsigned long
+#define uint32_t unsigned int
 #endif //!(defined uint32_t) && !(defined _UINT32_T_DECLARED)
 #if !(defined uint64_t) && !(defined _UINT64_T_DECLARED)
 #define uint64_t unsigned long long
@@ -52,7 +52,7 @@
 #define int16_t short
 #endif //!(defined int16_t) && !(defined _INT16_T_DECLARED)
 #if !(defined int32_t) && !(defined _INT32_T_DECLARED)
-#define int32_t long
+#define int32_t int
 #endif //!(defined int32_t) && !(defined _INT32_T_DECLARED)
 #if !(defined int64_t) && !(defined _INT64_T_DECLARED)
 #define int64_t long long
@@ -61,5 +61,5 @@
 #ifdef  __cplusplus
 }
 #endif
-
+#endif //!defined(_WIN32) && !defined(_WIN64) && !defined(__linux__)
 #endif //GXINT_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxobjects.h src/development/include/gxobjects.h
--- upstream/development/include/gxobjects.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxobjects.h	2024-06-19 13:37:18.000000000 +0000
@@ -2125,7 +2125,120 @@
     } gxMBusClient;
 #endif //DLMS_IGNORE_MBUS_CLIENT
 
+    typedef enum
+    {
+        DLMS_PROTECTION_TYPE_AUTHENTICATION = 1,
+        DLMS_PROTECTION_TYPE_ENCRYPTION = 2,
+        DLMS_PROTECTION_TYPE_AUTHENTICATION_ENCRYPTION = 3
+    } DLMS_PROTECTION_TYPE;
+
 #ifndef DLMS_IGNORE_PUSH_SETUP
+    /*This structure is used to count repetition delay for the next push message.*/
+    typedef struct
+    {
+        /**
+        * The minimum delay until a next push attempt is started in seconds.
+        */
+        uint16_t min;
+
+        /**
+         * Calculating the next delay.
+         */
+        uint16_t exponent;
+
+        /**
+         * The maximum delay until a next push attempt is started in seconds.
+         */
+        uint16_t max;
+
+    }gxRepetitionDelay;
+
+    /*Data protection identified key.*/
+    typedef struct
+    {
+        /*Data protection key type.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE keyType;
+    }gxDataProtectionIdentifiedKey;
+
+    /*Data protection wrapped key.*/
+    typedef struct
+    {
+        /*Data protectionKey type.*/
+        DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE keyType;
+
+        /*Key ciphered data.*/
+        gxByteBuffer key;
+    }gxDataProtectionWrappeddKey;
+
+    /*Data protection agreed key.*/
+    typedef struct
+    {
+        /*Key parameters.*/
+        gxByteBuffer parameters;
+
+        /*Key ciphered data.*/
+        gxByteBuffer data;
+    }gxDataProtectionAgreedKey;
+    
+    /*Data protection Key.*/
+    typedef struct
+    {
+        /*Data protectionKey type.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE dataProtectionKeyType;
+
+        /*Identified key parameters.*/
+        gxDataProtectionIdentifiedKey identifiedKey;
+
+        /*Wrapped key parameters.*/
+        gxDataProtectionWrappeddKey wrappedKey;
+        /*Agreed key parameters.*/
+        gxDataProtectionAgreedKey agreedKey;
+    }gxDataProtectionKey;
+
+    typedef struct
+    {
+        /*Protection type.*/
+        DLMS_PROTECTION_TYPE protectionType;
+
+        /**
+         * Transaction Id.
+         */
+        gxByteBuffer transactionId;
+
+        /**
+         * Originator system title.
+         */
+        unsigned char originatorSystemTitle[8];
+
+        /**
+         * Recipient system title.
+         */
+        unsigned char recipientSystemTitle[8];
+
+        /**
+         * Other information.
+         */
+        gxByteBuffer otherInformation;
+
+        /**
+         * Key info.
+         */
+        gxDataProtectionKey keyInfo;
+    }gxPushProtectionParameters;
+
+    /*Push confirmation parameters.*/
+    typedef struct
+    {
+        /**
+     * Confirmation start date. Fields of date-time not specified are not used.
+     */
+        gxtime startDate;
+        /**
+         * Confirmation time interval in seconds. Disabled, if zero.
+         */
+        uint32_t interval;
+    }gxPushConfirmationParameter;
+
     /*
     ---------------------------------------------------------------------------
     Online help:
@@ -2149,7 +2262,25 @@
         gxArray communicationWindow;
         uint16_t randomisationStartInterval;
         unsigned char numberOfRetries;
+        /* Repetition delay for version #0 and #1.*/
         uint16_t repetitionDelay;
+        /* Repetition delay for Version #2.*/
+        gxRepetitionDelay repetitionDelay2;
+        /*The logical name of a communication port setup object.*/
+#ifdef DLMS_IGNORE_MALLOC
+        unsigned char portReference[6];
+#else
+        gxObject* portReference;
+#endif //DLMS_IGNORE_MALLOC
+        /*Push client SAP.*/
+        signed char pushClientSAP;
+        /*Push protection parameters.*/
+        gxArray pushProtectionParameters;
+        /*Push operation method.*/
+        DLMS_PUSH_OPERATION_METHOD pushOperationMethod;
+        gxPushConfirmationParameter confirmationParameters;
+        /*Last confirmation date time.*/
+        gxtime lastConfirmationDateTime;
         //Executed time. This is for internal use.
         uint32_t executedTime;
     } gxPushSetup;
@@ -2225,12 +2356,6 @@
     } gxMBusMasterPortSetup;
 
 #endif //DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
-    typedef enum
-    {
-        DLMS_PROTECTION_TYPE_AUTHENTICATION = 1,
-        DLMS_PROTECTION_TYPE_ENCRYPTION = 2,
-        DLMS_PROTECTION_TYPE_AUTHENTICATION_ENCRYPTION = 3
-    } DLMS_PROTECTION_TYPE;
 
     //Global key types.
     typedef enum
@@ -3604,7 +3729,7 @@
     }functionStatus;
 
     typedef struct
-    {        
+    {
 #ifdef DLMS_IGNORE_MALLOC
         // Function name.
         unsigned char name[MAX_FUNCTION_NAME_LENGTH];
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/variant.h src/development/include/variant.h
--- upstream/development/include/variant.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/variant.h	2024-06-19 13:37:18.000000000 +0000
@@ -76,13 +76,16 @@
 #define GX_FLOAT(X) GX_UNION(&X, fltVal, DLMS_DATA_TYPE_FLOAT32)
 #define GX_DOUBLE(X) GX_UNION(&X, dblVal, DLMS_DATA_TYPE_FLOAT64)
 #define GX_BOOL(X) GX_UNION(&X, bVal, DLMS_DATA_TYPE_BOOLEAN)
+#define GX_ENUM(X) GX_UNION(&X, cVal, DLMS_DATA_TYPE_ENUM)
 #ifdef DLMS_IGNORE_MALLOC
 #define GX_DATETIME(X) X.size = 12; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATETIME))
+#define GX_DATE(X) X.size = 5; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATE))
+#define GX_TIME(X) X.size = 4; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_TIME))
 #else
 #define GX_DATETIME(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATETIME))
-#endif //DLMS_IGNORE_MALLOC
 #define GX_DATE(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATE))
 #define GX_TIME(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_TIME))
+#endif //DLMS_IGNORE_MALLOC
 #define GX_UINT8_BYREF(X, VALUE_) GX_UNION(&X, pbVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT8))
 #define GX_UINT16_BYREF(X, VALUE_) GX_UNION(&X, puiVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT16))
 #define GX_UINT32_BYREF(X, VALUE_) GX_UNION(&X, pulVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT32))
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/apdu.c src/development/src/apdu.c
--- upstream/development/src/apdu.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/apdu.c	2024-06-19 13:37:18.000000000 +0000
@@ -172,7 +172,10 @@
     }
     // Add system title.
 #ifndef DLMS_IGNORE_HIGH_GMAC
-    if (!settings->server && (ciphered || settings->authentication == DLMS_AUTHENTICATION_HIGH_GMAC))
+    if (!settings->server && (ciphered ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_GMAC ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256 ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_ECDSA))
     {
 #ifndef DLMS_IGNORE_MALLOC
         if (settings->cipher.systemTitle.size == 0)
@@ -385,7 +388,7 @@
         if ((ret = apdu_getInitiateRequest(settings, &crypted)) != 0)
         {
             return ret;
-        }        
+        }
 #ifndef DLMS_IGNORE_MALLOC
         ret = cip_encrypt(
             &settings->cipher,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/ciphering.c src/development/src/ciphering.c
--- upstream/development/src/ciphering.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/ciphering.c	2024-06-19 13:37:18.000000000 +0000
@@ -215,858 +215,858 @@
     0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
 };
 
-//Note! return value must be uint32_t.
-static inline uint32_t GetRcon(unsigned char offset)
-{
-#ifdef ARDUINO_ARCH_AVR
-    return pgm_read_dword_far(__R_CON + offset);
-#else
-    return __R_CON[offset];
-#endif //ARDUINO_ARCH_AVR
-}
+    //Note! return value must be uint32_t.
+    static inline uint32_t GetRcon(unsigned char offset)
+    {
+    #ifdef ARDUINO_ARCH_AVR
+        return pgm_read_dword_far(__R_CON + offset);
+    #else
+        return __R_CON[offset];
+    #endif //ARDUINO_ARCH_AVR
+    }
 
-static inline uint32_t GetTe(unsigned char offset)
-{
-#ifdef ARDUINO_ARCH_AVR
-    return pgm_read_dword_far(__TE + offset);
-#else
-    return __TE[offset];
-#endif //ARDUINO_ARCH_AVR
-}
+    static inline uint32_t GetTe(unsigned char offset)
+    {
+    #ifdef ARDUINO_ARCH_AVR
+        return pgm_read_dword_far(__TE + offset);
+    #else
+        return __TE[offset];
+    #endif //ARDUINO_ARCH_AVR
+    }
 
-#define RCON(i) (GetRcon(i) << 24)
+    #define RCON(i) (GetRcon(i) << 24)
 
-#define ROTATE(val, bits) ((val >> bits) | (val << (32 - bits)))
+    #define ROTATE(val, bits) ((val >> bits) | (val << (32 - bits)))
 
-#define TE0(i) GetTe(((i) >> 24) & 0xff)
+    #define TE0(i) GetTe(((i) >> 24) & 0xff)
 
-#define TE1(i) ROTATE(GetTe(((i) >> 16) & 0xff), 8)
+    #define TE1(i) ROTATE(GetTe(((i) >> 16) & 0xff), 8)
 
-#define TE2(i) ROTATE(GetTe(((i) >> 8) & 0xff), 16)
+    #define TE2(i) ROTATE(GetTe(((i) >> 8) & 0xff), 16)
 
-#define TE3(i) ROTATE(GetTe((i) & 0xff), 24)
+    #define TE3(i) ROTATE(GetTe((i) & 0xff), 24)
 
-#define TE41(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
+    #define TE41(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
 
-#define TE42(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
+    #define TE42(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
 
-#define TE43(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
+    #define TE43(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
 
-#define TE44(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
+    #define TE44(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
 
-#define TE421(i) ((GetTe(((i) >> 16) & 0xff) << 8) & 0xff000000)
+    #define TE421(i) ((GetTe(((i) >> 16) & 0xff) << 8) & 0xff000000)
 
-#define TE432(i) (GetTe(((i) >> 8) & 0xff) & 0x00ff0000)
+    #define TE432(i) (GetTe(((i) >> 8) & 0xff) & 0x00ff0000)
 
-#define TE443(i) (GetTe((i) & 0xff) & 0x0000ff00)
+    #define TE443(i) (GetTe((i) & 0xff) & 0x0000ff00)
 
-#define TE414(i) ((GetTe(((i) >> 24) & 0xff) >> 8) & 0x000000ff)
+    #define TE414(i) ((GetTe(((i) >> 24) & 0xff) >> 8) & 0x000000ff)
 
-#define TE411(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
+    #define TE411(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
 
-#define TE422(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
+    #define TE422(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
 
-#define TE433(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
+    #define TE433(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
 
-#define TE444(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
+    #define TE444(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
 
-int cip_int(uint32_t* rk,
-    const unsigned char* cipherKey,
-    uint16_t keyBits)
-{
-    uint8_t i;
-    uint32_t temp;
+    int cip_int(uint32_t* rk,
+        const unsigned char* cipherKey,
+        uint16_t keyBits)
+    {
+        uint8_t i;
+        uint32_t temp;
 
-    rk[0] = GETU32(cipherKey);
-    rk[1] = GETU32(cipherKey + 4);
-    rk[2] = GETU32(cipherKey + 8);
-    rk[3] = GETU32(cipherKey + 12);
+        rk[0] = GETU32(cipherKey);
+        rk[1] = GETU32(cipherKey + 4);
+        rk[2] = GETU32(cipherKey + 8);
+        rk[3] = GETU32(cipherKey + 12);
 
-    if (keyBits == 128)
-    {
-        for (i = 0; i < 10; i++)
+        if (keyBits == 128)
         {
-            temp = rk[3];
-            rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-                TE443(temp) ^ TE414(temp);
-            rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-                TE443(temp) ^ TE414(temp) ^ RCON(i);
-            rk[5] = rk[1] ^ rk[4];
-            rk[6] = rk[2] ^ rk[5];
-            rk[7] = rk[3] ^ rk[6];
-            rk += 4;
+            for (i = 0; i < 10; i++)
+            {
+                temp = rk[3];
+                rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                    TE443(temp) ^ TE414(temp);
+                rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                    TE443(temp) ^ TE414(temp) ^ RCON(i);
+                rk[5] = rk[1] ^ rk[4];
+                rk[6] = rk[2] ^ rk[5];
+                rk[7] = rk[3] ^ rk[6];
+                rk += 4;
+            }
+            return 0;
         }
-        return 0;
-    }
-    if (keyBits != 256)
+        if (keyBits != 256)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        rk[4] = GETU32(cipherKey + 16);
+        rk[5] = GETU32(cipherKey + 20);
+        rk[6] = GETU32(cipherKey + 24);
+        rk[7] = GETU32(cipherKey + 28);
+        for (i = 0; i < 7; i++)
+        {
+            temp = rk[7];
+            rk[8] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                TE443(temp) ^ TE414(temp) ^ RCON(i);
+            rk[9] = rk[1] ^ rk[8];
+            rk[10] = rk[2] ^ rk[9];
+            rk[11] = rk[3] ^ rk[10];
+            if (i == 6)
+            {
+                return 0;
+            }
+            temp = rk[11];
+            rk[12] = rk[4] ^ TE411(temp) ^ TE422(temp) ^
+                TE433(temp) ^ TE444(temp);
+            rk[13] = rk[5] ^ rk[12];
+            rk[14] = rk[6] ^ rk[13];
+            rk[15] = rk[7] ^ rk[14];
+            rk += 8;
+        }
+        return DLMS_ERROR_CODE_OK;
+    }
+
+    //Arduino DOIT ESP32 uses aes_encrypt. For that reason aes_Encrypt is used.
+    void aes_Encrypt(const uint32_t* rk, int Nr, const unsigned char* pt, unsigned char* ct)
+    {
+        uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
+        int r;
+        s0 = GETU32(pt) ^ rk[0];
+        s1 = GETU32(pt + 4) ^ rk[1];
+        s2 = GETU32(pt + 8) ^ rk[2];
+        s3 = GETU32(pt + 12) ^ rk[3];
+
+    #define ROUND(i,d,s) \
+    d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
+    d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
+    d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
+    d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
+
+        /* Nr - 1 full rounds: */
+        r = Nr >> 1;
+        for (;;)
+        {
+            ROUND(1, t, s);
+            rk += 8;
+            if (--r == 0)
+                break;
+            ROUND(0, s, t);
+        }
+
+    #undef ROUND
+
+        s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
+        PUT32(ct, s0);
+        s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
+        PUT32(ct + 4, s1);
+        s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
+        PUT32(ct + 8, s2);
+        s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
+        PUT32(ct + 12, s3);
+    }
+
+    /**
+    * Make cip_xor for 128 bits.
+    *
+    * @param block
+    *            block.
+    * @param val
+    */
+    static void cip_xor(
+        unsigned char* dst,
+        const unsigned char* src)
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    rk[4] = GETU32(cipherKey + 16);
-    rk[5] = GETU32(cipherKey + 20);
-    rk[6] = GETU32(cipherKey + 24);
-    rk[7] = GETU32(cipherKey + 28);
-    for (i = 0; i < 7; i++)
-    {
-        temp = rk[7];
-        rk[8] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-            TE443(temp) ^ TE414(temp) ^ RCON(i);
-        rk[9] = rk[1] ^ rk[8];
-        rk[10] = rk[2] ^ rk[9];
-        rk[11] = rk[3] ^ rk[10];
-        if (i == 6)
+        int pos;
+        for (pos = 0; pos != 16; ++pos)
         {
-            return 0;
+            dst[pos] ^= src[pos];
         }
-        temp = rk[11];
-        rk[12] = rk[4] ^ TE411(temp) ^ TE422(temp) ^
-            TE433(temp) ^ TE444(temp);
-        rk[13] = rk[5] ^ rk[12];
-        rk[14] = rk[6] ^ rk[13];
-        rk[15] = rk[7] ^ rk[14];
-        rk += 8;        
-    }
-    return DLMS_ERROR_CODE_OK;
-}
-
-//Arduino DOIT ESP32 uses aes_encrypt. For that reason aes_Encrypt is used.
-void aes_Encrypt(const uint32_t* rk, int Nr, const unsigned char* pt, unsigned char* ct)
-{
-    uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
-    int r;
-    s0 = GETU32(pt) ^ rk[0];
-    s1 = GETU32(pt + 4) ^ rk[1];
-    s2 = GETU32(pt + 8) ^ rk[2];
-    s3 = GETU32(pt + 12) ^ rk[3];
-
-#define ROUND(i,d,s) \
-d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
-d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
-d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
-d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
-
-    /* Nr - 1 full rounds: */
-    r = Nr >> 1;
-    for (;;)
-    {
-        ROUND(1, t, s);
-        rk += 8;
-        if (--r == 0)
-            break;
-        ROUND(0, s, t);
+        /*
+        uint32_t *d = (uint32_t *)dst;
+        uint32_t *s = (uint32_t *)src;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        */
     }
 
-#undef ROUND
-
-    s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
-    PUT32(ct, s0);
-    s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
-    PUT32(ct + 4, s1);
-    s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
-    PUT32(ct + 8, s2);
-    s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
-    PUT32(ct + 12, s3);
-}
-
-/**
-* Make cip_xor for 128 bits.
-*
-* @param block
-*            block.
-* @param val
-*/
-static void cip_xor(
-    unsigned char* dst,
-    const unsigned char* src)
-{
-    int pos;
-    for (pos = 0; pos != 16; ++pos)
-    {
-        dst[pos] ^= src[pos];
-    }
-    /*
-    uint32_t *d = (uint32_t *)dst;
-    uint32_t *s = (uint32_t *)src;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    */
-}
-
-static void shift_right_block(unsigned char* v)
-{
-    uint32_t val = GETU32(v + 12);
-    val >>= 1;
-    if (v[11] & 0x01)
+    static void shift_right_block(unsigned char* v)
     {
-        val |= 0x80000000;
-    }
-    PUT32(v + 12, val);
+        uint32_t val = GETU32(v + 12);
+        val >>= 1;
+        if (v[11] & 0x01)
+        {
+            val |= 0x80000000;
+        }
+        PUT32(v + 12, val);
 
-    val = GETU32(v + 8);
-    val >>= 1;
-    if (v[7] & 0x01)
-        val |= 0x80000000;
-    PUT32(v + 8, val);
+        val = GETU32(v + 8);
+        val >>= 1;
+        if (v[7] & 0x01)
+            val |= 0x80000000;
+        PUT32(v + 8, val);
 
-    val = GETU32(v + 4);
-    val >>= 1;
-    if (v[3] & 0x01)
-        val |= 0x80000000;
-    PUT32(v + 4, val);
+        val = GETU32(v + 4);
+        val >>= 1;
+        if (v[3] & 0x01)
+            val |= 0x80000000;
+        PUT32(v + 4, val);
 
-    val = GETU32(v);
-    val >>= 1;
-    PUT32(v, val);
-}
+        val = GETU32(v);
+        val >>= 1;
+        PUT32(v, val);
+    }
 
-static void cip_multiplyH(const unsigned char* x, const unsigned char* y, unsigned char* z)
-{
-    unsigned char tmp[16];
-    int i, j;
+    static void cip_multiplyH(const unsigned char* x, const unsigned char* y, unsigned char* z)
+    {
+        unsigned char tmp[16];
+        int i, j;
 
-    memset(z, 0, 16);
-    memcpy(tmp, y, 16);
+        memset(z, 0, 16);
+        memcpy(tmp, y, 16);
 
-    for (i = 0; i < 16; i++)
-    {
-        for (j = 0; j < 8; j++)
+        for (i = 0; i < 16; i++)
         {
-            if (x[i] & 1 << (7 - j))
-            {
-                cip_xor(z, tmp);
-            }
-            //If last bit.
-            if (tmp[15] & 0x01)
-            {
-                shift_right_block(tmp);
-                tmp[0] ^= 0xe1;
-            }
-            else
+            for (j = 0; j < 8; j++)
             {
-                shift_right_block(tmp);
+                if (x[i] & 1 << (7 - j))
+                {
+                    cip_xor(z, tmp);
+                }
+                //If last bit.
+                if (tmp[15] & 0x01)
+                {
+                    shift_right_block(tmp);
+                    tmp[0] ^= 0xe1;
+                }
+                else
+                {
+                    shift_right_block(tmp);
+                }
             }
         }
     }
-}
 
-/**
-* Count GHash.
-*/
-static void cip_getGHash(
-    const unsigned char* h,
-    const unsigned char* x,
-    int xlen,
-    unsigned char* y)
-{
-    int m, i;
-    const unsigned char* xpos = x;
-    unsigned char tmp[16];
-    m = xlen / 16;
-    for (i = 0; i < m; i++)
-    {
-        cip_xor(y, xpos);
-        xpos += 16;
-        cip_multiplyH(y, h, tmp);
-        memcpy(y, tmp, 16);
-    }
-    if (x + xlen > xpos)
-    {
-        size_t last = x + xlen - xpos;
-        memcpy(tmp, xpos, last);
-        memset(tmp + last, 0, sizeof(tmp) - last);
-
-        cip_xor(y, tmp);
-
-        cip_multiplyH(y, h, tmp);
-        memcpy(y, tmp, 16);
-    }
-}
-
-static void cip_init_j0(
-    const unsigned char* iv,
-    unsigned char len,
-    const unsigned char* H,
-    unsigned char* J0)
-{
-    //IV length.
-    if (len == 12)
-    {
-        memcpy(J0, iv, len);
-        memset(J0 + len, 0, 16 - len);
-        J0[15] = 0x01;
-    }
-    else
+    /**
+    * Count GHash.
+    */
+    static void cip_getGHash(
+        const unsigned char* h,
+        const unsigned char* x,
+        int xlen,
+        unsigned char* y)
     {
+        int m, i;
+        const unsigned char* xpos = x;
         unsigned char tmp[16];
-        memset(J0, 0, 16);
-        cip_getGHash(H, iv, len, J0);
-        PUT32(tmp, (uint32_t)0);
-        PUT32(tmp + 4, (uint32_t)0);
-        //Here is expected that data is newer longger than 32 bit.
-        //This is done because microcontrollers show warning here.
-        PUT32(tmp + 8, (uint32_t)0);
-        PUT32(tmp + 12, (uint32_t)(len * 8));
-        cip_getGHash(H, tmp, sizeof(tmp), J0);
-    }
-}
-
-static void cip_inc32(unsigned char* block)
-{
-    uint32_t val;
-    val = GETU32(block + 16 - 4);
-    val++;
-    PUT32(block + 16 - 4, val);
-}
-
-static void cip_gctr(uint32_t* aes, const unsigned char* icb, unsigned char* in, int len, unsigned char* out)
-{
-    size_t i, n, last;
-    unsigned char cb[16], tmp[16];
-    unsigned char* pin = in;
-    unsigned char* pout = out;
-    if (len == 0)
-    {
-        return;
-    }
-    n = len / 16;
-    memcpy(cb, icb, 16);
-    //Full blocks.
-    for (i = 0; i < n; i++)
+        m = xlen / 16;
+        for (i = 0; i < m; i++)
+        {
+            cip_xor(y, xpos);
+            xpos += 16;
+            cip_multiplyH(y, h, tmp);
+            memcpy(y, tmp, 16);
+        }
+        if (x + xlen > xpos)
+        {
+            size_t last = x + xlen - xpos;
+            memcpy(tmp, xpos, last);
+            memset(tmp + last, 0, sizeof(tmp) - last);
+
+            cip_xor(y, tmp);
+
+            cip_multiplyH(y, h, tmp);
+            memcpy(y, tmp, 16);
+        }
+    }
+
+    static void cip_init_j0(
+        const unsigned char* iv,
+        unsigned char len,
+        const unsigned char* H,
+        unsigned char* J0)
     {
-        if (out == NULL)
+        //IV length.
+        if (len == 12)
         {
-            aes_Encrypt(aes, aes[60], cb, tmp);
-            cip_xor(pin, tmp);
+            memcpy(J0, iv, len);
+            memset(J0 + len, 0, 16 - len);
+            J0[15] = 0x01;
         }
         else
         {
-            aes_Encrypt(aes, aes[60], cb, pout);
-            cip_xor(pout, pin);
+            unsigned char tmp[16];
+            memset(J0, 0, 16);
+            cip_getGHash(H, iv, len, J0);
+            PUT32(tmp, (uint32_t)0);
+            PUT32(tmp + 4, (uint32_t)0);
+            //Here is expected that data is newer longger than 32 bit.
+            //This is done because microcontrollers show warning here.
+            PUT32(tmp + 8, (uint32_t)0);
+            PUT32(tmp + 12, (uint32_t)(len * 8));
+            cip_getGHash(H, tmp, sizeof(tmp), J0);
         }
-        pin += 16;
-        pout += 16;
-        cip_inc32(cb);
     }
 
-    last = in + len - pin;
-    //Last, partial block.
-    if (last)
+    static void cip_inc32(unsigned char* block)
+    {
+        uint32_t val;
+        val = GETU32(block + 16 - 4);
+        val++;
+        PUT32(block + 16 - 4, val);
+    }
+
+    static void cip_gctr(uint32_t* aes, const unsigned char* icb, unsigned char* in, int len, unsigned char* out)
     {
-        aes_Encrypt(aes, aes[60], cb, tmp);
-        for (i = 0; i < last; i++)
+        size_t i, n, last;
+        unsigned char cb[16], tmp[16];
+        unsigned char* pin = in;
+        unsigned char* pout = out;
+        if (len == 0)
+        {
+            return;
+        }
+        n = len / 16;
+        memcpy(cb, icb, 16);
+        //Full blocks.
+        for (i = 0; i < n; i++)
         {
             if (out == NULL)
             {
-                *pin ^= tmp[i];
-                ++pin;
+                aes_Encrypt(aes, aes[60], cb, tmp);
+                cip_xor(pin, tmp);
             }
             else
             {
-                *pout = *pin++ ^ tmp[i];
-                ++pout;
+                aes_Encrypt(aes, aes[60], cb, pout);
+                cip_xor(pout, pin);
             }
+            pin += 16;
+            pout += 16;
+            cip_inc32(cb);
         }
-    }
-}
 
-static void aes_gcm_gctr(uint32_t* aes, const unsigned char* J0, unsigned char* in, int len, unsigned char* out)
-{
-    unsigned char J0inc[16];
-    if (len == 0)
-    {
-        return;
-    }
-
-    memcpy(J0inc, J0, 16);
-    cip_inc32(J0inc);
-    cip_gctr(aes, J0inc, in, len, out);
-}
-
-static void aes_gcm_ghash(const unsigned char* H, const unsigned char* aad, int aad_len,
-    const unsigned char* crypt, int crypt_len, unsigned char* S)
-{
-    unsigned char len_buf[16];
-    cip_getGHash(H, aad, aad_len, S);
-    cip_getGHash(H, crypt, crypt_len, S);
-    //Here is expected that data is never longer than 32 bit.
-    //This is done because microcontrollers show warning here.
-    PUT32(len_buf, (uint32_t)0);
-    PUT32(len_buf + 4, (uint32_t)(aad_len * 8));
-    PUT32(len_buf + 8, (uint32_t)0);
-    PUT32(len_buf + 12, (uint32_t)(crypt_len * 8));
-    cip_getGHash(H, len_buf, sizeof(len_buf), S);
-}
-
-#ifndef DLMS_IGNORE_MALLOC
-int cip_crypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    gxByteBuffer* key,
-    gxByteBuffer* input,
-    unsigned char encrypt)
-#else
-int cip_crypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    unsigned char* key,
-    gxByteBuffer* input,
-    unsigned char encrypt)
-#endif //DLMS_IGNORE_MALLOC
-{
-    int ret;
-#ifdef GX_DLMS_MICROCONTROLLER
-    static uint32_t aes[61] = { 0 };
-    static unsigned char H[16] = { 0 };
-    static unsigned char J0[16] = { 0 };
-    static unsigned char S[16] = { 0 };
-    //Nonse must be 20 bytes because it's used later.
-    static unsigned char NONSE[20] = { 0 };
-    memset(H, 0, sizeof(H));
-    memset(S, 0, sizeof(S));
-#else
-    uint32_t aes[61] = { 0 };
-    unsigned char H[16] = { 0 };
-    unsigned char J0[16] = { 0 };
-    unsigned char S[16] = { 0 };
-    //Nonse must be 20 bytes because it's used later.
-    unsigned char NONSE[20] = { 0 };
-#endif //GX_DLMS_MICROCONTROLLER
-    gxByteBuffer nonse;
-    if (memcmp(systemTitle, EMPTY_SYSTEM_TITLE, 8) == 0)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    bb_attach(&nonse, NONSE, 0, sizeof(NONSE));
-    if ((ret = cip_getNonse(frameCounter, systemTitle, &nonse)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = cip_int(
-        aes,
-#ifndef DLMS_IGNORE_MALLOC
-        key->data,
-#else
-        key,
-#endif //DLMS_IGNORE_MALLOC
-        settings->suite == DLMS_SECURITY_SUITE_V2 ? 32 * 8 : 16 * 8)) != 0)
-    {
-        return ret;
-    }
-    if (settings->suite == DLMS_SECURITY_SUITE_V2)
-    {
-        aes[60] = 14;
-    }
-    else
-    {
-        aes[60] = 10;
-    }
-    //Hash subkey.
-    aes_Encrypt(aes, aes[60], H, H);
-    cip_init_j0(nonse.data, (unsigned char)nonse.size, H, J0);
-    //Allocate space for authentication tag.
-    if (security != DLMS_SECURITY_ENCRYPTION && !encrypt)
-    {
-        //Save authentication key to nonse.
-        bb_clear(&nonse);
-        ret = bb_set(&nonse, input->data + input->size - 12, 12);
-        input->size -= 12;
-    }
-    unsigned char offset;
-    if (settings->suite == DLMS_SECURITY_SUITE_V2)
-    {
-        offset = 33;
-    }
-    else
-    {
-        offset = 17;
-    }
-    if (security == DLMS_SECURITY_AUTHENTICATION)
-    {
-        if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
+        last = in + len - pin;
+        //Last, partial block.
+        if (last)
         {
-            input->position = 0;
-            bb_setUInt8ByIndex(input, 0, security | settings->suite);
-#ifndef DLMS_IGNORE_MALLOC
-            memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
-#else
-            memcpy(input->data + 1, settings->authenticationKey, offset - 1);
-#endif //DLMS_IGNORE_MALLOC
-            aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
-            if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+            aes_Encrypt(aes, aes[60], cb, tmp);
+            for (i = 0; i < last; i++)
             {
-                cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                if (encrypt)
+                if (out == NULL)
                 {
-                    input->size += 12;                    
+                    *pin ^= tmp[i];
+                    ++pin;
                 }
                 else
                 {
-                    if (memcmp(NONSE, input->data + input->size, 12) != 0)
-                    {
-                        ret = DLMS_ERROR_CODE_INVALID_TAG;
-                    }
+                    *pout = *pin++ ^ tmp[i];
+                    ++pout;
                 }
             }
         }
     }
-    else if (security == DLMS_SECURITY_ENCRYPTION)
+
+    static void aes_gcm_gctr(uint32_t* aes, const unsigned char* J0, unsigned char* in, int len, unsigned char* out)
     {
-        //Encrypt the data.
-        aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
-        if (!encrypt)
+        unsigned char J0inc[16];
+        if (len == 0)
         {
-            ret = bb_move(input, input->position, 0, bb_available(input));
-            input->position = 0;
+            return;
         }
-        aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+
+        memcpy(J0inc, J0, 16);
+        cip_inc32(J0inc);
+        cip_gctr(aes, J0inc, in, len, out);
     }
-    else if (security == DLMS_SECURITY_AUTHENTICATION_ENCRYPTION)
+
+    static void aes_gcm_ghash(const unsigned char* H, const unsigned char* aad, int aad_len,
+        const unsigned char* crypt, int crypt_len, unsigned char* S)
     {
-        if (encrypt)
+        unsigned char len_buf[16];
+        cip_getGHash(H, aad, aad_len, S);
+        cip_getGHash(H, crypt, crypt_len, S);
+        //Here is expected that data is never longer than 32 bit.
+        //This is done because microcontrollers show warning here.
+        PUT32(len_buf, (uint32_t)0);
+        PUT32(len_buf + 4, (uint32_t)(aad_len * 8));
+        PUT32(len_buf + 8, (uint32_t)0);
+        PUT32(len_buf + 12, (uint32_t)(crypt_len * 8));
+        cip_getGHash(H, len_buf, sizeof(len_buf), S);
+    }
+
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_crypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        gxByteBuffer* key,
+        gxByteBuffer* input,
+        unsigned char encrypt)
+    #else
+    int cip_crypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        unsigned char* key,
+        gxByteBuffer* input,
+        unsigned char encrypt)
+    #endif //DLMS_IGNORE_MALLOC
+    {
+        int ret;
+    #ifdef GX_DLMS_MICROCONTROLLER
+        static uint32_t aes[61] = { 0 };
+        static unsigned char H[16] = { 0 };
+        static unsigned char J0[16] = { 0 };
+        static unsigned char S[16] = { 0 };
+        //Nonse must be 20 bytes because it's used later.
+        static unsigned char NONSE[20] = { 0 };
+        memset(H, 0, sizeof(H));
+        memset(S, 0, sizeof(S));
+    #else
+        uint32_t aes[61] = { 0 };
+        unsigned char H[16] = { 0 };
+        unsigned char J0[16] = { 0 };
+        unsigned char S[16] = { 0 };
+        //Nonse must be 20 bytes because it's used later.
+        unsigned char NONSE[20] = { 0 };
+    #endif //GX_DLMS_MICROCONTROLLER
+        gxByteBuffer nonse;
+        if (memcmp(systemTitle, EMPTY_SYSTEM_TITLE, 8) == 0)
         {
-            //Encrypt the data.
-            aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
         }
-        if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
+        bb_attach(&nonse, NONSE, 0, sizeof(NONSE));
+        if ((ret = cip_getNonse(frameCounter, systemTitle, &nonse)) != 0)
         {
-            input->position = 0;
-            ret = bb_setUInt8ByIndex(input, 0, security | settings->suite);
-#ifndef DLMS_IGNORE_MALLOC
-            memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
-#else
-            memcpy(input->data + 1, settings->authenticationKey, offset - 1);
-#endif //DLMS_IGNORE_MALLOC
-            aes_gcm_ghash(H, input->data, offset, input->data + offset, input->size - offset, S);
-            if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+            return ret;
+        }
+        if ((ret = cip_int(
+            aes,
+    #ifndef DLMS_IGNORE_MALLOC
+            key->data,
+    #else
+            key,
+    #endif //DLMS_IGNORE_MALLOC
+            settings->suite == DLMS_SECURITY_SUITE_V2 ? 32 * 8 : 16 * 8)) != 0)
+        {
+            return ret;
+        }
+        if (settings->suite == DLMS_SECURITY_SUITE_V2)
+        {
+            aes[60] = 14;
+        }
+        else
+        {
+            aes[60] = 10;
+        }
+        //Hash subkey.
+        aes_Encrypt(aes, aes[60], H, H);
+        cip_init_j0(nonse.data, (unsigned char)nonse.size, H, J0);
+        //Allocate space for authentication tag.
+        if (security != DLMS_SECURITY_ENCRYPTION && !encrypt)
+        {
+            //Save authentication key to nonse.
+            bb_clear(&nonse);
+            ret = bb_set(&nonse, input->data + input->size - 12, 12);
+            input->size -= 12;
+        }
+        unsigned char offset;
+        if (settings->suite == DLMS_SECURITY_SUITE_V2)
+        {
+            offset = 33;
+        }
+        else
+        {
+            offset = 17;
+        }
+        if (security == DLMS_SECURITY_AUTHENTICATION)
+        {
+            if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
             {
-                if (!encrypt)
+                input->position = 0;
+                bb_setUInt8ByIndex(input, 0, security | settings->suite);
+    #ifndef DLMS_IGNORE_MALLOC
+                memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
+    #else
+                memcpy(input->data + 1, settings->authenticationKey, offset - 1);
+    #endif //DLMS_IGNORE_MALLOC
+                aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
+                if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
                 {
                     cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                    //Decrypt the data.
-                    aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
-                }
-                cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                if (encrypt)
-                {
-                    input->size += 12;
-                }
-                else
-                {
-                    //Check authentication tag.
-                    if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                    if (encrypt)
                     {
-                        ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        input->size += 12;
                     }
                     else
                     {
-                        ret = bb_move(input, input->position, 0, bb_available(input));
+                        if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                        {
+                            ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        }
                     }
-                    input->position = 0;
                 }
             }
         }
-    }
-    if (ret == 0 && encrypt)
-    {
-        ++settings->invocationCounter;
-    }
-    if (ret == 0 && encrypt && type == DLMS_COUNT_TYPE_PACKET)
-    {
-        if ((ret = bb_clear(&nonse)) == 0 &&
-            (ret = bb_setUInt8(&nonse, tag)) == 0)
+        else if (security == DLMS_SECURITY_ENCRYPTION)
         {
-            if (tag == DLMS_COMMAND_GENERAL_GLO_CIPHERING ||
-                tag == DLMS_COMMAND_GENERAL_DED_CIPHERING)
+            //Encrypt the data.
+            aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
+            if (!encrypt)
             {
-                hlp_setObjectCount(8, &nonse);
-                bb_set(&nonse, systemTitle, 8);
+                ret = bb_move(input, input->position, 0, bb_available(input));
+                input->position = 0;
             }
-            tag = security | settings->suite;
-            if (settings->broacast)
+            aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+        }
+        else if (security == DLMS_SECURITY_AUTHENTICATION_ENCRYPTION)
+        {
+            if (encrypt)
             {
-                tag |= 0x40;
+                //Encrypt the data.
+                aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
             }
-            if ((ret = hlp_setObjectCount(5 + input->size, &nonse)) == 0 &&
-                (ret = bb_setUInt8(&nonse, tag)) == 0 &&
-                (ret = bb_setUInt32(&nonse, frameCounter)) == 0 &&
-                (ret = bb_insert(nonse.data, nonse.size, input, 0)) == 0)
+            if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
             {
-                memcpy(input->data, nonse.data, nonse.size);
+                input->position = 0;
+                ret = bb_setUInt8ByIndex(input, 0, security | settings->suite);
+    #ifndef DLMS_IGNORE_MALLOC
+                memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
+    #else
+                memcpy(input->data + 1, settings->authenticationKey, offset - 1);
+    #endif //DLMS_IGNORE_MALLOC
+                aes_gcm_ghash(H, input->data, offset, input->data + offset, input->size - offset, S);
+                if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+                {
+                    if (!encrypt)
+                    {
+                        cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
+                        //Decrypt the data.
+                        aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+                    }
+                    cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
+                    if (encrypt)
+                    {
+                        input->size += 12;
+                    }
+                    else
+                    {
+                        //Check authentication tag.
+                        if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                        {
+                            ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        }
+                        else
+                        {
+                            ret = bb_move(input, input->position, 0, bb_available(input));
+                        }
+                        input->position = 0;
+                    }
+                }
             }
         }
+        if (ret == 0 && encrypt)
+        {
+            ++settings->invocationCounter;
+        }
+        if (ret == 0 && encrypt && type == DLMS_COUNT_TYPE_PACKET)
+        {
+            if ((ret = bb_clear(&nonse)) == 0 &&
+                (ret = bb_setUInt8(&nonse, tag)) == 0)
+            {
+                if (tag == DLMS_COMMAND_GENERAL_GLO_CIPHERING ||
+                    tag == DLMS_COMMAND_GENERAL_DED_CIPHERING)
+                {
+                    hlp_setObjectCount(8, &nonse);
+                    bb_set(&nonse, systemTitle, 8);
+                }
+                tag = security | settings->suite;
+                if (settings->broacast)
+                {
+                    tag |= 0x40;
+                }
+                if ((ret = hlp_setObjectCount(5 + input->size, &nonse)) == 0 &&
+                    (ret = bb_setUInt8(&nonse, tag)) == 0 &&
+                    (ret = bb_setUInt32(&nonse, frameCounter)) == 0 &&
+                    (ret = bb_insert(nonse.data, nonse.size, input, 0)) == 0)
+                {
+                    memcpy(input->data, nonse.data, nonse.size);
+                }
+            }
+        }
+        return ret;
     }
-    return ret;
-}
 
-#ifndef DLMS_IGNORE_MALLOC
-int cip_encrypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    gxByteBuffer* key,
-    gxByteBuffer* input)
-#else
-int cip_encrypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    unsigned char* key,
-    gxByteBuffer* input)
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_encrypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        gxByteBuffer* key,
+        gxByteBuffer* input)
+    #else
+    int cip_encrypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        unsigned char* key,
+        gxByteBuffer* input)
 #endif //DLMS_IGNORE_MALLOC
-{
-    return cip_crypt(
-        settings,
-        security,
-        type,
-        frameCounter,
-        tag,
-        systemTitle,
-        key,
-        input,
-        1);
-}
-
-#ifndef DLMS_IGNORE_MALLOC
-int cip_decrypt(
-    ciphering* settings,
-    unsigned char* title,
-    gxByteBuffer* key,
-    gxByteBuffer* data,
-    DLMS_SECURITY* security,
-    DLMS_SECURITY_SUITE* suite,
-    uint64_t* invocationCounter)
-#else
-int cip_decrypt(
-    ciphering* settings,
-    unsigned char* title,
-    unsigned char* key,
-    gxByteBuffer* data,
-    DLMS_SECURITY* security,
-    DLMS_SECURITY_SUITE* suite,
-    uint64_t* invocationCounter)
-#endif //DLMS_IGNORE_MALLOC
-{
-#ifdef GX_DLMS_MICROCONTROLLER
-    static unsigned char systemTitle[8];
-#else
-    unsigned char systemTitle[8];
-#endif //GX_DLMS_MICROCONTROLLER
-    uint16_t length;
-    int ret;
-    unsigned char ch;
-    uint32_t frameCounter;
-    DLMS_COMMAND cmd;
-    if (data == NULL || data->size - data->position < 2)
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_getUInt8(data, &ch)) != 0)
-    {
-        return ret;
-    }
-    cmd = (DLMS_COMMAND)ch;
-    switch (cmd)
-    {
-    case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
-    case DLMS_COMMAND_GENERAL_DED_CIPHERING:
-        if ((ret = hlp_getObjectCount2(data, &length)) != 0)
+        return cip_crypt(
+            settings,
+            security,
+            type,
+            frameCounter,
+            tag,
+            systemTitle,
+            key,
+            input,
+            1);
+    }
+
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_decrypt(
+        ciphering* settings,
+        unsigned char* title,
+        gxByteBuffer* key,
+        gxByteBuffer* data,
+        DLMS_SECURITY* security,
+        DLMS_SECURITY_SUITE* suite,
+        uint64_t* invocationCounter)
+    #else
+    int cip_decrypt(
+        ciphering* settings,
+        unsigned char* title,
+        unsigned char* key,
+        gxByteBuffer* data,
+        DLMS_SECURITY* security,
+        DLMS_SECURITY_SUITE* suite,
+        uint64_t* invocationCounter)
+    #endif //DLMS_IGNORE_MALLOC
+    {
+    #ifdef GX_DLMS_MICROCONTROLLER
+        static unsigned char systemTitle[8];
+    #else
+        unsigned char systemTitle[8];
+    #endif //GX_DLMS_MICROCONTROLLER
+        uint16_t length;
+        int ret;
+        unsigned char ch;
+        uint32_t frameCounter;
+        DLMS_COMMAND cmd;
+        if (data == NULL || data->size - data->position < 2)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_getUInt8(data, &ch)) != 0)
         {
             return ret;
         }
-        if (length != 0)
+        cmd = (DLMS_COMMAND)ch;
+        switch (cmd)
         {
-            if (length != 8)
+        case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
+        case DLMS_COMMAND_GENERAL_DED_CIPHERING:
+            if ((ret = hlp_getObjectCount2(data, &length)) != 0)
             {
-                return DLMS_ERROR_CODE_INVALID_PARAMETER;
+                return ret;
             }
-            bb_get(data, systemTitle, length);
-            title = systemTitle;
+            if (length != 0)
+            {
+                if (length != 8)
+                {
+                    return DLMS_ERROR_CODE_INVALID_PARAMETER;
+                }
+                bb_get(data, systemTitle, length);
+                title = systemTitle;
+            }
+            break;
+        case DLMS_COMMAND_GLO_INITIATE_REQUEST:
+        case DLMS_COMMAND_GLO_INITIATE_RESPONSE:
+        case DLMS_COMMAND_GLO_READ_REQUEST:
+        case DLMS_COMMAND_GLO_READ_RESPONSE:
+        case DLMS_COMMAND_GLO_WRITE_REQUEST:
+        case DLMS_COMMAND_GLO_WRITE_RESPONSE:
+        case DLMS_COMMAND_GLO_GET_REQUEST:
+        case DLMS_COMMAND_GLO_GET_RESPONSE:
+        case DLMS_COMMAND_GLO_SET_REQUEST:
+        case DLMS_COMMAND_GLO_SET_RESPONSE:
+        case DLMS_COMMAND_GLO_METHOD_REQUEST:
+        case DLMS_COMMAND_GLO_METHOD_RESPONSE:
+        case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
+        case DLMS_COMMAND_DED_INITIATE_REQUEST:
+        case DLMS_COMMAND_DED_INITIATE_RESPONSE:
+        case DLMS_COMMAND_DED_GET_REQUEST:
+        case DLMS_COMMAND_DED_GET_RESPONSE:
+        case DLMS_COMMAND_DED_SET_REQUEST:
+        case DLMS_COMMAND_DED_SET_RESPONSE:
+        case DLMS_COMMAND_DED_METHOD_REQUEST:
+        case DLMS_COMMAND_DED_METHOD_RESPONSE:
+        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
+            break;
+        default:
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
         }
-        break;
-    case DLMS_COMMAND_GLO_INITIATE_REQUEST:
-    case DLMS_COMMAND_GLO_INITIATE_RESPONSE:
-    case DLMS_COMMAND_GLO_READ_REQUEST:
-    case DLMS_COMMAND_GLO_READ_RESPONSE:
-    case DLMS_COMMAND_GLO_WRITE_REQUEST:
-    case DLMS_COMMAND_GLO_WRITE_RESPONSE:
-    case DLMS_COMMAND_GLO_GET_REQUEST:
-    case DLMS_COMMAND_GLO_GET_RESPONSE:
-    case DLMS_COMMAND_GLO_SET_REQUEST:
-    case DLMS_COMMAND_GLO_SET_RESPONSE:
-    case DLMS_COMMAND_GLO_METHOD_REQUEST:
-    case DLMS_COMMAND_GLO_METHOD_RESPONSE:
-    case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
-    case DLMS_COMMAND_DED_INITIATE_REQUEST:
-    case DLMS_COMMAND_DED_INITIATE_RESPONSE:
-    case DLMS_COMMAND_DED_GET_REQUEST:
-    case DLMS_COMMAND_DED_GET_RESPONSE:
-    case DLMS_COMMAND_DED_SET_REQUEST:
-    case DLMS_COMMAND_DED_SET_RESPONSE:
-    case DLMS_COMMAND_DED_METHOD_REQUEST:
-    case DLMS_COMMAND_DED_METHOD_RESPONSE:
-    case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
-        break;
-    default:
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = hlp_getObjectCount2(data, &length)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = bb_getUInt8(data, &ch)) != 0)
-    {
-        return ret;
-    }
-    *security = (DLMS_SECURITY)(ch & 0x30);
-    if (suite != NULL)
-    {
-        *suite = (DLMS_SECURITY_SUITE) (ch & 0x3);
-    }
-    //If Key_Set or authentication or encryption is not used.
-    if (ch & 0x40 || *security == DLMS_SECURITY_NONE)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_getUInt32(data, &frameCounter)) != 0)
-    {
-        return ret;
-    }
-    if (invocationCounter != NULL)
-    {
-        *invocationCounter = frameCounter;
-    }
-    ret = cip_crypt(
-        settings,
-        *security,
-        DLMS_COUNT_TYPE_DATA,
-        frameCounter,
-        0,
-        title,
-        key,
-        data,
-        0);
-    return ret;
-}
-
-static const unsigned char WRAP_IV[] = { 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
-
-int cip_encryptKey(
-    unsigned char* kek,
-    unsigned char size,
-    gxByteBuffer* data,
-    gxByteBuffer* output)
-{
-    unsigned char buf[16] = { 0 };
-    unsigned char buf2[16] = { 0 };
-    unsigned char n, j, i;
-
-    if (kek == NULL || size != 16 ||
-        data == NULL || data->size != 16 ||
-        output == NULL)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    bb_capacity(output, 24);
-    output->size = 24;
-    output->position = 0;
-    // Amount of 64-bit blocks.
-    n = (unsigned char)(data->size >> 3);
-    memcpy(output->data, WRAP_IV, 8);
-    memcpy(output->data + 8, data->data, data->size);
-    for (j = 0; j != 6; j++)
-    {
-        for (i = 1; i <= n; i++)
-        {
-            memcpy(buf, output->data, 8);
-            memcpy(buf + 8, output->data + (8 * i), 8);
-            gxaes_ecb_encrypt(buf, kek, buf2, 16);
-            unsigned int t = n * j + i;
-            for (int k = 1; t != 0; k++)
-            {
-                unsigned char v = (unsigned char)t;
-                buf2[sizeof(WRAP_IV) - k] ^= v;
-                t = (int)((unsigned int)t >> 8);
-            }
-            memcpy(output->data, buf2, 8);
-            memcpy(output->data + (8 * i), buf2 + 8, 8);
-        }
-    }
-    return 0;
-}
-
-int cip_decryptKey(
-    unsigned char* kek,
-    //KEK size.
-    unsigned char size,
-    gxByteBuffer* data,
-    gxByteBuffer* output)
-{
-    int ret;
-    unsigned char a[8];
-    unsigned char buf[16];
-    unsigned char buf2[16];
-    signed char j, i;
-    unsigned char k, v, n;
-    uint16_t t;
-    // Amount of 64-bit blocks.
-    n = (unsigned char)(bb_size(data) >> 3);
-    if (kek == NULL || size != 16 || data == NULL || data->size != n * 8 ||
-        output == NULL)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_capacity(output, 16)) != 0)
-    {
+        if ((ret = hlp_getObjectCount2(data, &length)) != 0)
+        {
+            return ret;
+        }
+        if ((ret = bb_getUInt8(data, &ch)) != 0)
+        {
+            return ret;
+        }
+        *security = (DLMS_SECURITY)(ch & 0x30);
+        if (suite != NULL)
+        {
+            *suite = (DLMS_SECURITY_SUITE)(ch & 0x3);
+        }
+        //If Key_Set or authentication or encryption is not used.
+        if (ch & 0x40 || *security == DLMS_SECURITY_NONE)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_getUInt32(data, &frameCounter)) != 0)
+        {
+            return ret;
+        }
+        if (invocationCounter != NULL)
+        {
+            *invocationCounter = frameCounter;
+        }
+        ret = cip_crypt(
+            settings,
+            *security,
+            DLMS_COUNT_TYPE_DATA,
+            frameCounter,
+            0,
+            title,
+            key,
+            data,
+            0);
         return ret;
     }
-    output->size = 16;
-    output->position = 0;
-    memcpy(a, data->data, sizeof(WRAP_IV));
-    memcpy(output->data, data->data + sizeof(WRAP_IV), data->size - sizeof(WRAP_IV));
-    if (--n == 0)
-    {
-        n = 1;
+
+    static const unsigned char WRAP_IV[] = { 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
+
+    int cip_encryptKey(
+        unsigned char* kek,
+        unsigned char size,
+        gxByteBuffer* data,
+        gxByteBuffer* output)
+    {
+        unsigned char buf[16] = { 0 };
+        unsigned char buf2[16] = { 0 };
+        unsigned char n, j, i;
+
+        if (kek == NULL || size != 16 ||
+            data == NULL || data->size != 16 ||
+            output == NULL)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        bb_capacity(output, 24);
+        output->size = 24;
+        output->position = 0;
+        // Amount of 64-bit blocks.
+        n = (unsigned char)(data->size >> 3);
+        memcpy(output->data, WRAP_IV, 8);
+        memcpy(output->data + 8, data->data, data->size);
+        for (j = 0; j != 6; j++)
+        {
+            for (i = 1; i <= n; i++)
+            {
+                memcpy(buf, output->data, 8);
+                memcpy(buf + 8, output->data + (8 * i), 8);
+                gxaes_ecb_encrypt(buf, kek, buf2, 16);
+                unsigned int t = n * j + i;
+                for (int k = 1; t != 0; k++)
+                {
+                    unsigned char v = (unsigned char)t;
+                    buf2[sizeof(WRAP_IV) - k] ^= v;
+                    t = (int)((unsigned int)t >> 8);
+                }
+                memcpy(output->data, buf2, 8);
+                memcpy(output->data + (8 * i), buf2 + 8, 8);
+            }
+        }
+        return 0;
     }
-    for (j = 5; j >= 0; j--)
-    {
-        for (i = n; i >= 1; i--)
+
+    int cip_decryptKey(
+        unsigned char* kek,
+        //KEK size.
+        unsigned char size,
+        gxByteBuffer* data,
+        gxByteBuffer* output)
+    {
+        int ret;
+        unsigned char a[8];
+        unsigned char buf[16];
+        unsigned char buf2[16];
+        signed char j, i;
+        unsigned char k, v, n;
+        uint16_t t;
+        // Amount of 64-bit blocks.
+        n = (unsigned char)(bb_size(data) >> 3);
+        if (kek == NULL || size != 16 || data == NULL || data->size != n * 8 ||
+            output == NULL)
         {
-            memcpy(buf, a, sizeof(WRAP_IV));
-            memcpy(buf + sizeof(WRAP_IV), output->data + 8 * (i - 1), 8);
-            t = n * j + i;
-            for (k = 1; t != 0; k++)
-            {
-                v = (unsigned char)t;
-                buf[sizeof(WRAP_IV) - k] ^= v;
-                t = (uint16_t)(t >> 8);
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_capacity(output, 16)) != 0)
+        {
+            return ret;
+        }
+        output->size = 16;
+        output->position = 0;
+        memcpy(a, data->data, sizeof(WRAP_IV));
+        memcpy(output->data, data->data + sizeof(WRAP_IV), data->size - sizeof(WRAP_IV));
+        if (--n == 0)
+        {
+            n = 1;
+        }
+        for (j = 5; j >= 0; j--)
+        {
+            for (i = n; i >= 1; i--)
+            {
+                memcpy(buf, a, sizeof(WRAP_IV));
+                memcpy(buf + sizeof(WRAP_IV), output->data + 8 * (i - 1), 8);
+                t = n * j + i;
+                for (k = 1; t != 0; k++)
+                {
+                    v = (unsigned char)t;
+                    buf[sizeof(WRAP_IV) - k] ^= v;
+                    t = (uint16_t)(t >> 8);
+                }
+                gxaes_ecb_decrypt(buf, kek, buf2, 16);
+                memcpy(a, buf2, 8);
+                memcpy(output->data + 8 * (i - 1), buf2 + 8, 8);
             }
-            gxaes_ecb_decrypt(buf, kek, buf2, 16);
-            memcpy(a, buf2, 8);
-            memcpy(output->data + 8 * (i - 1), buf2 + 8, 8);
         }
+        if (memcmp(a, WRAP_IV, sizeof(WRAP_IV)) != 0)
+        {
+            output->size = 0;
+            return DLMS_ERROR_CODE_FALSE;
+        }
+        return 0;
     }
-    if (memcmp(a, WRAP_IV, sizeof(WRAP_IV)) != 0)
-    {
-        output->size = 0;
-        return DLMS_ERROR_CODE_FALSE;
-    }
-    return 0;
-}
 
-#endif //DLMS_IGNORE_HIGH_GMAC
+    #endif //DLMS_IGNORE_HIGH_GMAC
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/client.c src/development/src/client.c
--- upstream/development/src/client.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/client.c	2024-06-19 13:37:18.000000000 +0000
@@ -413,15 +413,14 @@
     gxByteBuffer challenge;
     gxByteBuffer* pw;
     dlmsVARIANT data;
-#ifndef DLMS_IGNORE_HIGH_GMAC
-#ifdef DLMS_IGNORE_MALLOC
+#if !defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
     gxByteBuffer pw2;
-#endif //DLMS_IGNORE_MALLOC
+    bb_init(&pw2);
 #endif //DLMS_IGNORE_HIGH_GMAC
 #ifndef GX_DLMS_MICROCONTROLLER
-    unsigned char APPLICATION_ASSOCIATION_REQUEST[32];
+    unsigned char APPLICATION_ASSOCIATION_REQUEST[64];
 #else
-    static unsigned char APPLICATION_ASSOCIATION_REQUEST[32];
+    static unsigned char APPLICATION_ASSOCIATION_REQUEST[64];
 #endif //DLMS_IGNORE_HIGH_GMAC
     bb_attach(&challenge, APPLICATION_ASSOCIATION_REQUEST, 0, sizeof(APPLICATION_ASSOCIATION_REQUEST));
     if (settings->authentication != DLMS_AUTHENTICATION_HIGH_ECDSA &&
@@ -444,8 +443,34 @@
         pw = &pw2;
 #endif //DLMS_IGNORE_MALLOC
     }
-    else
 #endif //DLMS_IGNORE_HIGH_GMAC
+#ifndef DLMS_IGNORE_HIGH_SHA256
+    else if (settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256)
+    {
+#ifdef DLMS_IGNORE_MALLOC
+        if ((ret = bb_set(&pw2, settings->password.data, settings->password.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->cipher.systemTitle, 8)) != 0 ||
+            (ret = bb_set(&pw2, settings->sourceSystemTitle, 8)) != 0)
+        {
+            return ret;
+        }
+#else
+        if ((ret = bb_set(&pw2, settings->password.data, settings->password.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->sourceSystemTitle, 8)) != 0)
+        {
+            return ret;
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if ((ret = bb_set(&pw2, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0)
+        {
+            return ret;
+        }
+        pw = &pw2;
+    }
+    else
+#endif //DLMS_IGNORE_HIGH_SHA256
     {
         pw = &settings->password;
     }
@@ -458,9 +483,14 @@
         & settings->stoCChallenge,
         pw,
         &challenge);
+#if !defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
+    bb_clear(&pw2);
+#endif //!defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
     if (ret == 0)
     {
+#if !defined(DLMS_IGNORE_HIGH_GMAC)
         ++settings->cipher.invocationCounter;
+#endif //!defined(DLMS_IGNORE_HIGH_GMAC)
         var_init(&data);
         data.vt = DLMS_DATA_TYPE_OCTET_STRING;
         data.byteArr = &challenge;
@@ -531,6 +561,22 @@
         }
         else
 #endif //DLMS_IGNORE_HIGH_GMAC
+#ifndef DLMS_IGNORE_HIGH_SHA256
+        if (settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256)
+        {
+            bb_attach(&bb2, CHALLENGE_BUFF, 0, sizeof(CHALLENGE_BUFF));
+            secret = &bb2;
+            if ((ret = bb_set(secret, settings->password.data, settings->password.size)) != 0 ||
+                (ret = bb_set(secret, settings->sourceSystemTitle, 8)) != 0 ||
+                (ret = bb_set(secret, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
+                (ret = bb_set(secret, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0 ||
+                (ret = bb_set(secret, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0)
+            {
+                return ret;
+            }
+        }
+        else
+#endif //DLMS_IGNORE_HIGH_SHA256        
         {
             secret = &settings->password;
         }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/converters.c src/development/src/converters.c
--- upstream/development/src/converters.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/converters.c	2024-06-19 13:37:18.000000000 +0000
@@ -1047,6 +1047,47 @@
 }
 
 #ifndef DLMS_IGNORE_PUSH_SETUP
+
+int obj_PushProtectionParametersToString(gxByteBuffer* ba, gxArray* objects)
+{
+    uint16_t pos;
+    int ret = DLMS_ERROR_CODE_OK;
+    gxPushProtectionParameters* it;
+    for (pos = 0; pos != objects->size; ++pos)
+    {
+        if ((ret = arr_getByIndex(objects, pos, (void**)&it)) != DLMS_ERROR_CODE_OK)
+        {
+            break;
+        }
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+        if ((ret = bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->target->objectType))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = hlp_appendLogicalName(ba, it->target->logicalName)) != 0)
+        {
+            break;
+        }
+#else
+        if ((ret = bb_addIntAsString(ba, it->protectionType)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->transactionId.data, bb_size(&it->transactionId))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->originatorSystemTitle, 8)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->recipientSystemTitle, 8)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->otherInformation.data, bb_size(&it->otherInformation))) != 0)
+        {
+            break;
+        }
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    }
+    return ret;
+}
+
 int obj_pushSetupToString(gxPushSetup* object, char** buff)
 {
     int ret;
@@ -1064,11 +1105,72 @@
         (ret = bb_addIntAsString(&ba, object->randomisationStartInterval)) == 0 &&
         (ret = bb_addString(&ba, "\nIndex: 6 Value: ")) == 0 &&
         (ret = bb_addIntAsString(&ba, object->numberOfRetries)) == 0 &&
-        (ret = bb_addString(&ba, "\nIndex: 7 Value: ")) == 0 &&
-        (ret = bb_addIntAsString(&ba, object->repetitionDelay)) == 0 &&
-        (ret = bb_addString(&ba, "\n")) == 0)
+        (ret = bb_addString(&ba, "\nIndex: 7 Value: ")) == 0)
     {
-        *buff = bb_toString(&ba);
+        if (object->base.version < 2)
+        {
+            ret = bb_addIntAsString(&ba, object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = bb_addIntAsString(&ba, object->repetitionDelay2.min)) == 0 &&
+                (ret = bb_addString(&ba, ", ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->repetitionDelay2.exponent)) == 0 &&
+                (ret = bb_addString(&ba, ", ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->repetitionDelay2.max)) == 0)
+            {
+
+            }
+        }
+        if (object->base.version > 0)
+        {
+            if ((ret = bb_addString(&ba, "\nIndex: 8 Value: ")) == 0)
+            {
+                if (object->portReference == NULL)
+                {
+                    ret = hlp_appendLogicalName(&ba, EMPTY_LN);
+                }
+                else
+                {
+                    ret = hlp_appendLogicalName(&ba, object->portReference->logicalName);
+                }
+            }
+
+            if (ret == 0 &&
+                (ret = bb_addString(&ba, "\nIndex: 9 Value: ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->pushClientSAP)) == 0)
+            {
+
+            }
+
+            if (ret == 0 &&
+                (ret = bb_addString(&ba, "\nIndex: 10 Value: ")) == 0)
+            {
+                ret = obj_PushProtectionParametersToString(&ba, &object->pushProtectionParameters);
+            }
+            if (object->base.version > 1 && ret == 0)
+            {
+                if ((ret = bb_addString(&ba, "\nIndex: 11 Value: ")) == 0 &&
+                    (ret = bb_addIntAsString(&ba, object->pushOperationMethod)) == 0)
+                {
+                    if ((ret = bb_addString(&ba, "\nIndex: 12 Value: ")) == 0 &&
+                        (ret = time_toString(&object->confirmationParameters.startDate, &ba)) == 0 &&
+                        (ret = bb_addString(&ba, ", ")) == 0 &&
+                        (ret = bb_addIntAsString(&ba, object->confirmationParameters.interval)) == 0)
+                    {
+                        if ((ret = bb_addString(&ba, "\nIndex: 13 Value: ")) == 0 &&
+                            (ret = time_toString(&object->lastConfirmationDateTime, &ba)) == 0)
+                        {
+                        }
+                    }
+                }
+            }
+        }
+        if (ret == 0 &&
+            (ret = bb_addString(&ba, "\n")) == 0)
+        {
+            *buff = bb_toString(&ba);
+        }
     }
     bb_clear(&ba);
     return ret;
@@ -1238,12 +1340,12 @@
             bb_addIntAsString(ba, it->scriptSelector);
             bb_addString(ba, " ");
             time_toString(&it->startTime, ba);
-        }
+            }
         bb_addString(ba, "]");
-    }
+        }
     bb_addString(ba, "]");
     return 0;
-}
+    }
 
 int obj_activityCalendarToString(gxActivityCalendar* object, char** buff)
 {
@@ -1502,13 +1604,13 @@
                     (ret = bb_attachString(&ba, bb_toHexString(&it->indexes))) != 0)
                 {
                     break;
-                }
-#endif //DLMS_IGNORE_OBJECT_POINTERS
             }
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+        }
             bb_addString(&ba, "]\n");
             *buff = bb_toString(&ba);
-        }
     }
+}
     bb_clear(&ba);
     return ret;
 }
@@ -1530,7 +1632,7 @@
 #endif //DLMS_IGNORE_OBJECT_POINTERS
     bb_addString(ba, " ");
     bb_addIntAsString(ba, item->scriptSelector);
-}
+    }
 #endif //!(defined(DLMS_IGNORE_REGISTER_MONITOR) && defined(DLMS_IGNORE_LIMITER))
 
 #ifndef DLMS_IGNORE_REGISTER_MONITOR
@@ -1601,7 +1703,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_REGISTER_MONITOR
 #ifndef DLMS_IGNORE_ACTION_SCHEDULE
 int obj_actionScheduleToString(gxActionSchedule* object, char** buff)
@@ -1655,7 +1757,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return DLMS_ERROR_CODE_OK;
-}
+    }
 #endif //DLMS_IGNORE_ACTION_SCHEDULE
 #ifndef DLMS_IGNORE_SAP_ASSIGNMENT
 int obj_sapAssignmentToString(gxSapAssignment* object, char** buff)
@@ -1762,7 +1864,7 @@
         {
             return ret;
         }
-    }
+        }
     bb_addString(&ba, "]\nIndex: 5 Value: [");
     for (pos = 0; pos != object->ipOptions.size; ++pos)
     {
@@ -1795,7 +1897,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_IP4_SETUP
 
 #ifndef DLMS_IGNORE_IP6_SETUP
@@ -1909,7 +2011,7 @@
     }
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_IP6_SETUP
 
 #ifndef DLMS_IGNORE_MBUS_DIAGNOSTIC
@@ -2340,7 +2442,7 @@
     if ((ret = obj_UInt16ArrayToString(&ba, &object->groupTable)) != 0)
     {
         return ret;
-    }
+}
 #else
     if ((ret = va_toString(&object->groupTable, &ba)) != 0)
     {
@@ -2369,7 +2471,7 @@
     {
         bb_clear(&ba);
         return ret;
-    }
+}
 #else
     if ((ret = va_toString(&object->destinationAddress, &ba)) != 0)
     {
@@ -2385,7 +2487,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return ret;
-}
+    }
 #endif //DLMS_IGNORE_G3_PLC_6LO_WPAN
 
 
@@ -2650,7 +2752,7 @@
     if ((ret = obj_UInt16ArrayToString(&ba, &object->emergencyProfileGroupIDs)) != 0)
     {
         return ret;
-    }
+}
 #else
     if ((ret = va_toString(&object->emergencyProfileGroupIDs, &ba)) != 0)
     {
@@ -2711,7 +2813,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_MBUS_CLIENT
 #ifndef DLMS_IGNORE_MODEM_CONFIGURATION
 int obj_modemConfigurationToString(gxModemConfiguration* object, char** buff)
@@ -3034,7 +3136,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_PPP_SETUP
 
 #ifndef DLMS_IGNORE_PROFILE_GENERIC
@@ -3088,7 +3190,7 @@
         {
             break;
         }
-    }
+}
     return ret;
 }
 int obj_accountToString(gxAccount* object, char** buff)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/cosem.c src/development/src/cosem.c
--- upstream/development/src/cosem.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/cosem.c	2024-06-19 13:37:18.000000000 +0000
@@ -926,7 +926,10 @@
     return 0;
 }
 
-int cosem_getOctetStringBase(gxByteBuffer* bb, gxByteBuffer* value, unsigned char type, unsigned char exact)
+int cosem_getOctetStringBase(gxByteBuffer* bb, 
+    gxByteBuffer* value, 
+    unsigned char type, 
+    unsigned char exact)
 {
     int ret;
     unsigned char tmp;
@@ -955,7 +958,11 @@
     return 0;
 }
 
-int cosem_getOctetStringBase2(gxByteBuffer* bb, unsigned char* value, uint16_t capacity, uint16_t* size, unsigned char type)
+int cosem_getOctetStringBase2(gxByteBuffer* bb, 
+    unsigned char* value, 
+    uint16_t capacity, 
+    uint16_t* size, 
+    unsigned char type)
 {
     int ret;
     unsigned char tmp;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/date.c src/development/src/date.c
--- upstream/development/src/date.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/date.c	2024-06-19 13:37:18.000000000 +0000
@@ -191,6 +191,11 @@
         time->extraInfo = DLMS_DATE_TIME_EXTRA_INFO_LAST_DAY2;
         day = 1;
     }
+    else if ((time->skip & DATETIME_SKIPS_MONTH) != 0)
+    {
+        //If month is skipped.
+        day += 2;
+    }
     tmp = month;
     tmp *= 30L;
     time->value += tmp;
@@ -238,12 +243,17 @@
     {
         time->skip |= DATETIME_SKIPS_SECOND;
     }
-    time->skip |= DATETIME_SKIPS_MS;
+    if (millisecond < 1000)
+    {
+        time->skip |= DATETIME_SKIPS_MS;
+        millisecond = 0;
+    }
     if (devitation == (short)0x8000)
     {
         time->skip |= DATETIME_SKIPS_DEVITATION;
     }
     time->deviation = devitation;
+    time->millisecond = millisecond;
 #else
     int skip = DATETIME_SKIPS_NONE;
     memset(&time->value, 0, sizeof(time->value));
@@ -317,6 +327,7 @@
     time->value.tm_min = minute;
     time->value.tm_sec = second;
     time->deviation = devitation;
+    time->millisecond = millisecond;
     if (gxmktime(&time->value) == (time_t)-1)
     {
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
@@ -1164,6 +1175,17 @@
         }
         bb_setUInt8(ba, '*');
     }
+    //Add milliseconds.
+    if ((time->skip & DATETIME_SKIPS_MS) == 0 &&
+        time->millisecond != 0)
+    {
+        if (!empty)
+        {
+            bb_setUInt8(ba, '.');
+        }
+        empty = 0;
+        bb_addIntAsString2(ba, time->millisecond, 2);
+    }
     if (time->deviation != (short)0x8000 && (time->skip & DATETIME_SKIPS_DEVITATION) == 0)
     {
         short tmp = time->deviation;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/dlms.c src/development/src/dlms.c
--- upstream/development/src/dlms.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/dlms.c	2024-06-19 13:37:18.000000000 +0000
@@ -3185,6 +3185,18 @@
         {
             settings->serverAddress = value;
         }
+#ifndef DLMS_IGNORE_SERVER
+        if (settings->connected == DLMS_CONNECTION_STATE_NONE)
+        {
+            // Check is data send to this server.
+            if (!svr_isTarget(settings, settings->serverAddress, settings->clientAddress))
+            {
+                settings->serverAddress = 0;
+                settings->clientAddress = 0;
+                return DLMS_ERROR_CODE_INVALID_CLIENT_ADDRESS;
+            }
+        }
+#endif //DLMS_IGNORE_SERVER
     }
     else
     {
@@ -3681,7 +3693,11 @@
 }
 #endif //DLMS_IGNORE_PLC
 
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+int dlms_getDataFromBlock(gxByteBuffer* data, uint32_t index)
+#else
 int dlms_getDataFromBlock(gxByteBuffer* data, uint16_t index)
+#endif
 {
 #if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
     uint32_t pos, len = data->position - index;
@@ -3886,7 +3902,7 @@
 int dlms_handleGetResponse(
     dlmsSettings* settings,
     gxReplyData* reply,
-    uint16_t index)
+    uint32_t index)
 {
     int ret;
     uint16_t count;
@@ -4852,6 +4868,9 @@
             {
                 return ret;
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         }
         //If pre-set connection is made.
         else if (dlms_usePreEstablishedConnection(settings) && emptySourceSystemTile)
@@ -4889,6 +4908,9 @@
             {
                 return ret;
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
             if (data->preEstablished == 0)
             {
                 data->preEstablished = 1;
@@ -4911,6 +4933,9 @@
             {
                 return ret;
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         }
         //If IC value is wrong.
         if (settings->expectedInvocationCounter != NULL)
@@ -4990,6 +5015,12 @@
                 return ret;
             }
         }
+#ifdef DLMS_TRACE_PDU
+        if (ret == 0)
+        {
+            cip_tracePdu(0, &bb);
+        }
+#endif //DLMS_TRACE_PDU
         data->data.size = bb.size + index;
         //If target is sending data ciphered using different security policy.
         if (settings->cipher.security != security)
@@ -5049,6 +5080,9 @@
         {
             return ret;
         }
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         // Get command
         if ((ret = bb_getUInt8(&data->data, &ch)) != 0)
         {
@@ -5167,7 +5201,7 @@
             break;
 #endif //!defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
         case DLMS_COMMAND_GET_RESPONSE:
-            if ((ret = dlms_handleGetResponse(settings, data, (uint16_t)index)) != 0)
+            if ((ret = dlms_handleGetResponse(settings, data, index)) != 0)
             {
                 if (ret == DLMS_ERROR_CODE_FALSE)
                 {
@@ -5253,7 +5287,8 @@
 #if !defined(DLMS_IGNORE_SERVER)
             if (settings->server)
             {
-                if ((settings->connected & DLMS_CONNECTION_STATE_DLMS) == 0)
+                if ((settings->connected & DLMS_CONNECTION_STATE_DLMS) == 0 &&
+                    dlms_usePreEstablishedConnection(settings) == 0)
                 {
                     return DLMS_ERROR_CODE_INVALID_DECIPHERING_ERROR;
                 }
@@ -5651,6 +5686,9 @@
     if (ciphering && p->command != DLMS_COMMAND_AARQ
         && p->command != DLMS_COMMAND_AARE)
     {
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(1, reply);
+#endif //DLMS_TRACE_PDU
         ret = cip_encrypt(
             &p->settings->cipher,
             p->settings->cipher.security,
@@ -5838,7 +5876,7 @@
         // Add attribute descriptor.
         if (ret == 0 && p->attributeDescriptor != NULL)
         {
-            ret = bb_set(reply, p->attributeDescriptor->data, p->attributeDescriptor->size);
+            ret = bb_set2(reply, p->attributeDescriptor, p->attributeDescriptor->position, p->attributeDescriptor->size);
         }
 #endif //DLMS_IGNORE_MALLOC
         if (ret == 0 &&
@@ -6001,6 +6039,9 @@
                 key = p->settings->cipher.blockCipherKey;
 #endif //DLMS_IGNORE_MALLOC
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(1, reply);
+#endif //DLMS_TRACE_PDU
             ret = cip_encrypt(
                 &p->settings->cipher,
                 p->settings->cipher.security,
@@ -6357,10 +6398,12 @@
         switch (data->command)
         {
         case DLMS_COMMAND_DATA_NOTIFICATION:
+#ifndef DLMS_IGNORE_HIGH_GMAC
         case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
+        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
+#endif //DLMS_IGNORE_HIGH_GMAC
         case DLMS_COMMAND_INFORMATION_REPORT:
         case DLMS_COMMAND_EVENT_NOTIFICATION:
-        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
             *isNotify = 1;
             notify->complete = data->complete;
             notify->moreData = data->moreData;
@@ -6388,9 +6431,10 @@
     gxByteBuffer* challenge)
 {
     // Random challenge is 8 to 64 bytes.
-    // Texas Instruments accepts only 16 byte int32_t challenge.
+    // Texas Instruments accepts only 16 byte long challenge.
     // For this reason challenge size is 16 bytes at the moment.
-    int ret = 0, pos, len = 16;//hlp_rand() % 58 + 8;
+    int ret = 0, pos, len = 16;
+    srand((unsigned int)time(NULL));
     bb_clear(challenge);
     for (pos = 0; pos != len; ++pos)
     {
@@ -6578,40 +6622,6 @@
             //If SHA256 is not used.
 #ifdef DLMS_IGNORE_HIGH_SHA256
             return DLMS_ERROR_CODE_NOT_IMPLEMENTED;
-#else
-#ifndef DLMS_IGNORE_HIGH_GMAC
-#ifdef DLMS_IGNORE_MALLOC
-            if ((ret = bb_set(&challenge, secret->data, secret->size)) != 0 ||
-                (ret = bb_set(&challenge, settings->cipher.systemTitle, 8)) != 0 ||
-                (ret = bb_set(&challenge, settings->sourceSystemTitle, 8)) != 0)
-            {
-                return ret;
-            }
-#else
-            if ((ret = bb_set(&challenge, secret->data, secret->size)) != 0 ||
-                (ret = bb_set(&challenge, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
-                (ret = bb_set(&challenge, settings->sourceSystemTitle, 8)) != 0)
-            {
-                return ret;
-            }
-#endif //DLMS_IGNORE_MALLOC
-            if (settings->server)
-            {
-                if ((ret = bb_set(&challenge, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0 ||
-                    (ret = bb_set(&challenge, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0)
-                {
-                    return ret;
-                }
-            }
-            else
-            {
-                if ((ret = bb_set(&challenge, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0 ||
-                    (ret = bb_set(&challenge, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0)
-                {
-                    return ret;
-                }
-            }
-#endif //DLMS_IGNORE_HIGH_GMAC
 #endif //DLMS_IGNORE_HIGH_SHA256
         }
         else
@@ -6651,7 +6661,7 @@
 #ifdef DLMS_IGNORE_HIGH_SHA256
         return DLMS_ERROR_CODE_NOT_IMPLEMENTED;
 #else
-        ret = gxsha256_encrypt(&challenge, reply);
+        ret = gxsha256_encrypt(secret, reply);
         bb_clear(&challenge);
         return ret;
 #endif //DLMS_IGNORE_HIGH_SHA256
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxget.c src/development/src/gxget.c
--- upstream/development/src/gxget.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxget.c	2024-06-19 13:37:18.000000000 +0000
@@ -4437,16 +4437,16 @@
                     {
                         break;
                     }
-                    }
                 }
             }
         }
+    }
     else
     {
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
     return ret;
-    }
+}
 #endif //DLMS_IGNORE_FUNCTION_CONTROL
 
 #ifndef DLMS_IGNORE_ARRAY_MANAGER
@@ -4581,7 +4581,7 @@
                     (ret = cosem_setUInt16(data, it->dataIndex)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->pushObjectList, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 4)) != 0 ||
@@ -4597,9 +4597,9 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
+            }
+        }
     }
-}
-}
     else if (e->index == 3)
     {
         if ((ret = cosem_setStructure(data, 3)) != 0 ||
@@ -4630,7 +4630,7 @@
                     (ret = cosem_setDateTimeAsOctetString(data, &d->second)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->communicationWindow, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 2)) != 0 ||
@@ -4642,7 +4642,7 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
+            }
         }
     }
     else if (e->index == 5)
@@ -4655,7 +4655,101 @@
     }
     else if (e->index == 7)
     {
-        ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay);
+        if (object->base.version < 2)
+        {
+            ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = cosem_setStructure(e->value.byteArr, 3)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.min)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.exponent)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.max)) == 0)
+            {
+            }
+        }
+    }
+    else if (e->index == 8)
+    {
+#ifdef DLMS_IGNORE_MALLOC
+        ret = cosem_setOctetString2(data, object->portReference, 6);
+#else
+        ret = cosem_setOctetString2(data, obj_getLogicalName(object->portReference), 6);
+#endif //DLMS_IGNORE_MALLOC
+    }
+    else if (e->index == 9)
+    {
+        ret = cosem_setInt8(e->value.byteArr, object->pushClientSAP);
+    }
+    else if (e->index == 10)
+    {
+        if ((ret = cosem_setArray(data, object->pushProtectionParameters.size)) != 0)
+        {
+            return ret;
+        }
+        gxPushProtectionParameters* it2;
+        for (pos = 0; pos != object->pushProtectionParameters.size; ++pos)
+        {
+#ifdef DLMS_IGNORE_MALLOC
+            if ((ret = arr_getByIndex(&object->pushProtectionParameters, pos, (void**)&it2, sizeof(gxPushProtectionParameters))) != 0 ||
+#else
+            if ((ret = arr_getByIndex(&object->pushProtectionParameters, pos, (void**)&it2)) != 0 ||
+#endif //DLMS_IGNORE_MALLOC
+                (ret = cosem_setStructure(data, 2)) != 0 ||
+                (ret = cosem_setEnum(data, it2->protectionType)) != 0 ||
+                (ret = cosem_setStructure(data, 5)) != 0 ||
+                (ret = cosem_setOctetString(data, &it2->transactionId)) != 0 ||
+                (ret = cosem_setOctetString2(data, it2->originatorSystemTitle, 8)) != 0 ||
+                (ret = cosem_setOctetString2(data, it2->recipientSystemTitle, 8)) != 0 ||
+                (ret = cosem_setOctetString(data, &it2->otherInformation)) != 0 ||
+                (ret = cosem_setStructure(data, 2)) != 0 ||
+                (ret = cosem_setEnum(data, it2->keyInfo.dataProtectionKeyType)) != 0)
+            {
+                break;
+            }
+            if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+            {
+                if ((ret = cosem_setStructure(data, 1)) != 0 ||
+                    (ret = cosem_setEnum(data, it2->keyInfo.identifiedKey.keyType)) != 0)
+                {
+                    break;
+                }
+            }
+            else if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+            {
+                if ((ret = cosem_setStructure(data, 2)) != 0 ||
+                    (ret = cosem_setEnum(data, it2->keyInfo.wrappedKey.keyType)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.wrappedKey.key)) != 0)
+                {
+                    break;
+                }
+            }
+            else if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+            {
+                if ((ret = cosem_setStructure(data, 2)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.agreedKey.parameters)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.agreedKey.data)) != 0)
+                {
+                    break;
+                }
+            }
+        }
+    }
+    else if (e->index == 11)
+    {
+        ret = cosem_setEnum(e->value.byteArr, object->pushOperationMethod);
+    }
+    else if (e->index == 12)
+    {
+        if ((ret = cosem_setStructure(e->value.byteArr, 2)) == 0 &&
+            (ret = cosem_setDateTime(e->value.byteArr, &object->confirmationParameters.startDate)) == 0 &&
+            (ret = cosem_setUInt32(e->value.byteArr, object->confirmationParameters.interval)) == 0)
+        {
+        }
+    }
+    else if (e->index == 13)
+    {
+        ret = cosem_setDateTime(e->value.byteArr, &object->lastConfirmationDateTime);
     }
     else
     {
@@ -4726,8 +4820,8 @@
             {
                 break;
             }
+        }
     }
-}
     else
     {
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -4784,7 +4878,7 @@
             (ret = cosem_setInt16(data, it->chargePerUnit)) != 0)
         {
             break;
-}
+        }
 #else
         if ((ret = arr_getByIndex(&target->chargeTables, pos, (void**)&it)) != 0 ||
             (ret = cosem_setStructure(data, 2)) != 0 ||
@@ -4894,7 +4988,7 @@
                 if ((ret = cosem_setOctetString2(data, it->value, it->size)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->descriptions, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setOctetString(data, it)) != 0)
@@ -4902,8 +4996,8 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
-}
+            }
+        }
         break;
     case 5:
         ret = cosem_setEnum(e->value.byteArr, object->deliveryMethod);
@@ -5037,9 +5131,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-}
     else if (e->index == 10)
     {
         if ((ret = cosem_setArray(data, object->chargeReferences.size)) == 0)
@@ -5055,9 +5149,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-    }
     else if (e->index == 11)
     {
         if ((ret = cosem_setArray(data, object->creditChargeConfigurations.size)) == 0)
@@ -5075,9 +5169,9 @@
                         (ret = cosem_setOctetString2(data, ccc->chargeReference, 6)) != 0 ||
                         //collection configuration
                         (ret = cosem_setBitString(data, ccc->collectionConfiguration, 3)) != 0)
-                    {
-                        break;
-                    }
+                {
+                    break;
+                }
         }
     }
     else if (e->index == 12)
@@ -5099,9 +5193,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-    }
     else if (e->index == 13)
     {
         ret = cosem_setDateTimeAsOctetString(e->value.byteArr, &object->accountActivationTime);
@@ -5900,15 +5994,15 @@
                 {
                     break;
                 }
+            }
         }
-    }
         break;
     case 8:
         ret = cosem_setDateTime(e->value.byteArr, &object->captureTime);
         break;
     default:
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-}
+    }
     return ret;
 }
 #endif //DLMS_IGNORE_GSM_DIAGNOSTIC
@@ -6000,7 +6094,7 @@
                     (ret = bb_setUInt8(data, it->attributeIndex)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->parameters, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 3)) != 0 ||
@@ -6014,8 +6108,8 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
-}
+            }
+        }
     }
     break;
     default:
@@ -6023,7 +6117,7 @@
         break;
     }
     return ret;
-    }
+}
 #endif //DLMS_IGNORE_PARAMETER_MONITOR
 
 #ifndef DLMS_IGNORE_LLC_SSCS_SETUP
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxinvoke.c src/development/src/gxinvoke.c
--- upstream/development/src/gxinvoke.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxinvoke.c	2024-06-19 13:37:18.000000000 +0000
@@ -809,8 +809,7 @@
                         memcpy(settings->base.cipher.blockCipherKey, BUFF, bb.size);
                         break;
                     case DLMS_GLOBAL_KEY_TYPE_BROADCAST_ENCRYPTION:
-                        //Invalid type
-                        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                        memcpy(settings->base.cipher.broadcastBlockCipherKey, BUFF, bb.size);
                         break;
                     case DLMS_GLOBAL_KEY_TYPE_AUTHENTICATION:
                         memcpy(settings->base.cipher.authenticationKey, BUFF, bb.size);
@@ -858,8 +857,8 @@
                     bb_set(&settings->base.cipher.blockCipherKey, bb.data, bb.size);
                     break;
                 case DLMS_GLOBAL_KEY_TYPE_BROADCAST_ENCRYPTION:
-                    //Invalid type
-                    ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    bb_clear(&settings->base.cipher.broadcastBlockCipherKey);
+                    bb_set(&settings->base.cipher.broadcastBlockCipherKey, bb.data, bb.size);                    
                     break;
                 case DLMS_GLOBAL_KEY_TYPE_AUTHENTICATION:
                     bb_clear(&settings->base.cipher.authenticationKey);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxobjects.c src/development/src/gxobjects.c
--- upstream/development/src/gxobjects.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxobjects.c	2024-06-19 13:37:18.000000000 +0000
@@ -1134,6 +1134,7 @@
 #ifndef DLMS_IGNORE_PUSH_SETUP
         case DLMS_OBJECT_TYPE_PUSH_SETUP:
             obj_clearPushObjectList(&((gxPushSetup*)object)->pushObjectList);
+            arr_clear(&((gxPushSetup*)object)->pushProtectionParameters);
 #ifdef DLMS_IGNORE_MALLOC
             ((gxPushSetup*)object)->destination.size = 0;
 #else
@@ -1513,7 +1514,18 @@
         ret = 2;
         break;
     case DLMS_OBJECT_TYPE_PUSH_SETUP:
-        ret = 7;
+        if (object->version == 0)
+        {
+            ret = 7;
+        }
+        else if (object->version == 1)
+        {
+            ret = 10;
+        }
+        else
+        {
+            ret = 13;
+        }
         break;
     case DLMS_OBJECT_TYPE_DATA_PROTECTION:
         ret = 6;
@@ -1927,7 +1939,14 @@
         ret = 0;
         break;
     case DLMS_OBJECT_TYPE_PUSH_SETUP:
-        ret = 1;
+        if (object->version < 2)
+        {
+            ret = 1;
+        }
+        else
+        {
+            ret = 2;
+        }
         break;
     case DLMS_OBJECT_TYPE_DATA_PROTECTION:
         ret = 3;
@@ -2118,7 +2137,7 @@
         object->status &= ~DLMS_CLOCK_STATUS_DAYLIGHT_SAVE_ACTIVE;
     }
     object->time.status = object->status;
-}
+    }
 #endif //DLMS_IGNORE_SERVER
 
 int clock_utcToMeterTime(gxClock* object, gxtime* value)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsetignoremalloc.c src/development/src/gxsetignoremalloc.c
--- upstream/development/src/gxsetignoremalloc.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsetignoremalloc.c	2024-06-19 13:37:18.000000000 +0000
@@ -2034,7 +2034,8 @@
             object->controlState = (DLMS_CONTROL_STATE)value->bVal;
             ret = 0;
         }
-        else if (value->vt == DLMS_DATA_TYPE_OCTET_STRING)
+        else if ((value->vt == DLMS_DATA_TYPE_OCTET_STRING) ||
+            (value->vt == (DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_OCTET_STRING)))
         {
             if ((ret = cosem_getEnum(value->byteArr, &ch)) == 0)
             {
@@ -2053,6 +2054,14 @@
             object->controlMode = (DLMS_CONTROL_MODE)value->bVal;
             ret = 0;
         }
+        else if ((value->vt == DLMS_DATA_TYPE_OCTET_STRING) ||
+            (value->vt == (DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_OCTET_STRING)))
+        {
+            if ((ret = cosem_getEnum(value->byteArr, &ch)) == 0)
+            {
+                object->controlMode = (DLMS_CONTROL_MODE)ch;
+            }
+        }
         else
         {
             ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -2121,7 +2130,7 @@
             for (pos = 0; pos != count; ++pos)
             {
                 if ((ret = cosem_getArrayItem(&object->emergencyProfileGroupIDs, pos, (void**)&it, sizeof(uint16_t))) != 0 ||
-                    (ret = bb_getUInt16(value->byteArr, it)) != 0)
+                    (ret = cosem_getUInt16(value->byteArr, it)) != 0)
                 {
                     break;
                 }
@@ -2190,7 +2199,7 @@
 #else
         ret = cosem_getOctetString2(value->byteArr, object->mBusPortReference, 6, NULL);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-    }
+            }
     else if (index == 3)
     {
 #if defined(DLMS_COSEM_EXACT_DATA_TYPES)
@@ -2212,8 +2221,8 @@
                 {
                     break;
                 }
-            }
         }
+    }
 #else
         gxCaptureDefinition* it;
         uint16_t count = arr_getCapacity(&object->captureDefinition);
@@ -2231,7 +2240,7 @@
             }
         }
 #endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
-    }
+}
     else if (index == 4)
     {
         ret = cosem_getUInt32(value->byteArr, &object->capturePeriod);
@@ -2348,8 +2357,8 @@
                     (ret = arr_push(&object->modemProfile, it)) != 0)
                 {
                     break;
-                }
-            }
+    }
+}
 #else
             for (pos = 0; pos != count; ++pos)
             {
@@ -2390,7 +2399,7 @@
 #else
         ret = cosem_getOctetString2(value->byteArr, object->PHYReference, 6, NULL);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-    }
+            }
     else if (index == 3)
     {
         arr_clear(&object->lcpOptions);
@@ -2456,7 +2465,7 @@
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
     return ret;
-}
+        }
 #endif //DLMS_IGNORE_PPP_SETUP
 #ifndef DLMS_IGNORE_REGISTER_ACTIVATION
 int cosem_setRegisterActivation(
@@ -2519,7 +2528,7 @@
 #endif //DLMS_IGNORE_OBJECT_POINTERS
             }
         }
-    }
+}
     else if (index == 3)
     {
         obj_clearRegisterActivationMaskList(&object->maskList);
@@ -2554,8 +2563,8 @@
                             (ret = bb_setUInt8(&k->indexes, ch)) != 0)
                         {
                             break;
-                        }
-                    }
+            }
+        }
 #else
                     k->count = (unsigned char)size;
                     for (pos2 = 0; pos2 != size; ++pos2)
@@ -2566,9 +2575,9 @@
                         }
                     }
 #endif //DLMS_COSEM_EXACT_DATA_TYPES
-                }
-            }
-        }
+    }
+    }
+}
     }
     else if (index == 4 && (value->vt & DLMS_DATA_TYPE_OCTET_STRING) != 0)
     {
@@ -2902,8 +2911,8 @@
 #else
             ret = bb_get(value->byteArr, object->ipReference, 6);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
+            }
         }
-    }
     else if (index == 4)
     {
         ret = cosem_getUInt16(value->byteArr, &object->maximumSegmentSize);
@@ -2921,7 +2930,7 @@
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
     return ret;
-}
+    }
 #endif //DLMS_IGNORE_TCP_UDP_SETUP
 
 #ifndef DLMS_IGNORE_MBUS_DIAGNOSTIC
@@ -3710,6 +3719,7 @@
 int cosem_setPushSetup(dlmsSettings* settings, gxPushSetup* object, unsigned char index, dlmsVARIANT* value)
 {
     int ret, pos;
+    unsigned char e1, e2;
     gxTarget* it;
     if (index == 2)
     {
@@ -3754,10 +3764,10 @@
                     svr_notifyTrace2("Adding object ", type, ln, 0);
 #endif //DLMS_DEBUG
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-                }
             }
         }
     }
+}
     else if (index == 3)
     {
         if ((ret = bb_clear(&object->destination)) != 0 ||
@@ -3797,7 +3807,103 @@
     }
     else if (index == 7)
     {
-        ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay);
+        if (object->base.version < 2)
+        {
+            ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = cosem_checkStructure(value->byteArr, 3)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.min)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.exponent)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.max)) != 0)
+            {
+            }
+        }
+    }
+    else if (index == 8)
+    {
+        ret = cosem_getOctetString2(value->byteArr, object->portReference, 6, NULL);
+    }
+    else if (index == 9)
+    {
+        ret = cosem_getInt8(value->byteArr, &object->pushClientSAP);
+    }
+    else if (index == 10)
+    {
+        gxPushProtectionParameters* it;
+        arr_clear(&object->pushProtectionParameters);
+        uint16_t count;
+        if ((ret = cosem_verifyArray(value->byteArr, &object->pushProtectionParameters, &count)) == 0) {
+            for (pos = 0; pos != count; ++pos)
+            {
+                if ((ret = cosem_getArrayItem(&object->pushProtectionParameters, pos,
+                    (void**)&it, sizeof(gxPushProtectionParameters))) == 0)
+                {
+                    if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                        (ret = cosem_getEnum(value->byteArr, &e1)) != 0 ||
+                        (ret = cosem_checkStructure(value->byteArr, 5)) != 0 ||
+                        (ret = cosem_getOctetString(value->byteArr, &it->transactionId)) != 0 ||
+                        (ret = cosem_getOctetString2(value->byteArr, it->originatorSystemTitle, 6, NULL)) != 0 ||
+                        (ret = cosem_getOctetString2(value->byteArr, it->recipientSystemTitle, 6, NULL)) != 0 ||
+                        (ret = cosem_getOctetString(value->byteArr, &it->otherInformation)) != 0 ||
+                        (ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                        (ret = cosem_getEnum(value->byteArr, &e2)) != 0)
+                    {
+                        break;
+                    }
+                    it->protectionType = (DLMS_PROTECTION_TYPE)e1;
+                    it->keyInfo.dataProtectionKeyType = (DLMS_DATA_PROTECTION_KEY_TYPE)e2;
+                    if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 1)) != 0 ||
+                            (ret = cosem_getEnum(value->byteArr, &e1)) != 0)
+                        {
+                            break;
+                        }
+                        it->keyInfo.identifiedKey.keyType = (DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE)e1;
+                    }
+                    else if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 1)) != 0 ||
+                            (ret = cosem_getEnum(value->byteArr, &e1)) != 0)
+                        {
+                            break;
+                        }
+                        it->keyInfo.wrappedKey.keyType = (DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE)e1;
+                    }
+                    else if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                            (ret = cosem_getOctetString(value->byteArr, &it->keyInfo.agreedKey.parameters)) != 0 ||
+                            (ret = cosem_getOctetString(value->byteArr, &it->keyInfo.agreedKey.data)) != 0)
+                        {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else if (index == 11)
+    {
+        ret = cosem_getEnum(value->byteArr, &e1);
+        if (ret == 0)
+        {
+            object->pushOperationMethod = (DLMS_PUSH_OPERATION_METHOD)e1;
+        }
+    }
+    else if (index == 12)
+    {
+        if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+            (ret = cosem_getDateTime(value->byteArr, &object->confirmationParameters.startDate)) != 0 ||
+            (ret = cosem_getUInt32(value->byteArr, &object->confirmationParameters.interval)) != 0)
+        {
+        }
+    }
+    else if (index == 13)
+    {
+        ret = cosem_getDateTime(value->byteArr, &object->lastConfirmationDateTime);
     }
     else
     {
@@ -5219,9 +5325,9 @@
 #else
                 memcpy(it->scriptLogicalName, ln, 6);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
+                }
             }
         }
-    }
     break;
     case 3:
     {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsetmalloc.c src/development/src/gxsetmalloc.c
--- upstream/development/src/gxsetmalloc.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsetmalloc.c	2024-06-19 13:37:18.000000000 +0000
@@ -5471,12 +5471,15 @@
 #endif //DLMS_IGNORE_ARRAY_MANAGER
 
 #ifndef DLMS_IGNORE_PUSH_SETUP
-int cosem_setPushSetup(dlmsSettings* settings, gxPushSetup* object, unsigned char index, dlmsVARIANT* value)
+int cosem_setPushSetup(dlmsSettings* settings,
+    gxPushSetup* object,
+    unsigned char index,
+    dlmsVARIANT* value)
 {
-    int ret, pos;
+    int ret = DLMS_ERROR_CODE_OK, pos;
     gxTarget* it;
     gxObject* obj;
-    dlmsVARIANT* tmp, * tmp3;
+    dlmsVARIANT* tmp, * tmp3, * options, * keyInfo, * data;
     gxtime* s, * e;
     if (index == 2)
     {
@@ -5489,12 +5492,12 @@
                 ret = va_getByIndex(value->Arr, pos, &tmp);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 ret = va_getByIndex(tmp->Arr, 0, &tmp3);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 type = (DLMS_OBJECT_TYPE)var_toInteger(tmp3);
                 //Get LN.
@@ -5502,18 +5505,18 @@
                 ret = va_getByIndex(tmp->Arr, 1, &tmp3);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 obj = NULL;
                 if ((ret = oa_findByLN(&settings->objects, type, tmp3->byteArr->data, &obj)) != 0)
                 {
-                    return ret;
+                    break;
                 }
                 if (obj == NULL)
                 {
                     if ((ret = cosem_createObject(type, &obj)) != 0)
                     {
-                        return ret;
+                        break;
                     }
                     oa_push(&settings->releasedObjects, obj);
                     memcpy(obj->logicalName, tmp3->byteArr->data, tmp3->byteArr->size);
@@ -5607,13 +5610,179 @@
     }
     else if (index == 7)
     {
-        object->repetitionDelay = (uint16_t)var_toInteger(value);
+        if (object->base.version < 2 ||
+            value->vt == DLMS_DATA_TYPE_UINT16)
+        {
+            object->repetitionDelay = (uint16_t)var_toInteger(value);
+        }
+        else if (value->vt == DLMS_DATA_TYPE_STRUCTURE)
+        {
+            ret = va_getByIndex(value->Arr, 0, &tmp);
+            if (ret == DLMS_ERROR_CODE_OK)
+            {
+                object->repetitionDelay2.min = (uint16_t)var_toInteger(tmp);
+                ret = va_getByIndex(value->Arr, 1, &tmp);
+                if (ret == DLMS_ERROR_CODE_OK)
+                {
+                    object->repetitionDelay2.exponent = (uint16_t)var_toInteger(tmp);
+                    ret = va_getByIndex(value->Arr, 2, &tmp);
+                    if (ret == DLMS_ERROR_CODE_OK)
+                    {
+                        object->repetitionDelay2.max = (uint16_t)var_toInteger(tmp);
+                    }
+                }
+            }
+        }
+        else
+        {
+            ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+    }
+    else if (index == 8)
+    {
+        object->portReference = NULL;
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        if (bb_size(value->byteArr) == 6)
+        {
+            ret = oa_findByLN(&settings->objects, DLMS_OBJECT_TYPE_NONE, value->byteArr->data, &object->portReference);
+        }
+#else
+        memset(object->portReference.logicalName, 0, 6);
+        if (it2->byteArr != NULL && it2->byteArr->size == 6)
+        {
+            memcpy(object->portReference.logicalName, it2->byteArr->data, 6);
+        }
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    else if (index == 9)
+    {
+        object->pushClientSAP = (signed char)var_toInteger(value);
+    }
+    else if (index == 10)
+    {
+        arr_clear(&object->pushProtectionParameters);
+        if (value->Arr != NULL)
+        {
+            gxPushProtectionParameters* p;
+            for (pos = 0; pos != value->Arr->size; ++pos)
+            {
+                p = gxmalloc(sizeof(gxPushProtectionParameters));
+                if (p == NULL)
+                {
+                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                    break;
+                }
+                if ((ret = va_getByIndex(value->Arr, pos, &tmp)) != 0 ||
+                    (ret = va_getByIndex(tmp->Arr, 0, &tmp3)) != 0 ||
+                    (ret = va_getByIndex(tmp->Arr, 1, &options)) != 0 ||
+                    (ret = va_getByIndex(options->Arr, 4, &keyInfo)) != 0 ||
+                    (ret = va_getByIndex(keyInfo->Arr, 1, &data)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                bb_init(&p->transactionId);
+                bb_init(&p->otherInformation);
+                bb_init(&p->keyInfo.agreedKey.parameters);
+                bb_init(&p->keyInfo.agreedKey.data);
+
+                p->protectionType = (DLMS_PROTECTION_TYPE)var_toInteger(tmp3);
+
+                if ((ret = va_getByIndex(options->Arr, 0, &tmp)) != 0 ||
+                    (ret = bb_set(&p->transactionId, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                if ((ret = va_getByIndex(options->Arr, 1, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                memcpy(p->originatorSystemTitle, tmp->byteArr->data, bb_size(tmp->byteArr));
+                if ((ret = va_getByIndex(options->Arr, 2, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                memcpy(p->recipientSystemTitle, tmp->byteArr, bb_size(tmp->byteArr));
+                if ((ret = va_getByIndex(options->Arr, 3, &tmp)) != 0 ||
+                    (ret = bb_set(&p->otherInformation, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                if ((ret = va_getByIndex(keyInfo->Arr, 0, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                p->keyInfo.dataProtectionKeyType = (DLMS_DATA_PROTECTION_KEY_TYPE)var_toInteger(tmp);
+                if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    p->keyInfo.identifiedKey.keyType = (DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE)var_toInteger(tmp);
+                }
+                else if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    p->keyInfo.wrappedKey.keyType = (DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE)var_toInteger(tmp);
+                }
+                else if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0 ||
+                        (ret = bb_set(&p->keyInfo.agreedKey.parameters, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    if ((ret = va_getByIndex(data->Arr, 1, &tmp)) != 0 ||
+                        (ret = bb_set(&p->keyInfo.agreedKey.data, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                }
+                arr_push(&object->pushProtectionParameters, p);
+            }
+        }
+    }
+    else if (index == 11)
+    {
+        object->pushOperationMethod = (DLMS_PUSH_OPERATION_METHOD)var_toInteger(value);
+    }
+    else if (index == 12)
+    {
+        ret = va_getByIndex(value->Arr, 0, &tmp);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        object->confirmationParameters.startDate = *tmp->dateTime;
+        ret = va_getByIndex(value->Arr, 1, &tmp);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        object->confirmationParameters.interval = (uint32_t)var_toInteger(tmp);
+    }
+    else if (index == 13)
+    {
+        object->lastConfirmationDateTime = *value->dateTime;
     }
     else
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
-    return DLMS_ERROR_CODE_OK;
+    return ret;
 }
 #endif //DLMS_IGNORE_PUSH_SETUP
 
@@ -7750,9 +7919,9 @@
                 }
                 it->scriptSelector = (uint16_t)var_toInteger(tmp2);
                 arr_push(&object->actions, it);
+                }
             }
         }
-    }
     break;
     case 3:
     {
@@ -7833,7 +8002,7 @@
         break;
     }
     return ret;
-}
+    }
 #endif //DLMS_IGNORE_ARBITRATOR
 #ifndef DLMS_IGNORE_IEC_8802_LLC_TYPE1_SETUP
 int cosem_setIec8802LlcType1Setup(
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsha256.c src/development/src/gxsha256.c
--- upstream/development/src/gxsha256.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsha256.c	2024-06-19 13:37:18.000000000 +0000
@@ -62,13 +62,7 @@
 #define SHA256_F2(x) (SHA2_ROTR(x,  6) ^ SHA2_ROTR(x, 11) ^ SHA2_ROTR(x, 25))
 #define SHA256_F3(x) (SHA2_ROTR(x,  7) ^ SHA2_ROTR(x, 18) ^ SHA2_SHFR(x,  3))
 #define SHA256_F4(x) (SHA2_ROTR(x, 17) ^ SHA2_ROTR(x, 19) ^ SHA2_SHFR(x, 10))
-#define SHA2_UNPACK32(x, str)                 \
-{                                             \
-    *((str) + 3) = (unsigned char) ((x)      );       \
-    *((str) + 2) = (unsigned char) ((x) >>  8);       \
-    *((str) + 1) = (unsigned char) ((x) >> 16);       \
-    *((str) + 0) = (unsigned char) ((x) >> 24);       \
-}
+
 #define SHA2_PACK32(str, x)                   \
 {                                             \
     *(x) =   ((uint32_t) *((str) + 3)      )    \
@@ -77,104 +71,101 @@
            | ((uint32_t) *((str) + 0) << 24);   \
 }
 
+#define SHA2_UNPACK64(x, str)                 \
+{                                             \
+    *((str) + 7) = (unsigned char) ((x));       \
+    *((str) + 6) = (unsigned char) ((x) >>  8);       \
+    *((str) + 5) = (unsigned char) ((x) >> 16);       \
+    *((str) + 4) = (unsigned char) ((x) >> 24);       \
+    *((str) + 3) = (unsigned char) ((x) >> 32);       \
+    *((str) + 2) = (unsigned char) ((x) >> 40);       \
+    *((str) + 1) = (unsigned char) ((x) >> 48);       \
+    *((str) + 0) = (unsigned char) ((x) >> 56);       \
+}
 
-void gxsha256_transform(uint32_t *h, const unsigned char *message, unsigned int block_nb)
+void gxsha256_transform(uint32_t* h, const unsigned char* message, uint32_t messageLength)
 {
     uint32_t w[64];
     uint32_t wv[8];
     uint32_t t1, t2;
-    const unsigned char *sub_block;
-    unsigned int i;
-    int j;
-    for (i = 0; i < block_nb; i++)
+    unsigned char pos;
+    for (pos = 0; pos < 16; ++pos)
     {
-        sub_block = message + (i << 6);
-        for (j = 0; j < 16; j++)
-        {
-            SHA2_PACK32(&sub_block[j << 2], &w[j]);
-        }
-        for (j = 16; j < 64; j++)
+        SHA2_PACK32(&message[pos << 2], &w[pos]);
+    }
+    for (pos = 16; pos < 64; pos++)
+    {
+        w[pos] = SHA256_F4(w[pos - 2]) + w[pos - 7] + SHA256_F3(w[pos - 15]) + w[pos - 16];
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        wv[pos] = h[pos];
+    }
+    for (pos = 0; pos < 64; pos++) {
+        t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
+            + sha256_k[pos] + w[pos];
+        t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
+        wv[7] = wv[6];
+        wv[6] = wv[5];
+        wv[5] = wv[4];
+        wv[4] = wv[3] + t1;
+        wv[3] = wv[2];
+        wv[2] = wv[1];
+        wv[1] = wv[0];
+        wv[0] = t1 + t2;
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        h[pos] += wv[pos];
+    }
+}
+
+int gxsha256_encrypt(gxByteBuffer* data, gxByteBuffer* digest)
+{
+    int ret = 0;
+    unsigned int len = data->size;
+    uint32_t h[8] = { 0x6a09e667, 0xbb67ae85,
+        0x3c6ef372, 0xa54ff53a,
+        0x510e527f, 0x9b05688c,
+        0x1f83d9ab, 0x5be0cd19 };
+
+    unsigned char block[64];
+    unsigned char pos, size = sizeof(block);
+    unsigned char bidsAdded = 0;
+    while (!bidsAdded)
+    {
+        if (bb_available(data) < 64)
         {
-            w[j] = SHA256_F4(w[j - 2]) + w[j - 7] + SHA256_F3(w[j - 15]) + w[j - 16];
+            size = (unsigned char)bb_available(data);
         }
-        for (j = 0; j < 8; j++)
+        memcpy(block, data->data + data->position, size);
+        memset(block + size, 0, sizeof(block) - size);
+        if (bb_available(data) < 64 && size != 0)
         {
-            wv[j] = h[j];
-        }
-        for (j = 0; j < 64; j++) {
-            t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
-                + sha256_k[j] + w[j];
-            t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
-            wv[7] = wv[6];
-            wv[6] = wv[5];
-            wv[5] = wv[4];
-            wv[4] = wv[3] + t1;
-            wv[3] = wv[2];
-            wv[2] = wv[1];
-            wv[1] = wv[0];
-            wv[0] = t1 + t2;
+            // Append a bit 1
+            block[size] = 0x80;
         }
-        for (j = 0; j < 8; j++)
+        if (bb_available(data) < 56)
         {
-            h[j] += wv[j];
+            bidsAdded = 1;
+            //Add bit length to the end of last block.
+            uint64_t len_b = (uint64_t)len;
+            len_b <<= 3;
+            SHA2_UNPACK64(len_b, block + sizeof(block) - 8);
         }
+        gxsha256_transform(h, block, size);
+        data->position += size;
     }
-}
-
-int gxsha256_update(uint32_t *h, unsigned char *block, gxByteBuffer* data, unsigned int *len, unsigned int *totalLen)
-{
-    unsigned int block_nb;
-    unsigned int new_len, rem_len, tmp_len;
-    const unsigned char *shifted_message;
-    tmp_len = 64 - (data->size - data->position);
-    rem_len = data->size < tmp_len ? data->size : tmp_len;
-    memcpy(&block[data->position], data->data, rem_len);
-    if (data->size - data->position < 64)
-    {
-        data->position = data->size;
-        return 0;
-    }
-    new_len = *len - rem_len;
-    block_nb = new_len / 64;
-    shifted_message = data->data + rem_len;
-    gxsha256_transform(h, block, 1);
-    gxsha256_transform(h, shifted_message, block_nb);
-    rem_len = new_len % 64;
-    memcpy(block, &shifted_message[block_nb << 6], rem_len);
-    *len = rem_len;
-    *totalLen += (block_nb + 1) << 6;
-    return 0;
-}
-
-int gxsha256_final(uint32_t *h, unsigned char *block, unsigned char *digest, unsigned int len, unsigned int totalLen)
-{
-    unsigned int block_nb;
-    unsigned int pm_len;
-    uint32_t len_b;
-    int i;
-    block_nb = (1 + ((64 - 9) < (len % 64)));
-    len_b = (totalLen + len) << 3;
-    pm_len = block_nb << 6;
-    memset(block + len, 0, pm_len - len);
-    block[len] = 0x80;
-    SHA2_UNPACK32(len_b, block + pm_len - 4);
-    gxsha256_transform(h, block, block_nb);
-    for (i = 0; i < 8; i++)
+    digest->size = 0;
+    bb_capacity(digest, 32);
+    for (pos = 0; pos < 8; ++pos)
     {
-        SHA2_UNPACK32(h[i], &digest[i << 2]);
+        if ((ret = bb_setUInt32(digest, h[pos])) != 0)
+        {
+            break;
+        }
     }
-    return 0;
-}
-
-int gxsha256_encrypt(gxByteBuffer* data, gxByteBuffer* digest)
-{
-    unsigned int len = data->size, totalLen = 0;
-    uint32_t h[8] = { 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };
-    unsigned char block[128];
-    bb_capacity(digest, 32);
-    digest->size = 32;
-    gxsha256_update((uint32_t*)&h, block, data, &len, &totalLen);
-    return gxsha256_final(h, block, digest->data, len, totalLen);
+    return ret;
 }
 
 #endif //DLMS_IGNORE_HIGH_SHA256
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/server.c src/development/src/server.c
--- upstream/development/src/server.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/server.c	2024-06-19 13:37:18.000000000 +0000
@@ -317,7 +317,7 @@
 {
     svr_setInitialize(settings);
     resetFrameSequence(&settings->base);
-    reply_clear2(&settings->info, 1);
+    reply_clear2(&settings->info, 0);
     settings->base.serverAddress = 0;
     settings->base.clientAddress = 0;
     settings->dataReceived = 0;
@@ -380,6 +380,9 @@
             key = settings->cipher.blockCipherKey;
 #endif //DLMS_IGNORE_MALLOC
         }
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(1, data);
+#endif //DLMS_TRACE_PDU
         ret = cip_encrypt(
             &settings->cipher,
             settings->cipher.security,
@@ -2984,7 +2987,7 @@
     bb_clear(data);
 #ifdef DLMS_IGNORE_MALLOC
     unsigned char offset = IS_HDLC(settings->base.interfaceType) ? 12 : 9;
-    bb_attach(&tmp, data->data + offset, 0, data->capacity - offset);
+    bb_attach(&tmp, data->data + offset, 0, bb_getCapacity(data) - offset);
 #else
     BYTE_BUFFER_INIT(&tmp);
 #endif //DLMS_IGNORE_MALLOC
