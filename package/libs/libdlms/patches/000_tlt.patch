diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2024-01-23 14:13:59.000000000 +0000
+++ src/.gitignore	2024-11-13 12:20:09.000000000 +0000
@@ -251,3 +251,8 @@
 *.raw
 *.vsidx
 *.lock
+development/VS/.vs/
+GuruxDLMSClientExample/VS/.vs/
+*.json
+*.bin
+*.hex
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSClientExample/src/communication.c src/GuruxDLMSClientExample/src/communication.c
--- upstream/GuruxDLMSClientExample/src/communication.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSClientExample/src/communication.c	2024-11-13 12:20:09.000000000 +0000
@@ -919,10 +919,6 @@
     {
         message messages;
         gxReplyData reply;
-        if (dlms_usePreEstablishedConnection(&connection->settings) != NULL)
-        {
-            connection->settings.negotiatedConformance |= DLMS_CONFORMANCE_GENERAL_PROTECTION;
-        }
         unsigned short add = connection->settings.clientAddress;
         DLMS_AUTHENTICATION auth = connection->settings.authentication;
         DLMS_SECURITY security = connection->settings.cipher.security;
@@ -995,7 +991,7 @@
             connection->settings.cipher.invocationCounter = 1 + var_toInteger(&d.value);
             if (connection->trace > GX_TRACE_LEVEL_WARNING)
             {
-                printf("Invocation counter: %lu (0x%lX)\r\n",
+                printf("Invocation counter: %u (0x%X)\r\n",
                     connection->settings.cipher.invocationCounter,
                     connection->settings.cipher.invocationCounter);
             }
@@ -1008,6 +1004,10 @@
             bb_set(&connection->settings.ctoSChallenge, challenge.data, challenge.size);
             bb_clear(&challenge);
             connection->settings.preEstablishedSystemTitle = preEstablishedSystemTitle;
+            if (dlms_usePreEstablishedConnection(&connection->settings))
+            {
+                connection->settings.negotiatedConformance |= DLMS_CONFORMANCE_GENERAL_PROTECTION;
+            }
         }
     }
     return ret;
@@ -1048,20 +1048,30 @@
             (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
             (ret = cl_parseAAREResponse(&connection->settings, &reply.data)) != 0)
         {
-            mes_clear(&messages);
-            reply_clear(&reply);
             if (ret == DLMS_ERROR_CODE_APPLICATION_CONTEXT_NAME_NOT_SUPPORTED)
             {
                 if (connection->trace > GX_TRACE_LEVEL_OFF)
                 {
                     printf("Use Logical Name referencing is wrong. Change it!\r\n");
                 }
-                return ret;
             }
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
+            else if (connection->trace > GX_TRACE_LEVEL_OFF)
             {
-                printf("AARQRequest failed %s\r\n", hlp_getErrorMessage(ret));
+                if (ret == (DLMS_ERROR_TYPE_EXCEPTION_RESPONSE | DLMS_EXCEPTION_SERVICE_ERROR_INVOCATION_COUNTER_ERROR))
+                {
+                    //If invocation counter value is too low.
+                    //Get invocation counter value.
+                    uint32_t value = 0;
+                    bb_getUInt32(&reply.data, &value);
+                    printf("Connection failed. Expected invocation counter value: %u \r\n", value);
+                }
+                else
+                {
+                    printf("AARQRequest failed %s\r\n", hlp_getErrorMessage(ret));
+                }
             }
+            mes_clear(&messages);
+            reply_clear(&reply);
             return ret;
         }
         mes_clear(&messages);
@@ -1256,6 +1266,7 @@
                     (ret = cosem_init2(pObj, obj.objectType, obj.logicalName)) == 0)
                 {
                     pObj->shortName = obj.shortName;
+                    pObj->version = obj.version;
                     oa_push(&connection->settings.objects, pObj);
                 }
             }
@@ -1801,7 +1812,7 @@
         }
         if (connection->trace > GX_TRACE_LEVEL_WARNING)
         {
-            printf("Entries: %ld/%ld\r\n", pg->entriesInUse, pg->profileEntries);
+            printf("Entries: %d/%d\r\n", pg->entriesInUse, pg->profileEntries);
         }
         //If there are no columns or rows.
         if (pg->entriesInUse == 0 || pg->captureObjects.size == 0)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSClientExample/src/main.c src/GuruxDLMSClientExample/src/main.c
--- upstream/GuruxDLMSClientExample/src/main.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSClientExample/src/main.c	2024-11-13 12:20:09.000000000 +0000
@@ -35,6 +35,72 @@
 #include "../../development/include/gxserializer.h"
 
 //Client don't need this.
+void svr_preGet(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+void svr_postGet(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+void svr_preRead(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+void svr_preWrite(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+
+//Client don't need this.
+void svr_preAction(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+extern void svr_postRead(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+extern void svr_postWrite(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+//Client don't need this.
+extern void svr_postAction(
+    dlmsSettings* settings,
+    gxValueEventCollection* args)
+{
+
+}
+
+
+//Client don't need this.
 unsigned char svr_isTarget(
     dlmsSettings* settings,
     unsigned long serverAddress,
@@ -135,6 +201,37 @@
     return ret;
 }
 
+/**
+* Activates and strengthens the security policy
+  for the security setup object
+*/
+int SecurityActivate(connection* connection,
+    DLMS_SECURITY_POLICY policy)
+{
+    int ret;
+    gxSecuritySetup ss;
+    unsigned char ln[] = { 0,0,43,0,0,255 };
+    INIT_OBJECT(ss, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln);
+    //Invokes capture action.
+    dlmsVARIANT param;
+    var_setEnum(&param, policy);
+    GX_ENUM(param) = policy;
+    ret = com_method(connection, BASE(ss), 1, &param);
+    return ret;
+}
+
+// Show PDU before it's encrypted or 
+// after it's decrypted when DLMS_TRACE_PDU
+// is defined.
+void cip_tracePdu(
+    unsigned char encrypt,
+    gxByteBuffer* pdu)
+{
+    const char* direction = encrypt ? "TX" : "RX";
+    char* str = bb_toHexString(pdu);
+    printf("\r\n%s PDU: %s\r\n", direction, str);
+    free(str);
+}
 
 /**
 * Executes selected script.
@@ -802,7 +899,6 @@
             con.settings.plcSettings.macDestinationAddress = atoi(optarg);
             break;
         case 'R':
-            con.settings.cipher.broacast = 1;
             if (strcasecmp("UnConfirmed", optarg) == 0)
             {
                 con.settings.serviceClass = DLMS_SERVICE_CLASS_UN_CONFIRMED;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSDataGateway/Development/include/communication.h src/GuruxDLMSDataGateway/Development/include/communication.h
--- upstream/GuruxDLMSDataGateway/Development/include/communication.h	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSDataGateway/Development/include/communication.h	2024-11-13 12:20:09.000000000 +0000
@@ -100,8 +100,7 @@
 int com_write(
     clientConnection* clientConnection,
     gxObject* object,
-    unsigned char attributeOrdinal,
-    dlmsVARIANT* value);
+    unsigned char attributeOrdinal);
 
 int com_method(
     clientConnection* clientConnection,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSDataGateway/Development/include/exampleserver.h src/GuruxDLMSDataGateway/Development/include/exampleserver.h
--- upstream/GuruxDLMSDataGateway/Development/include/exampleserver.h	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSDataGateway/Development/include/exampleserver.h	2024-11-13 12:20:09.000000000 +0000
@@ -48,8 +48,8 @@
 */
 unsigned char svr_isTarget(
     dlmsSettings *settings,
-    unsigned long int serverAddress,
-    unsigned long clientAddress);
+    uint32_t serverAddress,
+    uint32_t clientAddress);
 
 /**
 * Get attribute access level.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSDataGateway/Development/src/communication.c src/GuruxDLMSDataGateway/Development/src/communication.c
--- upstream/GuruxDLMSDataGateway/Development/src/communication.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSDataGateway/Development/src/communication.c	2024-11-13 12:20:09.000000000 +0000
@@ -1355,15 +1355,14 @@
 int com_write(
     clientConnection* clientConnection,
     gxObject* object,
-    unsigned char attributeOrdinal,
-    dlmsVARIANT* value)
+    unsigned char attributeOrdinal)
 {
     int ret;
     message data;
     gxReplyData reply;
     mes_init(&data);
     reply_init(&reply);
-    if ((ret = cl_write2(&clientConnection->settings, object, attributeOrdinal, value ,1, &data)) != 0 ||
+    if ((ret = cl_write(&clientConnection->settings, object, attributeOrdinal, &data)) != 0 ||
         (ret = com_readDataBlock(clientConnection, &data, &reply)) != 0)
     {
         com_reportError("Write failed", object, attributeOrdinal, ret);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSDataGateway/Development/src/exampleserver.c src/GuruxDLMSDataGateway/Development/src/exampleserver.c
--- upstream/GuruxDLMSDataGateway/Development/src/exampleserver.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSDataGateway/Development/src/exampleserver.c	2024-11-13 12:20:09.000000000 +0000
@@ -281,7 +281,7 @@
         }
         GXTRACE_LN("svr_preWrite: ", e->target->objectType, e->target->logicalName);
         bb_empty(&clientCon.data);
-        e->error = com_write(&clientCon, e->target, e->index,&e->parameters);
+        e->error = com_write(&clientCon, e->target, e->index);
         e->handled = 1;
     }
 }
@@ -370,8 +370,8 @@
 
 unsigned char svr_isTarget(
     dlmsSettings* settings,
-    unsigned long serverAddress,
-    unsigned long clientAddress)
+    uint32_t serverAddress,
+    uint32_t clientAddress)
 {
     //In this example gateway there is only one meter after the GW.
     return 1;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/include/exampleserver.h src/GuruxDLMSServerExample/include/exampleserver.h
--- upstream/GuruxDLMSServerExample/include/exampleserver.h	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/include/exampleserver.h	2024-11-13 12:20:09.000000000 +0000
@@ -21,8 +21,12 @@
 #endif
 
 #include "../../development/include/server.h"
+#define HDLC_HEADER_SIZE 17
+#define HDLC_BUFFER_SIZE 128
+#define PDU_BUFFER_SIZE 512
+#define WRAPPER_BUFFER_SIZE 8 + PDU_BUFFER_SIZE
 
-#if defined(_WIN32) | defined(_WIN64) || defined(__linux__)
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 #include "connection.h"
 char DATAFILE[FILENAME_MAX];
 char IMAGEFILE[FILENAME_MAX];
@@ -50,8 +54,8 @@
 */
 unsigned char svr_isTarget(
     dlmsSettings *settings,
-    unsigned long int serverAddress,
-    unsigned long clientAddress);
+    uint32_t serverAddress,
+    uint32_t clientAddress);
 
 /**
 * Get attribute access level.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/src/exampleserver/exampleserver.c src/GuruxDLMSServerExample/src/exampleserver/exampleserver.c
--- upstream/GuruxDLMSServerExample/src/exampleserver/exampleserver.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/src/exampleserver/exampleserver.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,2944 +0,0 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-
-#include <stdio.h>
-#include <stdlib.h> // malloc and free needs this or error is generated.
-
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-#if _MSC_VER > 1400
-#include <crtdbg.h>
-#include <malloc.h>
-#endif
-#include <tchar.h>
-#include <conio.h>
-#include <Winsock.h> //Add support for sockets
-#include <time.h>
-#include <process.h>//Add support for threads
-#include <Winsock.h> //Add support for sockets
-#include "../include/connection.h"
-#include "../../development/include/converters.h"
-#include "../../development/include/helpers.h"
-#include "../../development/include/date.h"
-#endif
-#if defined(__linux__) //Linux includes.
-#include <stdio.h>
-#include <pthread.h>
-#include <termios.h>
-#include <sys/types.h>
-#include <sys/socket.h> //Add support for sockets
-#include <unistd.h> //Add support for sockets
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#include <string.h>
-#include <sys/time.h>
-#include <errno.h>
-#include "../include/connection.h"
-#include "../../development/include/converters.h"
-#include "../../development/include/helpers.h"
-#include "../../development/include/date.h"
-#endif
-
-#include "../include/exampleserver.h"
-#include "../../development/include/cosem.h"
-#include "../../development/include/gxkey.h"
-#include "../../development/include/gxobjects.h"
-#include "../../development/include/gxget.h"
-#include "../../development/include/notify.h"
-#include "../../development/include/gxset.h"
-//DLMS settings.
-dlmsServerSettings settings;
-
-GX_TRACE_LEVEL trace = GX_TRACE_LEVEL_OFF;
-
-const static char* FLAG_ID = "GRX";
-//Serialization version is increased every time when structure of serialized data is changed.
-const static uint16_t SERIALIZATION_VERSION = 2;
-
-//Space for client challenge.
-static unsigned char C2S_CHALLENGE[64];
-//Space for server challenge.
-static unsigned char S2C_CHALLENGE[64];
-//Allocate space for read list.
-static gxValueEventArg events[10];
-
-int socket1 = -1;
-
-//TODO: Allocate space where profile generic row values are serialized.
-#define PDU_MAX_PROFILE_GENERIC_COLUMN_SIZE 100
-#define HDLC_HEADER_SIZE 17
-#define HDLC_BUFFER_SIZE 128
-#define PDU_BUFFER_SIZE 512
-#define WRAPPER_BUFFER_SIZE 8 + PDU_BUFFER_SIZE
-//Buffer where frames are saved.
-static unsigned char frameBuff[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
-//Buffer where PDUs are saved.
-static unsigned char pduBuff[PDU_BUFFER_SIZE];
-static unsigned char replyFrame[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
-//Define server system title.
-static unsigned char SERVER_SYSTEM_TITLE[8] = { 0 };
-time_t imageActionStartTime = 0;
-gxImageActivateInfo IMAGE_ACTIVATE_INFO[1];
-
-uint32_t time_current(void)
-{
-    //Get current time somewhere.
-    return (uint32_t)time(NULL);
-}
-
-uint32_t time_elapsed(void)
-{
-    return (uint32_t)clock() / (CLOCKS_PER_SEC / 1000);
-}
-
-static gxByteBuffer reply;
-
-//Action schedule execution times.
-typedef struct
-{
-    unsigned char count;
-    gxtime values[10];
-} GXExecutionTimes;
-
-//Push communication window.
-typedef struct
-{
-    unsigned char count;
-    gxTimePair values[10];
-} GXPushWindow;
-
-//Push object list.
-typedef struct
-{
-    uint16_t objectType;
-    unsigned char logicalName[6];
-    signed char attributeIndex;
-    uint16_t dataIndex;
-} GXTarget;
-
-//Push object list.
-typedef struct
-{
-    unsigned char count;
-    GXTarget values[5];
-} GXObjectCollection;
-
-//Profile Generic settings.
-typedef struct
-{
-    //How often load profile is captured to the EEPROM.
-    //Load profile period.
-    unsigned long period;
-    //Amount of used rows in profile generic buffer.
-    uint16_t entriesInUse;
-    //Amount of total rows in profile generic buffer.
-    uint16_t profileEntries;
-    //Entry where profile generic row is added in ring buffer.
-    uint16_t rowIndex;
-    //Capture object list.
-    GXObjectCollection objects;
-} GXProfileGeneric;
-
-//Push Setup.
-typedef struct
-{
-    //Push communication window.
-    GXPushWindow communicationWindow;
-    //Push object list.
-    GXObjectCollection objects;
-} GXPushSetup;
-
-//SAP assignment list.
-typedef struct
-{
-    unsigned char count;
-    gxSapItem values[5];
-} GXSapList;
-
-//Association settings (passwords).
-typedef struct
-{
-    //Define low level password.
-    unsigned char llsPasswordSize;
-    char llsPassword[20];
-    //Define high level password.
-    unsigned char hlsPasswordSize;
-    char hlsPassword[20];
-}GXAssociation;
-
-//Security settings
-typedef struct
-{
-    unsigned char authenticationKey[16];
-    unsigned char blockCipherKey[16];
-    unsigned char securityPolicy;
-    uint32_t invacationVector;
-}GXSecuritySettings;
-
-
-//Save serialized meter data here.
-typedef struct {
-    //Meter serial number.
-    uint32_t SERIAL_NUMBER;
-    //Define Logical Device Name.
-    char LDN[17];
-    //Association passwords.
-    GXAssociation association;
-    //Don't use clock as a name. Some compilers are using clock as reserved word.
-    gxClock clock1;
-    //Disconnect open execution times.
-    GXExecutionTimes disconnectOpenExecutions;
-    //Disconnect close execution times.
-    GXExecutionTimes disconnectCloseExecutions;
-    //IEC HDLC Setup.
-    gxIecHdlcSetup hdlc;
-    GXProfileGeneric loadProfile;
-    GXProfileGeneric eventLog;
-    GXPushSetup push;
-    //Is meter in test mode.
-    char testMode;
-    //SAP assigment lists.
-    GXSapList sapAssignmentList;
-    //Master key, A.K.A KEK.
-    unsigned char masterKey[16];
-    GXSecuritySettings securitySettings;
-    uint32_t InvocationCounter;
-} GXSerializedMeterData;
-
-GXSerializedMeterData meterData;
-
-//Push objects are added here.
-static gxTarget PUSH_OBJECTS[6];
-
-//Capture objects for load profile.
-static gxTarget LOAD_PROFILE_CAPTURE_OBJECT[10] = { 0 };
-//Two capture objects for event log.
-static gxTarget EVENT_LOG_CAPTURE_OBJECT[2] = { 0 };
-
-static gxData ldn;
-static gxData eventCode;
-static gxData unixTime;
-static gxData frameCounter;
-static gxAssociationLogicalName associationNone;
-static gxAssociationLogicalName associationLow;
-static gxAssociationLogicalName associationHigh;
-static gxAssociationLogicalName associationHighGMac;
-static gxRegister activePowerL1;
-static gxScriptTable scriptTableGlobalMeterReset;
-static gxScriptTable scriptTableDisconnectControl;
-static gxScriptTable scriptTableActivateTestMode;
-static gxScriptTable scriptTableActivateNormalMode;
-static gxProfileGeneric eventLog;
-static gxActionSchedule actionScheduleDisconnectOpen;
-static gxActionSchedule actionScheduleDisconnectClose;
-static gxPushSetup pushSetup;
-static gxDisconnectControl disconnectControl;
-static gxProfileGeneric loadProfile;
-static gxSapAssignment sapAssignment;
-//Security Setup High is for High authentication.
-static gxSecuritySetup securitySetupHigh;
-//Security Setup HighGMac is for GMac authentication.
-static gxSecuritySetup securitySetupHighGMac;
-
-gxImageTransfer imageTransfer;
-gxAutoConnect autoConnect;
-gxActivityCalendar activityCalendar;
-gxLocalPortSetup localPortSetup;
-gxDemandRegister demandRegister;
-gxRegisterMonitor registerMonitor;
-gxAutoAnswer autoAnswer;
-gxModemConfiguration modemConfiguration;
-gxMacAddressSetup macAddressSetup;
-gxTcpUdpSetup udpSetup;
-gxIp4Setup ip4Setup;
-gxPppSetup pppSetup;
-gxGPRSSetup gprsSetup;
-gxScriptTable tarifficationScriptTable;
-gxRegisterActivation registerActivation;
-gxCompactData compactData;
-
-//static gxObject* NONE_OBJECTS[] = { BASE(associationNone), BASE(ldn) };
-
-static gxObject* ALL_OBJECTS[] = { BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac), BASE(securitySetupHigh), BASE(securitySetupHighGMac),
-                                   BASE(ldn), BASE(sapAssignment), BASE(eventCode),
-                                   BASE(meterData.clock1), BASE(activePowerL1), BASE(pushSetup), BASE(scriptTableGlobalMeterReset), BASE(scriptTableDisconnectControl),
-                                   BASE(scriptTableActivateTestMode), BASE(scriptTableActivateNormalMode), BASE(loadProfile), BASE(eventLog), BASE(meterData.hdlc),
-                                   BASE(disconnectControl), BASE(actionScheduleDisconnectOpen), BASE(actionScheduleDisconnectClose), BASE(unixTime), BASE(frameCounter),
-                                   BASE(imageTransfer), BASE(udpSetup), BASE(autoConnect), BASE(activityCalendar), BASE(localPortSetup), BASE(demandRegister),
-                                   BASE(registerMonitor), BASE(autoAnswer), BASE(modemConfiguration), BASE(macAddressSetup), BASE(ip4Setup), BASE(pppSetup), BASE(gprsSetup),
-                                   BASE(tarifficationScriptTable), BASE(registerActivation)
-};
-
-
-///////////////////////////////////////////////////////////////////////
-// Write trace to the serial port.
-//
-// This can be used for debugging.
-///////////////////////////////////////////////////////////////////////
-void GXTRACE(const char* str, const char* data)
-{
-    //Send trace to the serial port in test mode.
-    if (meterData.testMode)
-    {
-        if (data == NULL)
-        {
-            printf("%s\r\n", str);
-        }
-        else
-        {
-            printf("%s %s\r\n", str, data);
-        }
-    }
-}
-
-///////////////////////////////////////////////////////////////////////
-// Write trace to the serial port.
-//
-// This can be used for debugging.
-///////////////////////////////////////////////////////////////////////
-void GXTRACE_INT(const char* str, int32_t value)
-{
-    char data[10];
-    sprintf(data, " %ld", value);
-    GXTRACE(str, data);
-}
-
-//Returns current time.
-//If you are not using operating system you have to implement this by yourself.
-//Reason for this is that all compilers's or HWs don't support time at all.
-void time_now(
-    gxtime* value, unsigned char meterTime)
-{
-    time_initUnix(value, (unsigned long)time(NULL));
-    //If date time is wanted in meter time.
-    if (meterTime)
-    {
-        clock_utcToMeterTime(&meterData.clock1, value);
-    }
-}
-
-void println(char* desc, gxByteBuffer* data)
-{
-    if (data != NULL)
-    {
-        char* str = bb_toHexString(data);
-        printf("%s: %s\r\n", desc, str);
-        free(str);
-    }
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example Logical Name Association object.
-///////////////////////////////////////////////////////////////////////
-int addAssociationNone()
-{
-    int ret;
-    const unsigned char ln[6] = { 0, 0, 40, 0, 1, 255 };
-    if ((ret = INIT_OBJECT(associationNone, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
-    {
-        //All objects are shown also without authentication.
-        OA_ATTACH(associationNone.objectList, ALL_OBJECTS);
-        //Uncomment this if you want to show only part of the objects without authentication.
-        //OA_ATTACH(associationNone.objectList, NONE_OBJECTS);
-        associationNone.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_NONE;
-        associationNone.clientSAP = 0x10;
-        //Max PDU is half of PDU size. This is for demonstration purposes only.
-        associationNone.xDLMSContextInfo.maxSendPduSize = associationNone.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE / 2;
-        associationNone.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_GET | DLMS_CONFORMANCE_SET);
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example Logical Name Association object.
-///////////////////////////////////////////////////////////////////////
-int addAssociationLow(uint16_t serializationVersion)
-{
-    int ret;
-    if (serializationVersion == 0)
-    {
-        memcpy(meterData.association.llsPassword, "Gurux", 5);
-        meterData.association.llsPasswordSize = 5;
-    }
-    const unsigned char ln[6] = { 0, 0, 40, 0, 2, 255 };
-    if ((ret = INIT_OBJECT(associationLow, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
-    {
-        //Only Logical Device Name is add to this Association View.
-        OA_ATTACH(associationLow.objectList, ALL_OBJECTS);
-        associationLow.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_LOW;
-        associationLow.clientSAP = 0x11;
-        associationLow.xDLMSContextInfo.maxSendPduSize = associationLow.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
-        associationLow.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
-            DLMS_CONFORMANCE_SET |
-            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
-            DLMS_CONFORMANCE_ACTION |
-            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
-            DLMS_CONFORMANCE_GET);
-        BB_ATTACH_STR(associationLow.secret, meterData.association.llsPassword, meterData.association.llsPasswordSize);
-        associationLow.securitySetup = NULL;
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example Logical Name Association object for High authentication.
-// UA in Indian standard.
-///////////////////////////////////////////////////////////////////////
-int addAssociationHigh(uint16_t serializationVersion)
-{
-    int ret;
-    if (serializationVersion == 0)
-    {
-        memcpy(meterData.association.hlsPassword, "Gurux", 5);
-        meterData.association.hlsPasswordSize = 5;
-    }
-    //Dedicated key.
-    static unsigned char CYPHERING_INFO[20] = { 0 };
-    const unsigned char ln[6] = { 0, 0, 40, 0, 3, 255 };
-    if ((ret = INIT_OBJECT(associationHigh, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
-    {
-        associationHigh.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH;
-        OA_ATTACH(associationHigh.objectList, ALL_OBJECTS);
-        BB_ATTACH(associationHigh.xDLMSContextInfo.cypheringInfo, CYPHERING_INFO, 0);
-        //All objects are add for this Association View later.
-        associationHigh.clientSAP = 0x12;
-        associationHigh.xDLMSContextInfo.maxSendPduSize = associationHigh.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
-        associationHigh.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
-            DLMS_CONFORMANCE_SET |
-            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
-            DLMS_CONFORMANCE_ACTION |
-            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
-            DLMS_CONFORMANCE_GET);
-        BB_ATTACH_STR(associationHigh.secret, meterData.association.hlsPassword, meterData.association.hlsPasswordSize);
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-        associationHigh.securitySetup = &securitySetupHigh;
-#else
-        memcpy(associationHigh.securitySetupReference, securitySetupHigh.base.logicalName, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    }
-    return ret;
-}
-
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example Logical Name Association object for GMAC High authentication.
-// UA in Indian standard.
-///////////////////////////////////////////////////////////////////////
-int addAssociationHighGMac(uint16_t serializationVersion)
-{
-    int ret;
-    //Dedicated key.
-    static unsigned char CYPHERING_INFO[20] = { 0 };
-    const unsigned char ln[6] = { 0, 0, 40, 0, 4, 255 };
-    if ((ret = INIT_OBJECT(associationHighGMac, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
-    {
-        associationHighGMac.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
-        OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
-        BB_ATTACH(associationHighGMac.xDLMSContextInfo.cypheringInfo, CYPHERING_INFO, 0);
-        associationHighGMac.clientSAP = 0x1;
-        associationHighGMac.xDLMSContextInfo.maxSendPduSize = associationHighGMac.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
-        associationHighGMac.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
-            DLMS_CONFORMANCE_SET |
-            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
-            DLMS_CONFORMANCE_ACTION |
-            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
-            DLMS_CONFORMANCE_GET);
-        //GMAC authentication don't need password.
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-        associationHighGMac.securitySetup = &securitySetupHighGMac;
-#else
-        memcpy(associationHighGMac.securitySetupReference, securitySetupHigh.base.logicalName, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds security setup object for High authentication.
-///////////////////////////////////////////////////////////////////////
-int addSecuritySetupHigh()
-{
-    int ret;
-    //Define client system title.
-    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0 };
-    const unsigned char ln[6] = { 0, 0, 43, 0, 1, 255 };
-    if ((ret = INIT_OBJECT(securitySetupHigh, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
-    {
-        BB_ATTACH(securitySetupHigh.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
-        BB_ATTACH(securitySetupHigh.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
-        securitySetupHigh.securityPolicy = DLMS_SECURITY_POLICY_NOTHING;
-        securitySetupHigh.securitySuite = DLMS_SECURITY_SUITE_V0;
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds security setup object for High GMAC authentication.
-///////////////////////////////////////////////////////////////////////
-int addSecuritySetupHighGMac()
-{
-    int ret;
-    //Define client system title.
-    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0 };
-    const unsigned char ln[6] = { 0, 0, 43, 0, 2, 255 };
-    if ((ret = INIT_OBJECT(securitySetupHighGMac, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
-    {
-        BB_ATTACH(securitySetupHighGMac.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
-        BB_ATTACH(securitySetupHighGMac.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
-        //Only Authenticated encrypted connections are allowed.
-        securitySetupHighGMac.securityPolicy = DLMS_SECURITY_POLICY_AUTHENTICATED_ENCRYPTED;
-        securitySetupHighGMac.securitySuite = DLMS_SECURITY_SUITE_V0;
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example register object.
-///////////////////////////////////////////////////////////////////////
-int addRegisterObject(
-    objectArray* objects)
-{
-    const unsigned char ln[6] = { 1,1,21,25,0,255 };
-    cosem_init2((gxObject*)&activePowerL1, DLMS_OBJECT_TYPE_REGISTER, ln);
-    //10 ^ 3 =  1000
-    var_setUInt32(&activePowerL1.value, 25400);
-    activePowerL1.scaler = -2;
-    activePowerL1.unit = 30;
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example clock object.
-///////////////////////////////////////////////////////////////////////
-int addClockObject(uint16_t serializationVersion)
-{
-    int ret = 0;
-    //Add default clock. Clock's Logical Name is 0.0.1.0.0.255.
-    if (serializationVersion == 0)
-    {
-        const unsigned char ln[6] = { 0, 0, 1, 0, 0, 255 };
-        if ((ret = INIT_OBJECT(meterData.clock1, DLMS_OBJECT_TYPE_CLOCK, ln)) == 0)
-        {
-            //Set default values.
-            time_init(&meterData.clock1.begin, -1, 3, 0, 0, 0, 0, 0, 0);
-            time_init(&meterData.clock1.end, -1, 9, 0, 0, 0, 0, 0, 0);
-            //Meter is using UTC time zone.
-            meterData.clock1.timeZone = 0;
-            //Deviation is 60 minutes.
-            meterData.clock1.deviation = 60;
-            meterData.clock1.clockBase = DLMS_CLOCK_BASE_FREQUENCY_50;
-        }
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//This method adds example TCP/UDP setup object.
-///////////////////////////////////////////////////////////////////////
-int addTcpUdpSetup()
-{
-    //Add Tcp/Udp setup. Default Logical Name is 0.0.25.0.0.255.
-    const unsigned char ln[6] = { 0,0,25,0,0,255 };
-    cosem_init2((gxObject*)&udpSetup, DLMS_OBJECT_TYPE_TCP_UDP_SETUP, ln);
-    udpSetup.maximumSimultaneousConnections = 1;
-    udpSetup.maximumSegmentSize = 40;
-    udpSetup.inactivityTimeout = 180;
-    return 0;
-}
-
-#define SET_CAPTURE_OBJECT(ARR, OBJECT, INDEX, DATA_INDEX) memcpy(ARR.logicalName, OBJECT.base.logicalName, 6); ARR.objectType = OBJECT.base.objectType; ARR.objectType = OBJECT.base.objectType; ARR.attributeIndex = INDEX; ARR.dataIndex = DATA_INDEX
-
-///////////////////////////////////////////////////////////////////////
-//Add profile generic (historical data) object.
-///////////////////////////////////////////////////////////////////////
-int addLoadProfileProfileGeneric(uint16_t serializationVersion)
-{
-    //Set default values if load the first time.
-    if (serializationVersion == 0)
-    {
-        meterData.loadProfile.entriesInUse = 0;
-        meterData.loadProfile.period = 0;
-        meterData.loadProfile.rowIndex = 0;
-        meterData.loadProfile.objects.count = 0;
-    }
-    int ret;
-    const unsigned char ln[6] = { 1, 0, 99, 1, 0, 255 };
-    if ((ret = INIT_OBJECT(loadProfile, DLMS_OBJECT_TYPE_PROFILE_GENERIC, ln)) == 0)
-    {
-        loadProfile.capturePeriod = meterData.loadProfile.period;
-        loadProfile.sortMethod = DLMS_SORT_METHOD_FIFO;
-        //entries in use.
-        loadProfile.entriesInUse = meterData.loadProfile.entriesInUse;
-        ///////////////////////////////////////////////////////////////////
-        ARR_ATTACH(loadProfile.captureObjects, LOAD_PROFILE_CAPTURE_OBJECT, 0);
-        //Add 2 columns.
-        if (serializationVersion == 0)
-        {
-            //Add clock obect.
-            SET_CAPTURE_OBJECT(meterData.loadProfile.objects.values[0], meterData.clock1, 2, 0);
-            //Add active power.
-            SET_CAPTURE_OBJECT(meterData.loadProfile.objects.values[1], activePowerL1, 2, 0);
-            //Update amount of capture objects.
-            loadProfile.captureObjects.size = meterData.loadProfile.objects.count = 2;
-        }
-        loadProfile.profileEntries = meterData.loadProfile.profileEntries;
-        //Set clock to sort object.
-        loadProfile.sortObject = BASE(meterData.clock1);
-        loadProfile.sortObjectAttributeIndex = 2;
-    }
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add profile generic (historical data) object.
-///////////////////////////////////////////////////////////////////////
-int addEventLogProfileGeneric(uint16_t serializationVersion)
-{
-    //Set default values if load the first time.
-    if (serializationVersion == 0)
-    {
-        meterData.eventLog.entriesInUse = 0;
-        meterData.eventLog.period = 0;
-        meterData.eventLog.rowIndex = 0;
-        meterData.eventLog.objects.count = 0;
-    }
-    int ret;
-    const unsigned char ln[6] = { 1, 0, 99, 98, 0, 255 };
-    if ((ret = INIT_OBJECT(eventLog, DLMS_OBJECT_TYPE_PROFILE_GENERIC, ln)) == 0)
-    {
-        //events are not captured.
-        eventLog.capturePeriod = 0;
-        eventLog.sortMethod = DLMS_SORT_METHOD_FIFO;
-        //entries in use.
-        eventLog.entriesInUse = meterData.eventLog.entriesInUse;
-        ARR_ATTACH(eventLog.captureObjects, EVENT_LOG_CAPTURE_OBJECT, 0);
-        ///////////////////////////////////////////////////////////////////
-        //Add 2 columns as default.
-        if (serializationVersion == 0)
-        {
-            //Add clock obect.
-            SET_CAPTURE_OBJECT(meterData.eventLog.objects.values[0], meterData.clock1, 2, 0);
-            //Add event code.
-            SET_CAPTURE_OBJECT(meterData.eventLog.objects.values[1], eventCode, 2, 0);
-            //Update amount of capture objects.
-            eventLog.captureObjects.size = meterData.eventLog.objects.count = 2;
-        }
-        eventLog.profileEntries = meterData.eventLog.profileEntries;
-        //Set clock to sort object.
-        eventLog.sortObject = BASE(meterData.clock1);
-        eventLog.sortObjectAttributeIndex = 2;
-    }
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Auto connect object.
-///////////////////////////////////////////////////////////////////////
-int addAutoConnect()
-{
-    gxByteBuffer* str;
-    gxtime* start, * end;
-    const unsigned char ln[6] = { 0,0,2,1,0,255 };
-    cosem_init2((gxObject*)&autoConnect, DLMS_OBJECT_TYPE_AUTO_CONNECT, ln);
-    autoConnect.mode = DLMS_AUTO_CONNECT_MODE_AUTO_DIALLING_ALLOWED_ANYTIME;
-    autoConnect.repetitions = 10;
-    autoConnect.repetitionDelay = 60;
-    //Calling is allowed between 1am to 6am.
-    start = (gxtime*)malloc(sizeof(gxtime));
-    time_init(start, -1, -1, -1, 1, 0, 0, -1, -1);
-    end = (gxtime*)malloc(sizeof(gxtime));
-    time_init(end, -1, -1, -1, 6, 0, 0, -1, -1);
-    arr_push(&autoConnect.callingWindow, key_init(start, end));
-    str = (gxByteBuffer*)malloc(sizeof(gxByteBuffer));
-    bb_init(str);
-    bb_addString(str, "www.gurux.org");
-    arr_push(&autoConnect.destinations, str);
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Activity Calendar object.
-///////////////////////////////////////////////////////////////////////
-int addActivityCalendar(
-    objectArray* objects)
-{
-    gxDayProfile* dp;
-    gxSeasonProfile* sp;
-    gxWeekProfile* wp;
-    gxDayProfileAction* act;
-
-    const unsigned char ln[6] = { 0,0,13,0,0,255 };
-    cosem_init2((gxObject*)&activityCalendar, DLMS_OBJECT_TYPE_ACTIVITY_CALENDAR, ln);
-
-    bb_addString(&activityCalendar.calendarNameActive, "Active");
-    //Add season profile.
-    sp = (gxSeasonProfile*)malloc(sizeof(gxSeasonProfile));
-    bb_init(&sp->name);
-    bb_addString(&sp->name, "Summer time");
-    time_init(&sp->start, -1, 3, 31, -1, -1, -1, -1, -1);
-    bb_init(&sp->weekName);
-    arr_push(&activityCalendar.seasonProfileActive, sp);
-    //Add week profile.
-    wp = (gxWeekProfile*)malloc(sizeof(gxWeekProfile));
-    bb_init(&wp->name);
-    bb_addString(&wp->name, "Monday");
-    wp->monday = wp->tuesday = wp->wednesday = wp->thursday = wp->friday = wp->saturday = wp->sunday = 1;
-    arr_push(&activityCalendar.weekProfileTableActive, wp);
-
-    //Add day profile.
-    dp = (gxDayProfile*)malloc(sizeof(gxDayProfile));
-    arr_init(&dp->daySchedules);
-
-    dp->dayId = 1;
-    act = (gxDayProfileAction*)malloc(sizeof(gxDayProfileAction));
-    time_now(&act->startTime, 0);
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    act->script = BASE(tarifficationScriptTable);
-#else
-    memcpy(act->scriptLogicalName, tarifficationScriptTable.base.logicalName, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-
-    act->scriptSelector = 1;
-    arr_push(&dp->daySchedules, act);
-    arr_push(&activityCalendar.dayProfileTableActive, dp);
-    bb_addString(&activityCalendar.calendarNamePassive, "Passive");
-
-    sp = (gxSeasonProfile*)malloc(sizeof(gxSeasonProfile));
-    bb_init(&sp->name);
-    bb_addString(&sp->name, "Winter time");
-    time_init(&sp->start, -1, 10, 30, -1, -1, -1, -1, -1);
-    bb_init(&sp->weekName);
-    arr_push(&activityCalendar.seasonProfilePassive, sp);
-    //Add week profile.
-    wp = (gxWeekProfile*)malloc(sizeof(gxWeekProfile));
-    bb_init(&wp->name);
-    bb_addString(&wp->name, "Tuesday");
-    wp->monday = wp->tuesday = wp->wednesday = wp->thursday = wp->friday = wp->saturday = wp->sunday = 1;
-    arr_push(&activityCalendar.weekProfileTablePassive, wp);
-
-    //Add day profile.
-    dp = (gxDayProfile*)malloc(sizeof(gxDayProfile));
-    arr_init(&dp->daySchedules);
-    dp->dayId = 1;
-    act = (gxDayProfileAction*)malloc(sizeof(gxDayProfileAction));
-    time_now(&act->startTime, 0);
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    act->script = BASE(tarifficationScriptTable);
-#else
-    memcpy(act->scriptLogicalName, tarifficationScriptTable.base.logicalName, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    act->scriptSelector = 1;
-    arr_push(&dp->daySchedules, act);
-    arr_push(&activityCalendar.dayProfileTablePassive, dp);
-    time_now(&activityCalendar.time, 0);
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Optical Port Setup object.
-///////////////////////////////////////////////////////////////////////
-int addOpticalPortSetup(
-    objectArray* objects)
-{
-    const unsigned char ln[6] = { 0,0,20,0,0,255 };
-    cosem_init2((gxObject*)&localPortSetup, DLMS_OBJECT_TYPE_IEC_LOCAL_PORT_SETUP, ln);
-    localPortSetup.defaultMode = DLMS_OPTICAL_PROTOCOL_MODE_DEFAULT;
-    localPortSetup.proposedBaudrate = DLMS_BAUD_RATE_9600;
-    localPortSetup.defaultBaudrate = DLMS_BAUD_RATE_300;
-    localPortSetup.responseTime = DLMS_LOCAL_PORT_RESPONSE_TIME_200_MS;
-    bb_addString(&localPortSetup.deviceAddress, "Gurux");
-    bb_addString(&localPortSetup.password1, "Gurux1");
-    bb_addString(&localPortSetup.password2, "Gurux2");
-    bb_addString(&localPortSetup.password5, "Gurux5");
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Demand Register object.
-///////////////////////////////////////////////////////////////////////
-int addDemandRegister(
-    objectArray* objects)
-{
-    const unsigned char ln[6] = { 1,0,31,4,0,255 };
-    cosem_init2((gxObject*)&demandRegister, DLMS_OBJECT_TYPE_DEMAND_REGISTER, ln);
-
-    var_setUInt16(&demandRegister.currentAverageValue, 10);
-    var_setUInt16(&demandRegister.lastAverageValue, 20);
-    var_setUInt8(&demandRegister.status, 1);
-    time_now(&demandRegister.startTimeCurrent, 1);
-    time_now(&demandRegister.captureTime, 1);
-    demandRegister.period = 10;
-    demandRegister.numberOfPeriods = 1;
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Register Monitor object.
-///////////////////////////////////////////////////////////////////////
-int addRegisterMonitor(
-    objectArray* objects)
-{
-    gxActionSet* action;
-    dlmsVARIANT* tmp;
-
-    const unsigned char ln[6] = { 0,0,16,1,0,255 };
-    cosem_init2((gxObject*)&registerMonitor, DLMS_OBJECT_TYPE_REGISTER_MONITOR, ln);
-
-    //Add low value.
-    tmp = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
-    var_init(tmp);
-    var_setUInt32(tmp, 10000);
-    va_push(&registerMonitor.thresholds, tmp);
-    //Add high value.
-    tmp = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
-    var_init(tmp);
-    var_setUInt32(tmp, 30000);
-    va_push(&registerMonitor.thresholds, tmp);
-
-    registerMonitor.monitoredValue.attributeIndex = 2;
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    registerMonitor.monitoredValue.target = BASE(activePowerL1);
-#else
-    registerMonitor.monitoredValue.objectType = activePowerL1.base.objectType;
-    memcpy(registerMonitor.monitoredValue.logicalName, activePowerL1.base.logicalName, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-
-
-    //Add low action.
-    action = (gxActionSet*)malloc(sizeof(gxActionSet));
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    action->actionDown.script = NULL;
-#else
-    memset(action->actionUp.logicalName, 0, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-
-    action->actionDown.scriptSelector = 1;
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    action->actionUp.script = NULL;
-#else
-    memset(action->actionUp.logicalName, 0, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    action->actionUp.scriptSelector = 1;
-    arr_push(&registerMonitor.actions, action);
-    //Add high action.
-    action = (gxActionSet*)malloc(sizeof(gxActionSet));
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    action->actionDown.script = NULL;
-#else
-    memset(action->actionDown.logicalName, 0, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    action->actionDown.scriptSelector = 1;
-#ifndef DLMS_IGNORE_OBJECT_POINTERS
-    action->actionUp.script = NULL;
-#else
-    memset(action->actionUp.logicalName, 0, 6);
-#endif //DLMS_IGNORE_OBJECT_POINTERS
-    action->actionUp.scriptSelector = 1;
-    arr_push(&registerMonitor.actions, action);
-    return 0;
-}
-
-
-///////////////////////////////////////////////////////////////////////
-//Add action schedule object for disconnect control to close the led.
-///////////////////////////////////////////////////////////////////////
-int addActionScheduleDisconnectClose()
-{
-    int ret;
-    const unsigned char ln[6] = { 0, 0, 15, 0, 1, 255 };
-    if ((ret = INIT_OBJECT(actionScheduleDisconnectClose, DLMS_OBJECT_TYPE_ACTION_SCHEDULE, ln)) == 0)
-    {
-        actionScheduleDisconnectClose.executedScript = &scriptTableDisconnectControl;
-        actionScheduleDisconnectClose.executedScriptSelector = 1;
-        actionScheduleDisconnectClose.type = DLMS_SINGLE_ACTION_SCHEDULE_TYPE1;
-        ARR_ATTACH(actionScheduleDisconnectClose.executionTime, meterData.disconnectCloseExecutions.values, meterData.disconnectCloseExecutions.count);
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add action schedule object for disconnect control to open the led.
-///////////////////////////////////////////////////////////////////////
-int addActionScheduleDisconnectOpen()
-{
-    int ret;
-    const unsigned char ln[6] = { 0, 0, 15, 0, 3, 255 };
-    //Action schedule execution times.
-    if ((ret = INIT_OBJECT(actionScheduleDisconnectOpen, DLMS_OBJECT_TYPE_ACTION_SCHEDULE, ln)) == 0)
-    {
-        actionScheduleDisconnectOpen.executedScript = &scriptTableDisconnectControl;
-        actionScheduleDisconnectOpen.executedScriptSelector = 2;
-        actionScheduleDisconnectOpen.type = DLMS_SINGLE_ACTION_SCHEDULE_TYPE1;
-        ARR_ATTACH(actionScheduleDisconnectOpen.executionTime, meterData.disconnectOpenExecutions.values, meterData.disconnectOpenExecutions.count);
-    }
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Disconnect control object.
-///////////////////////////////////////////////////////////////////////
-int addDisconnectControl()
-{
-    int ret;
-    const unsigned char ln[6] = { 0, 0, 96, 3, 10, 255 };
-    if ((ret = INIT_OBJECT(disconnectControl, DLMS_OBJECT_TYPE_DISCONNECT_CONTROL, ln)) == 0)
-    {
-    }
-    return ret;
-}
-
-
-///////////////////////////////////////////////////////////////////////
-//Add image transfer object.
-///////////////////////////////////////////////////////////////////////
-int addImageTransfer(
-    objectArray* objects)
-{
-    unsigned char ln[6] = { 0,0,44,0,0,255 };
-    cosem_init2((gxObject*)&imageTransfer, DLMS_OBJECT_TYPE_IMAGE_TRANSFER, ln);
-    imageTransfer.imageBlockSize = 100;
-    imageTransfer.imageFirstNotTransferredBlockNumber = 0;
-    //Enable image transfer.
-    imageTransfer.imageTransferEnabled = 1;
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add IEC HDLC Setup object.
-///////////////////////////////////////////////////////////////////////
-int addIecHdlcSetup(dlmsServerSettings* settings, uint16_t serializationVersion)
-{
-    int ret = 0;
-    if (serializationVersion == 0)
-    {
-        unsigned char ln[6] = { 0, 0, 22, 0, 0, 255 };
-        if ((ret = INIT_OBJECT(meterData.hdlc, DLMS_OBJECT_TYPE_IEC_HDLC_SETUP, ln)) == 0)
-        {
-            meterData.hdlc.communicationSpeed = DLMS_BAUD_RATE_9600;
-            meterData.hdlc.windowSizeReceive = meterData.hdlc.windowSizeTransmit = 1;
-            meterData.hdlc.maximumInfoLengthTransmit = meterData.hdlc.maximumInfoLengthReceive = 128;
-            meterData.hdlc.inactivityTimeout = 120;
-            meterData.hdlc.deviceAddress = 0x10;
-        }
-    }
-    settings->hdlc = &meterData.hdlc;
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add compact data object.
-///////////////////////////////////////////////////////////////////////
-int addCompactData(
-    dlmsServerSettings* settings,
-    objectArray* objects)
-{
-    gxTarget* capture;
-    gxKey* k;
-    unsigned char ln[6] = { 0,0,66,0,1,255 };
-    cosem_init2(&compactData.base, DLMS_OBJECT_TYPE_COMPACT_DATA, ln);
-    compactData.templateId = 66;
-#ifdef DLMS_ITALIAN_STANDARD
-    //Some Italy meters require that there is a array count in some compact buffer.
-    //This is against compact data structure defined in DLMS standard.
-    compactData.appendAA = 1;
-#endif //DLMS_ITALIAN_STANDARD
-    //Buffer is captured when invoke is called.
-    compactData.captureMethod = DLMS_CAPTURE_METHOD_INVOKE;
-    ////////////////////////////////////////
-    //Add capture objects.
-    //Add compact data template ID as first object.
-    capture = (gxTarget*)malloc(sizeof(gxTarget));
-    capture->attributeIndex = 4;
-    capture->dataIndex = 0;
-    k = key_init(&compactData, capture);
-    arr_push(&compactData.captureObjects, k);
-
-    capture = (gxTarget*)malloc(sizeof(gxTarget));
-    capture->attributeIndex = 4;
-    capture->dataIndex = 0;
-   //MIKKO k = key_init(&actionSchedule, capture);
-   //MIKKO arr_push(&compactData.captureObjects, k);
-    return compactData_updateTemplateDescription(&settings->base, &compactData);
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add SAP Assignment object.
-///////////////////////////////////////////////////////////////////////
-int addSapAssignment(uint16_t serializationVersion)
-{
-    int ret;
-    const unsigned char ln[6] = { 0, 0, 41, 0, 0, 255 };
-    if ((ret = INIT_OBJECT(sapAssignment, DLMS_OBJECT_TYPE_SAP_ASSIGNMENT, ln)) == 0)
-    {
-        if (serializationVersion == 0)
-        {
-            char tmp[16];
-            sprintf(tmp, "%s%.13lu", FLAG_ID, meterData.SERIAL_NUMBER);
-            bb_addString(&meterData.sapAssignmentList.values[0].name, tmp);
-            meterData.sapAssignmentList.values[0].id = 1;
-            meterData.sapAssignmentList.count = 1;
-        }
-        ARR_ATTACH(sapAssignment.sapAssignmentList, meterData.sapAssignmentList.values, meterData.sapAssignmentList.count);
-    }
-    return ret;
-}
-
-
-///////////////////////////////////////////////////////////////////////
-//Add Auto Answer object.
-///////////////////////////////////////////////////////////////////////
-int addAutoAnswer(
-    objectArray* objects)
-{
-    gxtime* start, * end;
-    const unsigned char ln[6] = { 0,0,2,2,0,255 };
-    cosem_init2((gxObject*)&autoAnswer, DLMS_OBJECT_TYPE_AUTO_ANSWER, ln);
-
-    start = (gxtime*)malloc(sizeof(gxtime));
-    time_init(start, -1, -1, -1, 6, -1, -1, -1, -1);
-    end = (gxtime*)malloc(sizeof(gxtime));
-    time_init(end, -1, -1, -1, 8, -1, -1, -1, -1);
-
-    autoAnswer.mode = DLMS_AUTO_CONNECT_MODE_EMAIL_SENDING;
-    arr_push(&autoAnswer.listeningWindow, key_init(start, end));
-    autoAnswer.status = DLMS_AUTO_ANSWER_STATUS_INACTIVE;
-    autoAnswer.numberOfCalls = 0;
-    autoAnswer.numberOfRingsInListeningWindow = 1;
-    autoAnswer.numberOfRingsOutListeningWindow = 2;
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add Modem Configuration object.
-///////////////////////////////////////////////////////////////////////
-int addModemConfiguration(
-    objectArray* objects)
-{
-    gxModemInitialisation* init;
-    const unsigned char ln[6] = { 0,0,2,0,0,255 };
-    cosem_init2((gxObject*)&modemConfiguration, DLMS_OBJECT_TYPE_MODEM_CONFIGURATION, ln);
-
-    modemConfiguration.communicationSpeed = DLMS_BAUD_RATE_38400;
-    init = (gxModemInitialisation*)malloc(sizeof(gxModemInitialisation));
-    bb_init(&init->request);
-    bb_init(&init->response);
-    bb_addString(&init->request, "AT");
-    bb_addString(&init->response, "OK");
-    init->delay = 0;
-    arr_push(&modemConfiguration.initialisationStrings, init);
-    return 0;
-}
-
-
-///////////////////////////////////////////////////////////////////////
-//Add Mac Address Setup object.
-///////////////////////////////////////////////////////////////////////
-int addMacAddressSetup(
-    objectArray* objects)
-{
-    const unsigned char ln[6] = { 0,0,25,2,0,255 };
-    cosem_init2((gxObject*)&macAddressSetup, DLMS_OBJECT_TYPE_MAC_ADDRESS_SETUP, ln);
-    bb_addString(&macAddressSetup.macAddress, "00:11:22:33:44:55:66");
-    return 0;
-}
-
-unsigned long getIpAddress()
-{
-    int ret = -1;
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-    struct hostent* phe;
-    char ac[80];
-    if ((ret = gethostname(ac, sizeof(ac))) != -1)
-    {
-        phe = gethostbyname(ac);
-        if (phe == 0)
-        {
-            ret = 0;
-        }
-        else
-        {
-            struct in_addr* addr = (struct in_addr*)phe->h_addr_list[0];
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-            return addr->S_un.S_addr;
-#else //or Linux
-            return addr->s_addr;
-#endif
-        }
-    }
-#else
-    //If no OS get IP.
-#endif
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add IP4 Setup object.
-///////////////////////////////////////////////////////////////////////
-int addIP4Setup(
-    objectArray* objects)
-{
-    const unsigned char ln[6] = { 0,0,25,1,0,255 };
-    cosem_init2((gxObject*)&ip4Setup, DLMS_OBJECT_TYPE_IP4_SETUP, ln);
-    ip4Setup.ipAddress = getIpAddress();
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
-//Add push setup object. (On Connectivity)
-///////////////////////////////////////////////////////////////////////
-int addPushSetup(
-    objectArray* objects)
-{
-    const char dest[] = "127.0.0.1:7000";
-
-    gxTarget* co;
-    const unsigned char ln[6] = { 0,0,25,9,0,255 };
-    cosem_init2((gxObject*)&pushSetup, DLMS_OBJECT_TYPE_PUSH_SETUP, ln);
-    pushSetup.destination = (char*)malloc(strlen(dest) + 1);
-    strcpy(pushSetup.destination, dest);
-
-    // Add push object itself. This is needed to tell structure of data to
-    // the Push listener.
-    co = (gxTarget*)malloc(sizeof(gxTarget));
-    co->attributeIndex = 2;
-    co->dataIndex = 0;
-    arr_push(&pushSetup.pushObjectList, key_init(&pushSetup, co));
-    // Add logical device name.
-    co = (gxTarget*)malloc(sizeof(gxTarget));
-    co->attributeIndex = 2;
-    co->dataIndex = 0;
-    arr_push(&pushSetup.pushObjectList, key_init(&ldn, co));
-    // Add 0.0.25.1.0.255 Ch. 0 IPv4 setup IP address.
-    co = (gxTarget*)malloc(sizeof(gxTarget));
-    co->attributeIndex = 3;
-    co->dataIndex = 0;
-    arr_push(&pushSetup.pushObjectList, key_init(&ip4Setup, co));
-    return 0;
-}
-
-int svr_InitObjects(
-    dlmsServerSettings* settings)
-{
-    int ret;
-    objectArray* objects = &settings->base.objects;
-    char FW[] = "Gurux FW 1.0.1";
-    char buff[17];
-    oa_attach(objects, ALL_OBJECTS, sizeof(ALL_OBJECTS) / sizeof(ALL_OBJECTS[0]));
-
-    ///////////////////////////////////////////////////////////////////////
-    //Add Logical Device Name. 123456 is meter serial number.
-    ///////////////////////////////////////////////////////////////////////
-    // COSEM Logical Device Name is defined as an octet-string of 16 octets.
-    // The first three octets uniquely identify the manufacturer of the device and it corresponds
-    // to the manufacturer's identification in IEC 62056-21.
-    // The following 13 octets are assigned by the manufacturer.
-    //The manufacturer is responsible for guaranteeing the uniqueness of these octets.
-    sprintf(buff, "GRX%.13lu", meterData.SERIAL_NUMBER);
-    {
-        const unsigned char ln[6] = { 0,0,42,0,0,255 };
-        cosem_init2((gxObject*)&ldn.base, DLMS_OBJECT_TYPE_DATA, ln);
-        var_addBytes(&ldn.value, (unsigned char*)buff, 16);
-    }
-    //Electricity ID 1
-    {
-        const unsigned char ln[6] = { 1,1,0,0,0,255 };
-        cosem_init2((gxObject*)&id1.base, DLMS_OBJECT_TYPE_DATA, ln);
-        var_setString(&id1.value, buff, 16);
-    }
-
-    //Electricity ID 2.
-    {
-        const unsigned char ln[6] = { 1,1,0,0,1,255 };
-        cosem_init2((gxObject*)&id2.base, DLMS_OBJECT_TYPE_DATA, ln);
-        var_setUInt32(&id2.value, meterData.SERIAL_NUMBER);
-    }
-
-    //Firmware version.
-    {
-        const unsigned char ln[6] = { 1,0,0,2,0,255 };
-        cosem_init2((gxObject*)&fw.base, DLMS_OBJECT_TYPE_DATA, ln);
-        var_setString(&fw.value, FW, (unsigned short)strlen(FW));
-    }
-    if ((ret = addRegisterObject()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addClockObject(objects)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addTcpUdpSetup()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addProfileGeneric()) != 0)
-    {
-        return ret;
-    }
-#ifdef DLMS_INDIAN_STANDARD
-    if ((ret = addInstantDataProfileGeneric()) != 0)
-    {
-        return ret;
-    }
-#endif //DLMS_INDIAN_STANDARD
-    if ((ret = addAutoConnect()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addActivityCalendar()) != 0)
-    {
-        return ret;
-    }
-
-    if ((ret = addOpticalPortSetup()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addDemandRegister()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addScriptTable()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addRegisterMonitor()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addActionSchedule()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addSapAssignment()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addAutoAnswer()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addModemConfiguration()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addMacAddressSetup()) != 0)
-    {
-        return ret;
-    }
-
-    if ((ret = addDisconnectControl()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addIP4Setup()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addPushSetup()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addImageTransfer()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addIecHdlcSetup()) != 0)
-    {
-        return ret;
-    }
-    if ((ret = addCompactData(settings, objects)) != 0)
-    {
-        return ret;
-    }
-    return oa_verify(objects);
-}
-
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-/**
-* Start server.
-*/
-int svr_start(
-    connection* con,
-    unsigned short port)
-{
-    int ret;
-    con->settings.pushClientAddress = 64;
-    if ((ret = svr_listen(con, port)) != 0)
-    {
-        return ret;
-    }
-    if (con->settings.base.interfaceType == DLMS_INTERFACE_TYPE_HDLC)
-    {
-        con->settings.hdlc = &iecHdlcSetup;
-    }
-    else if (con->settings.base.interfaceType == DLMS_INTERFACE_TYPE_WRAPPER)
-    {
-        con->settings.wrapper = &udpSetup;
-    }
-    else
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-
-    ///////////////////////////////////////////////////////////////////////
-    //Server must initialize after all objects are added.
-    ret = svr_initialize(&con->settings);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    bb_addString(&con->settings.base.kek, "1111111111111111");
-    return DLMS_ERROR_CODE_OK;
-}
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-
-int svr_findObject(
-    dlmsSettings* settings,
-    DLMS_OBJECT_TYPE objectType,
-    int sn,
-    unsigned char* ln,
-    gxValueEventArg* e)
-{
-#ifndef DLMS_ITALIAN_STANDARD
-    if (objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
-    {
-        const unsigned char CURRENT_ASSOCIATION[6] = { 0, 0, 40, 0, 0, 255 };
-        if (settings->authentication == DLMS_AUTHENTICATION_NONE &&
-            (memcmp(CURRENT_ASSOCIATION, ln, 6) == 0 || memcmp(ln, associationNone.base.logicalName, 6) == 0))
-        {
-            e->target = &associationNone.base;
-        }
-        else if (settings->authentication == DLMS_AUTHENTICATION_LOW &&
-            (memcmp(CURRENT_ASSOCIATION, ln, 6) == 0 || memcmp(ln, lowAssociation.base.logicalName, 6) == 0))
-        {
-            e->target = &lowAssociation.base;
-        }
-        else if (memcmp(CURRENT_ASSOCIATION, ln, 6) == 0 || memcmp(ln, highAssociation.base.logicalName, 6) == 0)
-        {
-            e->target = &highAssociation.base;
-        }
-    }
-    else
-    {
-        if (settings->authentication == DLMS_AUTHENTICATION_NONE)
-        {
-            return oa_findByLN(&associationNone.objectList, objectType, ln, &e->target);
-        }
-        else if (settings->authentication == DLMS_AUTHENTICATION_LOW)
-        {
-            return oa_findByLN(&lowAssociation.objectList, objectType, ln, &e->target);
-        }
-        else
-        {
-            return oa_findByLN(&highAssociation.objectList, objectType, ln, &e->target);
-        }
-    }
-#else
-    if (objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
-    {
-        if (settings->authentication == DLMS_AUTHENTICATION_NONE)
-        {
-            e->target = &associationNone.base;
-        }
-        else if (settings->authentication == DLMS_AUTHENTICATION_HIGH_GMAC)
-        {
-            e->target = &highAssociation.base;
-        }
-
-    }
-#endif //DLMS_ITALIAN_STANDARD
-    return 0;
-}
-
-/**
-*  Get head position where next new item is inserted.
-*
-* This is used with ring buffer.
-*
-* @return Position where next item is inserted.
-*/
-unsigned short getHead() {
-    unsigned short head = 0;
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    gxtime tm, last;
-    int len, month = 0, day = 0, year = 1971, hour = 0, minute = 0, second = 0, value = 0;
-    time_init(&last, year, month, day, hour, minute, second, 0, -1);
-#if _MSC_VER > 1400
-    FILE* f = NULL;
-    fopen_s(&f, DATAFILE, "r");
-#else
-    FILE* f = fopen(DATAFILE, "r");
-#endif
-    if (f != NULL)
-    {
-        while ((len = fscanf(f, "%d/%d/%d %d:%d:%d;%d", &month, &day, &year, &hour, &minute, &second, &value)) != -1)
-        {
-            time_init(&tm, year, month, day, hour, minute, second, 0, -1);
-            if (time_compare(&last, &tm) > 0)
-            {
-                break;
-            }
-            ++head;
-            last = tm;
-        }
-        fclose(f);
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    return head;
-}
-
-
-/**
-* Return data using start and end indexes.
-*
-* @param p
-*            ProfileGeneric
-* @param index start index.
-* @param count Amount of the rows.
-*/
-void getProfileGenericDataByEntry(gxProfileGeneric* p, long index, long count)
-{
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    dlmsVARIANT* tmp;
-    variantArray* row;
-    int len, month = 0, day = 0, year = 0, hour = 0, minute = 0, second = 0, value = 0;
-    if (count != 0)
-    {
-
-#if _MSC_VER > 1400
-        FILE* f = NULL;
-        fopen_s(&f, DATAFILE, "r");
-#else
-        FILE* f = fopen(DATAFILE, "r");
-#endif
-        if (f != NULL)
-        {
-            while ((len = fscanf(f, "%d/%d/%d %d:%d:%d;%d", &month, &day, &year, &hour, &minute, &second, &value)) != -1)
-            {
-                // Skip row
-                if (index > 0)
-                {
-                    --index;
-                }
-                else if (len == 7)
-                {
-                    if (p->buffer.size == count)
-                    {
-                        break;
-                    }
-                    row = (variantArray*)malloc(sizeof(variantArray));
-                    va_init(row);
-                    arr_push(&p->buffer, row);
-
-                    //Add date time.
-                    tmp = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
-                    var_init(tmp);
-                    tmp->dateTime = (gxtime*)malloc(sizeof(gxtime));
-                    time_init(tmp->dateTime, year, month, day, hour, minute, second, 0, -1);
-                    tmp->vt = DLMS_DATA_TYPE_DATETIME;
-                    va_push(row, tmp);
-
-                    //Add register value.
-                    tmp = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
-                    var_init(tmp);
-                    var_setInt32(tmp, value);
-                    va_push(row, tmp);
-                }
-                if (p->buffer.size == count)
-                {
-                    break;
-                }
-            }
-            fclose(f);
-        }
-        //Read values from the begin if ring buffer is used.
-        if (p->buffer.size != count)
-        {
-            getProfileGenericDataByEntry(p, index, count);
-        }
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-}
-
-/**
-* Get row count.
-*
-
-* @return
-*/
-int getProfileGenericDataCount() {
-    int rows = 0;
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    int ch;
-#if _MSC_VER > 1400
-    FILE* f = NULL;
-    fopen_s(&f, DATAFILE, "r");
-#else
-    FILE* f = fopen(DATAFILE, "r");
-#endif
-    if (f != NULL)
-    {
-        while ((ch = fgetc(f)) != EOF)
-        {
-            if (ch == '\n')
-            {
-                ++rows;
-            }
-        }
-        fclose(f);
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    return rows;
-}
-
-
-/**
-* Find start index and row count using start and end date time.
-*
-* @param start
-*            Start time.
-* @param end
-*            End time
-* @param index
-*            Start index.
-* @param count
-*            Item count.
-*/
-int GetProfileGenericDataByRangeFromRingBuffer(gxValueEventArg* e)
-{
-    int len, month = 0, day = 0, year = 1971, hour = 0, minute = 0, second = 0, value = 0;
-    dlmsVARIANT* it;
-    gxtime tm, start, end, last;
-    int ret;
-    unsigned short pos = 0;
-    dlmsVARIANT tmp;
-    var_init(&tmp);
-    time_init(&last, year, month, day, hour, minute, second, 0, -1);
-    if ((ret = va_getByIndex(e->parameters.Arr, 1, &it)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = dlms_changeType(it->byteArr, DLMS_DATA_TYPE_DATETIME, &tmp)) != 0)
-    {
-        var_clear(&tmp);
-        return ret;
-    }
-    //Start time.
-    start = *tmp.dateTime;
-    var_clear(&tmp);
-    if ((ret = va_getByIndex(e->parameters.Arr, 2, &it)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = dlms_changeType(it->byteArr, DLMS_DATA_TYPE_DATETIME, &tmp)) != 0)
-    {
-        var_clear(&tmp);
-        return ret;
-    }
-    end = *tmp.dateTime;
-    var_clear(&tmp);
-
-#if defined(_DEBUG) && !defined(GX_DLMS_MICROCONTROLLER)
-    gxByteBuffer bb;
-    bb_init(&bb);
-    time_toString(&start, &bb);
-    time_toString(&end, &bb);
-    printf("Reading rows %s\n", bb.data);
-    bb_clear(&bb);
-#endif
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-#if _MSC_VER > 1400
-    FILE* f = NULL;
-    fopen_s(&f, DATAFILE, "r");
-#else
-    FILE* f = fopen(DATAFILE, "r");
-#endif
-    if (f != NULL)
-    {
-        while ((len = fscanf(f, "%d/%d/%d %d:%d:%d;%d", &month, &day, &year, &hour, &minute, &second, &value)) != -1)
-        {
-            //Skip emmpty lines.
-            if (len == 7)
-            {
-                time_init(&tm, year, month, day, hour, minute, second, 0, -1);
-                //If value is inside of start and end time.
-                if (time_compare(&tm, &start) >= 0 && time_compare(&tm, &end) <= 0)
-                {
-                    if (time_getYears(&last) == 1971)
-                    {
-                        e->transactionStartIndex = pos;
-                        //Save end position if we have only one row.
-                        e->transactionEndIndex = pos + 1;
-                    }
-                    else
-                    {
-                        if (time_compare(&tm, &last) > 0)
-                        {
-                            e->transactionEndIndex = pos + 1;
-                        }
-                        else
-                        {
-                            gxProfileGeneric* p = (gxProfileGeneric*)e->target;
-                            if (e->transactionEndIndex == 0)
-                            {
-                                ++e->transactionEndIndex;
-                            }
-                            e->transactionEndIndex += getProfileGenericDataCount(p);
-                            e->transactionStartIndex = pos;
-                            break;
-                        }
-                    }
-                    time_copy(&last, &tm);
-                }
-                ++pos;
-            }
-            else
-            {
-                break;
-            }
-        }
-        fclose(f);
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    return 0;
-}
-
-/**
-* Find restricting object.
-*/
-int getRestrictingObject(dlmsSettings* settings, gxValueEventArg* e, gxObject** obj, short* index)
-{
-    int ret;
-    dlmsVARIANT* it, * it2;
-    if ((ret = va_getByIndex(e->parameters.Arr, 0, &it)) != 0)
-    {
-        return ret;
-    }
-    DLMS_OBJECT_TYPE ot;
-    unsigned char* ln;
-    if ((ret = va_getByIndex(it->Arr, 0, &it2)) != 0)
-    {
-        return ret;
-    }
-    ot = it2->iVal;
-    if ((ret = va_getByIndex(it->Arr, 1, &it2)) != 0)
-    {
-        return ret;
-    }
-    ln = it2->byteArr->data;
-    if ((ret = va_getByIndex(it->Arr, 3, &it2)) != 0)
-    {
-        return ret;
-    }
-    *index = it2->iVal;
-    if ((ret = oa_findByLN(&settings->objects, ot, ln, obj)) != 0)
-    {
-        return ret;
-    }
-    return ret;
-}
-
-/**
-* Find start index and row count using start and end date time.
-*
-* @param e
-*            Start and end time are get from the parameters.
-*/
-int getProfileGenericDataByRange(dlmsSettings* settings, gxValueEventArg* e)
-{
-    int len, month = 0, day = 0, year = 0, hour = 0, minute = 0, second = 0, value = 0;
-    dlmsVARIANT* it;
-    gxtime tm, start, end;
-    int ret;
-    dlmsVARIANT tmp;
-    var_init(&tmp);
-    gxObject* obj = NULL;
-    short index;
-    getRestrictingObject(settings, e, &obj, &index);
-    if ((ret = va_getByIndex(e->parameters.Arr, 1, &it)) != 0)
-    {
-        return ret;
-    }
-    if (it->vt == DLMS_DATA_TYPE_UINT32)
-    {
-        time_initUnix(&start, (time_t)it->ulVal);
-    }
-    else
-    {
-        if ((ret = dlms_changeType(it->byteArr, DLMS_DATA_TYPE_DATETIME, &tmp)) != 0)
-        {
-            var_clear(&tmp);
-            return ret;
-        }
-        //Start time.
-        start = *tmp.dateTime;
-        var_clear(&tmp);
-    }
-    if ((ret = va_getByIndex(e->parameters.Arr, 2, &it)) != 0)
-    {
-        return ret;
-    }
-    if (it->vt == DLMS_DATA_TYPE_UINT32)
-    {
-        time_initUnix(&end, (time_t)it->ulVal);
-    }
-    else
-    {
-        if ((ret = dlms_changeType(it->byteArr, DLMS_DATA_TYPE_DATETIME, &tmp)) != 0)
-        {
-            var_clear(&tmp);
-            return ret;
-        }
-        end = *tmp.dateTime;
-        var_clear(&tmp);
-    }
-#if defined(_DEBUG) && !defined(GX_DLMS_MICROCONTROLLER)
-    gxByteBuffer bb;
-    bb_init(&bb);
-    time_toString(&start, &bb);
-    time_toString(&end, &bb);
-    printf("Reading rows %s\n", bb.data);
-    bb_clear(&bb);
-#endif
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-#if _MSC_VER > 1400
-    FILE* f = NULL;
-    fopen_s(&f, DATAFILE, "r");
-#else
-    FILE* f = fopen(DATAFILE, "r");
-#endif
-    if (f != NULL)
-    {
-        while ((len = fscanf(f, "%d/%d/%d %d:%d:%d;%d", &month, &day, &year, &hour, &minute, &second, &value)) != -1)
-        {
-            //Skip emmpty lines.
-            if (len == 7)
-            {
-                time_init(&tm, year, month, day, hour, minute, second, 0, -1);
-                if (time_compare(&tm, &end) > 0)
-                {
-                    // If all data is read.
-                    break;
-                }
-                if (time_compare(&tm, &start) < 0)
-                {
-                    // If we have not find first item.
-                    ++e->transactionStartIndex;
-                }
-                ++e->transactionEndIndex;
-            }
-            else
-            {
-                break;
-            }
-        }
-        fclose(f);
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-    return 0;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_preRead(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-    gxValueEventArg* e;
-    int ret, pos;
-    DLMS_OBJECT_TYPE type;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-        //Let framework handle Logical Name read.
-        if (e->index == 1)
-        {
-            continue;
-        }
-
-        //Get target type.
-        type = (DLMS_OBJECT_TYPE)e->target->objectType;
-        //Let Framework will handle Association objects and profile generic automatically.
-        if (type == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME ||
-            type == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME)
-        {
-            continue;
-        }
-
-        if (e->target == &profileGeneric.base)
-        {
-            gxProfileGeneric* p = (gxProfileGeneric*)e->target;
-            // If buffer is read and we want to save memory.
-            if (e->index == 7)
-            {
-                // If client wants to know EntriesInUse.
-                p->entriesInUse = getProfileGenericDataCount();
-            }
-            else if (e->index == 2)
-            {
-                // Read rows from file.
-                // If reading first time.
-                if (e->transactionEndIndex == 0)
-                {
-                    if (e->selector == 0)
-                    {
-                        e->transactionEndIndex = getProfileGenericDataCount();
-                    }
-                    else if (e->selector == 1)
-                    {
-                        //Read by entry.
-                        if (useRingBuffer)
-                        {
-                            GetProfileGenericDataByRangeFromRingBuffer(e);
-                        }
-                        else
-                        {
-                            getProfileGenericDataByRange(settings, e);
-                        }
-                    }
-                    else if (e->selector == 2)
-                    {
-                        dlmsVARIANT* it;
-                        if ((ret = va_getByIndex(e->parameters.Arr, 0, &it)) != 0)
-                        {
-                            continue;
-                        }
-                        unsigned int begin = var_toInteger(it);
-                        if ((ret = va_getByIndex(e->parameters.Arr, 1, &it)) != 0)
-                        {
-                            continue;
-                        }
-                        e->transactionStartIndex = begin;
-                        e->transactionEndIndex = begin + var_toInteger(it);
-                        // If client wants to read more data what we have.
-                        int cnt = getProfileGenericDataCount();
-                        if (e->transactionEndIndex - e->transactionStartIndex > cnt - e->transactionStartIndex)
-                        {
-                            if (useRingBuffer)
-                            {
-                                e->transactionEndIndex = cnt;
-                            }
-                            else
-                            {
-                                e->transactionEndIndex = cnt - e->transactionStartIndex;
-                            }
-                            if (e->transactionEndIndex < 0)
-                            {
-                                e->transactionEndIndex = 0;
-                            }
-                        }
-                    }
-                }
-                unsigned long count = e->transactionEndIndex - e->transactionStartIndex;
-                // Read only rows that can fit to one PDU.
-                if (e->transactionEndIndex - e->transactionStartIndex > p->maxRowCount)
-                {
-                    /**
-                    * Max row count is used with Profile Generic to tell how many rows are read
-                    * to one PDU. Default value is 1. Change this for your needs.
-                    */
-                    count = p->maxRowCount;
-                }
-                // Clear old data. It's already serialized.
-                obj_clearProfileGenericBuffer(&p->buffer);
-
-                if (e->selector == 1)
-                {
-                    getProfileGenericDataByEntry(p, e->transactionStartIndex, count);
-                }
-                else
-                {
-                    //Index where to start.
-                    unsigned long index = e->transactionStartIndex;
-                    if (useRingBuffer)
-                    {
-                        index += getHead();
-                    }
-                    getProfileGenericDataByEntry(p, index, count);
-                }
-            }
-            continue;
-        }
-
-        //Update date and time of clock object.
-        if (e->target == (gxObject*)&clock1 && e->index == 2)
-        {
-            time_now(&((gxClock*)e->target)->time, 1);
-        }
-    }
-}
-
-#ifndef GX_DLMS_MICROCONTROLLER
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-int printValues(variantArray* values)
-{
-    int pos;
-    dlmsVARIANT* it;
-    gxByteBuffer bb;
-    bb_init(&bb);
-    for (pos = 0; pos != values->size; ++pos)
-    {
-        if (va_getByIndex(values, pos, &it) != 0 ||
-            var_toString(it, &bb) != 0)
-        {
-            return DLMS_ERROR_CODE_READ_WRITE_DENIED;
-        }
-        char* tmp = bb_toString(&bb);
-        printf("Writing %s\r\n", tmp);
-        free(tmp);
-        bb_clear(&bb);
-    }
-    return 0;
-}
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-#endif //GX_DLMS_MICROCONTROLLER
-
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_preWrite(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-    char str[25];
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-#ifndef GX_DLMS_MICROCONTROLLER
-        hlp_getLogicalNameToString(e->target->logicalName, str);
-        printf("Writing %s\r\n", str);
-#endif //GX_DLMS_MICROCONTROLLER
-        //Loop buffer elements in write.
-        if (e->target == &compactData.base && e->index == 2)
-        {
-#ifndef GX_DLMS_MICROCONTROLLER
-            variantArray values;
-            va_init(&values);
-            if ((compactData_getValues(settings, &compactData.templateDescription, e->value.byteArr, &values)) != 0 ||
-                printValues(&values) != 0)
-            {
-                e->error = DLMS_ERROR_CODE_READ_WRITE_DENIED;
-                break;
-            }
-            va_clear(&values);
-#endif //GX_DLMS_MICROCONTROLLER
-            break;
-        }
-#ifndef GX_DLMS_MICROCONTROLLER
-        //Loop excution times in write.
-        if (e->target == &actionSchedule.base && e->index == 4)
-        {
-            int pos;
-            dlmsVARIANT* it;
-            gxByteBuffer bb;
-            bb_init(&bb);
-            for (pos = 0; pos != e->value.Arr->size; ++pos)
-            {
-                if (va_getByIndex(e->value.Arr, pos, &it) != 0 ||
-                    var_toString(it, &bb) != 0)
-                {
-                    e->error = DLMS_ERROR_CODE_READ_WRITE_DENIED;
-                    break;
-                }
-                char* tmp = bb_toString(&bb);
-                printf("Writing %s\r\n", tmp);
-                free(tmp);
-                bb_clear(&bb);
-            }
-            break;
-        }
-#endif //GX_DLMS_MICROCONTROLLER
-    }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-}
-
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-int sendPush(dlmsSettings* settings, gxPushSetup* push);
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-//In this example we wait 5 seconds before image is verified or activated.
-time_t imageActionStartTime;
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_preAction(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-#if defined(_WIN64)
-    const char* fileName = "settings64.raw";
-#else // defined(_WIN32) || defined(__linux__)
-    const char* fileName = "settings.raw";
-#endif //defined(_WIN32) || defined(__linux__)
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-        GXTRACE_LN(("svr_preAction: "), e->target->objectType, e->target->logicalName);
-        if (e->target == BASE(loadProfile))
-        {
-            handleLoadProfileActions(e);
-            save(&meterData.loadProfile, sizeof(meterData.loadProfile));
-            e->handled = 1;
-        }
-        else if (e->target == BASE(eventLog))
-        {
-            handleEventLogActions(e);
-            save(&meterData.eventLog, sizeof(meterData.eventLog));
-            e->handled = 1;
-        }
-        else if (e->target == BASE(activePowerL1))
-        {
-            //Set default value for active power.
-            activePowerL1Value = 0;
-            e->handled = 1;
-        }
-        else if (e->target == BASE(pushSetup) && e->index == 1)
-        {
-            updateState(GURUX_EVENT_CODES_PUSH);
-            sendPush(settings, (gxPushSetup*)e->target);
-            e->handled = 1;
-        }
-        //If client wants to clear EEPROM data using Global meter reset script.
-        else if (e->target == BASE(scriptTableGlobalMeterReset) && e->index == 1)
-        {
-            //Initialize data size so default values are used on next connection.
-#if _MSC_VER > 1400
-            FILE* f = NULL;
-            fopen_s(&f, fileName, "wb");
-#else
-            FILE* f = fopen(fileName, "wb");
-#endif
-            if (f != NULL)
-            {
-                fclose(f);
-            }
-            //Load objects again.
-            createObjects();
-            updateState(GURUX_EVENT_CODES_GLOBAL_METER_RESET);
-            e->handled = 1;
-        }
-        else if (e->target == BASE(disconnectControl))
-        {
-            updateState(GURUX_EVENT_CODES_OUTPUT_RELAY_STATE);
-            //Disconnect. Turn led OFF.
-            if (e->index == 1)
-            {
-                printf("%s\r\n", "Led is OFF.");
-            }
-            else //Reconnnect. Turn LED ON.
-            {
-                printf("%s\r\n", "Led is ON.");
-            }
-        }
-        else if (e->target == BASE(scriptTableActivateTestMode))
-        {
-            //Activate test mode.
-            meterData.testMode = 1;
-            save(&meterData.testMode, sizeof(meterData.testMode));
-        }
-        else if (e->target == BASE(scriptTableActivateNormalMode))
-        {
-            //Activate normal mode.
-            meterData.testMode = 0;
-            save(&meterData.testMode, sizeof(meterData.testMode));
-        }
-        if (e->target == BASE(imageTransfer))
-        {
-            e->handled = 1;
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-            FILE* f;
-            gxImageTransfer* i = (gxImageTransfer*)e->target;
-            const char* imageFile = "image.raw";
-            //Image name and size to transfer
-            if (e->index == 1)
-            {
-                i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_NOT_INITIATED;
-                //There is only one image.
-                gxImageActivateInfo* info;
-                imageTransfer.imageActivateInfo.size = 1;
-                if ((e->error = arr_getByIndex(&imageTransfer.imageActivateInfo, 0, (void**)&info, sizeof(gxImageActivateInfo))) != 0)
-                {
-                    e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
-                    return;
-                }
-                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) != 0 ||
-                    (ret = cosem_getOctectString2(e->parameters.byteArr, info->identification.data, sizeof(info->identification.data), &info->identification.size)) != 0 ||
-                    (ret = cosem_getUInt32(e->parameters.byteArr, &info->size)) != 0)
-                {
-                    e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
-                    return;
-                }
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                printf("Updating image %s Size: %d\r\n", imageFile, info->size);
-#endif
-                allocateImageTransfer(imageFile, info->size);
-                ba_clear(&i->imageTransferredBlocksStatus);
-                i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_INITIATED;
-            }
-            //Transfers one block of the Image to the server
-            else if (e->index == 2)
-            {
-                uint32_t index;
-                uint16_t blockSize;
-                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) != 0 ||
-                    (ret = cosem_getUInt32(e->parameters.byteArr, &index)) != 0 ||
-                    (ret = hlp_getObjectCount2(e->parameters.byteArr, &blockSize)) != 0)
-                {
-                    e->error = DLMS_ERROR_CODE_HARDWARE_FAULT;
-                    return;
-                }
-                if ((ret = ba_setByIndex(&i->imageTransferredBlocksStatus, (uint16_t)index, 1)) == 0)
-                {
-                    i->imageFirstNotTransferredBlockNumber = index + 1;
-                }
-                f = fopen(imageFile, "r+b");
-                if (!f)
-                {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                    printf("Unable to open file %s\r\n", imageFile);
-#endif
-                    e->error = DLMS_ERROR_CODE_HARDWARE_FAULT;
-                    return;
-                }
-                int ret = (int)fwrite(e->parameters.byteArr->data + e->parameters.byteArr->position, 1, (int)blockSize, f);
-                fclose(f);
-                if (ret != (int)blockSize)
-                {
-                    e->error = DLMS_ERROR_CODE_UNMATCH_TYPE;
-                }
-                bb_clear(e->parameters.byteArr);
-                imageActionStartTime = time(NULL);
-                return;
-            }
-            //Verifies the integrity of the Image before activation.
-            else if (e->index == 3)
-            {
-                i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_INITIATED;
-                f = fopen(imageFile, "rb");
-                if (!f)
-                {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                    printf("Unable to open file %s\r\n", imageFile);
-#endif
-                    e->error = DLMS_ERROR_CODE_HARDWARE_FAULT;
-                    return;
-                }
-                fseek(f, 0L, SEEK_END);
-                long size = ftell(f);
-                fclose(f);
-                if (size != IMAGE_ACTIVATE_INFO[0].size)
-                {
-                    i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_FAILED;
-                    e->error = DLMS_ERROR_CODE_OTHER_REASON;
-                }
-                else
-                {
-                    //Wait 5 seconds before image is verified.  This is for example only.
-                    if (time(NULL) - imageActionStartTime < 5)
-                    {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                        printf("Image verification is on progress.\r\n");
-#endif
-                        e->error = DLMS_ERROR_CODE_TEMPORARY_FAILURE;
-                    }
-                    else
-                    {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                        printf("Image is verificated.\r\n");
-#endif
-                        i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_SUCCESSFUL;
-                        imageActionStartTime = time(NULL);
-                    }
-                }
-            }
-            //Activates the Image.
-            else if (e->index == 4)
-            {
-                i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_ACTIVATION_INITIATED;
-                //Wait 5 seconds before image is activated. This is for example only.
-                if (time(NULL) - imageActionStartTime < 5)
-                {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                    printf("Image activation is on progress.\r\n");
-#endif
-                    e->error = DLMS_ERROR_CODE_TEMPORARY_FAILURE;
-                }
-                else
-                {
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                    printf("Image is activated.\r\n");
-#endif
-                    i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_ACTIVATION_SUCCESSFUL;
-                    imageActionStartTime = time(NULL);
-                }
-            }
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-        }
-    }
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_postRead(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-        GXTRACE_LN(("svr_postRead: "), e->target->objectType, e->target->logicalName);
-    }
-}
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_postWrite(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-        GXTRACE_LN(("svr_postWrite: "), e->target->objectType, e->target->logicalName);
-        if (e->target == BASE(meterData.clock1))
-        {
-            save(&meterData.clock1, sizeof(meterData.clock1));
-        }
-        else if (e->target == BASE(actionScheduleDisconnectOpen))
-        {
-            meterData.disconnectOpenExecutions.count = (unsigned char)actionScheduleDisconnectOpen.executionTime.size;
-            save(&meterData.disconnectOpenExecutions, sizeof(meterData.disconnectOpenExecutions));
-        }
-        else if (e->target == BASE(actionScheduleDisconnectClose))
-        {
-            meterData.disconnectCloseExecutions.count = (unsigned char)actionScheduleDisconnectClose.executionTime.size;
-            save(&meterData.disconnectCloseExecutions, sizeof(meterData.disconnectCloseExecutions));
-        }
-        else if (e->target == BASE(meterData.hdlc))
-        {
-            save(&meterData.hdlc, sizeof(meterData.hdlc));
-        }
-        else if (e->target == BASE(loadProfile))
-        {
-            //Use want to change capture objects.
-            if (e->index == 3)
-            {
-                saveTargets(&meterData.loadProfile.objects, LOAD_PROFILE_CAPTURE_OBJECT, loadProfile.captureObjects.size);
-                //Clear buffer if user changes captured objects.
-                gxValueEventArg it;
-                ve_init(&it);
-                it.index = 1;
-                handleLoadProfileActions(&it);
-                //Count how many rows fit to the buffer.
-                loadProfile.profileEntries = meterData.loadProfile.profileEntries = getProfileGenericBufferMaxRowCount(&loadProfile);
-                if (loadProfile.captureObjects.size != 0 &&
-                    (LOAD_PROFILE_CAPTURE_OBJECT[0].target == BASE(meterData.clock1) ||
-                        LOAD_PROFILE_CAPTURE_OBJECT[0].target == BASE(unixTime)))
-                {
-                    //Set 1st object to sort object.
-                    loadProfile.sortObject = LOAD_PROFILE_CAPTURE_OBJECT[0].target;
-                }
-                else
-                {
-                    loadProfile.sortObject = NULL;
-                }
-            }
-            //User wants to change capture period.
-            if (e->index == 4)
-            {
-                meterData.loadProfile.period = loadProfile.capturePeriod;
-            }
-            //Use want to change max amount of profile entries.
-            if (e->index == 8)
-            {
-                //Count how many rows fit to the buffer.
-                uint16_t maxCount = getProfileGenericBufferMaxRowCount(&loadProfile);
-                //If use try to set max profileEntries bigger than can fit to EEPROM.
-                if (maxCount < loadProfile.profileEntries)
-                {
-                    loadProfile.profileEntries = maxCount;
-                }
-                meterData.loadProfile.profileEntries = (unsigned short)loadProfile.profileEntries;
-            }
-            save(&meterData.loadProfile, sizeof(meterData.loadProfile));
-        }
-        else if (e->target == BASE(pushSetup))
-        {
-            meterData.push.communicationWindow.count = (unsigned char)pushSetup.communicationWindow.size;
-            saveTargets(&meterData.push.objects, PUSH_OBJECTS, pushSetup.pushObjectList.size);
-            save(&meterData.push, sizeof(meterData.push));
-        }
-        else if (e->target == BASE(associationLow))
-        {
-            //Save LLS password.
-            meterData.association.llsPasswordSize = (char)associationLow.secret.size;
-            save(&meterData.association, sizeof(GXAssociation));
-        }
-    }
-    //Reset execute time to update execute time if user add new execute times or changes the time.
-   //MIKKO executeTime = 0;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-void svr_postAction(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-        GXTRACE_LN(("svr_postAction: "), e->target->objectType, e->target->logicalName);
-        if (e->target == BASE(associationHigh) && e->index == 2)
-        {
-            //Save HLS passwords.
-            meterData.association.hlsPasswordSize = (char)associationHigh.secret.size;
-            save(&meterData.association, sizeof(GXAssociation));
-        }
-        else if (e->target == BASE(associationHighGMac) && e->index == 2)
-        {
-            //Save HLS passwords.
-            meterData.association.hlsPasswordSize = (char)associationHighGMac.secret.size;
-            save(&meterData.association, sizeof(GXAssociation));
-        }
-        else if (e->target == BASE(securitySetupHigh) ||
-            e->target == BASE(securitySetupHighGMac))
-        {
-            //Update block cipher key.
-            //MIKKO memcpy(meterData.securitySettings.blockCipherKey, settings->cipher.blockCipherKey, sizeof(meterData.securitySettings.blockCipherKey));
-            //Update authentication key.
-            //MIKKO memcpy(meterData.securitySettings.authenticationKey, settings->cipher.authenticationKey, sizeof(meterData.securitySettings.authenticationKey));
-            save(&meterData.securitySettings, sizeof(GXSecuritySettings));
-        }
-    }
-}
-
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-/**
-* Connect to Push listener.
-*/
-int connectServer(
-    const char* address,
-    int port,
-    int* s)
-{
-    int ret;
-    struct sockaddr_in add;
-    //create socket.
-    *s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
-    if (*s == -1)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    add.sin_port = htons(port);
-    add.sin_family = AF_INET;
-    add.sin_addr.s_addr = inet_addr(address);
-    //If address is give as name
-    if (add.sin_addr.s_addr == INADDR_NONE)
-    {
-        struct hostent* Hostent = gethostbyname(address);
-        if (Hostent == NULL)
-        {
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-            int err = WSAGetLastError();
-#else
-            int err = errno;
-#endif
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-            closesocket(*s);
-#else
-            close(*s);
-#endif
-            return err;
-        };
-        add.sin_addr = *(struct in_addr*)(void*)Hostent->h_addr_list[0];
-    };
-
-    //Connect to the meter.
-    ret = connect(*s, (struct sockaddr*)&add, sizeof(struct sockaddr_in));
-    if (ret == -1)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    };
-    return DLMS_ERROR_CODE_OK;
-}
-
-int sendPush(
-    dlmsSettings* settings,
-    gxPushSetup* push)
-{
-    char* p, * host;
-    int ret, pos, port, s;
-    message messages;
-    gxByteBuffer* bb;
-    p = strchr(push->destination, ':');
-    if (p == NULL)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    pos = (int)(p - push->destination);
-    host = (char*)malloc(pos + 1);
-    memcpy(host, push->destination, pos);
-    host[pos] = '\0';
-    sscanf(++p, "%d", &port);
-    mes_init(&messages);
-    if ((ret = connectServer(host, port, &s)) == 0)
-    {
-        if ((ret = notify_generatePushSetupMessages(settings, 0, push, &messages)) == 0)
-        {
-            for (pos = 0; pos != messages.size; ++pos)
-            {
-                bb = messages.data[pos];
-                if ((ret = send(s, (char*)bb->data, bb->size, 0)) == -1)
-                {
-                    mes_clear(&messages);
-                    break;
-                }
-            }
-        }
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-        closesocket(s);
-#else
-        close(s);
-#endif
-    }
-    mes_clear(&messages);
-    free(host);
-    return 0;
-}
-#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
-
-unsigned char svr_isTarget(
-    dlmsSettings* settings,
-    unsigned long serverAddress,
-    unsigned long clientAddress)
-{
-#ifdef DLMS_ITALIAN_STANDARD
-    if (clientAddress == 1 || clientAddress == 16 || clientAddress == 3 || clientAddress == 48)
-    {
-        const unsigned char ss[6] = { 0, 0, 43, 0, (unsigned char)clientAddress, 255 };
-        memcpy(securitySetup.base.logicalName, ss, 6);
-        const unsigned char ln[6] = { 0, 0, 40, 0, (unsigned char)clientAddress, 255 };
-        memcpy(highAssociation.base.logicalName, ln, 6);
-        memcpy(highAssociation.securitySetupReference, securitySetup.base.logicalName, 6);
-    }
-    else
-    {
-        printf("Invalid HDLC address %d.\r\n", clientAddress);
-        return 0;
-    }
-    //Update invocation counter.
-    if (clientAddress == 1)
-    {
-        settings->cipher.invocationCounter = frameCounterOnLine.value.lVal;
-    }
-    else  if (clientAddress == 3)
-    {
-        settings->cipher.invocationCounter = frameCounterInstaller.value.lVal;
-    }
-    else  if (clientAddress == 48)
-    {
-        settings->cipher.invocationCounter = frameCounterGuarantor.value.lVal;
-    }
-#endif //DLMS_ITALIAN_STANDARD
-
-    objectArray objects;
-    oa_init(&objects);
-    unsigned char ret = 0;
-    uint16_t pos;
-    gxObject* tmp[6];
-    oa_attach(&objects, tmp, sizeof(tmp) / sizeof(tmp[0]));
-    objects.size = 0;
-    if (oa_getObjects(&settings->objects, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, &objects) == 0)
-    {
-        gxAssociationLogicalName* a;
-        for (pos = 0; pos != objects.size; ++pos)
-        {
-            if (oa_getByIndex(&objects, pos, (gxObject**)&a) == 0)
-            {
-                if (a->clientSAP == clientAddress)
-                {
-                    ret = 1;
-                    switch (a->authenticationMechanismName.mechanismId)
-                    {
-                    case DLMS_AUTHENTICATION_NONE:
-                        //Client connects without authentication.
-                        break;
-                    case DLMS_AUTHENTICATION_LOW:
-                        //Client connects using low authentication.
-                        break;
-                    default:
-                        //Client connects using High authentication.
-                        break;
-                    }
-                    break;
-                }
-            }
-        }
-    }
-    if (ret == 0)
-    {
-        //Authentication is now allowed. Meter is quiet and doesn't return an error.
-    }
-    else
-    {
-        // If address is not broadcast or serial number.
-        if (!(serverAddress == 0x3FFF || serverAddress == 0x7F ||
-            (serverAddress & 0x3FFF) == meterData.SERIAL_NUMBER % 10000 + 1000))
-        {
-            ret = 0;
-            // Find address from the SAP table.
-            gxSapAssignment* sap;
-            objects.size = 0;
-            if (oa_getObjects(&settings->objects, DLMS_OBJECT_TYPE_SAP_ASSIGNMENT, &objects) == 0)
-            {
-                gxSapItem* it;
-                uint16_t sapIndex, pos;
-                for (sapIndex = 0; sapIndex != objects.size; ++sapIndex)
-                {
-                    if (oa_getByIndex(&objects, sapIndex, (gxObject**)&sap) == 0)
-                    {
-                        for (pos = 0; pos != sap->sapAssignmentList.size; ++pos)
-                        {
-                            if (arr_getByIndex(&sap->sapAssignmentList, pos, (void**)&it) == 0)
-                            {
-                                //Check server address with one byte.
-                                if (((serverAddress & 0xFFFFFF00) == 0 && (serverAddress & 0x7F) == it->id) ||
-                                    //Check server address with two bytes.
-                                    ((serverAddress & 0xFFFF0000) == 0 && (serverAddress & 0x7FFF) == it->id))
-                                {
-                                    ret = 1;
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            oa_empty(&objects);
-        }
-    }
-    return ret;
-}
-
-DLMS_SOURCE_DIAGNOSTIC svr_validateAuthentication(
-    dlmsServerSettings* settings,
-    DLMS_AUTHENTICATION authentication,
-    gxByteBuffer* password)
-{
-    GXTRACE(("svr_validateAuthentication"), NULL);
-    if (authentication == DLMS_AUTHENTICATION_NONE)
-    {
-        //Uncomment this if authentication is always required.
-        //return DLMS_SOURCE_DIAGNOSTIC_AUTHENTICATION_MECHANISM_NAME_REQUIRED;
-        return DLMS_SOURCE_DIAGNOSTIC_NONE;
-    }
-    //Check Low Level security..
-    if (authentication == DLMS_AUTHENTICATION_LOW)
-    {
-        if (bb_compare(password, associationLow.secret.data, associationLow.secret.size) == 0)
-        {
-            GXTRACE(("Invalid low level password."), (const char*)associationLow.secret.data);
-            return DLMS_SOURCE_DIAGNOSTIC_AUTHENTICATION_FAILURE;
-        }
-    }
-    // Hith authentication levels are check on phase two.
-    return DLMS_SOURCE_DIAGNOSTIC_NONE;
-}
-
-
-//Get attribute access level for profile generic.
-DLMS_ACCESS_MODE getProfileGenericAttributeAccess(
-    dlmsSettings* settings,
-    gxObject* obj,
-    unsigned char index)
-{
-    //Only read is allowed for event log.
-    if (obj == BASE(eventLog))
-    {
-        return DLMS_ACCESS_MODE_READ;
-    }
-    //Write is allowed only for High authentication.
-    if (settings->authentication > DLMS_AUTHENTICATION_LOW)
-    {
-        switch (index)
-        {
-        case 3://captureObjects.
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        case 4://capturePeriod
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        case 8://Profile entries.
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        default:
-            break;
-        }
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-
-//Get attribute access level for Push Setup.
-DLMS_ACCESS_MODE getPushSetupAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    //Write is allowed only for High authentication.
-    if (settings->authentication > DLMS_AUTHENTICATION_LOW)
-    {
-        switch (index)
-        {
-        case 2://pushObjectList
-        case 4://communicationWindow
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        default:
-            break;
-        }
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for Disconnect Control.
-DLMS_ACCESS_MODE getDisconnectControlAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for register schedule.
-DLMS_ACCESS_MODE getActionSchduleAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    //Write is allowed only for High authentication.
-    if (settings->authentication > DLMS_AUTHENTICATION_LOW)
-    {
-        switch (index)
-        {
-        case 4://Execution time.
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        default:
-            break;
-        }
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for register.
-DLMS_ACCESS_MODE getRegisterAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for data objects.
-DLMS_ACCESS_MODE getDataAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for script table.
-DLMS_ACCESS_MODE getScriptTableAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for IEC HDLS setup.
-DLMS_ACCESS_MODE getHdlcSetupAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    //Write is allowed only for High authentication.
-    if (settings->authentication > DLMS_AUTHENTICATION_LOW)
-    {
-        switch (index)
-        {
-        case 2: //Communication speed.
-        case 7:
-        case 8:
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        default:
-            break;
-        }
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-
-//Get attribute access level for association LN.
-DLMS_ACCESS_MODE getAssociationAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    //If secret
-    if (settings->authentication == DLMS_AUTHENTICATION_LOW && index == 7)
-    {
-        return DLMS_ACCESS_MODE_READ_WRITE;
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-//Get attribute access level for security setup.
-DLMS_ACCESS_MODE getSecuritySetupAttributeAccess(
-    dlmsSettings* settings,
-    unsigned char index)
-{
-    //Only client system title is writable.
-    if (settings->authentication > DLMS_AUTHENTICATION_LOW && index == 4)
-    {
-        return DLMS_ACCESS_MODE_READ_WRITE;
-    }
-    return DLMS_ACCESS_MODE_READ;
-}
-
-/**
-* Get attribute access level.
-*/
-DLMS_ACCESS_MODE svr_getAttributeAccess(
-    dlmsSettings* settings,
-    gxObject* obj,
-    unsigned char index)
-{
-    GXTRACE("svr_getAttributeAccess", NULL);
-    // Only read is allowed if authentication is not used.
-    if (index == 1 || settings->authentication == DLMS_AUTHENTICATION_NONE)
-    {
-        return DLMS_ACCESS_MODE_READ;
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
-    {
-        return getAssociationAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC)
-    {
-        return getProfileGenericAttributeAccess(settings, obj, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_PUSH_SETUP)
-    {
-        return getPushSetupAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_DISCONNECT_CONTROL)
-    {
-        return getDisconnectControlAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_DISCONNECT_CONTROL)
-    {
-        return getDisconnectControlAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_ACTION_SCHEDULE)
-    {
-        return getActionSchduleAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_SCRIPT_TABLE)
-    {
-        return getScriptTableAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_REGISTER)
-    {
-        return getRegisterAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_DATA)
-    {
-        return getDataAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_IEC_HDLC_SETUP)
-    {
-        return getHdlcSetupAttributeAccess(settings, index);
-    }
-    if (obj->objectType == DLMS_OBJECT_TYPE_SECURITY_SETUP)
-    {
-        return getSecuritySetupAttributeAccess(settings, index);
-    }
-    // Only clock write is allowed.
-    if (settings->authentication == DLMS_AUTHENTICATION_LOW)
-    {
-        if (obj->objectType == DLMS_OBJECT_TYPE_CLOCK)
-        {
-            return DLMS_ACCESS_MODE_READ_WRITE;
-        }
-        return DLMS_ACCESS_MODE_READ;
-    }
-    // All writes are allowed.
-    return DLMS_ACCESS_MODE_READ_WRITE;
-}
-
-/**
-* Get method access level.
-*/
-DLMS_METHOD_ACCESS_MODE svr_getMethodAccess(
-    dlmsSettings* settings,
-    gxObject* obj,
-    unsigned char index)
-{
-    // Methods are not allowed.
-    if (settings->authentication == DLMS_AUTHENTICATION_NONE)
-    {
-        return DLMS_METHOD_ACCESS_MODE_NONE;
-    }
-    // Only clock methods are allowed.
-    if (settings->authentication == DLMS_AUTHENTICATION_LOW)
-    {
-        if (obj->objectType == DLMS_OBJECT_TYPE_CLOCK)
-        {
-            return DLMS_METHOD_ACCESS_MODE_ACCESS;
-        }
-        return DLMS_METHOD_ACCESS_MODE_NONE;
-    }
-    return DLMS_METHOD_ACCESS_MODE_ACCESS;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//Client has made connection to the server.
-/////////////////////////////////////////////////////////////////////////////
-int svr_connected(
-    dlmsServerSettings* settings)
-{
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-    printf("Connected %d.\r\n", settings->base.connected);
-#endif
-#ifdef DLMS_ITALIAN_STANDARD
-    if (settings->base.clientAddress == 1)
-    {
-        if (settings->base.connected != DLMS_CONNECTION_STATE_DLMS)
-        {
-            if (settings->base.preEstablishedSystemTitle != NULL)
-            {
-                bb_clear(settings->base.preEstablishedSystemTitle);
-            }
-            else
-            {
-                settings->base.preEstablishedSystemTitle = (gxByteBuffer*)malloc(sizeof(gxByteBuffer));
-                bb_init(settings->base.preEstablishedSystemTitle);
-            }
-            bb_addString(settings->base.preEstablishedSystemTitle, "ABCDEFGH");
-            settings->base.cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
-        }
-        else
-        {
-            //Return error if client can connect only using pre-established connnection.
-            return DLMS_ERROR_CODE_READ_WRITE_DENIED;
-        }
-    }
-#else
-#endif //DLMS_ITALIAN_STANDARD
-    return 0;
-}
-
-/**
-    * Client has try to made invalid connection. Password is incorrect.
-    *
-    * @param connectionInfo
-    *            Connection information.
-    */
-int svr_invalidConnection(dlmsServerSettings* settings)
-{
-    return 0;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-//
-/////////////////////////////////////////////////////////////////////////////
-int svr_disconnected(
-    dlmsServerSettings* settings)
-{
-#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-    printf("Disconnected %d.\r\n", settings->base.connected);
-#endif
-    return 0;
-}
-
-void svr_preGet(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-    gxValueEventArg* e;
-    int ret, pos;
-    for (pos = 0; pos != args->size; ++pos)
-    {
-        if ((ret = vec_getByIndex(args, pos, &e)) != 0)
-        {
-            return;
-        }
-    }
-}
-
-void svr_postGet(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-
-}
-
-/**
-* This is reserved for future use. Do not use it.
-*
-* @param args
-*            Handled data type requests.
-*/
-void svr_getDataType(
-    dlmsSettings* settings,
-    gxValueEventCollection* args)
-{
-
-}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/src/exampleserver.c src/GuruxDLMSServerExample/src/exampleserver.c
--- upstream/GuruxDLMSServerExample/src/exampleserver.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/src/exampleserver.c	2024-11-13 12:20:09.000000000 +0000
@@ -81,19 +81,14 @@
 
 //TODO: Allocate space where profile generic row values are serialized.
 #define PDU_MAX_PROFILE_GENERIC_COLUMN_SIZE 100
-#define HDLC_HEADER_SIZE 17
-#define HDLC_BUFFER_SIZE 128
-#define PDU_BUFFER_SIZE 512
-#define WRAPPER_BUFFER_SIZE 8 + PDU_BUFFER_SIZE
 //Buffer where frames are saved.
 static unsigned char frameBuff[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
 //Buffer where PDUs are saved.
 static unsigned char pduBuff[PDU_BUFFER_SIZE];
 static unsigned char replyFrame[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
 //Define server system title.
-static unsigned char SERVER_SYSTEM_TITLE[8] = { 0 };
+static unsigned char SERVER_SYSTEM_TITLE[8] = { 0x47, 0x52, 0x58, 0x00, 0x00, 0x00, 0x00, 0x01 };
 time_t imageActionStartTime = 0;
-gxImageActivateInfo IMAGE_ACTIVATE_INFO[1];
 static gxByteBuffer reply;
 
 uint32_t time_current(void)
@@ -120,6 +115,8 @@
 static gxAssociationLogicalName associationLow;
 static gxAssociationLogicalName associationHigh;
 static gxAssociationLogicalName associationHighGMac;
+static gxAssociationLogicalName associationHighGMacPreEstablished;
+static gxAssociationLogicalName associationHighEcdsa;
 static gxRegister activePowerL1;
 static gxScriptTable scriptTableGlobalMeterReset;
 static gxScriptTable scriptTableDisconnectControl;
@@ -138,6 +135,10 @@
 static gxSecuritySetup securitySetupHigh;
 //Security Setup HighGMac is for GMac authentication.
 static gxSecuritySetup securitySetupHighGMac;
+//Security Setup HighGMac is for pre-established GMac authentication.
+static gxSecuritySetup securitySetupHighGMacPreEstablished;
+//Security Setup HighEdcsa is for ECDSA authentication.
+static gxSecuritySetup securitySetupHighEcdsa;
 
 gxImageTransfer imageTransfer;
 gxAutoConnect autoConnect;
@@ -158,11 +159,56 @@
 gxLimiter limiter;
 gxG3PlcMacLayerCounters g3plcMacLayerCounters;
 gxG3PlcMacSetup g3PlcMacSetup;
+gxG3Plc6LoWPAN g3Plc6LoWPAN;
+gxArrayManager arrayManager;
+gxLteMonitoring lteMonitoring;
+gxAccount account;
+
+#ifdef DLMS_ITALIAN_STANDARD
+
+static gxTariffPlan activeTariffPlan;
+static gxTariffPlan passiveTariffPlan;
+static gxData currentDiagnostic;
+static gxData snapshotReasonCode;
+static gxData snapshotPeriodCounter;
+static gxData spareObject;
+static gxProfileGeneric hourlyProfileGeneric;
+static gxProfileGeneric dailyProfileGeneric;
+static gxProfileGeneric snapshotPeriodData;
+static gxData hourlyDiagnostic;
+//Compact Frame 6.
+static gxCompactData cf6;
+//Compact Frame 62.
+static gxCompactData cf62;
+//Compact Frame 63.
+static gxCompactData cf63;
+//Compact Frame 64.
+static gxCompactData cf64;
+static gxData ppNetworkStatus;
+static gxData metrologicalEventCounter;
+static gxData eventCounter;
+static gxData dailyDiagnostic;
+static gxRegister hourlyConvertedConsumption;
+static gxRegister hourlyConvertedConsumptionUnderAlarm;
+static gxRegister currentIndexOfConvertedVolume;
+static gxRegister currentIndexOfConvertedVolumeF1Rate;
+static gxRegister currentIndexOfConvertedVolumeF2Rate;
+static gxRegister currentIndexOfConvertedVolumeF3Rate;
+static gxData snapshotPeriodDiagnostic;
+static gxRegister currentIndexOfConvertedVolumeUnderAlarm;
+static gxExtendedRegister maximumConventionalConvertedGasFlow;
+static gxData managementFrameCounterOnLine;
+static gxData billingSnapshotPeriodCounter;
+#endif //DLMS_ITALIAN_STANDARD
 
 //static gxObject* NONE_OBJECTS[] = { BASE(associationNone), BASE(ldn) };
 
 static gxObject* ALL_OBJECTS[] = {
-    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac), BASE(securitySetupHigh), BASE(securitySetupHighGMac),
+    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac),
+    BASE(associationHighGMacPreEstablished),
+    BASE(associationHighEcdsa),
+    BASE(securitySetupHigh), BASE(securitySetupHighGMac),BASE(securitySetupHighGMacPreEstablished),
+    BASE(securitySetupHighEcdsa),
     BASE(ldn), BASE(sapAssignment), BASE(eventCode),
     BASE(clock1), BASE(activePowerL1), BASE(pushSetup), BASE(scriptTableGlobalMeterReset), BASE(scriptTableDisconnectControl),
     BASE(scriptTableActivateTestMode), BASE(scriptTableActivateNormalMode), BASE(loadProfile), BASE(eventLog), BASE(hdlc),
@@ -171,7 +217,40 @@
     BASE(registerMonitor), BASE(autoAnswer), BASE(modemConfiguration), BASE(macAddressSetup), BASE(ip4Setup), BASE(pppSetup), BASE(gprsSetup),
     BASE(tarifficationScriptTable), BASE(registerActivation), BASE(limiter),
     BASE(mbusDiagnostic), BASE(mbusPortSetup),
-    BASE(g3plcMacLayerCounters), BASE(g3PlcMacSetup)
+    BASE(g3plcMacLayerCounters), BASE(g3PlcMacSetup), BASE(g3Plc6LoWPAN), BASE(arrayManager),
+    BASE(lteMonitoring),
+    BASE(account),
+    #ifdef DLMS_ITALIAN_STANDARD
+    BASE(activeTariffPlan),
+    BASE(passiveTariffPlan),
+    BASE(spareObject),
+    BASE(currentDiagnostic),
+    BASE(snapshotReasonCode),
+    BASE(snapshotPeriodCounter),
+    BASE(cf6),
+    BASE(cf62),
+    BASE(cf63),
+    BASE(cf64),
+    BASE(hourlyProfileGeneric),
+    BASE(dailyProfileGeneric),
+    BASE(snapshotPeriodData),
+    BASE(hourlyDiagnostic),
+    BASE(hourlyConvertedConsumption),
+    BASE(hourlyConvertedConsumptionUnderAlarm),
+    BASE(ppNetworkStatus),
+    BASE(metrologicalEventCounter),
+    BASE(eventCounter),
+    BASE(dailyDiagnostic),
+    BASE(currentIndexOfConvertedVolume),
+    BASE(currentIndexOfConvertedVolumeF1Rate),
+    BASE(currentIndexOfConvertedVolumeF2Rate),
+    BASE(currentIndexOfConvertedVolumeF3Rate),
+    BASE(snapshotPeriodDiagnostic),
+    BASE(currentIndexOfConvertedVolumeUnderAlarm),
+    BASE(maximumConventionalConvertedGasFlow),
+    BASE(managementFrameCounterOnLine),
+    BASE(billingSnapshotPeriodCounter),
+#endif //DLMS_ITALIAN_STANDARD
 };
 
 ////////////////////////////////////////////////////
@@ -179,13 +258,17 @@
 gxSerializerIgnore NON_SERIALIZED_OBJECTS[] = {
     //Nothing is saved when authentication is not used.
     IGNORE_ATTRIBUTE(BASE(associationNone), GET_ATTRIBUTE_ALL()),
+    IGNORE_ATTRIBUTE(BASE(securitySetupHighGMac), GET_ATTRIBUTE_ALL()),
+    IGNORE_ATTRIBUTE(BASE(securitySetupHighGMacPreEstablished), GET_ATTRIBUTE_ALL()),
+    IGNORE_ATTRIBUTE(BASE(securitySetupHighEcdsa), GET_ATTRIBUTE_ALL()),
     //Only password is saved for low and high authentication.
     IGNORE_ATTRIBUTE(BASE(associationLow), GET_ATTRIBUTE_EXCEPT(7)),
     IGNORE_ATTRIBUTE(BASE(associationHigh), GET_ATTRIBUTE_EXCEPT(7)),
     //Only scaler and unit are saved for all register objects.
     IGNORE_ATTRIBUTE_BY_TYPE(DLMS_OBJECT_TYPE_REGISTER, GET_ATTRIBUTE(2)),
     //Objects are not load because they are created statically.
-    IGNORE_ATTRIBUTE_BY_TYPE(DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, GET_ATTRIBUTE(2)) };
+    IGNORE_ATTRIBUTE_BY_TYPE(DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, GET_ATTRIBUTE(2))
+};
 
 static uint32_t executeTime = 0;
 
@@ -491,11 +574,26 @@
 #else
     f = fopen(fileName, "r+b");
 #endif
+    if (f == NULL)
+    {
+        //Allocate space for the profile generic buffer.
+        allocateProfileGenericBuffer(fileName, 1024);
+#if _MSC_VER > 1400
+        fopen_s(&f, fileName, "r+b");
+#else
+        f = fopen(fileName, "r+b");
+#endif
+    }
     if (f != NULL)
     {
         uint16_t dataSize = 0;
-        uint8_t columnSizes[10];
-        DLMS_DATA_TYPE dataTypes[10];
+        uint8_t columnSizes[20];
+        DLMS_DATA_TYPE dataTypes[20];
+        if (sizeof(dataTypes) / sizeof(dataTypes[0]) < pg->captureObjects.size ||
+            sizeof(columnSizes) / sizeof(columnSizes[0]) < pg->captureObjects.size)
+        {
+            return DLMS_ERROR_CODE_OUTOFMEMORY;
+        }
         //Load current entry index from the begin of the data.
         uint16_t index = 0;
         if (fread(pdu.data, 1, 2, f) == 2)
@@ -740,8 +838,13 @@
         associationHighGMac.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
         OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
         associationHighGMac.clientSAP = 0x1;
+#ifndef DLMS_ITALIAN_STANDARD
         associationHighGMac.xDLMSContextInfo.maxSendPduSize = associationHighGMac.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+#else
+        associationHighGMac.xDLMSContextInfo.maxSendPduSize = associationHighGMac.xDLMSContextInfo.maxReceivePduSize = 504;
+#endif //DLMS_ITALIAN_STANDARD
         associationHighGMac.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+            DLMS_CONFORMANCE_GENERAL_PROTECTION |
             DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
             DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
             DLMS_CONFORMANCE_SET |
@@ -753,7 +856,71 @@
 #ifndef DLMS_IGNORE_OBJECT_POINTERS
         associationHighGMac.securitySetup = &securitySetupHighGMac;
 #else
-        memcpy(associationHighGMac.securitySetupReference, securitySetupHigh.base.logicalName, 6);
+        memcpy(associationHighGMac.securitySetupReference, securitySetupHighGMac.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds pre-established example 
+// Logical Name Association object for GMAC High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighGMacPreEstablished()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 5, 255 };
+    if ((ret = INIT_OBJECT(associationHighGMacPreEstablished, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighGMacPreEstablished.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
+        OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
+        associationHighGMacPreEstablished.clientSAP = 0x2;
+        associationHighGMacPreEstablished.xDLMSContextInfo.maxSendPduSize = associationHighGMacPreEstablished.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighGMacPreEstablished.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+            DLMS_CONFORMANCE_SET |
+            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+            DLMS_CONFORMANCE_ACTION |
+            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+            DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighGMacPreEstablished.securitySetup = &securitySetupHighGMacPreEstablished;
+#else
+        memcpy(associationHighGMacPreEstablished.securitySetupReference, securitySetupHighGMacPreEstablished.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example Logical Name Association object for ECDSA High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighECDSA()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 6, 255 };
+    if ((ret = INIT_OBJECT(associationHighEcdsa, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighEcdsa.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_ECDSA;
+        OA_ATTACH(associationHighEcdsa.objectList, ALL_OBJECTS);
+        associationHighEcdsa.clientSAP = 0x3;
+        associationHighEcdsa.xDLMSContextInfo.maxSendPduSize = associationHighEcdsa.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighEcdsa.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)
+            (DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+                DLMS_CONFORMANCE_SET |
+                DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+                DLMS_CONFORMANCE_ACTION |
+                DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+                DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighEcdsa.securitySetup = &securitySetupHighEcdsa;
+#else
+        memcpy(associationHighEcdsa.securitySetupReference, securitySetupHighEcdsa.base.logicalName, 6);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
     }
     return ret;
@@ -785,7 +952,13 @@
 {
     int ret;
     //Define client system title.
+#ifdef DLMS_ITALIAN_STANDARD
+    // Client system title is not send with message and it must define for the 
+    // meter. This example uses client system title: Gurux123
+    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0x47, 0x75, 0x72, 0x75, 0x78, 0x31, 0x32, 0x33 };
+#else
     static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0 };
+#endif
     const unsigned char ln[6] = { 0, 0, 43, 0, 2, 255 };
     if ((ret = INIT_OBJECT(securitySetupHighGMac, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
     {
@@ -799,6 +972,44 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for pre-established GMAC authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupPreEstablishedHighGMac()
+{
+    int ret;
+    //Define client system title for the pre-established connection.
+    //Pre-establiched system title is Gurux123
+    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0x47, 0x75, 0x72, 0x75, 0x78, 0x31, 0x32, 0x33 };
+    const unsigned char ln[6] = { 0, 0, 43, 0, 3, 255 };
+    if ((ret = INIT_OBJECT(securitySetupHighGMacPreEstablished, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighGMacPreEstablished.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        BB_ATTACH(securitySetupHighGMacPreEstablished.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
+        //Only Authenticated encrypted connections are allowed.
+        securitySetupHighGMacPreEstablished.securityPolicy = DLMS_SECURITY_POLICY_AUTHENTICATED_ENCRYPTED;
+        securitySetupHighGMacPreEstablished.securitySuite = DLMS_SECURITY_SUITE_V0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for ECDSA authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupHighEcdsa()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 43, 0, 4, 255 };
+    if ((ret = INIT_OBJECT(securitySetupHighEcdsa, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighEcdsa.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        //Ciphering is not used.
+        securitySetupHighEcdsa.securityPolicy = DLMS_SECURITY_POLICY_NOTHING;
+        securitySetupHighEcdsa.securitySuite = DLMS_SECURITY_SUITE_V1;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
 //This method adds example register object.
 ///////////////////////////////////////////////////////////////////////
 int addRegisterObject()
@@ -808,7 +1019,7 @@
     //10 ^ 3 =  1000
     GX_UINT16_BYREF(activePowerL1.value, activePowerL1Value);
     activePowerL1.scaler = -2;
-    activePowerL1.unit = 30;
+    activePowerL1.unit = DLMS_UNIT_ACTIVE_ENERGY;
     return 0;
 }
 
@@ -921,7 +1132,7 @@
 
         GX_UINT16(limiter.thresholdActive) = 1000;
         GX_UINT16(limiter.thresholdEmergency) = 2000;
-        GX_UINT16(limiter.thresholdNormal) = 1000;        
+        GX_UINT16(limiter.thresholdNormal) = 1000;
         limiter.minOverThresholdDuration = 60;
         limiter.minUnderThresholdDuration = 60;
         //////////////////////
@@ -1085,7 +1296,7 @@
         loadProfile.sortMethod = DLMS_SORT_METHOD_FIFO;
         ///////////////////////////////////////////////////////////////////
         //Add 2 columns.
-        //Add clock obect.
+        //Add clock object.
         capture = (gxTarget*)malloc(sizeof(gxTarget));
         capture->attributeIndex = 2;
         capture->dataIndex = 0;
@@ -1118,7 +1329,7 @@
         ///////////////////////////////////////////////////////////////////
         //Add 2 columns as default.
         gxTarget* capture;
-        //Add clock obect.
+        //Add clock object.
         capture = (gxTarget*)malloc(sizeof(gxTarget));
         capture->attributeIndex = 2;
         capture->dataIndex = 0;
@@ -1400,10 +1611,19 @@
 {
     unsigned char ln[6] = { 0,0,44,0,0,255 };
     INIT_OBJECT(imageTransfer, DLMS_OBJECT_TYPE_IMAGE_TRANSFER, ln);
-    imageTransfer.imageBlockSize = 100;
+    imageTransfer.imageBlockSize = 450;
     imageTransfer.imageFirstNotTransferredBlockNumber = 0;
     //Enable image transfer.
     imageTransfer.imageTransferEnabled = 1;
+    //There is only one image.
+    gxImageActivateInfo* info;
+    if (imageTransfer.imageActivateInfo.size == 0)
+    {
+        info = malloc(sizeof(gxImageActivateInfo));
+        bb_init(&info->identification);
+        bb_init(&info->signature);
+        arr_push(&imageTransfer.imageActivateInfo, info);
+    }
     return 0;
 }
 
@@ -1438,11 +1658,6 @@
     unsigned char ln[6] = { 0,0,66,0,1,255 };
     INIT_OBJECT(compactData, DLMS_OBJECT_TYPE_COMPACT_DATA, ln);
     compactData.templateId = 66;
-#ifdef DLMS_ITALIAN_STANDARD
-    //Some Italy meters require that there is a array count in some compact buffer.
-    //This is against compact data structure defined in DLMS standard.
-    compactData.appendAA = 1;
-#endif //DLMS_ITALIAN_STANDARD
     //Buffer is captured when invoke is called.
     compactData.captureMethod = DLMS_CAPTURE_METHOD_INVOKE;
     ////////////////////////////////////////
@@ -1717,7 +1932,6 @@
 int addMbusPortSetup()
 {
     int ret;
-    gxBroadcastFrameCounter* item;
     const unsigned char ln[6] = { 0,0,24,8,0,255 };
     const unsigned char PROFILE_SELECTION[6] = { 0,0,24,0,0,255 };
     if ((ret = INIT_OBJECT(mbusPortSetup, DLMS_OBJECT_TYPE_MBUS_PORT_SETUP, ln)) == 0)
@@ -1780,7 +1994,7 @@
         g3PlcMacSetup.shortAddress = 1;
         g3PlcMacSetup.rcCoord = 2;
         g3PlcMacSetup.panId = 3;
-        gxG3MacKeyTable* key = (gxG3MacKeyTable*) malloc(sizeof(gxG3MacKeyTable));
+        gxG3MacKeyTable* key = (gxG3MacKeyTable*)malloc(sizeof(gxG3MacKeyTable));
         key->id = 1;
         memcpy(key->key, GMK_KEY, sizeof(GMK_KEY));
         arr_push(&g3PlcMacSetup.keyTable, key);
@@ -1839,6 +2053,1279 @@
     return ret;
 }
 
+
+#ifdef DLMS_ITALIAN_STANDARD
+///////////////////////////////////////////////////////////////////////
+// Add tariff plan object. Tariff plan is used only in Italy standard.
+// 
+// Active UNI/TS Tariff Plan (end-of-billing-period)
+///////////////////////////////////////////////////////////////////////
+int addActiveTariffPlan()
+{
+    int ret;
+    static unsigned char CALENDAR_NAME[2] = { 0x0D, 0x01 };
+    static unsigned char WEEKLY_ACTIVATION[2] = { 0x7, 0xFF };
+    const unsigned char ln[6] = { 0, 0, 94, 39, 21, 101 };
+    if ((ret = INIT_OBJECT(activeTariffPlan, DLMS_OBJECT_TYPE_TARIFF_PLAN, ln)) == 0)
+    {
+        BB_ATTACH(activeTariffPlan.calendarName, CALENDAR_NAME, 2);
+        activeTariffPlan.enabled = 0;
+        time_init(&activeTariffPlan.activationTime, 2015, 1, 1, 0, 0, 0, 0, 120);
+        //General 
+        activeTariffPlan.plan.defaultTariffBand = 3;
+        BIT_ATTACH(activeTariffPlan.plan.weeklyActivation, WEEKLY_ACTIVATION, 2);
+
+        //////////////
+        //Get winter season.
+        activeTariffPlan.plan.winterSeason.dayOfMonth = 1;
+        activeTariffPlan.plan.winterSeason.month = 10;
+        //Working day interval #1.
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[1].startHour = 24;
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[2].startHour = 24;
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[3].startHour = 24;
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[4].startHour = 24;
+        activeTariffPlan.plan.winterSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[1].startHour = 21;
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[2].startHour = 21;
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[3].startHour = 21;
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[4].startHour = 21;
+        activeTariffPlan.plan.winterSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        activeTariffPlan.plan.winterSeason.holidayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.winterSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        activeTariffPlan.plan.winterSeason.holidayIntervals[1].startHour = 21;
+        activeTariffPlan.plan.winterSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        activeTariffPlan.plan.winterSeason.holidayIntervals[2].startHour = 21;
+        activeTariffPlan.plan.winterSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        activeTariffPlan.plan.winterSeason.holidayIntervals[3].startHour = 21;
+        activeTariffPlan.plan.winterSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        activeTariffPlan.plan.winterSeason.holidayIntervals[4].startHour = 21;
+        activeTariffPlan.plan.winterSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //////////////
+        // Get summer season.
+        activeTariffPlan.plan.summerSeason.dayOfMonth = 1;
+        activeTariffPlan.plan.summerSeason.month = 4;
+        //Working day interval #1.
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[1].startHour = 24;
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[2].startHour = 24;
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[3].startHour = 24;
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[4].startHour = 24;
+        activeTariffPlan.plan.summerSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[1].startHour = 21;
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[2].startHour = 21;
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[3].startHour = 21;
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[4].startHour = 21;
+        activeTariffPlan.plan.summerSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        activeTariffPlan.plan.summerSeason.holidayIntervals[0].startHour = 21;
+        activeTariffPlan.plan.summerSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        activeTariffPlan.plan.summerSeason.holidayIntervals[1].startHour = 21;
+        activeTariffPlan.plan.summerSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        activeTariffPlan.plan.summerSeason.holidayIntervals[2].startHour = 21;
+        activeTariffPlan.plan.summerSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        activeTariffPlan.plan.summerSeason.holidayIntervals[3].startHour = 21;
+        activeTariffPlan.plan.summerSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        activeTariffPlan.plan.summerSeason.holidayIntervals[4].startHour = 21;
+        activeTariffPlan.plan.summerSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        dlmsVARIANT* it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 5;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 6;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 7;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 8;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 9;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 10;
+        va_push(&activeTariffPlan.plan.specialDays, it);
+    }
+    return ret;
+}
+
+int addPassiveTariffPlan()
+{
+    int ret;
+    static unsigned char CALENDAR_NAME[2] = { 0x0D, 0x01 };
+    static unsigned char WEEKLY_ACTIVATION[2] = { 0x7, 0xFF };
+    const unsigned char ln[6] = { 0, 0, 94, 39, 22, 255 }; //0-0:94.39.22.255
+    if ((ret = INIT_OBJECT(passiveTariffPlan, DLMS_OBJECT_TYPE_TARIFF_PLAN, ln)) == 0)
+    {
+        BB_ATTACH(passiveTariffPlan.calendarName, CALENDAR_NAME, 2);
+        passiveTariffPlan.enabled = 0;
+        time_init(&passiveTariffPlan.activationTime, 2024, 1, 1, 0, 0, 0, 0, 120);
+        //General 
+        passiveTariffPlan.plan.defaultTariffBand = 3;
+        BIT_ATTACH(passiveTariffPlan.plan.weeklyActivation, WEEKLY_ACTIVATION, 2);
+
+        //////////////
+        //Get winter season.
+        passiveTariffPlan.plan.winterSeason.dayOfMonth = 1;
+        passiveTariffPlan.plan.winterSeason.month = 10;
+        //Working day interval #1.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[1].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[2].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[3].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[4].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //////////////
+        // Get summer season.
+        passiveTariffPlan.plan.summerSeason.dayOfMonth = 1;
+        passiveTariffPlan.plan.summerSeason.month = 4;
+        //Working day interval #1.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[1].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[2].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[3].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[4].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        dlmsVARIANT* it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 5;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 6;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 7;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 8;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 9;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 10;
+        va_push(&passiveTariffPlan.plan.specialDays, it);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add spare object as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSpareObject()
+{
+    int ret;
+    unsigned char DATA[1] = { 0 };
+    const unsigned char ln[6] = { 0, 0, 96, 39, 40, 255 };//0-0:94:39.40.255
+    if ((ret = INIT_OBJECT(spareObject, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        var_addBytes(&spareObject.value, DATA, 0);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add current diagnostic object as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCurrentDiagnostic()
+{
+    int ret;
+    unsigned char DATA[1] = { 0 };
+    const unsigned char ln[6] = { 7, 0, 96, 5, 1, 255 };//7-0:96:5.1.255
+    if ((ret = INIT_OBJECT(currentDiagnostic, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        GX_UINT16(currentDiagnostic.value) = 0;
+    }
+    return ret;
+}
+
+
+///////////////////////////////////////////////////////////////////////
+//Add snapshot reason code object as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSnapshotReasonCode()
+{
+    int ret;
+    unsigned char DATA[1] = { 0 };
+    const unsigned char ln[6] = { 0, 0, 96, 10, 2, 255 };//0-0:96:10.2.255
+    if ((ret = INIT_OBJECT(snapshotReasonCode, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        GX_UINT16(snapshotReasonCode.value) = 0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add snapshot perios counter object as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSnapshotPeriodCounter()
+{
+    int ret;
+    unsigned char DATA[1] = { 0 };
+    const unsigned char ln[6] = { 7, 0, 0, 1, 0, 255 };//7-0:0:1.0.255
+    if ((ret = INIT_OBJECT(snapshotPeriodCounter, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        GX_UINT16(snapshotPeriodCounter.value) = 0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Add management frame counter On-line object 
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addManagementFrameCounterOnLine()
+{
+    int ret;
+    const unsigned char ln[6] = { 0,0,43,1,1,255 };
+    if ((ret = INIT_OBJECT(managementFrameCounterOnLine, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        //Initial invocation counter value.
+        GX_UINT32(managementFrameCounterOnLine.value) = 0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Add billing snapshot/period counter object 
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addBillingSnapshotPeriodCounter()
+{
+    int ret;
+    const unsigned char ln[6] = { 7,0,0,1,0,255 };
+    if ((ret = INIT_OBJECT(billingSnapshotPeriodCounter, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        //Initial invocation counter value.
+        GX_UINT32(billingSnapshotPeriodCounter.value) = 0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Compact frame 6 as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCF6Plan(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 6, 255 }; // 0-0:66.0.6.255
+    if ((ret = INIT_OBJECT(cf6, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        cf6.templateId = 6;
+        cf6.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        //Add 6 capture objects.
+        //CF6 attribute #4.
+        gxTarget* capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        gxKey* k = key_init(BASE(cf6), capture);
+        arr_push(&cf6.captureObjects, k);
+        //Passive UNI/TS Tariff Plan attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(passiveTariffPlan), capture);
+        arr_push(&cf6.captureObjects, k);
+        //Passive UNI/TS Tariff Plan attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(passiveTariffPlan), capture);
+        arr_push(&cf6.captureObjects, k);
+        //Passive UNI/TS Tariff Plan attribute #4.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        k = key_init(BASE(passiveTariffPlan), capture);
+        arr_push(&cf6.captureObjects, k);
+        //Passive UNI/TS Tariff Plan attribute #5.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 5;
+        capture->dataIndex = 0;
+        k = key_init(BASE(passiveTariffPlan), capture);
+        arr_push(&cf6.captureObjects, k);
+        //Spare Object.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(spareObject), capture);
+        arr_push(&cf6.captureObjects, k);
+        ret = compactData_updateTemplateDescription(settings, &cf6);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Compact frame 62 as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCF62(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 62, 255 };//0-0:66.0.62.255
+    if ((ret = INIT_OBJECT(cf62, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        cf62.templateId = 62;
+        cf62.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        //Add 11 capture objects.
+        //CF62 attribute #4.
+        gxTarget* capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        gxKey* k = key_init(BASE(cf62), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //Unix time attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(unixTime), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //PP network status attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(ppNetworkStatus), capture);
+        arr_push(&cf62.captureObjects, k);
+        //LTE Monitoring attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(lteMonitoring), capture);
+        arr_push(&cf62.captureObjects, k);
+        //Metrological event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(metrologicalEventCounter), capture);
+        arr_push(&cf62.captureObjects, k);
+        //Event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(eventCounter), capture);
+        arr_push(&cf62.captureObjects, k);
+        //Daily diagnostic attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(dailyDiagnostic), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //Current index of converted Volume attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(currentIndexOfConvertedVolume), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //Daily load profile attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        //Last two day entries.
+        capture->dataIndex = 0xE002;
+        k = key_init(BASE(dailyProfileGeneric), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //Billing/Snapshot period counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(billingSnapshotPeriodCounter), capture);
+        arr_push(&cf62.captureObjects, k);
+
+        //Management frame counter - on-line attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(managementFrameCounterOnLine), capture);
+        arr_push(&cf62.captureObjects, k);
+        ret = compactData_updateTemplateDescription(settings, &cf62);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Compact frame 63 as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCF63(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 63, 255 };//0-0:66.0.63.255
+    if ((ret = INIT_OBJECT(cf63, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        cf63.templateId = 63;
+        cf63.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        //Add 11 capture objects.
+        //CF63 attribute #4.
+        gxTarget* capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        gxKey* k = key_init(BASE(cf63), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Unix time attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(unixTime), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //PP network status attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(ppNetworkStatus), capture);
+        arr_push(&cf63.captureObjects, k);
+        //LTE Monitoring attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(lteMonitoring), capture);
+        arr_push(&cf63.captureObjects, k);
+        //Metrological event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(metrologicalEventCounter), capture);
+        arr_push(&cf63.captureObjects, k);
+        //Event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(eventCounter), capture);
+        arr_push(&cf63.captureObjects, k);
+        //Daily diagnostic attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(dailyDiagnostic), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Current index of converted Volume attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(currentIndexOfConvertedVolume), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Daily load profile attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        //Last entry.
+        capture->dataIndex = 0xE001;
+        k = key_init(BASE(dailyProfileGeneric), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Hourle load profile attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        //Last day entry.
+        capture->dataIndex = 0xE201;
+        k = key_init(BASE(hourlyProfileGeneric), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Billing/Snapshot period counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(billingSnapshotPeriodCounter), capture);
+        arr_push(&cf63.captureObjects, k);
+
+        //Management frame counter - on-line attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(managementFrameCounterOnLine), capture);
+        arr_push(&cf63.captureObjects, k);
+        ret = compactData_updateTemplateDescription(settings, &cf63);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Compact frame 64 as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCF64(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 64, 255 };//0-0:66.0.64.255
+    if ((ret = INIT_OBJECT(cf64, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        cf64.templateId = 64;
+        cf64.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        //Add 11 capture objects.
+        //CF64 attribute #4.
+        gxTarget* capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        gxKey* k = key_init(BASE(cf64), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Unix time attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(unixTime), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //PP network status attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(ppNetworkStatus), capture);
+        arr_push(&cf64.captureObjects, k);
+        //LTE Monitoring attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(lteMonitoring), capture);
+        arr_push(&cf64.captureObjects, k);
+        //Metrological event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(metrologicalEventCounter), capture);
+        arr_push(&cf64.captureObjects, k);
+        //Event counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(eventCounter), capture);
+        arr_push(&cf64.captureObjects, k);
+        //Daily diagnostic attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(dailyDiagnostic), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Current index of converted Volume attribute #3.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 3;
+        capture->dataIndex = 0;
+        k = key_init(BASE(currentIndexOfConvertedVolume), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Daily load profile attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        //Last two entries.
+        capture->dataIndex = 0xE002;
+        k = key_init(BASE(dailyProfileGeneric), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Hourle load profile attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        //Last two-day entries.
+        capture->dataIndex = 0xE202;
+        k = key_init(BASE(hourlyProfileGeneric), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Billing/Snapshot period counter attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(billingSnapshotPeriodCounter), capture);
+        arr_push(&cf64.captureObjects, k);
+
+        //Management frame counter on-line attribute #2.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        k = key_init(BASE(managementFrameCounterOnLine), capture);
+        arr_push(&cf64.captureObjects, k);
+        ret = compactData_updateTemplateDescription(settings, &cf64);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Add hourly profile generic (historical data) object 
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addHourlyProfileGeneric(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 7, 0, 99, 99, 2, 255 };
+    if ((ret = INIT_OBJECT(hourlyProfileGeneric, DLMS_OBJECT_TYPE_PROFILE_GENERIC, ln)) == 0)
+    {
+        gxTarget* capture;
+        //Set default values if load the first time.
+        hourlyProfileGeneric.sortMethod = DLMS_SORT_METHOD_FIFO;
+        ///////////////////////////////////////////////////////////////////
+        //Add 4 columns.
+        //Add hourly diagnostic.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&hourlyProfileGeneric.captureObjects, key_init(BASE(hourlyDiagnostic), capture));
+
+        //Add hourly converted consumption.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&hourlyProfileGeneric.captureObjects, key_init(BASE(hourlyConvertedConsumption), capture));
+
+        //Add hourly converted consumption under alarm.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&hourlyProfileGeneric.captureObjects, key_init(BASE(hourlyConvertedConsumptionUnderAlarm), capture));
+
+        //Add unix time object.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&hourlyProfileGeneric.captureObjects, key_init(BASE(unixTime), capture));
+        ///////////////////////////////////////////////////////////////////
+        //Update amount of capture objects.
+        //Set clock to sort object.
+        hourlyProfileGeneric.sortObject = BASE(unixTime);
+        hourlyProfileGeneric.sortObjectAttributeIndex = 2;
+        hourlyProfileGeneric.profileEntries = getProfileGenericBufferMaxRowCount(settings, &hourlyProfileGeneric);
+    }
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Add Daily profile generic (historical data) object 
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addDailyProfileGeneric(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 7, 0, 99, 99, 3, 255 };
+    if ((ret = INIT_OBJECT(dailyProfileGeneric, DLMS_OBJECT_TYPE_PROFILE_GENERIC, ln)) == 0)
+    {
+        gxTarget* capture;
+        //Set default values if load the first time.
+        dailyProfileGeneric.sortMethod = DLMS_SORT_METHOD_FIFO;
+        ///////////////////////////////////////////////////////////////////
+        //Add 6 columns.
+
+        //Add unix time object.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(unixTime), capture));
+
+        //Add Daily diagnostic.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(dailyDiagnostic), capture));
+
+        //Add current index of converted volume.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(currentIndexOfConvertedVolume), capture));
+
+        //Add current index of converted volume under alarm.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(currentIndexOfConvertedVolumeUnderAlarm), capture));
+
+        //Add maximum conventional converted gas flow value.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(maximumConventionalConvertedGasFlow), capture));
+
+        //Add maximum conventional converted gas flow status.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        arr_push(&dailyProfileGeneric.captureObjects, key_init(BASE(maximumConventionalConvertedGasFlow), capture));
+
+        ///////////////////////////////////////////////////////////////////
+        //Update amount of capture objects.
+        //Set clock to sort object.
+        dailyProfileGeneric.sortObject = BASE(unixTime);
+        dailyProfileGeneric.sortObjectAttributeIndex = 2;
+        dailyProfileGeneric.profileEntries = getProfileGenericBufferMaxRowCount(settings, &dailyProfileGeneric);
+    }
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+// Add snapshot period data profile generic (historical data) object 
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSnapshotPeriodData(dlmsSettings* settings)
+{
+    int ret;
+    const unsigned char ln[6] = { 7, 0, 98, 11, 0, 255 };
+    if ((ret = INIT_OBJECT(snapshotPeriodData, DLMS_OBJECT_TYPE_PROFILE_GENERIC, ln)) == 0)
+    {
+        gxTarget* capture;
+        //Set default values if load the first time.
+        snapshotPeriodData.sortMethod = DLMS_SORT_METHOD_FIFO;
+        ///////////////////////////////////////////////////////////////////
+        //Add 13 columns.
+
+        //Add unix time object.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(unixTime), capture));
+
+        //Add current diagnostic.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentDiagnostic), capture));
+
+        //Add snapshot reason code.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(snapshotReasonCode), capture));
+
+        //Add snapshot period counter.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(snapshotPeriodCounter), capture));
+
+        //Add current index of converted volume.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentIndexOfConvertedVolume), capture));
+
+        //Add current index of converted volume F1 rate.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentIndexOfConvertedVolumeF1Rate), capture));
+
+        //Add current index of converted volume F2 rate.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentIndexOfConvertedVolumeF2Rate), capture));
+
+        //Add current index of converted volume F3 rate.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentIndexOfConvertedVolumeF3Rate), capture));
+
+        //Add current index of converted volume under alarm.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(currentIndexOfConvertedVolumeUnderAlarm), capture));
+
+        //Add maximum conventional converted gas flow value.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(maximumConventionalConvertedGasFlow), capture));
+
+        //Add maximum conventional converted gas flow status.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 4;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(maximumConventionalConvertedGasFlow), capture));
+
+        //Add snapshot period diagnostic.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(snapshotPeriodDiagnostic), capture));
+        //Add active UNI/TS tariff plan.
+        capture = (gxTarget*)malloc(sizeof(gxTarget));
+        capture->attributeIndex = 2;
+        capture->dataIndex = 0;
+        arr_push(&snapshotPeriodData.captureObjects, key_init(BASE(activeTariffPlan), capture));
+
+        ///////////////////////////////////////////////////////////////////
+        //Update amount of capture objects.
+        //Set clock to sort object.
+        snapshotPeriodData.sortObject = BASE(unixTime);
+        snapshotPeriodData.sortObjectAttributeIndex = 2;
+        snapshotPeriodData.profileEntries = getProfileGenericBufferMaxRowCount(settings, &snapshotPeriodData);
+    }
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example hourly diagnostic data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addHourlyDiagnostic()
+{
+    const unsigned char ln[6] = { 7,3,96,5,1,255 };
+    INIT_OBJECT(hourlyDiagnostic, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(hourlyDiagnostic.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example PP network status data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addPpNetworkStatus()
+{
+    const unsigned char ln[6] = { 0,1,96,5,4,255 };
+    INIT_OBJECT(ppNetworkStatus, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(ppNetworkStatus.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example metrological event counter data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addMetrologicalEventCounter()
+{
+    const unsigned char ln[6] = { 0,0,96,15,1,255 };
+    INIT_OBJECT(metrologicalEventCounter, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(metrologicalEventCounter.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example event counter data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addEventCounter()
+{
+    const unsigned char ln[6] = { 0,0,96,15,2,255 };
+    INIT_OBJECT(eventCounter, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(eventCounter.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example daily diagnostic data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addDailyDiagnostic()
+{
+    const unsigned char ln[6] = { 7,1,96,5,1,255 };
+    INIT_OBJECT(dailyDiagnostic, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(dailyDiagnostic.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example hourly diagnostic register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addHourlyConvertedConsumption()
+{
+    const unsigned char ln[6] = { 7,0,13,14,0,255 };
+    INIT_OBJECT(hourlyConvertedConsumption, DLMS_OBJECT_TYPE_REGISTER, ln);
+    //10 ^ -2 =  0,01
+    GX_UINT16(hourlyConvertedConsumption.value) = 0;
+    hourlyConvertedConsumption.scaler = -2;
+    hourlyConvertedConsumption.unit = DLMS_UNIT_ACTIVE_ENERGY;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds hourly converted consumption under alarm register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addHourlyConvertedConsumptionUnderAlarm()
+{
+    const unsigned char ln[6] = { 7,0,12,14,0,255 };
+    INIT_OBJECT(hourlyConvertedConsumptionUnderAlarm, DLMS_OBJECT_TYPE_REGISTER, ln);
+    //10 ^ -2 =  0,01
+    GX_UINT16(hourlyConvertedConsumptionUnderAlarm.value) = 1;
+    hourlyConvertedConsumptionUnderAlarm.scaler = -2;
+    hourlyConvertedConsumptionUnderAlarm.unit = DLMS_UNIT_ACTIVE_ENERGY;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds current index of converted volume register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCurrentIndexOfConvertedVolume()
+{
+    const unsigned char ln[6] = { 7, 0, 13, 2, 0, 255 };
+    INIT_OBJECT(currentIndexOfConvertedVolume, DLMS_OBJECT_TYPE_REGISTER, ln);
+    GX_UINT16(currentIndexOfConvertedVolume.value) = 0;
+    currentIndexOfConvertedVolume.scaler = 0;
+    currentIndexOfConvertedVolume.unit = DLMS_UNIT_NONE;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds current index of converted volume F1 rate register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addcurrentIndexOfConvertedVolumeF1Rate()
+{
+    const unsigned char ln[6] = { 7, 0, 13, 2, 1, 255 };
+    INIT_OBJECT(currentIndexOfConvertedVolumeF1Rate, DLMS_OBJECT_TYPE_REGISTER, ln);
+    GX_UINT16(currentIndexOfConvertedVolumeF1Rate.value) = 0;
+    currentIndexOfConvertedVolumeF1Rate.scaler = 0;
+    currentIndexOfConvertedVolumeF1Rate.unit = DLMS_UNIT_NONE;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds current index of converted volume F1 rate register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addcurrentIndexOfConvertedVolumeF2Rate()
+{
+    const unsigned char ln[6] = { 7, 0, 13, 2, 2, 255 };
+    INIT_OBJECT(currentIndexOfConvertedVolumeF2Rate, DLMS_OBJECT_TYPE_REGISTER, ln);
+    GX_UINT16(currentIndexOfConvertedVolumeF2Rate.value) = 0;
+    currentIndexOfConvertedVolumeF2Rate.scaler = 0;
+    currentIndexOfConvertedVolumeF2Rate.unit = DLMS_UNIT_NONE;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds current index of converted volume F1 rate register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addcurrentIndexOfConvertedVolumeF3Rate()
+{
+    const unsigned char ln[6] = { 7, 0, 13, 2, 3, 255 };
+    INIT_OBJECT(currentIndexOfConvertedVolumeF3Rate, DLMS_OBJECT_TYPE_REGISTER, ln);
+    GX_UINT16(currentIndexOfConvertedVolumeF3Rate.value) = 0;
+    currentIndexOfConvertedVolumeF3Rate.scaler = 0;
+    currentIndexOfConvertedVolumeF3Rate.unit = DLMS_UNIT_NONE;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+// This method adds snapshot period diagnostic data object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSnapshotPeriodDiagnostic()
+{
+    const unsigned char ln[6] = { 7, 2, 96, 5, 1, 255 };
+    INIT_OBJECT(snapshotPeriodDiagnostic, DLMS_OBJECT_TYPE_DATA, ln);
+    GX_UINT16(snapshotPeriodDiagnostic.value) = 0;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+// This method adds current index of converted volume under alarm register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCurrentIndexOfConvertedVolumeUnderAlarm()
+{
+    const unsigned char ln[6] = { 7,0,12,2,0,255 };
+    INIT_OBJECT(currentIndexOfConvertedVolumeUnderAlarm, DLMS_OBJECT_TYPE_REGISTER, ln);
+    GX_UINT16(currentIndexOfConvertedVolumeUnderAlarm.value) = 0;
+    currentIndexOfConvertedVolumeUnderAlarm.scaler = 0;
+    currentIndexOfConvertedVolumeUnderAlarm.unit = DLMS_UNIT_NONE;
+    return 0;
+}
+
+
+///////////////////////////////////////////////////////////////////////
+//This method adds  maximum conventional converted gas flow value extended register object
+// as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addMaximumConventionalConvertedGasFlow()
+{
+    const unsigned char ln[6] = { 7,0,43,45,0,255 };
+    INIT_OBJECT(maximumConventionalConvertedGasFlow, DLMS_OBJECT_TYPE_EXTENDED_REGISTER, ln);
+    //Set default value.
+    GX_UINT16(maximumConventionalConvertedGasFlow.value) = 10;
+    maximumConventionalConvertedGasFlow.scaler = 0;
+    maximumConventionalConvertedGasFlow.unit = DLMS_UNIT_NONE;
+    //Set default status.
+    GX_UINT16(maximumConventionalConvertedGasFlow.status) = 0;
+    return 0;
+}
+
+#endif //DLMS_ITALIAN_STANDARD
+
+///////////////////////////////////////////////////////////////////////
+//Add G3 PLC 6LoWPAN object.
+///////////////////////////////////////////////////////////////////////
+int addG3Plc6LoWPAN()
+{
+    int ret;
+    //The maximum Context field length is 16 bytes (128 bits).
+    static unsigned char PREFIX_TABLE[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
+    const unsigned char ln[6] = { 0,0,29,2,0,255 };
+    if ((ret = INIT_OBJECT(g3Plc6LoWPAN, DLMS_OBJECT_TYPE_G3_PLC_6LO_WPAN, ln)) == 0)
+    {
+        g3Plc6LoWPAN.maxHops = 1;
+        g3Plc6LoWPAN.weakLqiValue = 2;
+        g3Plc6LoWPAN.securityLevel = 3;
+        bb_set(&g3Plc6LoWPAN.prefixTable, PREFIX_TABLE, 16);
+        gxRoutingConfiguration* rg = (gxRoutingConfiguration*)malloc(sizeof(gxRoutingConfiguration));
+        rg->netTraversalTime = 1;
+        rg->routingTableEntryTtl = 2;
+        rg->kr = 3;
+        rg->km = 4;
+        rg->kc = 5;
+        rg->kq = 6;
+        rg->kh = 7;
+        rg->krt = 8;
+        rg->rReqRetries = 9;
+        rg->rReqReqWait = 10;
+        rg->blacklistTableEntryTtl = 11;
+        rg->unicastRreqGenEnable = 1;
+        rg->rlcEnabled = 1;
+        rg->addRevLinkCost = 14;
+        arr_push(&g3Plc6LoWPAN.routingConfiguration, rg);
+
+        gxRoutingTable* rt = (gxRoutingTable*)malloc(sizeof(gxRoutingTable));
+        rt->destinationAddress = 1;
+        rt->nextHopAddress = 2;
+        rt->routeCost = 3;
+        rt->hopCount = 4;
+        rt->weakLinkCount = 5;
+        rt->validTime = 6;
+        arr_push(&g3Plc6LoWPAN.routingTable, rt);
+
+        gxContextInformationTable* cit = (gxContextInformationTable*)malloc(sizeof(gxContextInformationTable));
+        cit->cid = 0xF;
+        cit->context[0] = 0xFF;
+        cit->context[1] = 0;
+        cit->context[2] = 0xFF;
+        cit->context[3] = 0;
+        cit->contextLength = 4;
+        cit->compression = 1;
+        cit->validLifetime = 4;
+        arr_push(&g3Plc6LoWPAN.contextInformationTable, cit);
+
+        gxBlacklistTable* blt = (gxBlacklistTable*)malloc(sizeof(gxBlacklistTable));
+        blt->neighbourAddress = 1;
+        blt->validTime = 2;
+        arr_push(&g3Plc6LoWPAN.blacklistTable, blt);
+        blt = (gxBlacklistTable*)malloc(sizeof(gxBlacklistTable));
+        blt->neighbourAddress = 3;
+        blt->validTime = 4;
+        arr_push(&g3Plc6LoWPAN.blacklistTable, blt);
+
+        dlmsVARIANT* it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&g3Plc6LoWPAN.groupTable, it);
+
+        g3Plc6LoWPAN.broadcastLogTableEntryTtl = 6;
+        g3Plc6LoWPAN.maxJoinWaitTime = 12;
+        g3Plc6LoWPAN.pathDiscoveryTime = 13;
+        g3Plc6LoWPAN.activeKeyIndex = 14;
+        g3Plc6LoWPAN.metricType = 15;
+        g3Plc6LoWPAN.coordShortAddress = 16;
+        g3Plc6LoWPAN.disableDefaultRouting = 1;
+        g3Plc6LoWPAN.deviceType = DLMS_PAN_DEVICE_TYPE_NOT_DEFINED;
+        g3Plc6LoWPAN.defaultCoordRouteEnabled = 1;
+
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 1;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 2;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 3;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+        it = (dlmsVARIANT*)malloc(sizeof(dlmsVARIANT));
+        GX_UINT16(*it) = 4;
+        va_push(&g3Plc6LoWPAN.destinationAddress, it);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add array manager object.
+///////////////////////////////////////////////////////////////////////
+int addArrayManager()
+{
+    int ret;
+    const unsigned char ln[6] = { 0,0,18,0,0,255 };
+    if ((ret = INIT_OBJECT(arrayManager, DLMS_OBJECT_TYPE_ARRAY_MANAGER, ln)) == 0)
+    {
+        gxArrayManagerItem* it = (gxArrayManagerItem*)malloc(sizeof(gxArrayManagerItem));
+        it->id = 1;
+        it->element.target = BASE(loadProfile);
+        it->element.attributeIndex = 2;
+        arr_push(&arrayManager.elements, it);
+        it = (gxArrayManagerItem*)malloc(sizeof(gxArrayManagerItem));
+        it->id = 2;
+        it->element.target = BASE(loadProfile);
+        it->element.attributeIndex = 3;
+        arr_push(&arrayManager.elements, it);
+    }
+    return ret;
+}
+
 ///////////////////////////////////////////////////////////////////////
 //Add push setup object. (On Connectivity)
 ///////////////////////////////////////////////////////////////////////
@@ -1871,6 +3358,50 @@
     return 0;
 }
 
+///////////////////////////////////////////////////////////////////////
+//Add account object.
+///////////////////////////////////////////////////////////////////////
+int addAccount()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 19, 0, 0, 255 };
+    if ((ret = INIT_OBJECT(account, DLMS_OBJECT_TYPE_ACCOUNT, ln)) == 0)
+    {
+        account.paymentMode = DLMS_ACCOUNT_PAYMENT_MODE_CREDIT;
+        //Set default values.
+        account.currentCreditStatus = DLMS_ACCOUNT_CREDIT_STATUS_OUT_OF_CREDIT;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add LTE monitoring object.
+///////////////////////////////////////////////////////////////////////
+int addLteMonitoring()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 25, 11, 0, 255 };
+    if ((ret = INIT_OBJECT(lteMonitoring, DLMS_OBJECT_TYPE_LTE_MONITORING, ln)) == 0)
+    {
+        //Set default values.
+        lteMonitoring.networkParameters.t3402 = 0;
+        lteMonitoring.networkParameters.t3412 = 0;
+        lteMonitoring.networkParameters.t3412ext2 = 0;
+        lteMonitoring.networkParameters.t3324 = 0;
+        lteMonitoring.networkParameters.teDRX = 0;
+        lteMonitoring.networkParameters.tPTW = 0;
+        lteMonitoring.networkParameters.qRxlevMin = 0;
+        lteMonitoring.networkParameters.qRxlevMinCE = 0;
+        lteMonitoring.networkParameters.qRxLevMinCE1 = 0;
+        lteMonitoring.qualityOfService.signalQuality = 0;
+        lteMonitoring.qualityOfService.signalLevel = 0;
+        lteMonitoring.qualityOfService.signalToNoiseRatio = 0;
+        lteMonitoring.qualityOfService.coverageEnhancement = 0;
+    }
+    return ret;
+}
+
+
 /////////////////////////////////////////////////////////////////////////////
 // Load security settings from the EEPROM.
 /////////////////////////////////////////////////////////////////////////////
@@ -2018,10 +3549,16 @@
         (ret = addAssociationHighGMac()) != 0 ||
         (ret = addSecuritySetupHigh()) != 0 ||
         (ret = addSecuritySetupHighGMac()) != 0 ||
+        (ret = addAssociationHighGMacPreEstablished()) != 0 ||
+        (ret = addAssociationHighECDSA()) != 0 ||
+        (ret = addSecuritySetupPreEstablishedHighGMac()) != 0 ||
+        (ret = addSecuritySetupHighEcdsa()) != 0 ||
         (ret = addMbusDiagnostic()) != 0 ||
         (ret = addMbusPortSetup()) != 0 ||
         (ret = addG3PlcMacLayerCounters()) != 0 ||
         (ret = addG3PlcMacSetup()) != 0 ||
+        (ret = addG3Plc6LoWPAN()) != 0 ||
+        (ret = addArrayManager()) != 0 ||
         (ret = addPushSetup()) != 0 ||
         (ret = addscriptTableGlobalMeterReset()) != 0 ||
         (ret = addscriptTableDisconnectControl()) != 0 ||
@@ -2050,6 +3587,41 @@
         (ret = addImageTransfer()) != 0 ||
         (ret = addCompactData(&settings->base, &settings->base.objects)) != 0 ||
         (ret = addLimiter()) != 0 ||
+        (ret = addLteMonitoring()) != 0 ||
+        (ret = addAccount()) != 0 ||        
+#ifdef DLMS_ITALIAN_STANDARD
+        (ret = addCurrentDiagnostic()) != 0 ||
+        (ret = addSnapshotReasonCode()) != 0 ||
+        (ret = addSnapshotPeriodCounter()) != 0 ||        
+        (ret = addActiveTariffPlan()) != 0 ||
+        (ret = addPassiveTariffPlan()) != 0 ||
+        (ret = addSpareObject()) != 0 ||
+        (ret = addHourlyDiagnostic()) != 0 ||
+        (ret = addHourlyConvertedConsumption()) != 0 ||
+        (ret = addHourlyConvertedConsumptionUnderAlarm()) != 0 ||
+        (ret = addCurrentIndexOfConvertedVolume()) != 0 ||
+        (ret = addcurrentIndexOfConvertedVolumeF1Rate()) != 0 ||
+        (ret = addcurrentIndexOfConvertedVolumeF2Rate()) != 0 ||
+        (ret = addcurrentIndexOfConvertedVolumeF3Rate()) != 0 ||
+        (ret = addSnapshotPeriodDiagnostic()) != 0 ||
+        (ret = addCurrentIndexOfConvertedVolumeUnderAlarm()) != 0 ||
+        (ret = addMaximumConventionalConvertedGasFlow()) != 0 ||
+        (ret = addPpNetworkStatus()) != 0 ||
+        (ret = addMetrologicalEventCounter()) != 0 ||
+        (ret = addEventCounter()) != 0 ||
+        (ret = addDailyDiagnostic()) != 0 ||
+        (ret = addManagementFrameCounterOnLine()) != 0 ||
+        (ret = addBillingSnapshotPeriodCounter()) != 0 ||
+        //Profile generic objects must add after capture objects are initialized.
+        (ret = addHourlyProfileGeneric(&settings->base)) != 0 ||
+        (ret = addDailyProfileGeneric(&settings->base)) != 0 ||
+        (ret = addSnapshotPeriodData(&settings->base)) != 0 ||
+        //Compact data object must add after capture objects are initialized.
+        (ret = addCF6Plan(&settings->base)) != 0 ||
+        (ret = addCF62(&settings->base)) != 0 ||
+        (ret = addCF63(&settings->base)) != 0 ||
+        (ret = addCF64(&settings->base)) != 0 ||
+#endif //DLMS_ITALIAN_STANDARD
         (ret = oa_verify(&settings->base.objects)) != 0 ||
         (ret = svr_initialize(settings)) != 0)
     {
@@ -2276,8 +3848,13 @@
         FILE* f = fopen(fileName, "rb");
 #endif
         uint16_t rowSize = 0;
-        uint8_t columnSizes[10];
-        DLMS_DATA_TYPE dataTypes[10];
+        uint8_t columnSizes[20];
+        DLMS_DATA_TYPE dataTypes[20];
+        if (sizeof(dataTypes) / sizeof(dataTypes[0]) < pg->captureObjects.size ||
+            sizeof(columnSizes) / sizeof(columnSizes[0]) < pg->captureObjects.size)
+        {
+            return DLMS_ERROR_CODE_OUTOFMEMORY;
+        }
         if (f != NULL)
         {
             getProfileGenericBufferColumnSizes(settings, pg, dataTypes, columnSizes, &rowSize);
@@ -2299,24 +3876,18 @@
                     }
                     else
                     {
-                        if (last <= t)
+                        if (t <= l)
                         {
-                            e->transactionEndIndex = pos + 1;
-                        }
-                        else
-                        {
-                            //Index is one based, not zero.
-                            if (e->transactionEndIndex == 0)
-                            {
-                                ++e->transactionEndIndex;
-                            }
-                            e->transactionEndIndex += pg->entriesInUse - 1;
-                            e->transactionStartIndex = pos;
-                            break;
+                            ++e->transactionEndIndex;
                         }
                     }
                     last = t;
                 }
+                else if (t > l)
+                {
+                    //End value is found.
+                    break;
+                }
             }
             fclose(f);
         }
@@ -2331,11 +3902,18 @@
     gxValueEventArg* e)
 {
     unsigned char first = e->transactionEndIndex == 0;
-    int ret = 0;
+    int ret;
     gxArray captureObjects;
     arr_init(&captureObjects);
     char fileName[30];
-    getProfileGenericFileName(pg, fileName);
+    ret = getProfileGenericFileName(pg, fileName);
+    if (e->action && e->dataIndex != 0)
+    {
+        //Data index tells rows count when compact data ask it.
+        e->selector = 1;
+        e->transactionEndIndex = pg->entriesInUse;
+        e->transactionStartIndex = e->transactionEndIndex - (e->dataIndex & 0xFF) + 1;        
+    }
     if (ret == DLMS_ERROR_CODE_OK)
     {
         e->byteArray = 1;
@@ -2351,11 +3929,14 @@
             }
             else if (e->selector == 1)
             {
-                //Read by entry. Find start and end index from the ring buffer.
-                if ((ret = getProfileGenericDataByRangeFromRingBuffer(settings, fileName, e)) != 0 ||
-                    (ret = cosem_getColumns(&pg->captureObjects, e->selector, &e->parameters, &captureObjects)) != 0)
+                if (!e->action)
                 {
-                    e->transactionStartIndex = e->transactionEndIndex = 0;
+                    //Read by entry. Find start and end index from the ring buffer.
+                    if ((ret = getProfileGenericDataByRangeFromRingBuffer(settings, fileName, e)) != 0 ||
+                        (ret = cosem_getColumns(&pg->captureObjects, e->selector, &e->parameters, &captureObjects)) != 0)
+                    {
+                        e->transactionStartIndex = e->transactionEndIndex = 0;
+                    }
                 }
             }
             else if (e->selector == 2)
@@ -2390,7 +3971,8 @@
         }
         bb_clear(e->value.byteArr);
         arr_clear(&captureObjects);
-        if (ret == 0 && first)
+        //Objects are saved to the buffer when action is used.
+        if (ret == 0 && first && !e->action)
         {
             if (e->transactionEndIndex == 0)
             {
@@ -2406,24 +3988,28 @@
             //Loop items.
             uint32_t pos;
             gxtime tm;
-            uint16_t pduSize;
             FILE* f = NULL;
 #if _MSC_VER > 1400
             if (fopen_s(&f, fileName, "rb") != 0)
             {
                 printf("Failed to open %s.\r\n", fileName);
-                return -1;
+                return DLMS_ERROR_CODE_INVALID_PARAMETER;
             }
 #else
             if ((f = fopen(fileName, "rb")) != 0)
             {
                 printf("Failed to open %s.\r\n", fileName);
-                return -1;
+                return DLMS_ERROR_CODE_INVALID_PARAMETER;
             }
 #endif
             uint16_t dataSize = 0;
-            uint8_t columnSizes[10];
-            DLMS_DATA_TYPE dataTypes[10];
+            uint8_t columnSizes[20];
+            DLMS_DATA_TYPE dataTypes[20];
+            if (sizeof(dataTypes) / sizeof(dataTypes[0]) < pg->captureObjects.size ||
+                sizeof(columnSizes) / sizeof(columnSizes[0]) < pg->captureObjects.size)
+            {
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
             if (f != NULL)
             {
                 ret = getProfileGenericBufferColumnSizes(settings, pg, dataTypes, columnSizes, &dataSize);
@@ -2437,15 +4023,46 @@
                     printf("Failed to seek %s.\r\n", fileName);
                     return -1;
                 }
+                //Objects are saved to the buffer when action is used.
+                if (e->action)
+                {
+                    //Clear buffer.
+                    arr_clear(&pg->buffer);
+                }
+                uint16_t pduSize = 0;
                 for (pos = e->transactionStartIndex - 1; pos != e->transactionEndIndex; ++pos)
                 {
-                    pduSize = (uint16_t)e->value.byteArr->size;
-                    if ((ret = cosem_setStructure(e->value.byteArr, pg->captureObjects.size)) != 0)
+                    //Objects are saved to the buffer when action is used.
+                    if (!e->action)
                     {
-                        break;
+                        if (dlms_isPduFull(settings, e->value.byteArr, NULL))
+                        {
+                            //Return last full row.
+                            --e->transactionStartIndex;
+                            e->value.byteArr->size = pduSize;
+                            ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                            break;
+                        }
+                        pduSize = e->value.byteArr->size;
+                        if ((ret = cosem_setStructure(e->value.byteArr, pg->captureObjects.size)) != 0)
+                        {
+                            break;
+                        }
                     }
                     uint8_t colIndex;
                     gxKey* it;
+                    variantArray* va = NULL;
+                    dlmsVARIANT* value;
+                    //Objects are saved to the buffer when action is used.
+                    if (e->action)
+                    {
+                        va = (variantArray*)malloc(sizeof(variantArray));
+                        va_init(va);
+                        arr_push(&pg->buffer, va);
+                        //Allocate space for 20 bytes.
+                        //The example expects that the max value size is 20 bytes.
+                        bb_capacity(e->value.byteArr, 20);
+                    }
                     //Loop capture columns and get values.
                     for (colIndex = 0; colIndex != pg->captureObjects.size; ++colIndex)
                     {
@@ -2463,37 +4080,85 @@
                                 {
                                     clock_utcToMeterTime(&clock1, &tm);
                                 }
-                                if ((ret = cosem_setDateTimeAsOctetString(e->value.byteArr, &tm)) != 0)
+                                //Objects are saved to the buffer when action is used.
+                                if (va != NULL)
                                 {
-                                    //Error is handled later.
+                                    value = malloc(sizeof(dlmsVARIANT));
+                                    var_init(value);
+                                    if (((gxObject*)it->key)->objectType == DLMS_OBJECT_TYPE_CLOCK)
+                                    {
+                                        //Add time from clock object.
+                                        gxtime tmp;
+                                        time_fromUnixTime(&tmp, &tm);
+                                        var_setDateTime(value, &tmp);
+                                    }
+                                    else
+                                    {
+                                        //Add time from data object.
+                                        var_setUInt32(value, time);
+                                    }
+                                    va_push(va, value);
+                                }
+                                else
+                                {
+                                    if (((gxObject*)it->key)->objectType == DLMS_OBJECT_TYPE_CLOCK)
+                                    {
+                                        ret = cosem_setDateTimeAsOctetString(e->value.byteArr, &tm);
+                                        //Error is handled later.
+                                    }
+                                    else
+                                    {
+                                        ret = cosem_setUInt32(e->value.byteArr, time_toUnixTime(&tm));
+                                        //Error is handled later.
+                                    }
                                 }
                             }
                             else
                             {
-                                //Append data type.
-                                e->value.byteArr->data[e->value.byteArr->size] = dataTypes[colIndex];
-                                ++e->value.byteArr->size;
+                                //Objects are saved to the buffer when action is used.
+                                if (!e->action)
+                                {
+                                    //Append data type.
+                                    if ((ret = bb_setUInt8(e->value.byteArr, dataTypes[colIndex])) != 0)
+                                    {
+                                        ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                                        break;
+                                    }
+                                    if (bb_getCapacity(e->value.byteArr) < bb_size(e->value.byteArr) + columnSizes[colIndex])
+                                    {
+                                        ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                                        break;
+                                    }
+                                }
                                 //Read data.
                                 fread(&e->value.byteArr->data[e->value.byteArr->size], columnSizes[colIndex], 1, f);
                                 e->value.byteArr->size += columnSizes[colIndex];
+                                if (e->action)
+                                {
+                                    gxDataInfo di;
+                                    di_init(&di);
+                                    di.type = dataTypes[colIndex];
+                                    value = malloc(sizeof(dlmsVARIANT));
+                                    var_init(value);
+                                    va_push(va, value);
+                                    ret = dlms_getData(e->value.byteArr, &di, value);
+                                    bb_empty(e->value.byteArr);
+                                    if (ret != 0)
+                                    {
+                                        break;
+                                    }
+                                }
                             }
                         }
                         if (ret != 0)
                         {
-                            //Don't set error if PDU is full.
-                            if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
-                            {
-                                --e->transactionStartIndex;
-                                e->value.byteArr->size = pduSize;
-                                ret = 0;
-                            }
-                            else
-                            {
-                                break;
-                            }
                             break;
                         }
                     }
+                    if (ret != 0)
+                    {
+                        break;
+                    }
                     ++e->transactionStartIndex;
                 }
                 fclose(f);
@@ -2501,10 +4166,96 @@
             else
             {
                 printf("Failed to open %s.\r\n", fileName);
-                return -1;
+                return DLMS_ERROR_CODE_INVALID_PARAMETER;
             }
         }
     }
+    if (ret == DLMS_ERROR_CODE_OUTOFMEMORY)
+    {
+        //Don't set error if PDU is full.
+        ret = 0;
+    }
+    return ret;
+}
+
+int updateCompactData(dlmsSettings* settings, gxCompactData* cd)
+{
+    int ret;
+    uint16_t pos;
+    gxValueEventCollection args2;
+    gxByteBuffer bb;
+    bb_init(&bb);
+    //Allocate space for 200 bytes.
+    bb_capacity(&bb, 200);
+
+    gxValueEventArg* e2 = malloc(sizeof(gxValueEventArg));
+    ve_init(e2);
+    e2->action = 1;
+    vec_init(&args2);
+    ret = vec_push(&args2, e2);
+    gxKey* kv;
+    //Loop capture columns and get values.
+    for (pos = 0; pos != cd->captureObjects.size; ++pos)
+    {
+        if ((ret = arr_getByIndex(&cd->captureObjects, (uint16_t)pos, (void**)&kv)) != 0)
+        {
+            break;
+        }
+        bb_empty(&bb);
+        e2->value.byteArr = &bb;
+        e2->value.vt = DLMS_DATA_TYPE_OCTET_STRING;
+        e2->target = (gxObject*)kv->key;
+        e2->index = ((gxTarget*)kv->value)->attributeIndex;
+        e2->dataIndex = ((gxTarget*)kv->value)->dataIndex;
+        //Read and update values. This example uses preRead.
+        svr_preRead(settings, &args2);
+        if (e2->error != 0)
+        {
+            ret = e2->error;
+            break;
+        }
+    }
+    //Update  template description.
+    ret = compactData_updateTemplateDescription(settings, cd);
+    //Byte buffer is clear separetly.
+    e2->value.vt = DLMS_DATA_TYPE_NONE;
+    vec_clear(&args2);
+    bb_clear(&bb);
+    return ret;
+}
+
+//Read profile generic captured values.
+int updateProfileGenericValues(dlmsSettings* settings, gxProfileGeneric* pg)
+{
+    int ret;
+    uint16_t pos;
+    gxValueEventCollection args2;
+    gxValueEventArg* e2 = malloc(sizeof(gxValueEventArg));
+    ve_init(e2);
+    e2->action = 1;
+    vec_init(&args2);
+    ret = vec_push(&args2, e2);
+    gxKey* kv;
+    //Loop capture columns and get values.
+    for (pos = 0; pos != pg->captureObjects.size; ++pos)
+    {
+        if ((ret = arr_getByIndex(&pg->captureObjects, (uint16_t)pos, (void**)&kv)) != 0)
+        {
+            break;
+        }
+        ve_clear(e2);
+        e2->target = (gxObject*)kv->key;
+        e2->index = ((gxTarget*)kv->value)->attributeIndex;
+        e2->dataIndex = ((gxTarget*)kv->value)->dataIndex;
+        //Read and update values. This example uses preRead.
+        svr_preRead(settings, &args2);
+        if (e2->error != 0)
+        {
+            ret = e2->error;
+            break;
+        }
+    }
+    vec_clear(&args2);
     return ret;
 }
 
@@ -2544,6 +4295,11 @@
         {
             readActivePowerValue();
         }
+        else if (e->target->objectType == DLMS_OBJECT_TYPE_REGISTER && e->index == 2)
+        {
+            //Update value by one every time when user reads register.
+            GX_ADD(((gxRegister*)e->target)->value, 1);
+        }
         //Get time if user want to read date and time.
         if (e->target == BASE(clock1) && e->index == 2)
         {
@@ -2562,8 +4318,19 @@
         {
             e->error = (DLMS_ERROR_CODE)readProfileGeneric(settings, (gxProfileGeneric*)e->target, e);
         }
+        else if (e->target->objectType == DLMS_OBJECT_TYPE_COMPACT_DATA && e->index == 2 &&
+            ((gxCompactData*)e->target)->captureMethod == DLMS_CAPTURE_METHOD_IMPLICIT)
+        {
+            //Compact data is updated in read.
+            ret = updateCompactData(settings, (gxCompactData*)e->target);
+        }
+        else if (e->target->objectType == DLMS_OBJECT_TYPE_COMPACT_DATA && e->index == 5)
+        {
+            //Update template description.
+            ret = compactData_updateTemplateDescription(settings, (gxCompactData*)e->target);
+        }
         //Update Unix time.
-        if (e->target == BASE(unixTime) && e->index == 2)
+        else if (e->target == BASE(unixTime) && e->index == 2)
         {
             gxtime dt;
             time_now(&dt, 0);
@@ -2696,9 +4463,12 @@
         {
             readActivePowerValue();
         }
-        captureProfileGeneric(settings, ((gxProfileGeneric*)it->target));
+        it->error = captureProfileGeneric(settings, ((gxProfileGeneric*)it->target));
+    }
+    if (it->error == 0)
+    {
+        it->error = saveSettings();
     }
-    saveSettings();
 }
 
 
@@ -2748,7 +4518,12 @@
         GXTRACE_LN(("svr_preAction: "), e->target->objectType, e->target->logicalName);
         if (e->target->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC)
         {
-            handleProfileGenericActions(settings, e);
+            //Read captured profile generic values.
+            e->error = updateProfileGenericValues(settings, (gxProfileGeneric*)e->target);
+            if (e->error == 0)
+            {
+                handleProfileGenericActions(settings, e);
+            }
             e->handled = 1;
         }
         else if (e->target == BASE(activePowerL1))
@@ -2793,7 +4568,7 @@
             }
             updateState(settings, GURUX_EVENT_CODES_GLOBAL_METER_RESET);
             e->handled = 1;
-        }
+    }
         else if (e->target == BASE(disconnectControl))
         {
             updateState(settings, GURUX_EVENT_CODES_OUTPUT_RELAY_STATE);
@@ -2819,11 +4594,18 @@
             testMode = 0;
             saveSettings();
         }
-        if (e->target == BASE(imageTransfer))
+        else if (e->target->objectType == DLMS_OBJECT_TYPE_COMPACT_DATA && e->index == 2 &&
+            ((gxCompactData*)e->target)->captureMethod == DLMS_CAPTURE_METHOD_INVOKE)
+        {
+            //Compact data is updated with invoke.
+            ret = updateCompactData(settings, (gxCompactData*)e->target);
+        }
+        else if (e->target == BASE(imageTransfer))
         {
             e->handled = 1;
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
             FILE* f;
+            dlmsVARIANT* identification, * pSize;
             gxImageTransfer* i = (gxImageTransfer*)e->target;
             const char* imageFile = "image.raw";
             //Image name and size to transfer
@@ -2832,21 +4614,23 @@
                 i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_NOT_INITIATED;
                 //There is only one image.
                 gxImageActivateInfo* info;
-                imageTransfer.imageActivateInfo.size = 1;
-                if ((e->error = arr_getByIndex(&imageTransfer.imageActivateInfo, 0, (void**)&info)) != 0)
+                if (e->parameters.vt != DLMS_DATA_TYPE_STRUCTURE ||
+                    (e->error = arr_getByIndex(&imageTransfer.imageActivateInfo, 0, (void**)&info)) != 0)
                 {
                     e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
                     return;
                 }
-                uint16_t size;
-                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) != 0 ||
-                    (ret = cosem_getOctetString2(e->parameters.byteArr, info->identification.data, sizeof(info->identification.data), &size)) != 0 ||
-                    (ret = cosem_getUInt32(e->parameters.byteArr, &info->size)) != 0)
+                if ((ret = va_getByIndex(e->parameters.Arr, 0, &identification)) != 0 ||
+                    identification->vt != DLMS_DATA_TYPE_OCTET_STRING ||
+                    (ret = va_getByIndex(e->parameters.Arr, 1, &pSize)) != 0 ||
+                    pSize->vt != DLMS_DATA_TYPE_UINT32)
                 {
                     e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
                     return;
                 }
-                info->identification.size = size;
+                info->size = var_toInteger(pSize);
+                bb_clear(&info->identification);
+                bb_set(&info->identification, identification->byteArr->data, bb_size(identification->byteArr));
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
                 printf("Updating image %s Size: %d\r\n", imageFile, info->size);
 #endif
@@ -2857,18 +4641,19 @@
             //Transfers one block of the Image to the server
             else if (e->index == 2)
             {
-                uint32_t index;
-                uint16_t blockSize;
-                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) != 0 ||
-                    (ret = cosem_getUInt32(e->parameters.byteArr, &index)) != 0 ||
-                    (ret = hlp_getObjectCount2(e->parameters.byteArr, &blockSize)) != 0)
+                dlmsVARIANT* index, * block;
+                if (e->parameters.vt != DLMS_DATA_TYPE_STRUCTURE ||
+                    (ret = va_getByIndex(e->parameters.Arr, 0, &index)) != 0 ||
+                    index->vt != DLMS_DATA_TYPE_UINT32 ||
+                    (ret = va_getByIndex(e->parameters.Arr, 1, &block)) != 0 ||
+                    block->vt != DLMS_DATA_TYPE_OCTET_STRING)
                 {
                     e->error = DLMS_ERROR_CODE_HARDWARE_FAULT;
                     return;
                 }
-                if ((ret = ba_setByIndex(&i->imageTransferredBlocksStatus, (uint16_t)index, 1)) == 0)
+                if ((ret = ba_setByIndex(&i->imageTransferredBlocksStatus, (uint16_t)var_toInteger(index), 1)) == 0)
                 {
-                    i->imageFirstNotTransferredBlockNumber = index + 1;
+                    i->imageFirstNotTransferredBlockNumber = (uint32_t)(var_toInteger(index) + 1);
                 }
                 f = fopen(imageFile, "r+b");
                 if (!f)
@@ -2879,13 +4664,12 @@
                     e->error = DLMS_ERROR_CODE_HARDWARE_FAULT;
                     return;
                 }
-                int ret = (int)fwrite(e->parameters.byteArr->data + e->parameters.byteArr->position, 1, (int)blockSize, f);
+                int ret = (int)fwrite(block->byteArr->data, 1, (int)bb_size(block->byteArr), f);
                 fclose(f);
-                if (ret != (int)blockSize)
+                if (ret != (int)bb_size(block->byteArr))
                 {
                     e->error = DLMS_ERROR_CODE_UNMATCH_TYPE;
                 }
-                bb_clear(e->parameters.byteArr);
                 imageActionStartTime = time(NULL);
                 return;
             }
@@ -2905,7 +4689,13 @@
                 fseek(f, 0L, SEEK_END);
                 long size = ftell(f);
                 fclose(f);
-                if (size != IMAGE_ACTIVATE_INFO[0].size)
+                gxImageActivateInfo* info;
+                if ((e->error = arr_getByIndex(&imageTransfer.imageActivateInfo, 0, (void**)&info)) != 0)
+                {
+                    e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    return;
+                }
+                if (size != info->size)
                 {
                     i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_FAILED;
                     e->error = DLMS_ERROR_CODE_OTHER_REASON;
@@ -2953,7 +4743,7 @@
             }
 #endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
         }
-    }
+}
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -3075,7 +4865,7 @@
             }
         }
         //Check is client changing the settings with action.
-        else if (svr_isChangedWithAction(e->target->objectType, e->index))
+        if (svr_isChangedWithAction(e->target->objectType, e->index))
         {
             //Save settings to EEPROM.
             if (e->error == 0)
@@ -3131,7 +4921,7 @@
             return err;
         };
         add.sin_addr = *(struct in_addr*)(void*)Hostent->h_addr_list[0];
-    };
+};
 
     //Connect to the meter.
     ret = connect(*s, (struct sockaddr*)&add, sizeof(struct sockaddr_in));
@@ -3173,24 +4963,24 @@
                     mes_clear(&messages);
                     break;
                 }
+                }
             }
-        }
 #if defined(_WIN32) || defined(_WIN64)//Windows includes
         closesocket(s);
 #else
         close(s);
 #endif
-    }
+        }
     mes_clear(&messages);
     free(host);
     return 0;
-}
+    }
 #endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 
 unsigned char svr_isTarget(
     dlmsSettings* settings,
-    unsigned long serverAddress,
-    unsigned long clientAddress)
+    uint32_t serverAddress,
+    uint32_t clientAddress)
 {
     GXTRACE(("svr_isTarget."), NULL);
     objectArray objects;
@@ -3227,24 +5017,37 @@
                     }
                     settings->proposedConformance = a->xDLMSContextInfo.conformance;
                     settings->expectedClientSystemTitle = NULL;
+#ifndef DLMS_INVOCATION_COUNTER_VALIDATOR
                     //Set Invocation counter value.
                     settings->expectedInvocationCounter = NULL;
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
                     //Client can establish a ciphered connection only with Security Suite 1.
                     settings->expectedSecuritySuite = 0;
                     //Security policy is not defined by default. Client can connect using any security policy.
                     settings->expectedSecurityPolicy = 0xFF;
                     if (a->securitySetup != NULL)
                     {
-                        //Set expected client system title. If this is set only client that is using expected client system title can connect to the meter.
+                        //Set expected client system title. If this is set only client that is 
+                        // using expected client system title can connect to the meter.
                         if (a->securitySetup->clientSystemTitle.size == 8)
                         {
                             settings->expectedClientSystemTitle = a->securitySetup->clientSystemTitle.data;
+                            settings->preEstablishedSystemTitle = &a->securitySetup->clientSystemTitle;
+                            settings->cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
+                            //Authentication is updated.
+                            settings->authentication = a->authenticationMechanismName.mechanismId;
+                        }
+                        else
+                        {
+                            settings->preEstablishedSystemTitle = NULL;
                         }
                         //GMac authentication uses innocation counter.
                         if (a->securitySetup == &securitySetupHighGMac)
                         {
+#ifndef DLMS_INVOCATION_COUNTER_VALIDATOR
                             //Set invocation counter value. If this is set client's invocation counter must match with server IC.
                             settings->expectedInvocationCounter = &securitySetupHighGMac.minimumInvocationCounter;
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
                         }
 
                         //Set security suite that client must use.
@@ -3269,8 +5072,8 @@
     {
         // If address is not broadcast or serial number.
         //Remove logical address from the server address.
-        unsigned char broadcast = (serverAddress & 0x3FFF) == 0x3FFF || (serverAddress & 0x7F) == 0x7F;
-        if (!(broadcast ||
+        settings->cipher.broadcast = (serverAddress & 0x3FFF) == 0x3FFF || (serverAddress & 0x7F) == 0x7F;
+        if (!(settings->cipher.broadcast ||
             (serverAddress & 0x3FFF) == SERIAL_NUMBER % 10000 + 1000))
         {
             ret = 0;
@@ -3319,7 +5122,7 @@
             oa_empty(&objects);
         }
         //Set serial number as meter address if broadcast is used.
-        if (broadcast)
+        if (settings->cipher.broadcast && settings->interfaceType == DLMS_INTERFACE_TYPE_HDLC)
         {
             settings->serverAddress = SERIAL_NUMBER % 10000 + 1000;
         }
@@ -3506,8 +5309,7 @@
     return DLMS_ACCESS_MODE_READ;
 }
 
-
-//Get attribute access level for security setup.
+//Get attribute access level for activity calendar.
 DLMS_ACCESS_MODE getActivityCalendarAttributeAccess(
     dlmsSettings* settings,
     unsigned char index)
@@ -3520,6 +5322,18 @@
     return DLMS_ACCESS_MODE_READ;
 }
 
+//Get attribute access level for array manager.
+DLMS_ACCESS_MODE getArrayManagerAttributeAccess(
+    dlmsSettings* settings,
+    unsigned char index)
+{
+    if (settings->authentication > DLMS_AUTHENTICATION_LOW && index == 2)
+    {
+        return DLMS_ACCESS_MODE_READ_WRITE;
+    }
+    return DLMS_ACCESS_MODE_READ;
+}
+
 /**
 * Get attribute access level.
 */
@@ -3582,6 +5396,10 @@
     {
         return getActivityCalendarAttributeAccess(settings, index);
     }
+    if (obj->objectType == DLMS_OBJECT_TYPE_ARRAY_MANAGER)
+    {
+        return getArrayManagerAttributeAccess(settings, index);
+    }
     // Only clock write is allowed.
     if (settings->authentication == DLMS_AUTHENTICATION_LOW)
     {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample/src/main.c src/GuruxDLMSServerExample/src/main.c
--- upstream/GuruxDLMSServerExample/src/main.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample/src/main.c	2024-11-13 12:20:09.000000000 +0000
@@ -46,12 +46,6 @@
 #include "../../development/include/cosem.h"
 #include "../../development/include/gxaes.h"
 
-
-#define HDLC_HEADER_SIZE 17
-
-#define HDLC_BUFFER_SIZE 128
-#define PDU_BUFFER_SIZE 1024
-#define WRAPPER_BUFFER_SIZE 8 + PDU_BUFFER_SIZE
 unsigned char snframeBuff[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
 unsigned char snpduBuff[PDU_BUFFER_SIZE];
 unsigned char lnframeBuff[HDLC_BUFFER_SIZE + HDLC_HEADER_SIZE];
@@ -140,7 +134,9 @@
     printf("Authentication levels:\n");
     printf("None: Client address 16 (0x10)\n");
     printf("Low: Client address 17 (0x11)\n");
-    printf("High: Client address 1 (0x1)\n");
+    printf("High GMac: Client address 1 (0x1)\n");
+    printf("High Pre-established: Client address 2 (0x2)\n");
+    printf("High ECDSA: Client address 3 (0x3)\n");
     printf("----------------------------------------------------------\n");
     println("System Title", &snHdlc.settings.base.cipher.systemTitle);
     println("Authentication key", &snHdlc.settings.base.cipher.authenticationKey);
@@ -150,6 +146,7 @@
     printf("----------------------------------------------------------\n");
     printf("Press Enter to close application.\r\n");
     uint32_t lastMonitor = 0;
+    uint32_t executeTime = 0;
     while (1)
     {
         //Monitor values only once/second.
@@ -188,6 +185,17 @@
             {
                 printf("lnWrapper monitor failed.\r\n");
             }
+            if (executeTime <= lastMonitor)
+            {
+                svr_run(&lnHdlc.settings, lastMonitor, &executeTime);
+                if (executeTime != -1)
+                {
+                    time_t tmp = lastMonitor;
+                    printf("%s", ctime(&tmp));
+                    tmp = executeTime;
+                    printf("%lu seconds before next invoke %s", executeTime - lastMonitor, ctime(&tmp));
+                }
+            }
         }
 #if defined(_WIN32) || defined(_WIN64)//Windows includes
         if (_kbhit()) {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj src/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj
--- upstream/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj	2024-11-13 12:20:09.000000000 +0000
@@ -20,44 +20,57 @@
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\dlms\src\apdu.c" />
+    <ClCompile Include="..\dlms\src\asn1Parser.c" />
+    <ClCompile Include="..\dlms\src\bigInteger.c" />
     <ClCompile Include="..\dlms\src\bitarray.c" />
     <ClCompile Include="..\dlms\src\bytebuffer.c" />
     <ClCompile Include="..\dlms\src\ciphering.c" />
     <ClCompile Include="..\dlms\src\client.c" />
     <ClCompile Include="..\dlms\src\converters.c" />
     <ClCompile Include="..\dlms\src\cosem.c" />
+    <ClCompile Include="..\dlms\src\curve.c" />
     <ClCompile Include="..\dlms\src\datainfo.c" />
     <ClCompile Include="..\dlms\src\date.c" />
     <ClCompile Include="..\dlms\src\dlms.c" />
     <ClCompile Include="..\dlms\src\dlmsSettings.c" />
+    <ClCompile Include="..\dlms\src\eccPoint.c" />
+    <ClCompile Include="..\dlms\src\gx509Certificate.c" />
     <ClCompile Include="..\dlms\src\gxaes.c" />
     <ClCompile Include="..\dlms\src\gxarray.c" />
+    <ClCompile Include="..\dlms\src\gxecdsa.c" />
     <ClCompile Include="..\dlms\src\gxget.c" />
     <ClCompile Include="..\dlms\src\gxinvoke.c" />
     <ClCompile Include="..\dlms\src\gxkey.c" />
     <ClCompile Include="..\dlms\src\gxmd5.c" />
     <ClCompile Include="..\dlms\src\gxobjects.c" />
+    <ClCompile Include="..\dlms\src\gxPkcs10.c" />
     <ClCompile Include="..\dlms\src\gxserializer.c" />
     <ClCompile Include="..\dlms\src\gxset.c" />
     <ClCompile Include="..\dlms\src\gxsetmalloc.c" />
     <ClCompile Include="..\dlms\src\gxsetignoremalloc.c" />
     <ClCompile Include="..\dlms\src\gxsha1.c" />
     <ClCompile Include="..\dlms\src\gxsha256.c" />
+    <ClCompile Include="..\dlms\src\gxsha384.c" />
     <ClCompile Include="..\dlms\src\gxvalueeventargs.c" />
     <ClCompile Include="..\dlms\src\helpers.c" />
     <ClCompile Include="..\dlms\src\message.c" />
     <ClCompile Include="..\dlms\src\notify.c" />
     <ClCompile Include="..\dlms\src\objectarray.c" />
     <ClCompile Include="..\dlms\src\parameters.c" />
+    <ClCompile Include="..\dlms\src\privateKey.c" />
+    <ClCompile Include="..\dlms\src\publicKey.c" />
     <ClCompile Include="..\dlms\src\replydata.c" />
     <ClCompile Include="..\dlms\src\server.c" />
     <ClCompile Include="..\dlms\src\serverevents.c" />
+    <ClCompile Include="..\dlms\src\shamirs.c" />
     <ClCompile Include="..\dlms\src\variant.c" />
     <ClCompile Include="..\src\getopt.c" />
     <ClCompile Include="..\src\main.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\dlms\include\apdu.h" />
+    <ClInclude Include="..\dlms\include\asn1Parser.h" />
+    <ClInclude Include="..\dlms\include\bigInteger.h" />
     <ClInclude Include="..\dlms\include\bitarray.h" />
     <ClInclude Include="..\dlms\include\bytebuffer.h" />
     <ClInclude Include="..\dlms\include\ciphering.h" />
@@ -66,15 +79,19 @@
     <ClInclude Include="..\dlms\include\converters.h" />
     <ClInclude Include="..\dlms\include\cosem.h" />
     <ClInclude Include="..\dlms\include\crc.h" />
+    <ClInclude Include="..\dlms\include\curve.h" />
     <ClInclude Include="..\dlms\include\datainfo.h" />
     <ClInclude Include="..\dlms\include\date.h" />
     <ClInclude Include="..\dlms\include\dlms.h" />
     <ClInclude Include="..\dlms\include\dlmssettings.h" />
+    <ClInclude Include="..\dlms\include\eccPoint.h" />
     <ClInclude Include="..\dlms\include\enums.h" />
     <ClInclude Include="..\dlms\include\errorcodes.h" />
+    <ClInclude Include="..\dlms\include\gx509Certificate.h" />
     <ClInclude Include="..\dlms\include\gxaes.h" />
     <ClInclude Include="..\dlms\include\gxarray.h" />
     <ClInclude Include="..\dlms\include\gxdefine.h" />
+    <ClInclude Include="..\dlms\include\gxecdsa.h" />
     <ClInclude Include="..\dlms\include\gxget.h" />
     <ClInclude Include="..\dlms\include\gxignore.h" />
     <ClInclude Include="..\dlms\include\gxint.h" />
@@ -83,12 +100,14 @@
     <ClInclude Include="..\dlms\include\gxmd5.h" />
     <ClInclude Include="..\dlms\include\gxmem.h" />
     <ClInclude Include="..\dlms\include\gxobjects.h" />
+    <ClInclude Include="..\dlms\include\gxPkcs10.h" />
     <ClInclude Include="..\dlms\include\gxserializer.h" />
     <ClInclude Include="..\dlms\include\gxset.h" />
     <ClInclude Include="..\dlms\include\gxsetignoremalloc.h" />
     <ClInclude Include="..\dlms\include\gxsetmalloc.h" />
     <ClInclude Include="..\dlms\include\gxsha1.h" />
     <ClInclude Include="..\dlms\include\gxsha256.h" />
+    <ClInclude Include="..\dlms\include\gxsha384.h" />
     <ClInclude Include="..\dlms\include\gxvalueeventargs.h" />
     <ClInclude Include="..\dlms\include\helpers.h" />
     <ClInclude Include="..\dlms\include\lnparameters.h" />
@@ -96,9 +115,12 @@
     <ClInclude Include="..\dlms\include\notify.h" />
     <ClInclude Include="..\dlms\include\objectarray.h" />
     <ClInclude Include="..\dlms\include\parameters.h" />
+    <ClInclude Include="..\dlms\include\privateKey.h" />
+    <ClInclude Include="..\dlms\include\publicKey.h" />
     <ClInclude Include="..\dlms\include\replydata.h" />
     <ClInclude Include="..\dlms\include\server.h" />
     <ClInclude Include="..\dlms\include\serverevents.h" />
+    <ClInclude Include="..\dlms\include\shamirs.h" />
     <ClInclude Include="..\dlms\include\snparameters.h" />
     <ClInclude Include="..\dlms\include\variant.h" />
     <ClInclude Include="..\include\getopt.h" />
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj.filters src/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj.filters
--- upstream/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj.filters	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample2/VS/GuruxDLMSServerExample2.vcxproj.filters	2024-11-13 12:20:09.000000000 +0000
@@ -132,6 +132,39 @@
     <ClCompile Include="..\dlms\src\gxsetignoremalloc.c">
       <Filter>dlms\src</Filter>
     </ClCompile>
+    <ClCompile Include="..\dlms\src\bigInteger.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\curve.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\eccPoint.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\gxecdsa.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\gxsha384.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\privateKey.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\publicKey.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\shamirs.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\gxPkcs10.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\asn1Parser.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\dlms\src\gx509Certificate.c">
+      <Filter>dlms\src</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\dlms\include\apdu.h">
@@ -269,5 +302,38 @@
     <ClInclude Include="..\dlms\include\gxsetmalloc.h">
       <Filter>dlms\include</Filter>
     </ClInclude>
+    <ClInclude Include="..\dlms\include\bigInteger.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\curve.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\eccPoint.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\gxecdsa.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\gxsha384.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\privateKey.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\publicKey.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\shamirs.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\gxPkcs10.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\asn1Parser.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\dlms\include\gx509Certificate.h">
+      <Filter>dlms\include</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/GuruxDLMSServerExample2/src/main.c src/GuruxDLMSServerExample2/src/main.c
--- upstream/GuruxDLMSServerExample2/src/main.c	2024-01-23 14:13:59.000000000 +0000
+++ src/GuruxDLMSServerExample2/src/main.c	2024-11-13 12:20:09.000000000 +0000
@@ -140,7 +140,7 @@
 //Define server system title.
 static unsigned char SERVER_SYSTEM_TITLE[8] = { 0 };
 time_t imageActionStartTime = 0;
-gxImageActivateInfo IMAGE_ACTIVATE_INFO[1];
+gxImageActivateInfo IMAGE_ACTIVATE_INFO[1] = { 0 };
 static gxIecTwistedPairSetup twistedPairSetup;
 
 uint32_t time_current(void)
@@ -178,6 +178,8 @@
 static gxAssociationLogicalName associationLow;
 static gxAssociationLogicalName associationHigh;
 static gxAssociationLogicalName associationHighGMac;
+static gxAssociationLogicalName associationHighGMacPreEstablished;
+static gxAssociationLogicalName associationHighEcdsa;
 static gxRegister activePowerL1;
 static gxRegister activePowerL1;
 static gxScriptTable scriptTableGlobalMeterReset;
@@ -197,10 +199,15 @@
 static gxSecuritySetup securitySetupHigh;
 //Security Setup HighGMac is for GMac authentication.
 static gxSecuritySetup securitySetupHighGMac;
+//Security Setup HighGMac is for pre-established GMac authentication.
+static gxSecuritySetup securitySetupHighGMacPreEstablished;
+//Security Setup HighEdcsa is for ECDSA authentication.
+static gxSecuritySetup securitySetupHighEcdsa;
 
 gxImageTransfer imageTransfer;
 gxAutoConnect autoConnect;
 gxActivityCalendar activityCalendar;
+gxLocalPortSetup localPortSetup;
 gxSpecialDaysTable specialDaysTable;
 gxDemandRegister demandRegister;
 gxRegisterMonitor registerMonitor;
@@ -223,17 +230,32 @@
 static gxG3Plc6LoWPAN g3Plc6LoWPAN;
 static gxArrayManager arrayManager;
 static gxFunctionControl functionControl;
+static gxLteMonitoring lteMonitoring;
+
+static gxCompactData compactDataExample;
+
+#ifdef DLMS_ITALIAN_STANDARD
+static gxTariffPlan tariffPlan;
+static gxTariffPlan passiveTariffPlan;
+static gxData spareObject;
+//Compact Frame 6.
+static gxCompactData cf6;
+#endif //DLMS_ITALIAN_STANDARD
+
 
 //static gxObject* NONE_OBJECTS[] = { BASE(associationNone), BASE(ldn) };
 
 //Append new COSEM object to the end so serialization will work correctly.
 static gxObject* ALL_OBJECTS[] = {
-    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac), BASE(securitySetupHigh), BASE(securitySetupHighGMac),
+    BASE(associationNone), BASE(associationLow), BASE(associationHigh), BASE(associationHighGMac),
+    BASE(associationHighGMacPreEstablished), BASE(associationHighEcdsa),
+    BASE(securitySetupHigh), BASE(securitySetupHighGMac),BASE(securitySetupHighGMacPreEstablished),
+    BASE(securitySetupHighEcdsa),
     BASE(ldn), BASE(eeprom), BASE(testMode), BASE(sapAssignment), BASE(eventCode),
     BASE(clock1), BASE(activePowerL1), BASE(pushSetup), BASE(scriptTableGlobalMeterReset), BASE(scriptTableDisconnectControl),
     BASE(scriptTableActivateTestMode), BASE(scriptTableActivateNormalMode), BASE(loadProfile), BASE(eventLog), BASE(hdlc),
     BASE(disconnectControl), BASE(actionScheduleDisconnectOpen), BASE(actionScheduleDisconnectClose), BASE(unixTime), BASE(invocationCounter),
-    BASE(imageTransfer), BASE(udpSetup), BASE(autoConnect), BASE(activityCalendar), BASE(demandRegister),
+    BASE(imageTransfer), BASE(udpSetup), BASE(autoConnect), BASE(activityCalendar), BASE(localPortSetup), BASE(demandRegister),
     BASE(registerMonitor), BASE(autoAnswer), BASE(modemConfiguration), BASE(macAddressSetup), BASE(ip4Setup), BASE(pppSetup), BASE(gprsSetup),
     BASE(tarifficationScriptTable), BASE(registerActivation), BASE(primeNbOfdmPlcMacFunctionalParameters), BASE(primeNbOfdmPlcMacNetworkAdministrationData),
     BASE(twistedPairSetup), BASE(specialDaysTable), BASE(currentlyActiveTariff),
@@ -241,7 +263,15 @@
     BASE(blockCipherKey), BASE(authenticationKey), BASE(kek),BASE(serverInvocationCounter), BASE(limiter),
     BASE(mbusDiagnostic), BASE(mbusPortSetup),
     BASE(g3plcMacLayerCounters), BASE(g3PlcMacSetup), BASE(g3Plc6LoWPAN), BASE(arrayManager),
-    BASE(functionControl)
+    BASE(functionControl),
+    BASE(lteMonitoring),
+    BASE(compactDataExample),
+#ifdef DLMS_ITALIAN_STANDARD
+    BASE(tariffPlan),
+    BASE(passiveTariffPlan),    
+    BASE(spareObject),    
+    BASE(cf6)
+#endif //DLMS_ITALIAN_STANDARD
 };
 
 //List of COSEM objects that are removed from association view(s).
@@ -846,7 +876,72 @@
 #ifndef DLMS_IGNORE_OBJECT_POINTERS
         associationHighGMac.securitySetup = &securitySetupHighGMac;
 #else
-        memcpy(associationHighGMac.securitySetupReference, securitySetupHigh.base.logicalName, 6);
+        memcpy(associationHighGMac.securitySetupReference, securitySetupHighGMac.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
+
+///////////////////////////////////////////////////////////////////////
+//This method adds pre-established example 
+// Logical Name Association object for GMAC High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighGMacPreEstablished()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 5, 255 };
+    if ((ret = INIT_OBJECT(associationHighGMacPreEstablished, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighGMacPreEstablished.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_GMAC;
+        OA_ATTACH(associationHighGMac.objectList, ALL_OBJECTS);
+        associationHighGMacPreEstablished.clientSAP = 0x2;
+        associationHighGMacPreEstablished.xDLMSContextInfo.maxSendPduSize = associationHighGMacPreEstablished.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighGMacPreEstablished.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)(DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+            DLMS_CONFORMANCE_SET |
+            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+            DLMS_CONFORMANCE_ACTION |
+            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+            DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighGMacPreEstablished.securitySetup = &securitySetupHighGMacPreEstablished;
+#else
+        memcpy(associationHighGMacPreEstablished.securitySetupReference, securitySetupHighGMacPreEstablished.base.logicalName, 6);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds example Logical Name Association object for ECDSA High authentication.
+///////////////////////////////////////////////////////////////////////
+int addAssociationHighECDSA()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 40, 0, 6, 255 };
+    if ((ret = INIT_OBJECT(associationHighEcdsa, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln)) == 0)
+    {
+        associationHighEcdsa.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_HIGH_ECDSA;
+        OA_ATTACH(associationHighEcdsa.objectList, ALL_OBJECTS);
+        associationHighEcdsa.clientSAP = 0x3;
+        associationHighEcdsa.xDLMSContextInfo.maxSendPduSize = associationHighEcdsa.xDLMSContextInfo.maxReceivePduSize = PDU_BUFFER_SIZE;
+        associationHighEcdsa.xDLMSContextInfo.conformance = (DLMS_CONFORMANCE)
+            (DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+                DLMS_CONFORMANCE_SET |
+                DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+                DLMS_CONFORMANCE_ACTION |
+                DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+                DLMS_CONFORMANCE_GET);
+        //GMAC authentication don't need password.
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        associationHighEcdsa.securitySetup = &securitySetupHighEcdsa;
+#else
+        memcpy(associationHighEcdsa.securitySetupReference, securitySetupHighEcdsa.base.logicalName, 6);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
     }
     return ret;
@@ -891,6 +986,54 @@
     return ret;
 }
 
+
+///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for pre-established GMAC authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupPreEstablishedHighGMac()
+{
+    int ret;
+    //Define client system title for the pre-established connection.
+    //Pre-establiched system title is Gurux123
+    static unsigned char CLIENT_SYSTEM_TITLE[8] = { 0x47, 0x75, 0x72, 0x75, 0x78, 0x31, 0x32, 0x33 };
+    const unsigned char ln[6] = { 0, 0, 43, 0, 3, 255 };
+    if ((ret = INIT_OBJECT(securitySetupHighGMacPreEstablished, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighGMacPreEstablished.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        BB_ATTACH(securitySetupHighGMacPreEstablished.clientSystemTitle, CLIENT_SYSTEM_TITLE, 8);
+        //Only Authenticated encrypted connections are allowed.
+        securitySetupHighGMacPreEstablished.securityPolicy = DLMS_SECURITY_POLICY_AUTHENTICATED_ENCRYPTED;
+        securitySetupHighGMacPreEstablished.securitySuite = DLMS_SECURITY_SUITE_V0;
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//This method adds security setup object for ECDSA authentication.
+///////////////////////////////////////////////////////////////////////
+int addSecuritySetupHighEcdsa()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 43, 0, 4, 255 };
+    static gxCertificateInfo CERTIFICATES[2] = {0};
+    if ((ret = INIT_OBJECT(securitySetupHighEcdsa, DLMS_OBJECT_TYPE_SECURITY_SETUP, ln)) == 0)
+    {
+        BB_ATTACH(securitySetupHighEcdsa.serverSystemTitle, SERVER_SYSTEM_TITLE, 8);
+        //Ciphering is not used.
+        securitySetupHighEcdsa.securityPolicy = DLMS_SECURITY_POLICY_NOTHING;
+        securitySetupHighEcdsa.securitySuite = DLMS_SECURITY_SUITE_V1;
+        ARR_ATTACH(securitySetupHighEcdsa.certificates, CERTIFICATES, 0);
+        //Assign certificates.
+        uint16_t pos;
+        gxCertificateInfo* ci = securitySetupHighEcdsa.certificates.data;
+        for (pos = 0; pos != arr_getCapacity(&securitySetupHighEcdsa.certificates); ++pos)
+        {
+            BB_ATTACH(CERTIFICATES[pos].cert, CERTIFICATES[pos].CERTIFICATE_BUFFER, 0);
+        }
+    }
+    return ret;
+}
+
 ///////////////////////////////////////////////////////////////////////
 //Add SAP Assignment object.
 ///////////////////////////////////////////////////////////////////////
@@ -1236,6 +1379,39 @@
 ///////////////////////////////////////////////////////////////////////
 //Add Optical Port Setup object.
 ///////////////////////////////////////////////////////////////////////
+int addOpticalPortSetup()
+{
+    const unsigned char ln[6] = { 0,0,20,0,0,255 };
+    //Define device address.
+    static unsigned char DEVICE_ADDRESS[10] = { 0 };
+    //Define password 1.
+    static unsigned char PASSWORD_1[10] = { 0 };
+    //Define password 2.
+    static unsigned char PASSWORD_2[10] = { 0 };
+    //Define password 5.
+    static unsigned char PASSWORD_5[10] = { 0 };
+    INIT_OBJECT(localPortSetup, DLMS_OBJECT_TYPE_IEC_LOCAL_PORT_SETUP, ln);
+    localPortSetup.defaultMode = DLMS_OPTICAL_PROTOCOL_MODE_DEFAULT;
+    localPortSetup.proposedBaudrate = DLMS_BAUD_RATE_9600;
+    localPortSetup.defaultBaudrate = DLMS_BAUD_RATE_300;
+    localPortSetup.responseTime = DLMS_LOCAL_PORT_RESPONSE_TIME_200_MS;
+    BB_ATTACH(localPortSetup.deviceAddress, DEVICE_ADDRESS, 0);
+    bb_addString(&localPortSetup.deviceAddress, "12345678");
+    BB_ATTACH(localPortSetup.password1, PASSWORD_1, 0);
+    bb_addString(&localPortSetup.password1, "Gurux1");
+    BB_ATTACH(localPortSetup.password2, PASSWORD_2, 0);
+    bb_addString(&localPortSetup.password2, "Gurux2");
+    BB_ATTACH(localPortSetup.password5, PASSWORD_5, 0);
+    bb_addString(&localPortSetup.password5, "Gurux5");
+    //Set flag id.
+    memcpy(settings.flagId, "GRX", 3);
+    settings.localPortSetup = &localPortSetup;
+    return 0;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Optical Port Setup object.
+///////////////////////////////////////////////////////////////////////
 int addSpecialDaysTable()
 {
     int ret;
@@ -1287,14 +1463,6 @@
 }
 
 ///////////////////////////////////////////////////////////////////////
-//Add Optical Port Setup object.
-///////////////////////////////////////////////////////////////////////
-int addOpticalPortSetup()
-{
-    return 0;
-}
-
-///////////////////////////////////////////////////////////////////////
 //Add Demand Register object.
 ///////////////////////////////////////////////////////////////////////
 int addDemandRegister()
@@ -1721,6 +1889,348 @@
     return ret;
 }
 
+#ifdef DLMS_ITALIAN_STANDARD
+///////////////////////////////////////////////////////////////////////
+// Add tariff plan object. Tariff plan is used only in Italy standard.
+// 
+// Active UNI/TS Tariff Plan (end-of-billing-period)
+///////////////////////////////////////////////////////////////////////
+int addTariffPlan()
+{
+    int ret;
+    static uint16_t SPECIAL_DAYS[10] = { 0x0, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00 };
+    static unsigned char CALENDAR_NAME[2] = { 0x0D, 0x01 };
+    static unsigned char WEEKLY_ACTIVATION[2] = { 0x7, 0xFF };
+    const unsigned char ln[6] = { 0, 0, 94, 39, 21, 101 };
+    if ((ret = INIT_OBJECT(tariffPlan, DLMS_OBJECT_TYPE_TARIFF_PLAN, ln)) == 0)
+    {
+        BB_ATTACH(tariffPlan.calendarName, CALENDAR_NAME, 2);
+        tariffPlan.enabled = 0;
+        time_init(&tariffPlan.activationTime, 2015, 1, 1, 0, 0, 0, 0, 120);
+        //General 
+        tariffPlan.plan.defaultTariffBand = 3;
+        BIT_ATTACH(tariffPlan.plan.weeklyActivation, WEEKLY_ACTIVATION, 2);
+
+        //////////////
+        //Get winter season.
+        tariffPlan.plan.winterSeason.dayOfMonth = 1;
+        tariffPlan.plan.winterSeason.month = 10;
+        //Working day interval #1.
+        tariffPlan.plan.winterSeason.workingDayIntervals[0].startHour = 21;
+        tariffPlan.plan.winterSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        tariffPlan.plan.winterSeason.workingDayIntervals[1].startHour = 24;
+        tariffPlan.plan.winterSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        tariffPlan.plan.winterSeason.workingDayIntervals[2].startHour = 24;
+        tariffPlan.plan.winterSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        tariffPlan.plan.winterSeason.workingDayIntervals[3].startHour = 24;
+        tariffPlan.plan.winterSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        tariffPlan.plan.winterSeason.workingDayIntervals[4].startHour = 24;
+        tariffPlan.plan.winterSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        tariffPlan.plan.winterSeason.saturdayIntervals[0].startHour = 21;
+        tariffPlan.plan.winterSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        tariffPlan.plan.winterSeason.saturdayIntervals[1].startHour = 21;
+        tariffPlan.plan.winterSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        tariffPlan.plan.winterSeason.saturdayIntervals[2].startHour = 21;
+        tariffPlan.plan.winterSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        tariffPlan.plan.winterSeason.saturdayIntervals[3].startHour = 21;
+        tariffPlan.plan.winterSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        tariffPlan.plan.winterSeason.saturdayIntervals[4].startHour = 21;
+        tariffPlan.plan.winterSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        tariffPlan.plan.winterSeason.holidayIntervals[0].startHour = 21;
+        tariffPlan.plan.winterSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        tariffPlan.plan.winterSeason.holidayIntervals[1].startHour = 21;
+        tariffPlan.plan.winterSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        tariffPlan.plan.winterSeason.holidayIntervals[2].startHour = 21;
+        tariffPlan.plan.winterSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        tariffPlan.plan.winterSeason.holidayIntervals[3].startHour = 21;
+        tariffPlan.plan.winterSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        tariffPlan.plan.winterSeason.holidayIntervals[4].startHour = 21;
+        tariffPlan.plan.winterSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //////////////
+        // Get summer season.
+        tariffPlan.plan.summerSeason.dayOfMonth = 1;
+        tariffPlan.plan.summerSeason.month = 4;
+        //Working day interval #1.
+        tariffPlan.plan.summerSeason.workingDayIntervals[0].startHour = 21;
+        tariffPlan.plan.summerSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        tariffPlan.plan.summerSeason.workingDayIntervals[1].startHour = 24;
+        tariffPlan.plan.summerSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        tariffPlan.plan.summerSeason.workingDayIntervals[2].startHour = 24;
+        tariffPlan.plan.summerSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        tariffPlan.plan.summerSeason.workingDayIntervals[3].startHour = 24;
+        tariffPlan.plan.summerSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        tariffPlan.plan.summerSeason.workingDayIntervals[4].startHour = 24;
+        tariffPlan.plan.summerSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        tariffPlan.plan.summerSeason.saturdayIntervals[0].startHour = 21;
+        tariffPlan.plan.summerSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        tariffPlan.plan.summerSeason.saturdayIntervals[1].startHour = 21;
+        tariffPlan.plan.summerSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        tariffPlan.plan.summerSeason.saturdayIntervals[2].startHour = 21;
+        tariffPlan.plan.summerSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        tariffPlan.plan.summerSeason.saturdayIntervals[3].startHour = 21;
+        tariffPlan.plan.summerSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        tariffPlan.plan.summerSeason.saturdayIntervals[4].startHour = 21;
+        tariffPlan.plan.summerSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        tariffPlan.plan.summerSeason.holidayIntervals[0].startHour = 21;
+        tariffPlan.plan.summerSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        tariffPlan.plan.summerSeason.holidayIntervals[1].startHour = 21;
+        tariffPlan.plan.summerSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        tariffPlan.plan.summerSeason.holidayIntervals[2].startHour = 21;
+        tariffPlan.plan.summerSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        tariffPlan.plan.summerSeason.holidayIntervals[3].startHour = 21;
+        tariffPlan.plan.summerSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        tariffPlan.plan.summerSeason.holidayIntervals[4].startHour = 21;
+        tariffPlan.plan.summerSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        ARR_ATTACH(tariffPlan.plan.specialDays, SPECIAL_DAYS, 10);
+    }
+    return ret;
+}
+
+int addPassiveTariffPlan()
+{
+    int ret;
+    static uint16_t SPECIAL_DAYS[10] = { 0x0, 0x00, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00, 0x00, 0x00 };
+    static unsigned char CALENDAR_NAME[2] = { 0x0D, 0x01 };
+    static unsigned char WEEKLY_ACTIVATION[2] = { 0x7, 0xFF };
+    const unsigned char ln[6] = { 0, 0, 94, 39, 22, 255}; //0-0:94.39.22.255
+    if ((ret = INIT_OBJECT(passiveTariffPlan, DLMS_OBJECT_TYPE_TARIFF_PLAN, ln)) == 0)
+    {
+        BB_ATTACH(passiveTariffPlan.calendarName, CALENDAR_NAME, 2);
+        passiveTariffPlan.enabled = 0;
+        time_init(&passiveTariffPlan.activationTime, 2015, 1, 1, 0, 0, 0, 0, 120);
+        //General 
+        passiveTariffPlan.plan.defaultTariffBand = 3;
+        BIT_ATTACH(passiveTariffPlan.plan.weeklyActivation, WEEKLY_ACTIVATION, 2);
+
+        //////////////
+        //Get winter season.
+        passiveTariffPlan.plan.winterSeason.dayOfMonth = 1;
+        passiveTariffPlan.plan.winterSeason.month = 10;
+        //Working day interval #1.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[1].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[2].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[3].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[4].startHour = 24;
+        passiveTariffPlan.plan.winterSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.winterSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //////////////
+        // Get summer season.
+        passiveTariffPlan.plan.summerSeason.dayOfMonth = 1;
+        passiveTariffPlan.plan.summerSeason.month = 4;
+        //Working day interval #1.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Working day interval #2.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[1].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #3.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[2].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #4.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[3].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Working day interval #5.
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[4].startHour = 24;
+        passiveTariffPlan.plan.summerSeason.workingDayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Saturday interval #1.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Saturday interval #2.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #3.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #4.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Saturday interval #5.
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.saturdayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+
+        //Holiday interval #1.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[0].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[0].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_TARIFF_BAND_2;
+        //Holiday interval #2.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[1].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[1].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #3.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[2].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[2].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #4.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[3].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[3].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        //Holiday interval #5.
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[4].startHour = 21;
+        passiveTariffPlan.plan.summerSeason.holidayIntervals[4].intervalTariff = DLMS_DEFAULT_TARIFF_BAND_NONE;
+        ARR_ATTACH(passiveTariffPlan.plan.specialDays, SPECIAL_DAYS, 10);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add spare object as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addSpareObject()
+{
+    int ret;
+    static unsigned char DATA[1] = {0};
+    const unsigned char ln[6] = { 0, 0, 96, 39, 40, 255 };//0-0:94:39.40.255
+    if ((ret = INIT_OBJECT(spareObject, DLMS_OBJECT_TYPE_DATA, ln)) == 0)
+    {
+        GX_OCTET_STRING(spareObject.value, DATA, 0);
+    }
+    return ret;
+}
+
+///////////////////////////////////////////////////////////////////////
+//Add Compact frame 6 as defined in UNI TS 11291-13-2 specifications.
+///////////////////////////////////////////////////////////////////////
+int addCF6Plan()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 6, 255 };//0-0:66.0.6.255
+    static gxTarget CAPTURE_OBBJECTS[6] = {0};
+    static unsigned char BUFFER[72];
+    static unsigned char TEMPLATE_DESCRIPTION[86];
+    if ((ret = INIT_OBJECT(cf6, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        BB_ATTACH(cf6.buffer, BUFFER, 0);
+        BB_ATTACH(cf6.templateDescription, TEMPLATE_DESCRIPTION, 0);
+        cf6.templateId = 6;
+        cf6.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        cf6.appendAA = 1;
+        //Add 6 capture objects.
+        ARR_ATTACH(cf6.captureObjects, CAPTURE_OBBJECTS, 6);
+        //CF6 attribute #4.
+        CAPTURE_OBBJECTS[0].target = BASE(cf6);
+        CAPTURE_OBBJECTS[0].attributeIndex = 4;
+        //Passive UNI/TS Tariff Plan attribute #2.
+        CAPTURE_OBBJECTS[1].target = BASE(passiveTariffPlan);
+        CAPTURE_OBBJECTS[1].attributeIndex = 2;
+        //Passive UNI/TS Tariff Plan attribute #3.
+        CAPTURE_OBBJECTS[2].target = BASE(passiveTariffPlan);
+        CAPTURE_OBBJECTS[2].attributeIndex = 3;
+        //Passive UNI/TS Tariff Plan attribute #4.
+        CAPTURE_OBBJECTS[3].target = BASE(passiveTariffPlan);
+        CAPTURE_OBBJECTS[3].attributeIndex = 4;
+        //Passive UNI/TS Tariff Plan attribute #5.
+        CAPTURE_OBBJECTS[4].target = BASE(passiveTariffPlan);
+        CAPTURE_OBBJECTS[4].attributeIndex = 5;
+        //Spare Object.
+        CAPTURE_OBBJECTS[5].target = BASE(spareObject);
+        CAPTURE_OBBJECTS[5].attributeIndex = 2;
+        ret = compactData_updateTemplateDescription(&settings.base, &cf6);
+    }
+    return ret;
+}
+#endif //DLMS_ITALIAN_STANDARD
+
+///////////////////////////////////////////////////////////////////////
+// Add Compact data example where are only template description 
+// and buffer for 20 UInt16 Value.
+///////////////////////////////////////////////////////////////////////
+int addCompactDataExample()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 66, 0, 1, 255 };//0-0:66.0.1.255
+    static unsigned char BUFFER[20 * sizeof(uint32_t)];
+    static unsigned char TEMPLATE_DESCRIPTION[3];
+    if ((ret = INIT_OBJECT(compactDataExample, DLMS_OBJECT_TYPE_COMPACT_DATA, ln)) == 0)
+    {
+        BB_ATTACH(compactDataExample.buffer, BUFFER, 0);
+        //Data type is structure.
+        TEMPLATE_DESCRIPTION[0] = DLMS_DATA_TYPE_STRUCTURE;
+        //The number of elements in the structure 
+        TEMPLATE_DESCRIPTION[1] = 1;
+        TEMPLATE_DESCRIPTION[2] = DLMS_DATA_TYPE_UINT32;
+        BB_ATTACH(compactDataExample.templateDescription, TEMPLATE_DESCRIPTION, sizeof(TEMPLATE_DESCRIPTION));
+        compactDataExample.templateId = 1;
+        //Data is captured upon reading.
+        compactDataExample.captureMethod = DLMS_CAPTURE_METHOD_IMPLICIT;
+        //Update buffer with data.
+        for (int pos = 0; pos != sizeof(BUFFER) / sizeof(uint32_t); ++pos)
+        {
+            bb_setUInt32(&compactDataExample.buffer, pos);
+        }
+    }
+    return ret;
+}
 ///////////////////////////////////////////////////////////////////////
 //Add G3 PLC 6LoWPAN object.
 ///////////////////////////////////////////////////////////////////////
@@ -1815,9 +2325,9 @@
 {
     int ret;
     //Function statuc must initialize to zero.
-    static functionStatus FUNCTION_STATUS[2] = {0};
+    static functionStatus FUNCTION_STATUS[2] = { 0 };
     //Function block must initialize to zero.
-    static functionalBlock FUNCTION_BLOCKS[2] = { 0 };    
+    static functionalBlock FUNCTION_BLOCKS[2] = { 0 };
     const unsigned char ln[6] = { 0,0,44,1,0,255 };
     if ((ret = INIT_OBJECT(functionControl, DLMS_OBJECT_TYPE_FUNCTION_CONTROL, ln)) == 0)
     {
@@ -2033,6 +2543,9 @@
     if ((ret = INIT_OBJECT(limiter, DLMS_OBJECT_TYPE_LIMITER, ln)) == 0)
     {
         limiter.monitoredValue = BASE(activePowerL1);
+        GX_UINT32(limiter.thresholdNormal) = 100;
+        GX_UINT32(limiter.thresholdActive) = 150;
+        GX_UINT32(limiter.thresholdEmergency) = 200;
         limiter.selectedAttributeIndex = 2;
         //Add emergency profile group IDs.
         GROUPS[0] = 1;
@@ -2274,6 +2787,34 @@
     return ret;
 }
 
+
+///////////////////////////////////////////////////////////////////////
+//Add LTE monitoring object.
+///////////////////////////////////////////////////////////////////////
+int addLteMonitoring()
+{
+    int ret;
+    const unsigned char ln[6] = { 0, 0, 25, 11, 0, 255 };
+    if ((ret = INIT_OBJECT(lteMonitoring, DLMS_OBJECT_TYPE_LTE_MONITORING, ln)) == 0)
+    {
+        //Set default values.
+        lteMonitoring.networkParameters.t3402 = 0;
+        lteMonitoring.networkParameters.t3412 = 0;
+        lteMonitoring.networkParameters.t3412ext2 = 0;
+        lteMonitoring.networkParameters.t3324 = 0;
+        lteMonitoring.networkParameters.teDRX = 0;
+        lteMonitoring.networkParameters.tPTW = 0;
+        lteMonitoring.networkParameters.qRxlevMin = 0;
+        lteMonitoring.networkParameters.qRxlevMinCE = 0;
+        lteMonitoring.networkParameters.qRxLevMinCE1 = 0;
+        lteMonitoring.qualityOfService.signalQuality = 0;
+        lteMonitoring.qualityOfService.signalLevel = 0;
+        lteMonitoring.qualityOfService.signalToNoiseRatio = 0;
+        lteMonitoring.qualityOfService.coverageEnhancement = 0;
+    }
+    return ret;
+}
+
 /////////////////////////////////////////////////////////////////////////////
 // This method is used to test object serialization.
 // Object is first save and then load.
@@ -2375,6 +2916,10 @@
         (ret = addAssociationLow()) != 0 ||
         (ret = addAssociationHigh()) != 0 ||
         (ret = addAssociationHighGMac()) != 0 ||
+        (ret = addAssociationHighGMacPreEstablished()) != 0 ||
+        (ret = addSecuritySetupPreEstablishedHighGMac()) != 0 ||
+        (ret = addSecuritySetupHighEcdsa()) != 0 ||
+        (ret = addAssociationHighECDSA()) != 0 ||
         (ret = addSecuritySetupHigh()) != 0 ||
         (ret = addSecuritySetupHighGMac()) != 0 ||
         (ret = addMbusDiagnostic()) != 0 ||
@@ -2402,10 +2947,10 @@
         (ret = addTcpUdpSetup()) != 0 ||
         (ret = addAutoConnect()) != 0 ||
         (ret = addActivityCalendar()) != 0 ||
+        (ret = addOpticalPortSetup()) != 0 ||
         (ret = addSpecialDaysTable()) != 0 ||
         (ret = addCurrentlyActiveTariff()) != 0 ||
         (ret = addPrimeNbOfdmPlcMacCounters()) != 0 ||
-        (ret = addOpticalPortSetup()) != 0 ||
         (ret = addDemandRegister()) != 0 ||
         (ret = addRegisterMonitor()) != 0 ||
         (ret = addAutoAnswer()) != 0 ||
@@ -2418,6 +2963,14 @@
         (ret = addPrimeNbOfdmPlcMacNetworkAdministrationData()) != 0 ||
         (ret = addTwistedPairSetup()) != 0 ||
         (ret = addLimiter()) != 0 ||
+        (ret = addLteMonitoring()) != 0 ||  
+        (ret = addCompactDataExample()) != 0 ||        
+#ifdef DLMS_ITALIAN_STANDARD
+        (ret = addTariffPlan()) != 0 ||
+        (ret = addPassiveTariffPlan()) != 0 ||
+        (ret = addSpareObject()) != 0 ||
+        (ret = addCF6Plan()) != 0 ||
+#endif //DLMS_ITALIAN_STANDARD
         (ret = oa_verify(&settings.base.objects)) != 0 ||
         (ret = svr_initialize(&settings)) != 0)
     {
@@ -2933,8 +3486,23 @@
         {
             e->error = (DLMS_ERROR_CODE)readProfileGeneric(settings, &eventLog, e);
         }
+        else if (e->target == BASE(compactDataExample) && e->index == 2)
+        {
+            //There are no capture objects in compact data example.
+            //This causes that the buffer must update manually.
+            uint32_t value;
+            for (int pos = 0; pos <= compactDataExample.buffer.size / sizeof(uint32_t); pos += 4)
+            {
+                if ((ret = bb_getUInt32ByIndex(&compactDataExample.buffer, pos, &value)) != 0 ||
+                    (ret = bb_setUInt32ByIndex(&compactDataExample.buffer, pos, 1 + value)) != 0)
+                {
+                    e->error = ret;
+                    break;
+                }
+            }
+        }        
         //Update Unix time.
-        if (e->target == BASE(unixTime) && e->index == 2)
+        else if (e->target == BASE(unixTime) && e->index == 2)
         {
             gxtime dt;
             time_now(&dt, 0);
@@ -3256,24 +3824,19 @@
             {
                 i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_NOT_INITIATED;
                 //There is only one image.
-                gxImageActivateInfo* info;
                 imageTransfer.imageActivateInfo.size = 1;
-                if ((e->error = arr_getByIndex(&imageTransfer.imageActivateInfo, 0, (void**)&info, sizeof(gxImageActivateInfo))) != 0)
-                {
-                    e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
-                    return;
-                }
                 if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) != 0 ||
-                    (ret = cosem_getOctetString2(e->parameters.byteArr, info->identification.data, sizeof(info->identification.data), &info->identification.size)) != 0 ||
-                    (ret = cosem_getUInt32(e->parameters.byteArr, &info->size)) != 0)
+                    (ret = cosem_getOctetString2(e->parameters.byteArr, IMAGE_ACTIVATE_INFO[0].identification.data,
+                        sizeof(IMAGE_ACTIVATE_INFO[0].identification.data), &IMAGE_ACTIVATE_INFO[0].identification.size)) != 0 ||
+                    (ret = cosem_getUInt32(e->parameters.byteArr, &IMAGE_ACTIVATE_INFO[0].size)) != 0)
                 {
                     e->error = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
                     return;
                 }
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
-                printf("Updating image %s Size: %ld\r\n", imageFile, info->size);
+                printf("Updating image %s Size: %ld\r\n", imageFile, IMAGE_ACTIVATE_INFO[0].size);
 #endif
-                allocateImageTransfer(imageFile, info->size);
+                allocateImageTransfer(imageFile, IMAGE_ACTIVATE_INFO[0].size);
                 ba_clear(&i->imageTransferredBlocksStatus);
                 i->imageTransferStatus = DLMS_IMAGE_TRANSFER_STATUS_INITIATED;
             }
@@ -3510,8 +4073,8 @@
 
 unsigned char svr_isTarget(
     dlmsSettings* settings,
-    unsigned long serverAddress,
-    unsigned long clientAddress)
+    uint32_t serverAddress,
+    uint32_t clientAddress)
 {
     GXTRACE(("svr_isTarget."), NULL);
     objectArray objects;
@@ -3559,6 +4122,8 @@
                         if (a->securitySetup->clientSystemTitle.size == 8)
                         {
                             settings->expectedClientSystemTitle = a->securitySetup->clientSystemTitle.data;
+                            memcpy(settings->preEstablishedSystemTitle, a->securitySetup->clientSystemTitle.data, 8);
+                            settings->cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
                         }
                         //GMac authentication uses innocation counter.
                         if (a->securitySetup == &securitySetupHighGMac)
@@ -3589,8 +4154,8 @@
     {
         // If address is not broadcast or serial number.
         //Remove logical address from the server address.
-        unsigned char broadcast = (serverAddress & 0x3FFF) == 0x3FFF || (serverAddress & 0x7F) == 0x7F;
-        if (!(broadcast ||
+        settings->cipher.broadcast = (serverAddress & 0x3FFF) == 0x3FFF || (serverAddress & 0x7F) == 0x7F;
+        if (!(settings->cipher.broadcast ||
             (serverAddress & 0x3FFF) == SERIAL_NUMBER % 10000 + 1000))
         {
             ret = 0;
@@ -3627,7 +4192,7 @@
             }
         }
         //Set serial number as meter address if broadcast is used.
-        if (broadcast)
+        if (settings->cipher.broadcast)
         {
             settings->serverAddress = SERIAL_NUMBER % 10000 + 1000;
         }
@@ -4299,7 +4864,7 @@
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
             if (trace > GX_TRACE_LEVEL_WARNING)
             {
-                if (first)
+                // if (first)
                 {
                     printf("\nRX:\t");
                     first = 0;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/VS/GuruxDLMS.c.vcxproj src/development/VS/GuruxDLMS.c.vcxproj
--- upstream/development/VS/GuruxDLMS.c.vcxproj	2024-01-23 14:13:59.000000000 +0000
+++ src/development/VS/GuruxDLMS.c.vcxproj	2024-11-13 12:20:09.000000000 +0000
@@ -265,43 +265,56 @@
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="..\src\apdu.c" />
+    <ClCompile Include="..\src\asn1Parser.c" />
+    <ClCompile Include="..\src\bigInteger.c" />
     <ClCompile Include="..\src\bitarray.c" />
     <ClCompile Include="..\src\bytebuffer.c" />
     <ClCompile Include="..\src\ciphering.c" />
     <ClCompile Include="..\src\client.c" />
     <ClCompile Include="..\src\converters.c" />
     <ClCompile Include="..\src\cosem.c" />
+    <ClCompile Include="..\src\curve.c" />
     <ClCompile Include="..\src\datainfo.c" />
     <ClCompile Include="..\src\date.c" />
     <ClCompile Include="..\src\dlms.c" />
     <ClCompile Include="..\src\dlmsSettings.c" />
+    <ClCompile Include="..\src\eccPoint.c" />
+    <ClCompile Include="..\src\gx509Certificate.c" />
     <ClCompile Include="..\src\gxaes.c" />
     <ClCompile Include="..\src\gxarray.c" />
+    <ClCompile Include="..\src\gxecdsa.c" />
     <ClCompile Include="..\src\gxget.c" />
     <ClCompile Include="..\src\gxinvoke.c" />
     <ClCompile Include="..\src\gxkey.c" />
     <ClCompile Include="..\src\gxmd5.c" />
     <ClCompile Include="..\src\gxobjects.c" />
+    <ClCompile Include="..\src\gxPkcs10.c" />
     <ClCompile Include="..\src\gxset.c" />
     <ClCompile Include="..\src\gxsetignoremalloc.c" />
     <ClCompile Include="..\src\gxsetmalloc.c" />
     <ClCompile Include="..\src\gxsha1.c" />
     <ClCompile Include="..\src\gxsha256.c" />
+    <ClCompile Include="..\src\gxsha384.c" />
     <ClCompile Include="..\src\gxvalueeventargs.c" />
     <ClCompile Include="..\src\helpers.c" />
     <ClCompile Include="..\src\message.c" />
     <ClCompile Include="..\src\notify.c" />
     <ClCompile Include="..\src\objectarray.c" />
     <ClCompile Include="..\src\parameters.c" />
+    <ClCompile Include="..\src\privateKey.c" />
+    <ClCompile Include="..\src\publicKey.c" />
     <ClCompile Include="..\src\replydata.c" />
     <ClCompile Include="..\src\gxserializer.c" />
     <ClCompile Include="..\src\server.c" />
     <ClCompile Include="..\src\serverevents.c" />
+    <ClCompile Include="..\src\shamirs.c" />
     <ClCompile Include="..\src\variant.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\include\apdu.h" />
+    <ClInclude Include="..\include\asn1Parser.h" />
     <ClInclude Include="..\include\bitarray.h" />
+    <ClInclude Include="..\include\bigInteger.h" />
     <ClInclude Include="..\include\bytebuffer.h" />
     <ClInclude Include="..\include\ciphering.h" />
     <ClInclude Include="..\include\cipheringenums.h" />
@@ -309,15 +322,19 @@
     <ClInclude Include="..\include\converters.h" />
     <ClInclude Include="..\include\cosem.h" />
     <ClInclude Include="..\include\crc.h" />
+    <ClInclude Include="..\include\curve.h" />
     <ClInclude Include="..\include\datainfo.h" />
     <ClInclude Include="..\include\date.h" />
     <ClInclude Include="..\include\dlms.h" />
     <ClInclude Include="..\include\dlmsSettings.h" />
+    <ClInclude Include="..\include\eccPoint.h" />
     <ClInclude Include="..\include\enums.h" />
     <ClInclude Include="..\include\errorCodes.h" />
+    <ClInclude Include="..\include\gx509Certificate.h" />
     <ClInclude Include="..\include\gxaes.h" />
     <ClInclude Include="..\include\gxarray.h" />
     <ClInclude Include="..\include\gxdefine.h" />
+    <ClInclude Include="..\include\gxecdsa.h" />
     <ClInclude Include="..\include\gxget.h" />
     <ClInclude Include="..\include\gxignore.h" />
     <ClInclude Include="..\include\gxint.h" />
@@ -326,11 +343,13 @@
     <ClInclude Include="..\include\gxmd5.h" />
     <ClInclude Include="..\include\gxmem.h" />
     <ClInclude Include="..\include\gxobjects.h" />
+    <ClInclude Include="..\include\gxPkcs10.h" />
     <ClInclude Include="..\include\gxset.h" />
     <ClInclude Include="..\include\gxsetignoremalloc.h" />
     <ClInclude Include="..\include\gxsetmalloc.h" />
     <ClInclude Include="..\include\gxsha1.h" />
     <ClInclude Include="..\include\gxsha256.h" />
+    <ClInclude Include="..\include\gxsha384.h" />
     <ClInclude Include="..\include\gxvalueeventargs.h" />
     <ClInclude Include="..\include\helpers.h" />
     <ClInclude Include="..\include\lnparameters.h" />
@@ -338,10 +357,13 @@
     <ClInclude Include="..\include\notify.h" />
     <ClInclude Include="..\include\objectarray.h" />
     <ClInclude Include="..\include\parameters.h" />
+    <ClInclude Include="..\include\privateKey.h" />
+    <ClInclude Include="..\include\publicKey.h" />
     <ClInclude Include="..\include\replydata.h" />
     <ClInclude Include="..\include\gxserializer.h" />
     <ClInclude Include="..\include\server.h" />
     <ClInclude Include="..\include\serverevents.h" />
+    <ClInclude Include="..\include\shamirs.h" />
     <ClInclude Include="..\include\snparameters.h" />
     <ClInclude Include="..\include\variant.h" />
   </ItemGroup>
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/VS/GuruxDLMS.c.vcxproj.filters src/development/VS/GuruxDLMS.c.vcxproj.filters
--- upstream/development/VS/GuruxDLMS.c.vcxproj.filters	2024-01-23 14:13:59.000000000 +0000
+++ src/development/VS/GuruxDLMS.c.vcxproj.filters	2024-11-13 12:20:09.000000000 +0000
@@ -112,6 +112,39 @@
     <ClCompile Include="..\src\gxsetignoremalloc.c">
       <Filter>src</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\gxsha384.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\bigInteger.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\privateKey.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\publicKey.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\curve.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\eccPoint.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\shamirs.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\gxecdsa.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\gxPkcs10.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\gx509Certificate.c">
+      <Filter>src</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\asn1Parser.c">
+      <Filter>src</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\include\apdu.h">
@@ -246,5 +279,38 @@
     <ClInclude Include="..\include\gxsetmalloc.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\include\gxsha384.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\bigInteger.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\publicKey.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\privateKey.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\curve.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\eccPoint.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\shamirs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\gxecdsa.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\gxPkcs10.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\gx509Certificate.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\asn1Parser.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/asn1Parser.h src/development/include/asn1Parser.h
--- upstream/development/include/asn1Parser.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/asn1Parser.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,58 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef ASN1PARSER_H
+#define ASN1PARSER_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "bytebuffer.h"   
+#include "gx509Certificate.h"       
+   
+    /*Parse X.509 certificate from byte array.*/
+    int asn1Parser_parsex509Certificate(
+        gx509Certificate* cert,
+        gxByteBuffer* data,
+        DLMS_X509_CERTIFICATE_DATA target,
+        uint8_t level,
+        uint8_t index);
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //ASN1PARSER_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/bigInteger.h src/development/include/bigInteger.h
--- upstream/development/include/bigInteger.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/bigInteger.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,172 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef BIG_INTEGER_H
+#define BIG_INTEGER_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#include "bytebuffer.h"
+
+#ifdef DLMS_SECURITY_SUITE_2
+#define BIG_INTERER_CAPACITY 80
+#else
+#define BIG_INTERER_CAPACITY 26
+#endif //DLMS_SECURITY_SUITE_2
+
+    typedef struct
+    {
+        //List of values. Least Significated is in the first item.
+        uint32_t* data;
+
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+        uint32_t capacity;
+        //Bit array size.
+        uint32_t size;
+#else
+        uint16_t capacity;
+        //Bit array size.
+        uint16_t size;
+#endif
+        /** Is value IsNegative.*/
+        unsigned char isNegative;
+        //Access big integer throught data. Don't use buff directly.
+        uint32_t buff[BIG_INTERER_CAPACITY];
+    } bigInteger;
+
+    /*Initialize default value.*/
+    void bi_init(bigInteger* arr);
+
+    /*Append value.*/
+    void bi_append(bigInteger* arr,
+        uint32_t value);
+
+    //Attach bit array.
+    int bi_attach(
+        bigInteger* arr,
+        uint32_t* value,
+        uint16_t count,
+        uint16_t capacity);
+
+    /*
+    * Is static big integer buffer used.
+    */
+    char bi_isAttached(
+        bigInteger* arr);
+
+    int bi_clear(bigInteger* arr);
+
+    //Copy big integer.
+    int bi_copy(bigInteger* target, bigInteger* source);
+
+    //Bit array capacity.
+    uint16_t bi_getCapacity(
+        bigInteger* arr);
+
+    /*
+  * Allocate new size for the bit array.
+  */
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    int bi_capacity(
+        bigInteger* arr,
+        uint32_t capacity);
+#else
+    int bi_capacity(
+        bigInteger* arr,
+        uint16_t capacity);
+#endif
+
+    /*
+    * Get size.
+    */
+    uint16_t bi_size(bigInteger* bb);
+
+    //Invert value.
+    int bi_inv(bigInteger* arr, bigInteger* value);
+    //Multiply value.
+    int bi_multiply(bigInteger* arr, bigInteger* value);
+    //Multiply value.
+    void bi_multiplyInt32(bigInteger* arr, int32_t value);
+    //Modulus.
+    int bi_mod(bigInteger* arr, bigInteger* mod);
+
+    //Push new values to the bit array.
+    int bi_addRange(
+        bigInteger* arr,
+        const uint32_t* values, uint16_t count);
+
+    //Push new value to big integer.
+    int bi_add(
+        bigInteger* arr,
+        const uint32_t item);
+
+    //Push new value to the big integer.
+    int bi_addBigInteger(bigInteger* arr, bigInteger* value);
+
+    void bi_sub(bigInteger* arr, bigInteger* value);
+
+#define BI_ATTACH(X, V, S) bi_attach(&X, V, S, 8 * sizeof(V)/sizeof(V[0]))
+
+    unsigned char bi_isZero(bigInteger* arr);
+
+    unsigned char bi_isEven(bigInteger* arr);
+
+    unsigned char bi_isOne(bigInteger* arr);
+
+    //Create biginteger from byte buffer.
+    int bi_fromByteBuffer(bigInteger* value, gxByteBuffer* bb);
+
+    //Convert big integer to byte buffer.
+    int bi_toArray(bigInteger* arr, gxByteBuffer* data);
+
+    //Used bits.
+    uint16_t bi_getUsedBits(bigInteger* bi);
+
+    //This method checks if the bit is set.
+    unsigned char bi_isBitSet(bigInteger* bi, uint16_t index);
+
+    /**
+     Compare biginter value to other big integer value.
+
+     Returns 1 is compared value is bigger, -1 if smaller and 0 if values are equals.     
+    */
+    int bi_compare(bigInteger* arr, bigInteger* value);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //BIG_INTEGER_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/bytebuffer.h src/development/include/bytebuffer.h
--- upstream/development/include/bytebuffer.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/bytebuffer.h	2024-11-13 12:20:09.000000000 +0000
@@ -48,7 +48,6 @@
 #endif //DESP_PLATFORM
 
 #define VECTOR_CAPACITY 50
-
     typedef struct
     {
 #if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
@@ -525,6 +524,16 @@
         gxByteBuffer* bb,
         char ch);
 
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    void bb_reverse(gxByteBuffer* bb,
+        uint32_t index,
+        uint32_t count);
+#else
+    void bb_reverse(gxByteBuffer* bb,
+        uint16_t index,
+        uint16_t count);
+#endif
+
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
     //Print content of byte buffer to cout.
     int bb_print(gxByteBuffer* bb);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/ciphering.h src/development/include/ciphering.h
--- upstream/development/include/ciphering.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/ciphering.h	2024-11-13 12:20:09.000000000 +0000
@@ -99,7 +99,7 @@
     unsigned char dedicatedKey[32];
 #endif //DLMS_IGNORE_MALLOC
     //Is data send as a broadcast or unicast.
-    unsigned char broacast;
+    unsigned char broadcast;
 } ciphering;
 
 
@@ -170,6 +170,21 @@
     gxByteBuffer* data,
     gxByteBuffer* output);
 
+//Show decoded PDU. 
+// This can be used to show decoded PDU. 
+//In default this is not used.
+//It's used after DLMS_TRACE_PDU is defined.
+#ifdef DLMS_TRACE_PDU
+/*
+* Show send or received PDU without ciphering. This can be use in debugging.
+* encrypt: If true, the data is encrypt (send) and if false, it's decrypted (received).
+* pdu: decrypted Pdu.
+*/
+extern void cip_tracePdu(
+    unsigned char encrypt,
+    gxByteBuffer* pdu);
+#endif //DLMS_TRACE_PDU
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/client.h src/development/include/client.h
--- upstream/development/include/client.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/client.h	2024-11-13 12:20:09.000000000 +0000
@@ -38,7 +38,7 @@
 #endif
 
 #include "gxignore.h"
-#if !(defined(DLMS_IGNORE_CLIENT) && defined(DLMS_IGNORE_MALLOC))
+#if !(defined(DLMS_IGNORE_CLIENT) || defined(DLMS_IGNORE_MALLOC))
 #ifdef DLMS_DEBUG
 #include "serverevents.h"
 #endif //DLMS_DEBUG
@@ -442,5 +442,5 @@
 #ifdef  __cplusplus
 }
 #endif
-#endif //!defined(DLMS_IGNORE_CLIENT) && !defined(DLMS_IGNORE_MALLOC)
+#endif //!(defined(DLMS_IGNORE_CLIENT) || defined(DLMS_IGNORE_MALLOC))
 #endif //CLIENT_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/cosem.h src/development/include/cosem.h
--- upstream/development/include/cosem.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/cosem.h	2024-11-13 12:20:09.000000000 +0000
@@ -157,6 +157,10 @@
   int cosem_getIntegerFromBitString(gxByteBuffer* bb, uint32_t* value);
 
   int cosem_getVariant(gxByteBuffer* bb, dlmsVARIANT* value);
+  
+  /*Updated variant data type must be the same as the existing value.
+  E.g. limiter uses this.*/
+  int cosem_getVariantExact(gxByteBuffer* bb, dlmsVARIANT* value);
 
   int cosem_getEnum(gxByteBuffer* bb, unsigned char* value);
 
@@ -206,7 +210,21 @@
   int cosem_setArray(gxByteBuffer* bb, uint16_t count);
   int cosem_setEnum(gxByteBuffer* bb, unsigned char value);
   int cosem_setBoolean(gxByteBuffer* bb, unsigned char value);
-
+#ifndef DLMS_IGNORE_DELTA
+  int cosem_setDeltaInt8(gxByteBuffer* bb, char value);
+  int cosem_setDeltaInt16(gxByteBuffer* bb, int16_t value);
+  int cosem_setDeltaInt32(gxByteBuffer* bb, int32_t value);
+  int cosem_setDeltaUInt8(gxByteBuffer* bb, unsigned char value);
+  int cosem_setDeltaUInt16(gxByteBuffer* bb, uint16_t value);
+  int cosem_setDeltaUInt32(gxByteBuffer* bb, uint32_t value);
+
+  int cosem_getDeltaUInt8(gxByteBuffer* bb, unsigned char* value);
+  int cosem_getDeltaUInt16(gxByteBuffer* bb, uint16_t* value);
+  int cosem_getDeltaUInt32(gxByteBuffer* bb, uint32_t* value);
+  int cosem_getDeltaInt8(gxByteBuffer* bb, signed char* value);
+  int cosem_getDeltaInt16(gxByteBuffer* bb, int16_t* value);
+  int cosem_getDeltaInt32(gxByteBuffer* bb, int32_t* value);
+#endif //DLMS_IGNORE_DELTA
 #ifndef DLMS_IGNORE_PROFILE_GENERIC
   int cosem_getColumns(
       gxArray* captureObjects,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/curve.h src/development/include/curve.h
--- upstream/development/include/curve.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/curve.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,76 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef CURVE_H
+#define CURVE_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#include "enums.h"
+#include "bigInteger.h"
+#include "eccPoint.h"
+
+    typedef struct
+    {
+        /**
+        * ECC curve a value.
+        */
+        bigInteger a;
+        /**
+        * ECC curve p value.
+        */
+        bigInteger p;
+        /**
+        * ECC curve b parameter.
+        */
+        bigInteger b;
+        /**
+         x and y-coordinate of base point G
+        */
+        gxEccPoint g;
+        /**
+         Order of point G in ECC curve.
+        */
+        bigInteger n;
+    } gxCurve;
+
+    /*Initialize curve.*/
+    int curve_init(gxCurve* curve, ECC scheme);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //CURVE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/datainfo.h src/development/include/datainfo.h
--- upstream/development/include/datainfo.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/datainfo.h	2024-11-13 12:20:09.000000000 +0000
@@ -51,10 +51,6 @@
     DLMS_DATA_TYPE type;
     // Is data parsed to the end.
     unsigned char complete;
-#ifdef DLMS_ITALIAN_STANDARD
-    //Some meters require that there is a array count in data.
-    unsigned char appendAA;
-#endif //DLMS_ITALIAN_STANDARD
 } gxDataInfo;
 
 void di_init(gxDataInfo *info);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/date.h src/development/include/date.h
--- upstream/development/include/date.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/date.h	2024-11-13 12:20:09.000000000 +0000
@@ -83,6 +83,8 @@
 #else
         struct tm value;
 #endif
+        /*Milliseconds.*/
+        uint16_t millisecond;
         int16_t deviation;
         DATETIME_SKIPS skip : 16;
         DLMS_DATE_TIME_EXTRA_INFO extraInfo : 8;
@@ -236,12 +238,23 @@
         gxtime* value);
 
     /*
+    Returns the date.
+*/
+    uint32_t time_getDate(uint32_t value);
+
+    /*
     Clears time part.
     */
     void time_clearTime(
         gxtime* value);
 
     /*
+    Returns the time.
+    */
+    uint32_t time_getTime(uint32_t value);
+
+
+    /*
     Clears hours.
     */
     void time_clearHours(
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/dlms.h src/development/include/dlms.h
--- upstream/development/include/dlms.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/dlms.h	2024-11-13 12:20:09.000000000 +0000
@@ -48,7 +48,6 @@
 #include "replydata.h"
 #include "datainfo.h"
 #include "parameters.h"
-
     //Makes sure that the basic settings are set.
     int dlms_checkInit(
         dlmsSettings* settings);
@@ -102,22 +101,22 @@
     int dlms_setData(
         gxByteBuffer* data,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 
 #if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
     //Set data from DLMS Varuant to DLMS byte stream.
     int dlms_setData2(
-        unsigned char *buff,
+        unsigned char* buff,
         uint32_t length,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 #else
     //Set data from DLMS Varuant to DLMS byte stream.
     int dlms_setData2(
-        unsigned char *buff,
+        unsigned char* buff,
         uint16_t length,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 #endif
 
     int dlms_receiverReady(
@@ -141,7 +140,7 @@
     int dlms_getData(
         gxByteBuffer* data,
         gxDataInfo* info,
-        dlmsVARIANT *value);
+        dlmsVARIANT* value);
 
 #ifndef DLMS_IGNORE_ASSOCIATION_SHORT_NAME
     /**
@@ -181,14 +180,14 @@
 #endif //DLMS_IGNORE_WRAPPER
 
     int dlms_changeType2(
-        dlmsVARIANT *value,
+        dlmsVARIANT* value,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *newValue);
+        dlmsVARIANT* newValue);
 
     int dlms_changeType(
         gxByteBuffer* value,
         DLMS_DATA_TYPE type,
-        dlmsVARIANT *newValue);
+        dlmsVARIANT* newValue);
 
 
     int dlms_getPdu(
@@ -220,7 +219,7 @@
          * @return    Status code.
          */
     int dlms_getLnMessages(
-        gxLNParameters *p,
+        gxLNParameters* p,
         message* reply);
 
 #ifndef DLMS_IGNORE_HDLC
@@ -249,13 +248,13 @@
     * @return    Status code.
     */
     int dlms_getSnMessages(
-        gxSNParameters *p,
+        gxSNParameters* p,
         message* reply);
 
     int dlms_getActionInfo(
         DLMS_OBJECT_TYPE objectType,
-        unsigned char *value,
-        unsigned char *count);
+        unsigned char* value,
+        unsigned char* count);
 #endif // DLMS_IGNORE_ASSOCIATION_SHORT_NAME
 
     int dlms_generateChallenge(
@@ -293,6 +292,12 @@
         dlmsSettings* settings,
         gxByteBuffer* data,
         uint16_t* size);
+
+    //Ths method returns the amount of availabe bytes in PDU.
+    int dlms_pduAvailable(
+        dlmsSettings* settings,
+        gxByteBuffer* data,
+        uint16_t* size);
 
     int dlms_getMacFrame(
         dlmsSettings* settings,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/dlmssettings.h src/development/include/dlmssettings.h
--- upstream/development/include/dlmssettings.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/dlmssettings.h	2024-11-13 12:20:09.000000000 +0000
@@ -132,7 +132,6 @@
         uint16_t clientAddress;
         //Server address.
         uint32_t serverAddress;
-
         unsigned char useLogicalNameReferencing;
         DLMS_INTERFACE_TYPE interfaceType;
         DLMS_AUTHENTICATION authentication;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/eccPoint.h src/development/include/eccPoint.h
--- upstream/development/include/eccPoint.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/eccPoint.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,63 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef ECCPOINT_H
+#define ECCPOINT_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#include "bigInteger.h"
+
+    /*ECC x and y points in the curve.*/
+    typedef struct
+    {
+        /**
+        * x point.
+        */
+        bigInteger x;
+        /**
+        * y point.
+        */
+        bigInteger y;
+    } gxEccPoint;
+
+    /*Initialize curve.*/
+    int eccPoint_init(gxEccPoint* point);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //ECCPOINT_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/enums.h src/development/include/enums.h
--- upstream/development/include/enums.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/enums.h	2024-11-13 12:20:09.000000000 +0000
@@ -159,7 +159,7 @@
         */
         DLMS_SECURITY_SUITE_V1 = 1,
         /*
-            AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap        
+            AES-GCM-256 authenticated encryption, ECDSA P-384 digital signature, ECDH P-384 key agreement, SHA-384 hash, V.44 compression and AES-256 key wrap
         */
         DLMS_SECURITY_SUITE_V2 = 2
     } DLMS_SECURITY_SUITE;
@@ -173,7 +173,13 @@
         DLMS_SERVICE_TYPE_SMS = 4,
         DLMS_SERVICE_TYPE_HDLC = 5,
         DLMS_SERVICE_TYPE_M_BUS = 6,
-        DLMS_SERVICE_TYPE_ZIG_BEE = 7
+        DLMS_SERVICE_TYPE_ZIG_BEE = 7,
+        /*DLMS Gateway.*/
+        DLMS_SERVICE_TYPE_DLMS_GATEWAY = 8,
+        /*Reliable CoAP.*/
+        DLMS_SERVICE_TYPE_RELIABLE_COAP = 9,
+        /*Unreliable CoAP.*/
+        DLMS_SERVICE_TYPE_UNRELIABLE_COAP = 10
     } DLMS_SERVICE_TYPE;
 
     typedef enum
@@ -183,6 +189,50 @@
         DLMS_MESSAGE_TYPE_MANUFACTURER_SPESIFIC = 128
     } DLMS_MESSAGE_TYPE;
 
+    /*Push operation method defines what service class is used with push messages.*/
+    typedef enum
+    {
+        /**
+        * Unconfirmed, retry on supporting protocol layer failure.
+        */
+        DLMS_PUSH_OPERATION_METHOD_UNCONFIRMED_FAILURE = 0,
+        /**
+         * Unconfirmed, retry on missing supporting protocol layer confirmation.
+         */
+        DLMS_PUSH_OPERATION_METHOD_UNCONFIRMED_MISSING,
+        /**
+         * Confirmed, retry on missing confirmation.
+         */
+        DLMS_PUSH_OPERATION_METHOD_CONFIRMED
+    } DLMS_PUSH_OPERATION_METHOD;
+
+    /*Data protection identified key types.*/
+    typedef enum
+    {
+        /*Global unicast encryption key.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE_UNICAST_ENCRYPTION,
+        /*Global broadcast encryption key.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE_BROADCAST_ENCRYPTION
+    }DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE;
+
+    /*Data protection wrapped key types.*/
+    typedef enum
+    {
+        /*Master key.*/
+        DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE_MASTER_KEY = 0
+    }DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE;
+
+    /*Enumerates data protection key types.*/
+    typedef enum
+    {
+        /*Identified key.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED,
+        /*Wrapped key.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED,
+        /*Agreed.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE_AGREED
+    }DLMS_DATA_PROTECTION_KEY_TYPE;
+    
     typedef enum
     {
         DLMS_CLOCK_STATUS_OK = 0x0,
@@ -395,7 +445,28 @@
         * Function control.
         */
         DLMS_OBJECT_TYPE_FUNCTION_CONTROL = 122,
-            
+
+        // Communication port protection.
+        DLMS_OBJECT_TYPE_COMMUNICATION_PORT_PROTECTION = 124,
+
+        // LTE monitoring.
+        DLMS_OBJECT_TYPE_LTE_MONITORING = 151,
+
+        // CoAP setup.
+        DLMS_OBJECT_TYPE_COAP_SETUP = 152,
+
+        // CoAP diagnostic.
+        DLMS_OBJECT_TYPE_COAP_DIAGNOSTIC = 153,
+
+        // G3-PLC Hybrid RF MAC layer counters.
+        DLMS_OBJECT_TYPE_G3_PLC_HYBRID_RF_MAC_LAYER_COUNTERS = 160,
+
+        // G3-PLC Hybrid RF MAC setup.
+        DLMS_OBJECT_TYPE_G3_PLC_HYBRID_RF_MAC_SETUP = 161,
+
+        // G3-PLC Hybrid 6LoWPAN adaptation layer setup.
+        DLMS_OBJECT_TYPE_G3_PLC_HYBRID_6LOWPAN_ADAPTATION_LAYER_SETUP = 162,
+        
         /*
         * Configure a ZigBee PRO device with information necessary to create or
         * join the network.
@@ -442,18 +513,21 @@
     typedef enum
     {
         DLMS_DATA_TYPE_NONE = 0,
+        DLMS_DATA_TYPE_ARRAY = 1,
+        DLMS_DATA_TYPE_STRUCTURE = 2,
         DLMS_DATA_TYPE_BOOLEAN = 3,
         DLMS_DATA_TYPE_BIT_STRING = 4,
         DLMS_DATA_TYPE_INT32 = 5,
         DLMS_DATA_TYPE_UINT32 = 6,
         DLMS_DATA_TYPE_OCTET_STRING = 9,
         DLMS_DATA_TYPE_STRING = 10,
-        DLMS_DATA_TYPE_BINARY_CODED_DESIMAL = 13,
         DLMS_DATA_TYPE_STRING_UTF8 = 12,
+        DLMS_DATA_TYPE_BINARY_CODED_DESIMAL = 13,
         DLMS_DATA_TYPE_INT8 = 15,
         DLMS_DATA_TYPE_INT16 = 16,
         DLMS_DATA_TYPE_UINT8 = 17,
         DLMS_DATA_TYPE_UINT16 = 18,
+        DLMS_DATA_TYPE_COMPACT_ARRAY = 19,
         DLMS_DATA_TYPE_INT64 = 20,
         DLMS_DATA_TYPE_UINT64 = 21,
         DLMS_DATA_TYPE_ENUM = 22,
@@ -462,9 +536,12 @@
         DLMS_DATA_TYPE_DATETIME = 25,
         DLMS_DATA_TYPE_DATE = 26,
         DLMS_DATA_TYPE_TIME = 27,
-        DLMS_DATA_TYPE_ARRAY = 1,
-        DLMS_DATA_TYPE_STRUCTURE = 2,
-        DLMS_DATA_TYPE_COMPACT_ARRAY = 19,
+        DLMS_DATA_TYPE_DELTA_INT8 = 28,
+        DLMS_DATA_TYPE_DELTA_INT16 = 29,
+        DLMS_DATA_TYPE_DELTA_INT32 = 30,
+        DLMS_DATA_TYPE_DELTA_UINT8 = 31,
+        DLMS_DATA_TYPE_DELTA_UINT16 = 32,
+        DLMS_DATA_TYPE_DELTA_UINT32 = 33,
         DLMS_DATA_TYPE_BYREF = 0x80
     } DLMS_DATA_TYPE;
 
@@ -744,6 +821,14 @@
         */
         BER_TYPE_UTF8_STRING = 12,
         /*
+        * Sequence.
+        */
+        BER_TYPE_SEQUENCE = 16,
+        /*
+        * Set.
+        */
+        BER_TYPE_SET = 17,
+        /*
         * Numeric string.
         */
         BER_TYPE_NUMERIC_STRING = 18,
@@ -1998,489 +2083,489 @@
     /*
     * Enumerates all Unit constants.
     */
-    typedef enum 
+    typedef enum
     {
-    /*
-    * No Unit.
-    */
-    DLMS_UNIT_NONE = 0,
-    /*
-    * Year.
-    */
-    DLMS_UNIT_YEAR = 1,
+        /*
+        * No Unit.
+        */
+        DLMS_UNIT_NONE = 0,
+        /*
+        * Year.
+        */
+        DLMS_UNIT_YEAR = 1,
 
-    /*
-    * Month.
-    */
-    DLMS_UNIT_MONTH = 2,
+        /*
+        * Month.
+        */
+        DLMS_UNIT_MONTH = 2,
 
-    /*
-    * Week.
-    */
-    DLMS_UNIT_WEEK = 3,
+        /*
+        * Week.
+        */
+        DLMS_UNIT_WEEK = 3,
 
-    /*
-    * Day.
-    */
-    DLMS_UNIT_DAY = 4,
+        /*
+        * Day.
+        */
+        DLMS_UNIT_DAY = 4,
 
-    /*
-    * Hour.
-    */
-    DLMS_UNIT_HOUR = 5,
+        /*
+        * Hour.
+        */
+        DLMS_UNIT_HOUR = 5,
 
-    /*
-    * Minute.
-    */
-    DLMS_UNIT_MINUTE = 6,
+        /*
+        * Minute.
+        */
+        DLMS_UNIT_MINUTE = 6,
 
-    /*
-    * Second.
-    */
-    DLMS_UNIT_SECOND = 7,
+        /*
+        * Second.
+        */
+        DLMS_UNIT_SECOND = 7,
 
-    /*
-    * Phase angle degree.
-    */
-    DLMS_UNIT_PHASE_ANGLE_DEGREE = 8,
-    /*
-    * Temperature T degree centigrade, rad*180/p.
-    */
-    DLMS_UNIT_TEMPERATURE = 9,
-    /*
-    * Local currency.
-    */
-    DLMS_UNIT_LOCAL_CURRENCY = 10,
-    /*
-    * Length l meter m.
-    */
-    DLMS_UNIT_LENGTH = 11,
-    /*
-    * Speed v m/s.
-    */
-    DLMS_UNIT_SPEED = 12,
-    /*
-    * Volume V m3.
-    */
-    DLMS_UNIT_VOLUME_CUBIC_METER = 13,
-    /*
-    * Corrected volume m3.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME = 14,
-    /*
-    * Volume flux m3/60*60s.
-    */
-    DLMS_UNIT_VOLUME_FLUX_HOUR = 15,
-    /*
-    * Corrected volume flux m3/60*60s.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME_FLUX_HOUR = 16,
-    /*
-    * Volume flux m3/24*60*60s.
-    */
-    DLMS_UNIT_VOLUME_FLUX_DAY = 17,
-    /*
-    * Corrected volume flux m3/24*60*60s.
-    */
-    DLMS_UNIT_CORRECTED_VOLUME_FLUX_DAY = 18,
-    /*
-    * Volume 10-3 m3.
-    */
-    DLMS_UNIT_VOLUME_LITER = 19,
-    /*
-    * Mass m kilogram kg.
-    */
-    DLMS_UNIT_MASS_KG = 20,
-    /*
-    * return "Force F newton N.
-    */
-    DLMS_UNIT_FORCE = 21,
-    /*
-    * Energy newtonmeter J = Nm = Ws.
-    */
-    DLMS_UNIT_ENERGY = 22,
-    /*
-    * Pressure p pascal N/m2.
-    */
-    DLMS_UNIT_PRESSURE_PASCAL = 23,
-    /*
-    * Pressure p bar 10-5 N/m2.
-    */
-    DLMS_UNIT_PRESSURE_BAR = 24,
-    /*
-    * Energy joule J = Nm = Ws.
-    */
-    DLMS_UNIT_ENERGY_JOULE = 25,
-    /*
-    * Thermal power J/60*60s.
-    */
-    DLMS_UNIT_THERMAL_POWER = 26,
-    /*
-    * Active power P watt W = J/s.
-    */
-    DLMS_UNIT_ACTIVE_POWER = 27,
-    /*
-    * Apparent power S.
-    */
-    DLMS_UNIT_APPARENT_POWER = 28,
-    /*
-    * Reactive power Q.
-    */
-    DLMS_UNIT_REACTIVE_POWER = 29,
-    /*
-    * Active energy W*60*60s.
-    */
-    DLMS_UNIT_ACTIVE_ENERGY = 30,
-    /*
-    * Apparent energy VA*60*60s.
-    */
-    DLMS_UNIT_APPARENT_ENERGY = 31,
-    /*
-    * Reactive energy var*60*60s.
-    */
-    DLMS_UNIT_REACTIVE_ENERGY = 32,
-    /*
-    * Current I ampere A.
-    */
-    DLMS_UNIT_CURRENT = 33,
-    /*
-    * Electrical charge Q coulomb C = As.
-    */
-    DLMS_UNIT_ELECTRICAL_CHARGE = 34,
-    /*
-    * Voltage.
-    */
-    DLMS_UNIT_VOLTAGE = 35,
-    /*
-    * Electrical field strength E V/m.
-    */
-    DLMS_UNIT_ELECTRICAL_FIELD_STRENGTH = 36,
-    /*
-    * Capacity C farad C/V = As/V.
-    */
-    DLMS_UNIT_CAPACITY = 37,
-    /*
-    * Resistance R ohm = V/A.
-    */
-    DLMS_UNIT_RESISTANCE = 38,
-    /*
-    * Resistivity.
-    */
-    DLMS_UNIT_RESISTIVITY = 39,
-    /*
-    * Magnetic flux F weber Wb = Vs.
-    */
-    DLMS_UNIT_MAGNETIC_FLUX = 40,
-    /*
-    * Induction T tesla Wb/m2.
-    */
-    DLMS_UNIT_INDUCTION = 41,
-    /*
-    * Magnetic field strength H A/m.
-    */
-    DLMS_UNIT_MAGNETIC = 42,
-    /*
-    * Inductivity L henry H = Wb/A.
-    */
-    DLMS_UNIT_INDUCTIVITY = 43,
-    /*
-    * Frequency f.
-    */
-    DLMS_UNIT_FREQUENCY = 44,
-    /*
-    * Active energy meter constant 1/Wh.
-    */
-    DLMS_UNIT_ACTIVE = 45,
-    /*
-    * Reactive energy meter constant.
-    */
-    DLMS_UNIT_REACTIVE = 46,
-    /*
-    * Apparent energy meter constant.
-    */
-    DLMS_UNIT_APPARENT = 47,
-    /*
-    * V260*60s.
-    */
-    DLMS_UNIT_V260 = 48,
-    /*
-    * A260*60s.
-    */
-    DLMS_UNIT_A260 = 49,
-    /*
-    * Mass flux kg/s.
-    */
-    DLMS_UNIT_MASS_KG_PER_SECOND = 50,
-    /*
-    * Unit is Conductance siemens 1/ohm.
-    */
-    DLMS_UNIT_CONDUCTANCE = 51,
-    /*
-    * Temperature in Kelvin.
-    */
-    DLMS_UNIT_KELVIN = 52,
-    /*
-    * 1/(V2h) RU2h , volt-squared hour meter constant or pulse value.
-    */
-    DLMS_UNIT_RU2H = 53,
-    /*
-    * 1/(A2h) RI2h , ampere-squared hour meter constant or pulse value.
-    */
-    DLMS_UNIT_RI2H = 54,
-    /*
-    * 1/m3 RV , meter constant or pulse value  = volume).
-    */
-    DLMS_UNIT_CUBIC_METER_RV = 55,
-    /*
-    * Percentage.
-    */
-    DLMS_UNIT_PERCENTAGE = 56,
-    /*
-    * Ah ampere hours.
-    */
-    DLMS_UNIT_AMPERE_HOURS = 57,
-    /*
-    * Wh/m3 energy per volume 3,6*103 J/m3.
-    */
-    DLMS_UNIT_ENERGY_PER_VOLUME = 60,
-    /*
-    * J/m3 calorific value, wobbe.
-    */
-    DLMS_UNIT_WOBBE = 61,
-    /*
-    * Mol % molar fraction of gas composition mole percent  = Basic gas
-    * composition unit).
-    */
-    DLMS_UNIT_MOLE_PERCENT = 62,
-    /*
-    * g/m3 mass density, quantity of material.
-    */
-    DLMS_UNIT_MASS_DENSITY = 63,
-    /*
-    * Dynamic viscosity pascal second  = Characteristic of gas stream).
-    */
-    DLMS_UNIT_PASCAL_SECOND = 64,
-    /*
-    * J/kg Specific energy NOTE The amount of energy per unit of mass of a
-    * substance Joule / kilogram m2 . kg . s -2 / kg = m2.
-    */
-    DLMS_UNIT_JOULE_KILOGRAM = 65,
-    /*
-    * Pressure, gram per square centimeter.
-    */
-    DLMS_UNIT_PRESSURE_GRAM_PER_SQUARE_CENTIMETER = 66,
-    /*
-    * Pressure, atmosphere.
-    */
-    DLMS_UNIT_PRESSURE_ATMOSPHERE = 67,
-    /*
-    * Signal strength, dB milliwatt (e.g. of GSM radio systems)
-    */
-    DLMS_UNIT_SIGNAL_STRENGTH_MILLI_WATT = 70,
-    /*
-    * Signal strength, dB microvolt.
-    */
-    DLMS_UNIT_SIGNAL_STRENGTH_MICRO_VOLT = 71,
-    /*
-    * Logarithmic unit that expresses the ratio between two values of a physical quantity
-    */
-    DLMS_UNIT_DB = 72,
-    /*
-    * Length in inches.
-    */
-    DLMS_UNIT_INCH = 128,
-    /*
-    * Foot (Length).
-    */
-    DLMS_UNIT_FOOT = 129,
-    /*
-    * Pound (mass).
-    */
-    DLMS_UNIT_POUND = 130,
-    /*
-    * Fahrenheit.
-    */
-    DLMS_UNIT_FAHRENHEIT = 131,
-    /*
-    * Rankine.
-    */
-    DLMS_UNIT_RANKINE = 132,
-    /*
-    * Square inch.
-    */
-    DLMS_UNIT_SQUARE_INCH = 133,
-    /*
-    * Square foot.
-    */
-    DLMS_UNIT_SQUARE_FOOT = 134,
-    /*
-    * Acre.
-    */
-    DLMS_UNIT_ACRE = 135,
-    /*
-    * Cubic inch.
-    */
-    DLMS_UNIT_CUBIC_INCH = 136,
-    /*
-    * Cubic foot.
-    */
-    DLMS_UNIT_CUBIC_FOOT = 137,
-    /*
-    * Acre foot.
-    */
-    DLMS_UNIT_ACRE_FOOT = 138,
-    /*
-    * Gallon (imperial).
-    */
-    DLMS_UNIT_GALLON_IMPERIAL = 139,
-    /*
-    *  Gallon (US).
-    */
-    DLMS_UNIT_GALLON_US = 140,
-    /*
-    * Pound force.
-    */
-    DLMS_UNIT_POUND_FORCE = 141,
-    /*
-    * Pound force per square inch.
-    */
-    DLMS_UNIT_POUND_FORCE_PER_SQUARE_INCH = 142,
-    /*
-    * Pound per cubic foot.
-    */
-    DLMS_UNIT_POUND_PER_CUBIC_FOOT = 143,
-    /*
-    * Pound per (foot second).
-    */
-    DLMS_UNIT_POUND_PER_FOOT_SECOND = 144,
-    /*
-    * Square foot per second.
-    */
-    DLMS_UNIT_SQUARE_FOOT_PER_SECOND = 145,
-    /*
-    * British thermal unit.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT = 146,
-    /*
-    * Therm EU.
-    */
-    DLMS_UNIT_THERM_EU = 147,
-    /*
-    * Therm US.
-    */
-    DLMS_UNIT_THERM_US = 148,
-    /*
-    * British thermal unit per pound.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_POUND = 149,
-    /*
-    * British thermal unit per cubic foot.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_CUBIC_FOOT = 150,
-    /*
-    * Cubic feet.
-    */
-    DLMS_UNIT_CUBIC_FEET = 151,
-    /*
-    * Foot per second.
-    */
-    DLMS_UNIT_FOOT_PER_SECOND = 152,
-    /*
-    * Cubic foot per second.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_SECOND = 153,
-    /*
-    * Cubic foot per min.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_MIN = 154,
-    /*
-    * Cubic foot per hour.
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_HOUR = 155,
-    /*
-    * Cubic foot per day
-    */
-    DLMS_UNIT_CUBIC_FOOT_PER_DAY = 156,
-    /*
-    * Acre foot per second.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_SECOND = 157,
-    /*
-    * Acre foot per min.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_MIN = 158,
-    /*
-    *  Acre foot per hour.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_HOUR = 159,
-    /*
-    *  Acre foot per day.
-    */
-    DLMS_UNIT_ACRE_FOOT_PER_DAY = 160,
-    /*
-    * Imperial gallon.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON = 161,
-    /*
-    * Imperial gallon per second.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_SECOND = 162,
-    /*
-    * Imperial gallon per min.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_MIN = 163,
-    /*
-    * Imperial gallon per hour.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_HOUR = 164,
-    /*
-    * Imperial gallon per day.
-    */
-    DLMS_UNIT_IMPERIAL_GALLON_PER_DAY = 165,
-    /*
-    * US gallon.
-    */
-    DLMS_UNIT_US_GALLON = 166,
-    /*
-    * US gallon per second.
-    */
-    DLMS_UNIT_US_GALLON_PER_SECOND = 167,
-    /*
-    * US gallon per min.
-    */
-    DLMS_UNIT_US_GALLON_PER_MIN = 168,
-    /*
-    * US gallon per hour.
-    */
-    DLMS_UNIT_US_GALLON_PER_HOUR = 169,
-    /*
-    * US gallon per day.
-    */
-    DLMS_UNIT_US_GALLON_PER_DAY = 170,
-    /*
-    * British thermal unit per second.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_SECOND = 171,
-    /*
-    * British thermal unit per minute.
-    */        
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_MIN = 172,
-    /*
-    * British thermal unit per hour.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_HOUR = 173,
-    /*
-    * British thermal unit per day.
-    */
-    DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_DAY = 174,
-    /*
-    * Other Unit.
-    */
-    DLMS_UNIT_OTHER = 254,
-    /*
-    * No Unit.
-    */
-    DLMS_UNIT_NO_UNIT = 255
+        /*
+        * Phase angle degree.
+        */
+        DLMS_UNIT_PHASE_ANGLE_DEGREE = 8,
+        /*
+        * Temperature T degree centigrade, rad*180/p.
+        */
+        DLMS_UNIT_TEMPERATURE = 9,
+        /*
+        * Local currency.
+        */
+        DLMS_UNIT_LOCAL_CURRENCY = 10,
+        /*
+        * Length l meter m.
+        */
+        DLMS_UNIT_LENGTH = 11,
+        /*
+        * Speed v m/s.
+        */
+        DLMS_UNIT_SPEED = 12,
+        /*
+        * Volume V m3.
+        */
+        DLMS_UNIT_VOLUME_CUBIC_METER = 13,
+        /*
+        * Corrected volume m3.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME = 14,
+        /*
+        * Volume flux m3/60*60s.
+        */
+        DLMS_UNIT_VOLUME_FLUX_HOUR = 15,
+        /*
+        * Corrected volume flux m3/60*60s.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME_FLUX_HOUR = 16,
+        /*
+        * Volume flux m3/24*60*60s.
+        */
+        DLMS_UNIT_VOLUME_FLUX_DAY = 17,
+        /*
+        * Corrected volume flux m3/24*60*60s.
+        */
+        DLMS_UNIT_CORRECTED_VOLUME_FLUX_DAY = 18,
+        /*
+        * Volume 10-3 m3.
+        */
+        DLMS_UNIT_VOLUME_LITER = 19,
+        /*
+        * Mass m kilogram kg.
+        */
+        DLMS_UNIT_MASS_KG = 20,
+        /*
+        * return "Force F newton N.
+        */
+        DLMS_UNIT_FORCE = 21,
+        /*
+        * Energy newtonmeter J = Nm = Ws.
+        */
+        DLMS_UNIT_ENERGY = 22,
+        /*
+        * Pressure p pascal N/m2.
+        */
+        DLMS_UNIT_PRESSURE_PASCAL = 23,
+        /*
+        * Pressure p bar 10-5 N/m2.
+        */
+        DLMS_UNIT_PRESSURE_BAR = 24,
+        /*
+        * Energy joule J = Nm = Ws.
+        */
+        DLMS_UNIT_ENERGY_JOULE = 25,
+        /*
+        * Thermal power J/60*60s.
+        */
+        DLMS_UNIT_THERMAL_POWER = 26,
+        /*
+        * Active power P watt W = J/s.
+        */
+        DLMS_UNIT_ACTIVE_POWER = 27,
+        /*
+        * Apparent power S.
+        */
+        DLMS_UNIT_APPARENT_POWER = 28,
+        /*
+        * Reactive power Q.
+        */
+        DLMS_UNIT_REACTIVE_POWER = 29,
+        /*
+        * Active energy W*60*60s.
+        */
+        DLMS_UNIT_ACTIVE_ENERGY = 30,
+        /*
+        * Apparent energy VA*60*60s.
+        */
+        DLMS_UNIT_APPARENT_ENERGY = 31,
+        /*
+        * Reactive energy var*60*60s.
+        */
+        DLMS_UNIT_REACTIVE_ENERGY = 32,
+        /*
+        * Current I ampere A.
+        */
+        DLMS_UNIT_CURRENT = 33,
+        /*
+        * Electrical charge Q coulomb C = As.
+        */
+        DLMS_UNIT_ELECTRICAL_CHARGE = 34,
+        /*
+        * Voltage.
+        */
+        DLMS_UNIT_VOLTAGE = 35,
+        /*
+        * Electrical field strength E V/m.
+        */
+        DLMS_UNIT_ELECTRICAL_FIELD_STRENGTH = 36,
+        /*
+        * Capacity C farad C/V = As/V.
+        */
+        DLMS_UNIT_CAPACITY = 37,
+        /*
+        * Resistance R ohm = V/A.
+        */
+        DLMS_UNIT_RESISTANCE = 38,
+        /*
+        * Resistivity.
+        */
+        DLMS_UNIT_RESISTIVITY = 39,
+        /*
+        * Magnetic flux F weber Wb = Vs.
+        */
+        DLMS_UNIT_MAGNETIC_FLUX = 40,
+        /*
+        * Induction T tesla Wb/m2.
+        */
+        DLMS_UNIT_INDUCTION = 41,
+        /*
+        * Magnetic field strength H A/m.
+        */
+        DLMS_UNIT_MAGNETIC = 42,
+        /*
+        * Inductivity L henry H = Wb/A.
+        */
+        DLMS_UNIT_INDUCTIVITY = 43,
+        /*
+        * Frequency f.
+        */
+        DLMS_UNIT_FREQUENCY = 44,
+        /*
+        * Active energy meter constant 1/Wh.
+        */
+        DLMS_UNIT_ACTIVE = 45,
+        /*
+        * Reactive energy meter constant.
+        */
+        DLMS_UNIT_REACTIVE = 46,
+        /*
+        * Apparent energy meter constant.
+        */
+        DLMS_UNIT_APPARENT = 47,
+        /*
+        * V260*60s.
+        */
+        DLMS_UNIT_V260 = 48,
+        /*
+        * A260*60s.
+        */
+        DLMS_UNIT_A260 = 49,
+        /*
+        * Mass flux kg/s.
+        */
+        DLMS_UNIT_MASS_KG_PER_SECOND = 50,
+        /*
+        * Unit is Conductance siemens 1/ohm.
+        */
+        DLMS_UNIT_CONDUCTANCE = 51,
+        /*
+        * Temperature in Kelvin.
+        */
+        DLMS_UNIT_KELVIN = 52,
+        /*
+        * 1/(V2h) RU2h , volt-squared hour meter constant or pulse value.
+        */
+        DLMS_UNIT_RU2H = 53,
+        /*
+        * 1/(A2h) RI2h , ampere-squared hour meter constant or pulse value.
+        */
+        DLMS_UNIT_RI2H = 54,
+        /*
+        * 1/m3 RV , meter constant or pulse value  = volume).
+        */
+        DLMS_UNIT_CUBIC_METER_RV = 55,
+        /*
+        * Percentage.
+        */
+        DLMS_UNIT_PERCENTAGE = 56,
+        /*
+        * Ah ampere hours.
+        */
+        DLMS_UNIT_AMPERE_HOURS = 57,
+        /*
+        * Wh/m3 energy per volume 3,6*103 J/m3.
+        */
+        DLMS_UNIT_ENERGY_PER_VOLUME = 60,
+        /*
+        * J/m3 calorific value, wobbe.
+        */
+        DLMS_UNIT_WOBBE = 61,
+        /*
+        * Mol % molar fraction of gas composition mole percent  = Basic gas
+        * composition unit).
+        */
+        DLMS_UNIT_MOLE_PERCENT = 62,
+        /*
+        * g/m3 mass density, quantity of material.
+        */
+        DLMS_UNIT_MASS_DENSITY = 63,
+        /*
+        * Dynamic viscosity pascal second  = Characteristic of gas stream).
+        */
+        DLMS_UNIT_PASCAL_SECOND = 64,
+        /*
+        * J/kg Specific energy NOTE The amount of energy per unit of mass of a
+        * substance Joule / kilogram m2 . kg . s -2 / kg = m2.
+        */
+        DLMS_UNIT_JOULE_KILOGRAM = 65,
+        /*
+        * Pressure, gram per square centimeter.
+        */
+        DLMS_UNIT_PRESSURE_GRAM_PER_SQUARE_CENTIMETER = 66,
+        /*
+        * Pressure, atmosphere.
+        */
+        DLMS_UNIT_PRESSURE_ATMOSPHERE = 67,
+        /*
+        * Signal strength, dB milliwatt (e.g. of GSM radio systems)
+        */
+        DLMS_UNIT_SIGNAL_STRENGTH_MILLI_WATT = 70,
+        /*
+        * Signal strength, dB microvolt.
+        */
+        DLMS_UNIT_SIGNAL_STRENGTH_MICRO_VOLT = 71,
+        /*
+        * Logarithmic unit that expresses the ratio between two values of a physical quantity
+        */
+        DLMS_UNIT_DB = 72,
+        /*
+        * Length in inches.
+        */
+        DLMS_UNIT_INCH = 128,
+        /*
+        * Foot (Length).
+        */
+        DLMS_UNIT_FOOT = 129,
+        /*
+        * Pound (mass).
+        */
+        DLMS_UNIT_POUND = 130,
+        /*
+        * Fahrenheit.
+        */
+        DLMS_UNIT_FAHRENHEIT = 131,
+        /*
+        * Rankine.
+        */
+        DLMS_UNIT_RANKINE = 132,
+        /*
+        * Square inch.
+        */
+        DLMS_UNIT_SQUARE_INCH = 133,
+        /*
+        * Square foot.
+        */
+        DLMS_UNIT_SQUARE_FOOT = 134,
+        /*
+        * Acre.
+        */
+        DLMS_UNIT_ACRE = 135,
+        /*
+        * Cubic inch.
+        */
+        DLMS_UNIT_CUBIC_INCH = 136,
+        /*
+        * Cubic foot.
+        */
+        DLMS_UNIT_CUBIC_FOOT = 137,
+        /*
+        * Acre foot.
+        */
+        DLMS_UNIT_ACRE_FOOT = 138,
+        /*
+        * Gallon (imperial).
+        */
+        DLMS_UNIT_GALLON_IMPERIAL = 139,
+        /*
+        *  Gallon (US).
+        */
+        DLMS_UNIT_GALLON_US = 140,
+        /*
+        * Pound force.
+        */
+        DLMS_UNIT_POUND_FORCE = 141,
+        /*
+        * Pound force per square inch.
+        */
+        DLMS_UNIT_POUND_FORCE_PER_SQUARE_INCH = 142,
+        /*
+        * Pound per cubic foot.
+        */
+        DLMS_UNIT_POUND_PER_CUBIC_FOOT = 143,
+        /*
+        * Pound per (foot second).
+        */
+        DLMS_UNIT_POUND_PER_FOOT_SECOND = 144,
+        /*
+        * Square foot per second.
+        */
+        DLMS_UNIT_SQUARE_FOOT_PER_SECOND = 145,
+        /*
+        * British thermal unit.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT = 146,
+        /*
+        * Therm EU.
+        */
+        DLMS_UNIT_THERM_EU = 147,
+        /*
+        * Therm US.
+        */
+        DLMS_UNIT_THERM_US = 148,
+        /*
+        * British thermal unit per pound.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_POUND = 149,
+        /*
+        * British thermal unit per cubic foot.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_CUBIC_FOOT = 150,
+        /*
+        * Cubic feet.
+        */
+        DLMS_UNIT_CUBIC_FEET = 151,
+        /*
+        * Foot per second.
+        */
+        DLMS_UNIT_FOOT_PER_SECOND = 152,
+        /*
+        * Cubic foot per second.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_SECOND = 153,
+        /*
+        * Cubic foot per min.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_MIN = 154,
+        /*
+        * Cubic foot per hour.
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_HOUR = 155,
+        /*
+        * Cubic foot per day
+        */
+        DLMS_UNIT_CUBIC_FOOT_PER_DAY = 156,
+        /*
+        * Acre foot per second.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_SECOND = 157,
+        /*
+        * Acre foot per min.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_MIN = 158,
+        /*
+        *  Acre foot per hour.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_HOUR = 159,
+        /*
+        *  Acre foot per day.
+        */
+        DLMS_UNIT_ACRE_FOOT_PER_DAY = 160,
+        /*
+        * Imperial gallon.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON = 161,
+        /*
+        * Imperial gallon per second.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_SECOND = 162,
+        /*
+        * Imperial gallon per min.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_MIN = 163,
+        /*
+        * Imperial gallon per hour.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_HOUR = 164,
+        /*
+        * Imperial gallon per day.
+        */
+        DLMS_UNIT_IMPERIAL_GALLON_PER_DAY = 165,
+        /*
+        * US gallon.
+        */
+        DLMS_UNIT_US_GALLON = 166,
+        /*
+        * US gallon per second.
+        */
+        DLMS_UNIT_US_GALLON_PER_SECOND = 167,
+        /*
+        * US gallon per min.
+        */
+        DLMS_UNIT_US_GALLON_PER_MIN = 168,
+        /*
+        * US gallon per hour.
+        */
+        DLMS_UNIT_US_GALLON_PER_HOUR = 169,
+        /*
+        * US gallon per day.
+        */
+        DLMS_UNIT_US_GALLON_PER_DAY = 170,
+        /*
+        * British thermal unit per second.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_SECOND = 171,
+        /*
+        * British thermal unit per minute.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_MIN = 172,
+        /*
+        * British thermal unit per hour.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_HOUR = 173,
+        /*
+        * British thermal unit per day.
+        */
+        DLMS_UNIT_BRITISH_THERMAL_UNIT_PER_DAY = 174,
+        /*
+        * Other Unit.
+        */
+        DLMS_UNIT_OTHER = 254,
+        /*
+        * No Unit.
+        */
+        DLMS_UNIT_NO_UNIT = 255
     }DLMS_UNIT;
 
 
@@ -2831,13 +2916,13 @@
     // Certificate entity.
     typedef enum {
         // Certificate entity is server.
-        DLMS_CERTIFICATE_ENTITY_Server = 0,
+        DLMS_CERTIFICATE_ENTITY_SERVER = 0,
         // Certificate entity is client.
-        DLMS_CERTIFICATE_ENTITY_Client,
+        DLMS_CERTIFICATE_ENTITY_CLIENT,
         // Certificate entity is certification authority.
-        DLMS_CERTIFICATE_ENTITY_Certification_Authority,
+        DLMS_CERTIFICATE_ENTITY_CERTIFICATION_AUTHORITY,
         // Certificate entity is other.
-        DLMS_CERTIFICATE_ENTITY_Other
+        DLMS_CERTIFICATE_ENTITY_OTHER
     }DLMS_CERTIFICATE_ENTITY;
 
     // Certificate type.
@@ -2850,7 +2935,7 @@
         DLMS_CERTIFICATE_TYPE_TLS = 2,
         // Certificate type is other.
         DLMS_CERTIFICATE_TYPE_OTHER = 3
-    }    DLMS_CERTIFICATE_TYPE;
+    }DLMS_CERTIFICATE_TYPE;
 
     // Connection types.
     typedef enum {
@@ -2864,6 +2949,13 @@
         DLMS_CONNECTION_STATE_IEC = 4
     }DLMS_CONNECTION_STATE;
 
+    // Used ECC scheme.
+    typedef enum {
+        //ECC-P256 domain parameters are used.
+        ECC_P256 = 0,
+        //ECC-384 domain parameters are used.
+        ECC_P384 = 1
+    }ECC;
     typedef enum {
         //Data is captured with Capture-method.
         DLMS_CAPTURE_METHOD_INVOKE,
@@ -3386,7 +3478,7 @@
         // Not Defined.
         DLMS_PAN_DEVICE_TYPE_NOT_DEFINED
     }DLMS_PAN_DEVICE_TYPE;
-    
+
 
     // Defines the ZigBee status enumeration values.
     typedef enum
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/errorcodes.h src/development/include/errorcodes.h
--- upstream/development/include/errorcodes.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/errorcodes.h	2024-11-13 12:20:09.000000000 +0000
@@ -157,7 +157,16 @@
         //Serialization save failed.
         DLMS_ERROR_CODE_SERIALIZATION_SAVE_FAILURE,
         //Serialization count failed.
-        DLMS_ERROR_CODE_SERIALIZATION_COUNT_FAILURE
+        DLMS_ERROR_CODE_SERIALIZATION_COUNT_FAILURE,
+        //Verify failed.
+        DLMS_ERROR_CODE_VERIFY_FAILED,
+        //Invalid X.509 certificate.
+        DLMS_ERROR_CODE_INVALID_CERTIFICATE,
+        // Feature is not implemented. 
+        // This means that the command is unknown.
+        // THe code might be ignored with compiler flag.
+        //See DLMS_IGNORE values.
+        DLMS_ERROR_CODE_UNKNOWN_COMMAND,
     }DLMS_ERROR_CODE;
 
 #ifdef  __cplusplus
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gx509Certificate.h src/development/include/gx509Certificate.h
--- upstream/development/include/gx509Certificate.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/gx509Certificate.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,178 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GX509CERTIFICATE_H
+#define GX509CERTIFICATE_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "bytebuffer.h"   
+#include "bigInteger.h"     
+#include "publicKey.h"     
+#include "enums.h"     
+
+    typedef enum
+    {
+        /*All data is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_NONE,
+        /*System title start index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_SYSTEM_TITLE,
+        /*Valid from start index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_VALID_FROM,
+        /*System title valid to index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_VALID_TO,
+        /*Serial number start index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_SERIAL_NUMBER,
+        /*Issuer start index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_ISSUER,
+        /*Subject start index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_SUBJECT,
+        /*Subject Alt Namestart index is returned.*/
+        DLMS_X509_CERTIFICATE_DATA_SUBJECT_ALT_NAME,
+    }DLMS_X509_CERTIFICATE_DATA;
+
+    // Key Usage.
+    typedef enum
+    {
+        // Key is not used.
+        DLMS_KEY_USAGE_NONE = 0,
+        // Digital signature.        
+        DLMS_KEY_USAGE_DIGITAL_SIGNATURE = 0x1,
+        // Key agreement.        
+        DLMS_KEY_USAGE_KEY_AGREEMENT = 0x10,
+    }DLMS_KEY_USAGE;
+
+    /*X.509 v3 certificate.
+    https://tools.ietf.org/html/rfc5280
+    */
+    typedef struct
+    {
+        bigInteger serialNumber;
+        ECC signatureAlgorithm;
+        /*Certificate validity starts.*/
+        uint32_t validFrom;
+        /*Certificate validity ends.*/
+        uint32_t validTo;
+        /*System title from the subject CN.*/
+        unsigned char systemTitle[8];
+        DLMS_KEY_USAGE keyUsage;
+        gxPublicKey publicKey;
+    } gx509Certificate;
+
+    /*Initialize X.509 v3 certificate.
+        cert: X.509 certificate.
+    */
+    void gx509Certificate_init(gx509Certificate* cert);
+
+    /*Clear X.509 v3 certificate.
+        cert: X.509 certificate.
+    */
+    void gx509Certificate_clear(gx509Certificate* cert);
+
+    /*Validate X.509 v3 certificate.
+        cert: X.509 certificate.
+        time: Current time. Time validation is ignored if it is zero.
+    */
+    int gx509Certificate_validate(gx509Certificate* cert, uint32_t time);
+
+    /*Load X.509 v3 certificate from bytes.
+        cert: X.509 certificate.
+    */
+    int gx509Certificate_fromBytes(gx509Certificate* cert, 
+        DLMS_X509_CERTIFICATE_DATA info, 
+        gxByteBuffer* data);
+
+    /*Load X.509 v3 certificate from DER.
+        cert: X.509 certificate.
+    */
+    int gx509Certificate_fromDer(gx509Certificate* cert, 
+        DLMS_X509_CERTIFICATE_DATA info, 
+        const char* data);
+
+    /*Load X.509 v3 certificate from PEM.*/
+    int gx509Certificate_fromPem(gx509Certificate* cert, 
+        DLMS_X509_CERTIFICATE_DATA info, 
+        const char* data);
+
+    /*Get serial number from X.509 v3 certificate.*/
+    int gx509Certificate_getSerialNumber(gxByteBuffer* data, 
+        gxByteBuffer* sn);
+
+    /*Get System title from X.509 v3 certificate.*/
+    int gx509Certificate_getSystemTitle(gxByteBuffer* data,
+        gxByteBuffer* st);
+
+    /*Get Valid from value from X.509 v3 certificate.*/
+    int gx509Certificate_getValidFrom(gxByteBuffer* data,
+        gxByteBuffer* st);
+
+    /*Get Valid to value from X.509 v3 certificate.*/
+    int gx509Certificate_getValidTo(gxByteBuffer* data,
+        gxByteBuffer* st);
+
+    /*Get issuer from X.509 v3 certificate.*/
+    int gx509Certificate_getIssuer(gxByteBuffer* data, 
+        gxByteBuffer* issuer);
+
+    /*Get subject from X.509 v3 certificate.*/
+    int gx509Certificate_getSubject(gxByteBuffer* data, 
+        gxByteBuffer* subject);
+
+    /*Get subject Alt Name from X.509 v3 certificate.*/
+    int gx509Certificate_getSubjectAltName(gxByteBuffer* data, 
+        gxByteBuffer* subject);
+
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+    /*Load X.509 v3 certificate.
+        cert: X.509 certificate.
+    */
+    int gx509Certificate_load(gx509Certificate* cert, 
+        const char* path);
+
+    /*Load spesific data from X.509 v3 certificate.
+        cert: X.509 certificate.
+    */
+    int gx509Certificate_load2(const char* path,
+        DLMS_X509_CERTIFICATE_DATA info, 
+        gxByteBuffer* value);
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //GX509CERTIFICATE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxPkcs10.h src/development/include/gxPkcs10.h
--- upstream/development/include/gxPkcs10.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/gxPkcs10.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,56 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GXPKCS10_H
+#define GXPKCS10_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "bytebuffer.h"   
+#include "privateKey.h"       
+    /*Create Certificate Signing Request.*/
+    int pkcs10_createCertificateSigningRequest(
+        gxPrivateKey* priv,
+        const unsigned char* subject,
+        gxByteBuffer* value);
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //GXPKCS10_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxdefine.h src/development/include/gxdefine.h
--- upstream/development/include/gxdefine.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxdefine.h	2024-11-13 12:20:09.000000000 +0000
@@ -112,7 +112,7 @@
 #define MAX_CLIENT_PDU_SIZE 200
 
 //Define max capture object buffer size.
-#define MAX_CAPTURE_OBJECT_BUFFER_SIZE 100
+#define MAX_CAPTURE_OBJECT_BUFFER_SIZE 200
 
 //Define max challenge size.
 #define MAX_CHALLENGE_SIZE 64
@@ -141,6 +141,9 @@
 //Define neighbour table tone map size for G3 MAC Setup object.
 #define MAX_G3_MAC_NEIGHBOUR_TABLE_TONE_MAP_SIZE 5
 
+//X.509 certificate max size.
+#define DLMS_X509_CETRIFICATE_MAX_SIZE 2048
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxecdsa.h src/development/include/gxecdsa.h
--- upstream/development/include/gxecdsa.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/gxecdsa.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,70 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GXECDSA_H
+#define GXECDSA_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "gxignore.h"
+#include "privateKey.h"
+
+    /*Verify signature.
+        signature: Generated signature.
+        data: Data to valuate.
+    */
+    int gxecdsa_verify(gxPublicKey* key, gxByteBuffer* signature, gxByteBuffer* data);
+
+    /*Sign data.
+    data: Signed data.
+    signature: Generated signature.
+    */
+    int gxecdsa_sign(gxPrivateKey* key, gxByteBuffer* data, gxByteBuffer* signature);
+
+    /**
+     Generates public and private key pair.
+    */
+    int gxecdsa_generateKeyPair(
+        ECC scheme,
+        gxPublicKey* pub, gxPrivateKey* priv);
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //GXECDSA_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxget.h src/development/include/gxget.h
--- upstream/development/include/gxget.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxget.h	2024-11-13 12:20:09.000000000 +0000
@@ -276,18 +276,10 @@
     int cosem_getSFSKReportingSystemList(
         gxValueEventArg* e);
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
-
-#ifdef DLMS_ITALIAN_STANDARD
-    //Convert compact data buffer to array of values.
-    //Some Italy meters require that there is a array count in data.
-    //This is against compact data structure defined in DLMS standard.
-    int compactData_getValues2(
-        dlmsSettings* settings,
-        gxByteBuffer* templateDescription,
-        gxByteBuffer* buffer,
-        variantArray* values,
-        unsigned char appendAA);
-#endif //DLMS_ITALIAN_STANDARD
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    int cosem_getLteMonitoring(
+        gxValueEventArg* e);
+#endif //DLMS_IGNORE_LTE_MONITORING
 
 #ifdef  __cplusplus
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxignore.h src/development/include/gxignore.h
--- upstream/development/include/gxignore.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxignore.h	2024-11-13 12:20:09.000000000 +0000
@@ -36,146 +36,169 @@
 extern "C" {
 #endif
 
-/* Uncomment defines to ignore non-needed parts to make image size smaller. */
+    /* Uncomment defines to ignore non-needed parts to make image size smaller. */
 
-// #define DLMS_IGNORE_HDLC
-// #define DLMS_IGNORE_WRAPPER
-// #define DLMS_IGNORE_PLC
-// #define DLMS_IGNORE_IEC
-// #define DLMS_IGNORE_NOTIFY
-// #define DLMS_IGNORE_SERVER
-// #define DLMS_IGNORE_CLIENT
-// #define GX_DLMS_MICROCONTROLLER
-// #define DLMS_IGNORE_HIGH_SHA256
-// #define DLMS_IGNORE_HIGH_SHA1
-// #define DLMS_IGNORE_HIGH_MD5
-// #define DLMS_IGNORE_AES
-// #define DLMS_IGNORE_HIGH_GMAC
-// #define DLMS_IGNORE_DATA
-// #define DLMS_IGNORE_REGISTER
-// #define DLMS_IGNORE_EXTENDED_REGISTER
-// #define DLMS_IGNORE_DEMAND_REGISTER
-// #define DLMS_IGNORE_REGISTER_ACTIVATION
-// #define DLMS_IGNORE_PROFILE_GENERIC
-// #define DLMS_IGNORE_CLOCK
-// #define DLMS_IGNORE_SCRIPT_TABLE
-// #define DLMS_IGNORE_SCHEDULE
-// #define DLMS_IGNORE_SPECIAL_DAYS_TABLE
-// #define DLMS_IGNORE_ASSOCIATION_SHORT_NAME
-// #define DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
-// #define DLMS_IGNORE_SAP_ASSIGNMENT
-// #define DLMS_IGNORE_IMAGE_TRANSFER
-// #define DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
-// #define DLMS_IGNORE_ACTIVITY_CALENDAR
-// #define DLMS_IGNORE_REGISTER_MONITOR
-// #define DLMS_IGNORE_ACTION_SCHEDULE
-// #define DLMS_IGNORE_IEC_HDLC_SETUP
-// #define DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
-// #define DLMS_IGNORE_MBUS_SLAVE_PORT_SETUP
-// #define DLMS_IGNORE_UTILITY_TABLES
-// #define DLMS_IGNORE_MODEM_CONFIGURATION
-// #define DLMS_IGNORE_AUTO_ANSWER
-// #define DLMS_IGNORE_AUTO_CONNECT
-// #define DLMS_IGNORE_TCP_UDP_SETUP
-// #define DLMS_IGNORE_IP4_SETUP
-// #define DLMS_IGNORE_IP6_SETUP
-// #define DLMS_IGNORE_MAC_ADDRESS_SETUP
-// #define DLMS_IGNORE_PPP_SETUP
-// #define DLMS_IGNORE_GPRS_SETUP
-// #define DLMS_IGNORE_SMTP_SETUP
-// #define DLMS_IGNORE_GSM_DIAGNOSTIC
-// #define DLMS_IGNORE_REGISTER_TABLE
-// #define DLMS_IGNORE_STATUS_MAPPING
-// #define DLMS_IGNORE_SECURITY_SETUP
-// #define DLMS_IGNORE_DISCONNECT_CONTROL
-// #define DLMS_IGNORE_LIMITER
-// #define DLMS_IGNORE_MBUS_CLIENT
-// #define DLMS_IGNORE_PUSH_SETUP
-// #define DLMS_IGNORE_PARAMETER_MONITOR
-// #define DLMS_IGNORE_WIRELESS_MODE_Q_CHANNEL
-// #define DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
-// #define DLMS_IGNORE_ZIG_BEE_SAS_STARTUP
-// #define DLMS_IGNORE_ZIG_BEE_SAS_JOIN
-// #define DLMS_IGNORE_ZIG_BEE_SAS_APS_FRAGMENTATION
-// #define DLMS_IGNORE_ZIG_BEE_NETWORK_CONTROL
-// #define DLMS_IGNORE_DATA_PROTECTION
-// #define DLMS_IGNORE_ACCOUNT
-// #define DLMS_IGNORE_CREDIT
-// #define DLMS_IGNORE_CHARGE
-// #define DLMS_IGNORE_TOKEN_GATEWAY
-// #define DLMS_IGNORE_COMPACT_DATA
-// #define DLMS_IGNORE_LLC_SSCS_SETUP
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_PHYSICAL_LAYER_COUNTERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_SETUP
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_FUNCTIONAL_PARAMETERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_COUNTERS
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_NETWORK_ADMINISTRATION_DATA
-// #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_APPLICATIONS_IDENTIFICATION
-// #define DLMS_IGNORE_ARBITRATOR
-// #define DLMS_IGNORE_G3_PLC_MAC_LAYER_COUNTERS
-// #define DLMS_IGNORE_G3_PLC_MAC_SETUP
-// #define DLMS_IGNORE_G3_PLC_6LO_WPAN
-// #define DLMS_IGNORE_FUNCTION_CONTROL
-// #define DLMS_IGNORE_ARRAY_MANAGER
-
-// #define DLMS_IGNORE_MALLOC
-// #define DLMS_USE_CUSTOM_MALLOC
-
-// #define DLMS_IGNORE_OBJECT_POINTERS
-
-// #define DLMS_IGNORE_FLOAT32
-// #define DLMS_IGNORE_FLOAT64
-
-//Use EPOCH time. This can be used to improve memory usage.
-// #define DLMS_USE_EPOCH_TIME
-
-//Use UTC time zone. Read more: https://www.gurux.fi/Gurux.DLMS.Objects.GXDLMSClock
-// #define DLMS_USE_UTC_TIME_ZONE
-
-// #define DLMS_IGNORE_SET
-// #define DLMS_IGNORE_ACTION
-
-// String converters are not used.
-// #define DLMS_IGNORE_STRING_CONVERTER
-
-//Framework send debug information that can be used in debugging.
-// #define DLMS_DEBUG
-
-//Defined if AVR is used.
-// #define USE_AVR
-
-//Defined if program memory (flash) is used instead of SRAM.
-// #define USE_PROGMEM
-
-// COSEM objects are using DLMS standard data types.
-// Using exact data types will save memory, but reading failes if meter returns wrong data type,
-// ex. Int8 when data type should be UInt8.
-// #define DLMS_COSEM_EXACT_DATA_TYPES
-
-// If innovation counter size is UInt64 and not default UInt32.
-// #define DLMS_COSEM_INVOCATION_COUNTER_SIZE64
-
-// Use 32 bit max size bytebuffer instead of 16 bit.
-// This might be used in client side if a lot of data is read from the meter.
-// #define GX_DLMS_BYTE_BUFFER_SIZE_32
-
-//Serializer is not used.
-//DLMS_IGNORE_SERIALIZER
-//Serializer is used instead of file system.
-//#define GX_DLMS_SERIALIZER
-
-//GENERAL_CIPHERING is not used.
-//#define DLMS_IGNORE_GENERAL_CIPHERING
-
-/**
-*  Ignore HDLC Control field check.
-Some meters are sending invalid control field.
-Note! It's not recommended to use this.
-*/
-//#define DLMS_IGNORE_HDLC_CHECK
-
-// #define DLMS_ITALIAN_STANDARD
-// #define DLMS_INDONESIA_STANDARD
+    // #define DLMS_IGNORE_HDLC
+    // #define DLMS_IGNORE_WRAPPER
+    // #define DLMS_IGNORE_PLC
+    // #define DLMS_IGNORE_IEC
+    // #define DLMS_IGNORE_NOTIFY
+    // #define DLMS_IGNORE_SERVER
+    // #define DLMS_IGNORE_CLIENT
+    // #define GX_DLMS_MICROCONTROLLER
+    // #define DLMS_IGNORE_HIGH_SHA256
+    // #define DLMS_IGNORE_HIGH_SHA1
+    // #define DLMS_IGNORE_HIGH_MD5
+    // #define DLMS_IGNORE_AES
+    // #define DLMS_IGNORE_HIGH_GMAC
+    // #define DLMS_IGNORE_DATA
+    // #define DLMS_IGNORE_REGISTER
+    // #define DLMS_IGNORE_EXTENDED_REGISTER
+    // #define DLMS_IGNORE_DEMAND_REGISTER
+    // #define DLMS_IGNORE_REGISTER_ACTIVATION
+    // #define DLMS_IGNORE_PROFILE_GENERIC
+    // #define DLMS_IGNORE_CLOCK
+    // #define DLMS_IGNORE_SCRIPT_TABLE
+    // #define DLMS_IGNORE_SCHEDULE
+    // #define DLMS_IGNORE_SPECIAL_DAYS_TABLE
+    // #define DLMS_IGNORE_ASSOCIATION_SHORT_NAME
+    // #define DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+    // #define DLMS_IGNORE_SAP_ASSIGNMENT
+    // #define DLMS_IGNORE_IMAGE_TRANSFER
+    // #define DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+    // #define DLMS_IGNORE_ACTIVITY_CALENDAR
+    // #define DLMS_IGNORE_REGISTER_MONITOR
+    // #define DLMS_IGNORE_ACTION_SCHEDULE
+    // #define DLMS_IGNORE_IEC_HDLC_SETUP
+    // #define DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+    // #define DLMS_IGNORE_MBUS_SLAVE_PORT_SETUP
+    // #define DLMS_IGNORE_UTILITY_TABLES
+    // #define DLMS_IGNORE_MODEM_CONFIGURATION
+    // #define DLMS_IGNORE_AUTO_ANSWER
+    // #define DLMS_IGNORE_AUTO_CONNECT
+    // #define DLMS_IGNORE_TCP_UDP_SETUP
+    // #define DLMS_IGNORE_IP4_SETUP
+    // #define DLMS_IGNORE_IP6_SETUP
+    // #define DLMS_IGNORE_MAC_ADDRESS_SETUP
+    // #define DLMS_IGNORE_PPP_SETUP
+    // #define DLMS_IGNORE_GPRS_SETUP
+    // #define DLMS_IGNORE_SMTP_SETUP
+    // #define DLMS_IGNORE_GSM_DIAGNOSTIC
+    // #define DLMS_IGNORE_REGISTER_TABLE
+    // #define DLMS_IGNORE_STATUS_MAPPING
+    // #define DLMS_IGNORE_SECURITY_SETUP
+    // #define DLMS_IGNORE_DISCONNECT_CONTROL
+    // #define DLMS_IGNORE_LIMITER
+    // #define DLMS_IGNORE_MBUS_CLIENT
+    // #define DLMS_IGNORE_PUSH_SETUP
+    // #define DLMS_IGNORE_PARAMETER_MONITOR
+    // #define DLMS_IGNORE_WIRELESS_MODE_Q_CHANNEL
+    // #define DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_STARTUP
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_JOIN
+    // #define DLMS_IGNORE_ZIG_BEE_SAS_APS_FRAGMENTATION
+    // #define DLMS_IGNORE_ZIG_BEE_NETWORK_CONTROL
+    // #define DLMS_IGNORE_DATA_PROTECTION
+    // #define DLMS_IGNORE_ACCOUNT
+    // #define DLMS_IGNORE_CREDIT
+    // #define DLMS_IGNORE_CHARGE
+    // #define DLMS_IGNORE_TOKEN_GATEWAY
+    // #define DLMS_IGNORE_COMPACT_DATA
+    // #define DLMS_IGNORE_LLC_SSCS_SETUP
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_PHYSICAL_LAYER_COUNTERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_SETUP
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_FUNCTIONAL_PARAMETERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_COUNTERS
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_MAC_NETWORK_ADMINISTRATION_DATA
+    // #define DLMS_IGNORE_PRIME_NB_OFDM_PLC_APPLICATIONS_IDENTIFICATION
+    // #define DLMS_IGNORE_ARBITRATOR
+    // #define DLMS_IGNORE_G3_PLC_MAC_LAYER_COUNTERS
+    // #define DLMS_IGNORE_G3_PLC_MAC_SETUP
+    // #define DLMS_IGNORE_G3_PLC_6LO_WPAN
+    // #define DLMS_IGNORE_FUNCTION_CONTROL
+    // #define DLMS_IGNORE_ARRAY_MANAGER
+
+    // #define DLMS_IGNORE_MALLOC
+    // #define DLMS_USE_CUSTOM_MALLOC
+
+    // #define DLMS_IGNORE_OBJECT_POINTERS
+
+    // #define DLMS_IGNORE_FLOAT32
+    // #define DLMS_IGNORE_FLOAT64
+    
+    //Delta values are ignored.
+    // #define DLMS_IGNORE_DELTA
+
+    //Use EPOCH time. This can be used to improve memory usage.
+    // #define DLMS_USE_EPOCH_TIME
+
+    //Use UTC time zone. Read more: https://www.gurux.fi/Gurux.DLMS.Objects.GXDLMSClock
+    // #define DLMS_USE_UTC_TIME_ZONE
+
+    // #define DLMS_IGNORE_SET
+    // #define DLMS_IGNORE_ACTION
+
+    // String converters are not used.
+    // #define DLMS_IGNORE_STRING_CONVERTER
+
+    //Framework send debug information that can be used in debugging.
+    // #define DLMS_DEBUG
+
+    //Defined if AVR is used.
+    // #define USE_AVR
+
+    //Defined if program memory (flash) is used instead of SRAM.
+    // #define USE_PROGMEM
+
+    // COSEM objects are using DLMS standard data types.
+    // Using exact data types will save memory, but reading failes if meter returns wrong data type,
+    // ex. Int8 when data type should be UInt8.
+    // #define DLMS_COSEM_EXACT_DATA_TYPES
+
+    // If innovation counter size is UInt64 and not default UInt32.
+    // #define DLMS_COSEM_INVOCATION_COUNTER_SIZE64
+
+    // Use 32 bit max size bytebuffer instead of 16 bit.
+    // This might be used in client side if a lot of data is read from the meter.
+    // #define GX_DLMS_BYTE_BUFFER_SIZE_32
+
+    //Serializer is not used.
+    //DLMS_IGNORE_SERIALIZER
+    //Serializer is used instead of file system.
+    //#define GX_DLMS_SERIALIZER
+
+    //GENERAL_CIPHERING is not used.
+    //#define DLMS_IGNORE_GENERAL_CIPHERING
+
+    /**
+    *  Ignore HDLC Control field check.
+    Some meters are sending invalid control field.
+    Note! It's not recommended to use this.
+    */
+    //#define DLMS_IGNORE_HDLC_CHECK
+
+    // #define DLMS_ITALIAN_STANDARD
+    // #define DLMS_INDONESIA_STANDARD
+
+    // Show decoded PDU. 
+    // This can be used to show decoded PDU.
+    // #define DLMS_TRACE_PDU
+
+    // Some DLMS standard define that invocation counter must between given range.
+    // The server can validate IC using svr_validInvocationCounter method.
+    //#define DLMS_INVOCATION_COUNTER_VALIDATOR
+
+    // Server notifies invalid authentication error.
+    //#define DLMS_NOTIFY_AUTHENTICATION_ERROR
+
+    // Server notifies invalid ciphering error.
+    //#define DLMS_NOTIFY_CIPHERING_ERROR
+
+    //Security Suite 1 is used.
+    //#define DLMS_SECURITY_SUITE_1
+    
+    //Security Suite 2 is used.
+    //#define DLMS_SECURITY_SUITE_2
 
 #ifdef ARDUINO
 /////////////////////////////////////////////////////////////////////////////
@@ -228,7 +251,6 @@
 /////////////////////////////////////////////////////////////////////////////
 #endif //ARDUINO_ARCH_ESP8266
 
-
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxint.h src/development/include/gxint.h
--- upstream/development/include/gxint.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxint.h	2024-11-13 12:20:09.000000000 +0000
@@ -34,7 +34,7 @@
 #define GXINT_H
 
 #include <stdint.h>
-
+#if !defined(_WIN32) && !defined(_WIN64) && !defined(__linux__)
 #ifdef  __cplusplus
 extern "C" {
 #endif
@@ -42,7 +42,7 @@
 #define uint16_t unsigned short
 #endif //!(defined uint16_t) && !(defined _UINT16_T_DECLARED)
 #if !(defined uint32_t) && !(defined _UINT32_T_DECLARED)
-#define uint32_t unsigned long
+#define uint32_t unsigned int
 #endif //!(defined uint32_t) && !(defined _UINT32_T_DECLARED)
 #if !(defined uint64_t) && !(defined _UINT64_T_DECLARED)
 #define uint64_t unsigned long long
@@ -52,7 +52,7 @@
 #define int16_t short
 #endif //!(defined int16_t) && !(defined _INT16_T_DECLARED)
 #if !(defined int32_t) && !(defined _INT32_T_DECLARED)
-#define int32_t long
+#define int32_t int
 #endif //!(defined int32_t) && !(defined _INT32_T_DECLARED)
 #if !(defined int64_t) && !(defined _INT64_T_DECLARED)
 #define int64_t long long
@@ -61,5 +61,5 @@
 #ifdef  __cplusplus
 }
 #endif
-
+#endif //!defined(_WIN32) && !defined(_WIN64) && !defined(__linux__)
 #endif //GXINT_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxobjects.h src/development/include/gxobjects.h
--- upstream/development/include/gxobjects.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxobjects.h	2024-11-13 12:20:09.000000000 +0000
@@ -51,6 +51,11 @@
 #include "gxkey.h"
 #include "gxdefine.h"
 
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "privateKey.h"
+#include "gx509Certificate.h"
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
 #ifdef  __cplusplus
 extern "C" {
 #endif
@@ -766,6 +771,7 @@
 #ifndef DLMS_IGNORE_SECURITY_SETUP
     typedef struct
     {
+#ifndef DLMS_IGNORE_CLIENT
         // Used certificate entity.
         DLMS_CERTIFICATE_ENTITY entity;
 
@@ -795,6 +801,14 @@
         // Certificate subject alt name.
         char* subjectAltName;
 #endif //DLMS_IGNORE_MALLOC
+#endif //DLMS_IGNORE_CLIENT
+#ifndef DLMS_IGNORE_SERVER
+        //Server side sertificate. 
+        gxByteBuffer cert;
+#ifdef DLMS_IGNORE_MALLOC
+        unsigned char CERTIFICATE_BUFFER[DLMS_X509_CETRIFICATE_MAX_SIZE];
+#endif //DLMS_IGNORE_MALLOC
+#endif //DLMS_IGNORE_SERVER
     }gxCertificateInfo;
 
     /*
@@ -819,6 +833,23 @@
 #else
         uint32_t minimumInvocationCounter;
 #endif //DLMS_COSEM_INVOCATION_COUNTER_SIZE64
+        //Block cipher key.
+        gxByteBuffer guek;
+        //Broadcast block cipher key.
+        gxByteBuffer gbek;
+        //Authentication key.
+        gxByteBuffer gak;
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+        //Signing key of the server.
+        gxPrivateKey signingKey;
+
+        //Key agreement key of the server.
+        gxPrivateKey keyAgreementKey;
+
+        //TLS pair of the server.
+        gxPrivateKey tlsKey;
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
     } gxSecuritySetup;
 #endif //DLMS_IGNORE_SECURITY_SETUP
 
@@ -2125,7 +2156,120 @@
     } gxMBusClient;
 #endif //DLMS_IGNORE_MBUS_CLIENT
 
+    typedef enum
+    {
+        DLMS_PROTECTION_TYPE_AUTHENTICATION = 1,
+        DLMS_PROTECTION_TYPE_ENCRYPTION = 2,
+        DLMS_PROTECTION_TYPE_AUTHENTICATION_ENCRYPTION = 3
+    } DLMS_PROTECTION_TYPE;
+
 #ifndef DLMS_IGNORE_PUSH_SETUP
+    /*This structure is used to count repetition delay for the next push message.*/
+    typedef struct
+    {
+        /**
+        * The minimum delay until a next push attempt is started in seconds.
+        */
+        uint16_t min;
+
+        /**
+         * Calculating the next delay.
+         */
+        uint16_t exponent;
+
+        /**
+         * The maximum delay until a next push attempt is started in seconds.
+         */
+        uint16_t max;
+
+    }gxRepetitionDelay;
+
+    /*Data protection identified key.*/
+    typedef struct
+    {
+        /*Data protection key type.*/
+        DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE keyType;
+    }gxDataProtectionIdentifiedKey;
+
+    /*Data protection wrapped key.*/
+    typedef struct
+    {
+        /*Data protectionKey type.*/
+        DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE keyType;
+
+        /*Key ciphered data.*/
+        gxByteBuffer key;
+    }gxDataProtectionWrappeddKey;
+
+    /*Data protection agreed key.*/
+    typedef struct
+    {
+        /*Key parameters.*/
+        gxByteBuffer parameters;
+
+        /*Key ciphered data.*/
+        gxByteBuffer data;
+    }gxDataProtectionAgreedKey;
+
+    /*Data protection Key.*/
+    typedef struct
+    {
+        /*Data protectionKey type.*/
+        DLMS_DATA_PROTECTION_KEY_TYPE dataProtectionKeyType;
+
+        /*Identified key parameters.*/
+        gxDataProtectionIdentifiedKey identifiedKey;
+
+        /*Wrapped key parameters.*/
+        gxDataProtectionWrappeddKey wrappedKey;
+        /*Agreed key parameters.*/
+        gxDataProtectionAgreedKey agreedKey;
+    }gxDataProtectionKey;
+
+    typedef struct
+    {
+        /*Protection type.*/
+        DLMS_PROTECTION_TYPE protectionType;
+
+        /**
+         * Transaction Id.
+         */
+        gxByteBuffer transactionId;
+
+        /**
+         * Originator system title.
+         */
+        unsigned char originatorSystemTitle[8];
+
+        /**
+         * Recipient system title.
+         */
+        unsigned char recipientSystemTitle[8];
+
+        /**
+         * Other information.
+         */
+        gxByteBuffer otherInformation;
+
+        /**
+         * Key info.
+         */
+        gxDataProtectionKey keyInfo;
+    }gxPushProtectionParameters;
+
+    /*Push confirmation parameters.*/
+    typedef struct
+    {
+        /**
+     * Confirmation start date. Fields of date-time not specified are not used.
+     */
+        gxtime startDate;
+        /**
+         * Confirmation time interval in seconds. Disabled, if zero.
+         */
+        uint32_t interval;
+    }gxPushConfirmationParameter;
+
     /*
     ---------------------------------------------------------------------------
     Online help:
@@ -2149,7 +2293,25 @@
         gxArray communicationWindow;
         uint16_t randomisationStartInterval;
         unsigned char numberOfRetries;
+        /* Repetition delay for version #0 and #1.*/
         uint16_t repetitionDelay;
+        /* Repetition delay for Version #2.*/
+        gxRepetitionDelay repetitionDelay2;
+        /*The logical name of a communication port setup object.*/
+#ifdef DLMS_IGNORE_MALLOC
+        unsigned char portReference[6];
+#else
+        gxObject* portReference;
+#endif //DLMS_IGNORE_MALLOC
+        /*Push client SAP.*/
+        signed char pushClientSAP;
+        /*Push protection parameters.*/
+        gxArray pushProtectionParameters;
+        /*Push operation method.*/
+        DLMS_PUSH_OPERATION_METHOD pushOperationMethod;
+        gxPushConfirmationParameter confirmationParameters;
+        /*Last confirmation date time.*/
+        gxtime lastConfirmationDateTime;
         //Executed time. This is for internal use.
         uint32_t executedTime;
     } gxPushSetup;
@@ -2225,12 +2387,6 @@
     } gxMBusMasterPortSetup;
 
 #endif //DLMS_IGNORE_MBUS_MASTER_PORT_SETUP
-    typedef enum
-    {
-        DLMS_PROTECTION_TYPE_AUTHENTICATION = 1,
-        DLMS_PROTECTION_TYPE_ENCRYPTION = 2,
-        DLMS_PROTECTION_TYPE_AUTHENTICATION_ENCRYPTION = 3
-    } DLMS_PROTECTION_TYPE;
 
     //Global key types.
     typedef enum
@@ -3604,7 +3760,7 @@
     }functionStatus;
 
     typedef struct
-    {        
+    {
 #ifdef DLMS_IGNORE_MALLOC
         // Function name.
         unsigned char name[MAX_FUNCTION_NAME_LENGTH];
@@ -3700,10 +3856,6 @@
         unsigned char templateId;
         gxByteBuffer templateDescription;
         DLMS_CAPTURE_METHOD captureMethod;
-#ifdef DLMS_ITALIAN_STANDARD
-        //Some meters require that there is a array count in data.
-        unsigned char appendAA;
-#endif //DLMS_ITALIAN_STANDARD
     } gxCompactData;
 #endif //DLMS_IGNORE_COMPACT_DATA
 
@@ -4053,6 +4205,85 @@
     } gxSFSKReportingSystemList;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+
+    /// <summary>
+    /// Lte coverage enhancement.
+    /// </summary>
+    typedef enum
+    {
+        // CE Mode A in LTE Cat M1 and CE Level 0 in NB-Iot.
+        DLMS_LTE_COVERAGE_ENHANCEMENT_LEVEL0 = 0,
+        // CE Mode B in LTE Cat M1 and CE Level 1 in NB-Iot.
+        DLMS_LTE_COVERAGE_ENHANCEMENT_LEVEL1,
+        // CE Level 2 in NB-Iot.
+        DLMS_LTE_COVERAGE_ENHANCEMENT_LEVEL2
+    }DLMS_LTE_COVERAGE_ENHANCEMENT;
+
+    // Network parameters for the LTE network
+    typedef struct
+    {
+        // T3402 timer in seconds.
+        uint16_t t3402;
+
+        // T3412 timer in seconds.
+        uint16_t t3412;
+
+        // T3412ext2 timer in seconds.
+        uint32_t t3412ext2;
+
+        // Power saving mode active timer timer in 0,01 seconds.
+        uint16_t t3324;
+
+        // Extended idle mode DRX cycle timer in 0,01 seconds.
+        uint32_t teDRX;
+
+        // DRX paging time window timer in seconds.
+        uint16_t tPTW;
+
+        // The minimum required Rx level in the cell in dBm.
+        signed char qRxlevMin;
+
+        // The minimum required Rx level in enhanced coverage CE Mode A.
+        signed char qRxlevMinCE;
+
+        // The minimum required Rx level in enhanced coverage CE Mode B.
+        signed char qRxLevMinCE1;
+    }gxLteNetworkParameters;
+
+    // Quality of service of the LTE network.
+    typedef struct
+    {
+        // Signal quality.
+        signed char signalQuality;
+
+        // Signal level.
+        signed char signalLevel;
+
+        // Signal to noise ratio.
+        signed char signalToNoiseRatio;
+
+        // Coverage enhancement.
+        DLMS_LTE_COVERAGE_ENHANCEMENT coverageEnhancement;
+    }gxLteQualityOfService;
+
+    // Online help:
+    // https://www.gurux.fi/Gurux.DLMS.Objects.GXDLMSLteMonitoring
+    typedef struct
+    {
+        /*
+        * Base class where class is derived.
+        */
+        gxObject base;
+
+        // Network parameters for the LTE network.
+        gxLteNetworkParameters networkParameters;
+
+        // Quality of service of the LTE network.
+        gxLteQualityOfService qualityOfService;
+    } gxLteMonitoring;
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifdef DLMS_ITALIAN_STANDARD
 
     /*
@@ -4155,7 +4386,11 @@
         // Seasons.
         bitArray weeklyActivation;
         // Seasons.
+#ifdef DLMS_IGNORE_MALLOC
         gxArray specialDays; //UInt16[]
+#else 
+        variantArray specialDays; //UInt16[]
+#endif //DLMS_IGNORE_MALLOC
     } gxPlan;
 
     /*
@@ -4171,7 +4406,7 @@
         gxObject base;
 
         // Calendar Name.
-        char* calendarName;
+        gxByteBuffer calendarName;
         //Is tariff plan enabled.
         unsigned char enabled;
         // Tariff plan.
@@ -4210,6 +4445,10 @@
     int obj_clearScheduleEntries(gxArray* list);
     int obj_clearScriptTable(gxArray* list);
 
+#if defined(DLMS_SECURITY_SUITE_1) ||defined(DLMS_SECURITY_SUITE_2) 
+    int obj_clearCertificates(gxArray* list);
+#endif //defined(DLMS_SECURITY_SUITE_1) ||defined(DLMS_SECURITY_SUITE_2) 
+
 #if !(defined(DLMS_IGNORE_OBJECT_POINTERS) || defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES))
     int obj_clearRegisterActivationAssignment(objectArray* list);
 #else
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxserializer.h src/development/include/gxserializer.h
--- upstream/development/include/gxserializer.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxserializer.h	2024-11-13 12:20:09.000000000 +0000
@@ -128,6 +128,8 @@
         //This is for internal use.
         uint16_t currentIndex;
 #endif //DLMS_IGNORE_MALLOC
+        //Serializer version number.
+        unsigned char version;
     } gxSerializerSettings;
 
     void ser_init(gxSerializerSettings* settings);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxsetignoremalloc.h src/development/include/gxsetignoremalloc.h
--- upstream/development/include/gxsetignoremalloc.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxsetignoremalloc.h	2024-11-13 12:20:09.000000000 +0000
@@ -248,6 +248,11 @@
         gxCompactData* object,
         unsigned char index,
         dlmsVARIANT* value);
+
+    int compactData_update(
+        dlmsSettings* settings,
+        gxCompactData* object,
+        unsigned char isTemplate);
 #endif //DLMS_IGNORE_COMPACT_DATA
 
 #ifndef DLMS_IGNORE_PARAMETER_MONITOR
@@ -380,6 +385,17 @@
                 dlmsVARIANT* value);
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+            int cosem_setLteMonitoring(
+                dlmsSettings* settings,
+                gxLteMonitoring* object,
+                unsigned char index,
+                dlmsVARIANT* value);
+#endif //DLMS_IGNORE_LTE_MONITORING
+
+#ifdef DLMS_ITALIAN_STANDARD
+            int cosem_setTariffPlan(gxTariffPlan* object, unsigned char index, dlmsVARIANT* value);
+#endif //DLMS_ITALIAN_STANDARD
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxsetmalloc.h src/development/include/gxsetmalloc.h
--- upstream/development/include/gxsetmalloc.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxsetmalloc.h	2024-11-13 12:20:09.000000000 +0000
@@ -388,6 +388,17 @@
         dlmsVARIANT* value);
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    int cosem_setLteMonitoring(
+        dlmsSettings* settings,
+        gxLteMonitoring* object,
+        unsigned char index,
+        dlmsVARIANT* value);
+#endif //DLMS_IGNORE_LTE_MONITORING
+
+#ifdef DLMS_ITALIAN_STANDARD
+    int cosem_setTariffPlan(gxTariffPlan* object, unsigned char index, dlmsVARIANT* value);
+#endif //DLMS_ITALIAN_STANDARD
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxsha256.h src/development/include/gxsha256.h
--- upstream/development/include/gxsha256.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxsha256.h	2024-11-13 12:20:09.000000000 +0000
@@ -42,7 +42,7 @@
 
 #include "bytebuffer.h"
 
-    int gxsha256_encrypt(gxByteBuffer* data, gxByteBuffer* digest);
+    int gxsha256_hash(gxByteBuffer* data, gxByteBuffer* digest);
     
 #ifdef  __cplusplus
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxsha384.h src/development/include/gxsha384.h
--- upstream/development/include/gxsha384.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/gxsha384.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,52 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GXSHA_384
+#define GXSHA_384
+
+#include "gxignore.h"
+#ifndef DLMS_IGNORE_HIGH_SHA384
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+#include "bytebuffer.h"
+
+    int gxsha384_hash(gxByteBuffer* data, gxByteBuffer* digest);
+    
+#ifdef  __cplusplus
+}
+#endif
+#endif //DLMS_IGNORE_HIGH_SHA384
+
+#endif //GXSHA_384
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/gxvalueeventargs.h src/development/include/gxvalueeventargs.h
--- upstream/development/include/gxvalueeventargs.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/gxvalueeventargs.h	2024-11-13 12:20:09.000000000 +0000
@@ -66,6 +66,10 @@
         */
         unsigned char index;
         /**
+        * Data index.
+        */
+        unsigned char dataIndex;        
+        /**
         * Optional selector.
         */
         unsigned char selector;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/helpers.h src/development/include/helpers.h
--- upstream/development/include/helpers.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/helpers.h	2024-11-13 12:20:09.000000000 +0000
@@ -86,7 +86,7 @@
 
     const char* hlp_getErrorMessage(int error);
 
-    //Returns items count. Use hlp_getObjectCount22.
+    //Returns items count. Use hlp_getObjectCount2.
     int hlp_getObjectCount(gxByteBuffer* buff);
 
     //Returns items count.
@@ -114,6 +114,11 @@
     */
     int hlp_bytesToHex2(const unsigned char* bytes, uint16_t count, char* buff, uint16_t size);
 
+    /**
+    * Convert byte array to hex string.
+    */
+    int hlp_bytesToHex3(const unsigned char* bytes, uint16_t count, char* buff, uint16_t size, unsigned char addSpace);
+
 #ifndef DLMS_IGNORE_MALLOC
     /**
     * Convert hex string to byte array. This method use malloc to allocate enough memory.
@@ -220,6 +225,17 @@
     */
     int32_t hlp_stringToInt(
         const char* str);
+
+    /**
+    * Convert string to integer.
+    *
+    * @param str
+    *            Parsed string.
+    * @return Value of string as integer.
+    */
+    int32_t hlp_stringToInt2(
+        const char* str, const char* end);
+
     /**
     * Convert integer to string.
     *
@@ -267,6 +283,28 @@
     //Swap bits. Reserved for internal use.
     unsigned char hlp_swapBits(unsigned char value);
 
+
+    /*Load file.*/
+    int hlp_load(const char* path, char* value, uint16_t* length);
+
+    /*Save file.*/
+    int hlp_save(const char* path, const char* value);
+
+    /*Create new directory.*/
+    int hlp_createDir(const char* path);
+    
+    /*Check if the directory exists.*/
+    unsigned char hlp_directoryExists(const char* path);
+
+    /**
+     * Convert Base64 string to byte array.
+     *
+     * @param input
+     *            Base64 string.
+     * @return Converted byte array.
+     */
+    int hlp_fromBase64(const char* input, uint16_t length, gxByteBuffer* decoded);
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/privateKey.h src/development/include/privateKey.h
--- upstream/development/include/privateKey.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/privateKey.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,91 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GXPRIVATEKEY_H
+#define GXPRIVATEKEY_H
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "enums.h"
+#include "byteBuffer.h"
+#include "publicKey.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+#ifdef DLMS_SECURITY_SUITE_1
+#define PRIVATE_KEY_SIZE 32
+#endif //DLMS_SECURITY_SUITE_1
+#ifdef DLMS_SECURITY_SUITE_2
+#define PRIVATE_KEY_SIZE 80
+#endif //DLMS_SECURITY_SUITE_2
+    typedef struct
+    {
+        /**
+            Used scheme.
+        */
+        ECC scheme;
+        /**
+         Private key raw value.
+        */
+        gxByteBuffer rawValue;
+        gxPublicKey publicKey;
+        //Access private key throught rawValue. Don't use buff directly.
+        unsigned char buff[PRIVATE_KEY_SIZE];
+    } gxPrivateKey;
+
+    void priv_init(gxPrivateKey* key);
+
+    /*Clear the private key.*/
+    void priv_clear(gxPrivateKey* key);
+
+    /**
+        Create the private key from raw bytes.
+        value: Raw data
+        key: Private key.
+    */
+    int priv_fromRawBytes(
+        gxByteBuffer* value,
+        gxPrivateKey* key);
+
+    /**
+        Get public key from private key.
+        Returns Public key.
+    */
+    int priv_getPublicKey(gxPrivateKey* priv,
+        gxPublicKey* pub);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#endif //GXPRIVATEKEY_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/publicKey.h src/development/include/publicKey.h
--- upstream/development/include/publicKey.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/publicKey.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,96 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef GXPUBLICKEY_H
+#define GXPUBLICKEY_H
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "enums.h"
+#include "byteBuffer.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef DLMS_SECURITY_SUITE_1
+#define PUBLIC_KEY_SIZE 65
+#endif //DLMS_SECURITY_SUITE_1
+#ifdef DLMS_SECURITY_SUITE_2
+#define PUBLIC_KEY_SIZE 80
+#endif //DLMS_SECURITY_SUITE_2
+
+    typedef struct
+    {
+        /**
+            Used scheme.
+        */
+        ECC scheme;
+        /**
+         Public key raw value.
+        */
+        gxByteBuffer rawValue;
+        //Access public key throught rawValue. Don't use buff directly.
+        unsigned char buff[PUBLIC_KEY_SIZE];
+    } gxPublicKey;
+
+    void pub_init(gxPublicKey* key);
+
+    /*Clear the public key.*/
+    void pub_clear(gxPublicKey* key);
+
+    /**
+    Create the public key from raw bytes.
+    key: Public key.
+    value: Raw data
+    */
+    int pub_fromRawBytes(
+        gxPublicKey* key, 
+        gxByteBuffer* value);
+
+    /**
+     X Coordinate.
+    */
+    int pub_getX(gxPublicKey* key,
+        gxByteBuffer* value);
+
+    /**
+        Y Coordinate.
+    */
+    int pub_getY(gxPublicKey* key,
+        gxByteBuffer* value);
+
+#ifdef  __cplusplus
+}
+#endif
+#endif//defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#endif //GXPUBLICKEY_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/server.h src/development/include/server.h
--- upstream/development/include/server.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/server.h	2024-11-13 12:20:09.000000000 +0000
@@ -146,10 +146,29 @@
         unsigned char force);
 #endif  //DLMS_IGNORE_ASSOCIATION_SHORT_NAME
 
+#if !defined(DLMS_IGNORE_ACTIVITY_CALENDAR) && !defined(DLMS_IGNORE_OBJECT_POINTERS)
+    int svr_handleActivityCalendar(
+        dlmsServerSettings* settings,
+        gxActivityCalendar* object,
+        uint32_t time,
+        uint32_t* next);
+#endif //!defined(DLMS_IGNORE_ACTIVITY_CALENDAR) && !defined(DLMS_IGNORE_OBJECT_POINTERS)
+
     //Check is client changing the settings with action.
     //This can be used to check is meter data changed.
     //Return value is saved atribute index or zero if nothing hasn't change.
     uint32_t svr_isChangedWithAction(DLMS_OBJECT_TYPE objectType, unsigned char methodIndex);
+
+#ifdef DLMS_NOTIFY_CIPHERING_ERROR
+    //Meter notifies from the ciphering error.
+    extern void svr_cipheringError();
+#endif //DLMS_NOTIFY_CIPHERING_ERROR
+
+#ifdef DLMS_NOTIFY_AUTHENTICATION_ERROR
+    //Meter notifies from the authentication error.
+    extern void svr_authenticationError();
+#endif //DLMS_NOTIFY_AUTHENTICATION_ERROR
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/serverevents.h src/development/include/serverevents.h
--- upstream/development/include/serverevents.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/serverevents.h	2024-11-13 12:20:09.000000000 +0000
@@ -220,6 +220,27 @@
     //Server uses notify trace if DLMS_DEBUG is defined.
     void svr_notifyTrace2(const char* str, const short ot, const unsigned char* ln, int err);
 
+#ifdef DLMS_INVOCATION_COUNTER_VALIDATOR
+    //Some DLMS sub standard define that invocation counter must between given range.
+    //Returns zero if the invocation counter is accepted.
+    extern unsigned char svr_validateInvocationCounter(
+        dlmsSettings* settings, 
+        uint32_t value);
+
+    /* Code example:
+    unsigned char svr_validateInvocationCounter(dlmsSettings* settings, uint32_t value)
+    {
+        if (value < *settings->expectedInvocationCounter - 3 &&
+            value > *settings->expectedInvocationCounter + 3) {
+            // If the IC value is out of the expected range
+            return 1;
+        }
+        *settings->expectedInvocationCounter = value + 1;
+        return 0;
+    }
+    */
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
+
 #ifdef  __cplusplus
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/shamirs.h src/development/include/shamirs.h
--- upstream/development/include/shamirs.h	1970-01-01 00:00:00.000000000 +0000
+++ src/development/include/shamirs.h	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,101 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#ifndef SHAMIR_H
+#define SHAMIR_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "gxignore.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "curve.h"
+#include "publickey.h"
+#include "bytebuffer.h"
+#include "bigInteger.h"    
+
+    /// <summary>
+    /// Count Shamir's trick.
+    /// </summary>
+    /// <param name="curve">Used curve.</param>
+    /// <param name="pub">Public key.</param>
+    /// <param name="ret">Result.</param>
+    /// <param name="u1"></param>
+    /// <param name="u2"></param>
+    int shamirs_trick(gxCurve* curve,
+        gxPublicKey* pub,
+        gxEccPoint* ret,
+        bigInteger* u1,
+        bigInteger* u2);
+
+    /// <summary>
+    /// Add points.
+    /// </summary>
+    /// <param name="curve">Used curve.</param>
+    /// <param name="ret">Result.</param>
+    /// <param name="p1">Point 1.</param>
+    /// <param name="p2">Point 2.</param>
+    int shamirs_pointAdd(gxCurve* curve,
+        gxEccPoint* ret,
+        gxEccPoint* p1,
+        gxEccPoint* p2);
+
+    /// <summary>
+    /// Double point.
+    /// </summary>
+    /// <param name="curve">Used curve.</param>
+    /// <param name="ret">Result value.</param>
+    /// <param name="p1">Point to double</param>
+    int shamirs_pointDouble(gxCurve* curve,
+        gxEccPoint* ret,
+        gxEccPoint* p1);
+
+    /// <summary>
+    /// Multiply point with big integer value.
+    /// </summary>
+    /// <param name="curve">Used curve.</param>
+    /// <param name="value">Return value.</param>
+    /// <param name="point">Point.</param>
+    /// <param name="scalar">Scaler.</param>
+    int shamirs_pointMulti(gxCurve* curve,
+        gxEccPoint* value,
+        gxEccPoint* point,
+        bigInteger* scalar);
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //SHAMIR_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/include/variant.h src/development/include/variant.h
--- upstream/development/include/variant.h	2024-01-23 14:13:59.000000000 +0000
+++ src/development/include/variant.h	2024-11-13 12:20:09.000000000 +0000
@@ -76,13 +76,16 @@
 #define GX_FLOAT(X) GX_UNION(&X, fltVal, DLMS_DATA_TYPE_FLOAT32)
 #define GX_DOUBLE(X) GX_UNION(&X, dblVal, DLMS_DATA_TYPE_FLOAT64)
 #define GX_BOOL(X) GX_UNION(&X, bVal, DLMS_DATA_TYPE_BOOLEAN)
+#define GX_ENUM(X) GX_UNION(&X, cVal, DLMS_DATA_TYPE_ENUM)
 #ifdef DLMS_IGNORE_MALLOC
 #define GX_DATETIME(X) X.size = 12; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATETIME))
+#define GX_DATE(X) X.size = 5; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATE))
+#define GX_TIME(X) X.size = 4; GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_TIME))
 #else
 #define GX_DATETIME(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATETIME))
-#endif //DLMS_IGNORE_MALLOC
 #define GX_DATE(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_DATE))
 #define GX_TIME(X) GX_UNION(&X, pVal, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_TIME))
+#endif //DLMS_IGNORE_MALLOC
 #define GX_UINT8_BYREF(X, VALUE_) GX_UNION(&X, pbVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT8))
 #define GX_UINT16_BYREF(X, VALUE_) GX_UNION(&X, puiVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT16))
 #define GX_UINT32_BYREF(X, VALUE_) GX_UNION(&X, pulVal = &VALUE_, (DLMS_DATA_TYPE)(DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_UINT32))
@@ -131,6 +134,8 @@
 /*Get boolean value from variant.*/
 #define GX_GET_BOOL(X) (X.vt & DLMS_DATA_TYPE_BYREF) == 0 ? (X.bVal != 0) : (*X.pbVal != 0)
 
+#define GX_ADD(X, VALUE_) GX_UNION(&X, pbVal += VALUE_, X.vt)
+
     typedef struct
     {
 #ifdef DLMS_IGNORE_MALLOC
@@ -428,8 +433,8 @@
 
     //copy variant.
     int var_copy(
-        dlmsVARIANT* value,
-        dlmsVARIANT* copy);
+        dlmsVARIANT* target,
+        dlmsVARIANT* source);
 
     //Clear variant.
     int var_clear(
@@ -453,6 +458,15 @@
         gxByteBuffer* ba,
         unsigned char addType);
 
+    //Get bytes from variant value.
+    int var_getBytes4(
+        dlmsVARIANT* data,
+        DLMS_DATA_TYPE type,
+        gxByteBuffer* ba,
+        unsigned char addType,
+        unsigned char addArraySize,
+        unsigned char addStructureSize);
+
     //Get size in bytes.
     int var_getSize(
         DLMS_DATA_TYPE vt);
@@ -525,6 +539,67 @@
 
 #endif //GX_DLMS_MICROCONTROLLER
 
+#ifndef DLMS_IGNORE_DELTA
+    //Set byte delta value to variant.
+    int var_setDeltaUInt8(
+        dlmsVARIANT* data,
+        unsigned char value);
+
+    //Set UInt16 delta value to variant.
+    int var_setDeltaUInt16(
+        dlmsVARIANT* data,
+        uint16_t value);
+
+    //Set UInt32 delta value to variant.
+    int var_setDeltaUInt32(dlmsVARIANT
+        * data,
+        uint32_t value);
+
+    //Set signed byte delta value to variant.
+    int var_setDeltaInt8(
+        dlmsVARIANT* data,
+        char value);
+
+    //Set Int16 delta value to variant.
+    int var_setDeltaInt16(
+        dlmsVARIANT* data,
+        short value);
+
+    //Set Int32 delta value to variant.
+    int var_setDeltaInt32(
+        dlmsVARIANT* data,
+        int32_t value);
+
+    //Get byte value from variant.
+    int var_getDeltaUInt8(
+        dlmsVARIANT* data,
+        unsigned char* value);
+
+    //Get UInt16 value from variant.
+    int var_getDeltaUInt16(
+        dlmsVARIANT* data,
+        uint16_t* value);
+
+    //Get UInt32 value from variant.
+    int var_getDeltaUInt32(
+        dlmsVARIANT* data,
+        uint32_t* value);
+
+    //Get signed byte value from variant.
+    int var_getDeltaInt8(
+        dlmsVARIANT* data,
+        char* value);
+
+    //Get Int16 value from variant.
+    int var_getDeltaInt16(
+        dlmsVARIANT* data,
+        short* value);
+
+    //Get Int32 value from variant.
+    int var_getDeltaInt32(
+        dlmsVARIANT* data,
+        int32_t* value);
+#endif //DLMS_IGNORE_DELTA
 #define VA_ATTACH(X, V, S) va_attach(&X, V, S, sizeof(V)/sizeof(V[0]))
 
 #ifdef  __cplusplus
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/apdu.c src/development/src/apdu.c
--- upstream/development/src/apdu.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/apdu.c	2024-11-13 12:20:09.000000000 +0000
@@ -172,7 +172,10 @@
     }
     // Add system title.
 #ifndef DLMS_IGNORE_HIGH_GMAC
-    if (!settings->server && (ciphered || settings->authentication == DLMS_AUTHENTICATION_HIGH_GMAC))
+    if (!settings->server && (ciphered ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_GMAC ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256 ||
+        settings->authentication == DLMS_AUTHENTICATION_HIGH_ECDSA))
     {
 #ifndef DLMS_IGNORE_MALLOC
         if (settings->cipher.systemTitle.size == 0)
@@ -385,7 +388,7 @@
         if ((ret = apdu_getInitiateRequest(settings, &crypted)) != 0)
         {
             return ret;
-        }        
+        }
 #ifndef DLMS_IGNORE_MALLOC
         ret = cip_encrypt(
             &settings->cipher,
@@ -513,6 +516,12 @@
         {
             return DLMS_ERROR_CODE_INVALID_SECURITY_SUITE;
         }
+#ifdef DLMS_INVOCATION_COUNTER_VALIDATOR
+        if (svr_validateInvocationCounter(settings, invocationCounter) != 0)
+        {
+            return DLMS_ERROR_CODE_INVOCATION_COUNTER_TOO_SMALL;
+        }
+#else
         if (settings->expectedInvocationCounter != NULL)
         {
             if (invocationCounter < 1 + *settings->expectedInvocationCounter)
@@ -520,12 +529,12 @@
                 return DLMS_ERROR_CODE_INVOCATION_COUNTER_TOO_SMALL;
             }
 #ifdef DLMS_COSEM_INVOCATION_COUNTER_SIZE64
-            *settings->expectedInvocationCounter = 1 + invocationCounter;
+            * settings->expectedInvocationCounter = 1 + invocationCounter;
 #else
-            *settings->expectedInvocationCounter = (uint32_t)(1 + invocationCounter);
+            * settings->expectedInvocationCounter = (uint32_t)(1 + invocationCounter);
 #endif //DLMS_COSEM_INVOCATION_COUNTER_SIZE64
-
         }
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
         //If client system title doesn't match.
         if (settings->expectedClientSystemTitle != NULL &&
             memcmp(settings->expectedClientSystemTitle, EMPTY_SYSTEM_TITLE, 8) != 0 &&
@@ -2035,10 +2044,13 @@
 #ifndef DLMS_IGNORE_HIGH_GMAC
         if (encryptedData != NULL && encryptedData->size != 0)
         {
-            bb_capacity(&tmp, 2 + encryptedData->size);
-            bb_setUInt8(&tmp, DLMS_COMMAND_GLO_INITIATE_RESPONSE);
-            hlp_setObjectCount(encryptedData->size, &tmp);
-            bb_set2(&tmp, encryptedData, 0, encryptedData->size);
+            if ((ret = bb_capacity(&tmp, 2 + encryptedData->size)) != 0 ||
+                (ret = bb_setUInt8(&tmp, DLMS_COMMAND_GLO_INITIATE_RESPONSE)) != 0 ||
+                (ret = hlp_setObjectCount(encryptedData->size, &tmp)) != 0 ||
+                (ret = bb_set2(&tmp, encryptedData, 0, encryptedData->size)) != 0)
+            {
+                return ret;
+            }
         }
         else
 #endif //DLMS_IGNORE_HIGH_GMAC
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/asn1Parser.c src/development/src/asn1Parser.c
--- upstream/development/src/asn1Parser.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/asn1Parser.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,298 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include <string.h> /* memset */
+#include "../include/asn1Parser.h"
+#include "../include/helpers.h"
+
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+uint32_t asn1Parser_getUtcTime(const char* dateString)
+{
+    gxtime time;
+    uint32_t year = 2000 + hlp_stringToInt2(dateString, dateString + 2);
+    unsigned char month = (unsigned char)hlp_stringToInt2(dateString + 2, dateString + 4);
+    unsigned char day = (unsigned char)hlp_stringToInt2(dateString + 4, dateString + 6);
+    unsigned char hour = (unsigned char)hlp_stringToInt2(dateString + 6, dateString + 8);
+    unsigned char minute = (unsigned char)hlp_stringToInt2(dateString + 8, dateString + 10);
+    time_init(&time, year, month, day, hour, minute, 0, 0, 0);
+    return time_toUnixTime2(&time);
+}
+
+int asn1Parser_fromByteArray(
+    gx509Certificate* cert,
+    gxByteBuffer* data,
+    DLMS_X509_CERTIFICATE_DATA info,
+    uint8_t level,
+    uint8_t index,
+    unsigned char** objectIdentifier)
+{
+    int ret = 0;
+    uint16_t length;
+    unsigned char type;
+    uint8_t index2 = 0;
+    if ((ret = bb_getUInt8(data, &type)) == 0 &&
+        (ret = hlp_getObjectCount2(data, &length)) == 0)
+    {
+        if (length > bb_available(data))
+        {
+            return DLMS_ERROR_CODE_OUTOFMEMORY;
+        }
+        uint32_t start = data->position;
+        switch (type)
+        {
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_SEQUENCE:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT | 1:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT | 2:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT | 3:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT | 4:
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_CONTEXT | 5:
+        {
+            ++level;
+            if (cert == NULL)
+            {
+                if ((info == DLMS_X509_CERTIFICATE_DATA_ISSUER && level == 3 && index == 3) ||
+                    (info == DLMS_X509_CERTIFICATE_DATA_SUBJECT && level == 3 && index == 5))
+                {
+                    //return Issuer raw.
+                    data->position -= 1 + hlp_getObjectCountSizeInBytes(length);
+                    data->size = 1 + hlp_getObjectCountSizeInBytes(length) + data->position + length;
+                    //Return false to indicate that the value has found.
+                    return DLMS_ERROR_CODE_FALSE;
+                }
+            }
+            while (data->position < start + length)
+            {
+                if ((ret = asn1Parser_fromByteArray(cert, data, info, 
+                    level, index2, objectIdentifier)) != 0)
+                {
+                    break;
+                }
+                ++index2;
+            }
+            if (level == 0 && index2 != 3)
+            {
+                //If not X.509 certifiate.
+                return DLMS_ERROR_CODE_INVALID_CERTIFICATE;
+            }
+        }
+        break;
+        case BER_TYPE_CONTEXT:
+        case BER_TYPE_CONTEXT | 1:
+        case BER_TYPE_CONTEXT | 2:
+        case BER_TYPE_CONTEXT | 3:
+        case BER_TYPE_CONTEXT | 4:
+        case BER_TYPE_CONTEXT | 5:
+        case BER_TYPE_CONTEXT | 6:
+            data->position += length;
+            break;
+
+        case BER_TYPE_CONSTRUCTED | BER_TYPE_SET:
+            if ((ret = asn1Parser_fromByteArray(cert, data, 
+                info, 1 + level, index2, objectIdentifier)) != 0)
+            {
+                break;
+            }
+            break;
+        case BER_TYPE_INTEGER:
+            if (length == 1)
+            {
+                if (level == 3 && index == 0)
+                {
+                    //Version must be 3 with DLMS meters.
+                    if (data->data[data->position] != 2)
+                    {
+                        return DLMS_ERROR_CODE_INVALID_CERTIFICATE;
+                    }
+                }
+            }
+            else
+            {
+                if (level == 2 && index == 1)
+                {
+                    //Serial number.
+                    if (cert != NULL)
+                    {
+                        cert->serialNumber.size = length / sizeof(uint32_t);
+                        memset(cert->serialNumber.data + cert->serialNumber.size, 0, sizeof(uint32_t));
+                        memcpy(cert->serialNumber.data, data->data + data->position, length);
+                        if (length % sizeof(uint32_t) != 0)
+                        {
+                            ++cert->serialNumber.size;
+                        }
+                    }
+                    else
+                    {
+                        if (info == DLMS_X509_CERTIFICATE_DATA_SERIAL_NUMBER)
+                        {
+                            data->position -= 1 + hlp_getObjectCountSizeInBytes(length);
+                            data->size = 1 + hlp_getObjectCountSizeInBytes(length) + data->position + length;
+                            //Return false to indicate that the value has found.
+                            return DLMS_ERROR_CODE_FALSE;
+                        }
+                    }
+                }
+            }
+            data->position += length;
+            break;
+        case BER_TYPE_OBJECT_IDENTIFIER:
+            *objectIdentifier = data->data + data->position;
+            if (cert != NULL && level == 3 && index == 0)
+            {
+                //Signature algrythm.
+                static unsigned char SHA256_WITH_ECDSA[] = { 0x2A, 0x86, 0x48, 0xCE, 0x3d, 0x04, 0x03, 0x02 };
+                static unsigned char SHA384_WITH_ECDSA[] = { 0x2A, 0x86, 0x48, 0xCE, 0x3d, 0x04, 0x03, 0x02 };
+                if (memcmp(data->data + data->position, SHA256_WITH_ECDSA, sizeof(SHA256_WITH_ECDSA)) == 0)
+                {
+                    cert->signatureAlgorithm = ECC_P256;
+                }
+                else if (memcmp(data->data + data->position, SHA384_WITH_ECDSA, sizeof(SHA384_WITH_ECDSA)) == 0)
+                {
+                    cert->signatureAlgorithm = ECC_P384;
+                }
+                else
+                {
+                    ret = DLMS_ERROR_CODE_INVALID_CERTIFICATE;
+                }
+            }
+            data->position += length;
+            break;
+        case BER_TYPE_UTF8_STRING:
+        case BER_TYPE_PRINTABLE_STRING:
+        {
+            static unsigned char ID[] = { 0x55, 0x4, 0x3 };
+            if (level == 5 && length == 16 && *objectIdentifier != NULL &&
+                memcmp(*objectIdentifier, ID, sizeof(ID)) == 0)
+            {
+                if (cert != NULL)
+                {
+                    uint16_t count = 7;
+                    // Don't handle return value because only 8 bytes are needed and 
+                    // hlp_hexToBytes2 returns DLMS_ERROR_CODE_OUTOFMEMORY.
+                    hlp_hexToBytes2((const char*)(data->data + data->position), cert->systemTitle, &count);
+                }
+                else
+                {
+                    if (info == DLMS_X509_CERTIFICATE_DATA_SYSTEM_TITLE)
+                    {
+                        data->position -= 1 + hlp_getObjectCountSizeInBytes(length);
+                        data->size = 1 + hlp_getObjectCountSizeInBytes(length) + data->position + length;
+                        //Return false to indicate that the value has found.
+                        return DLMS_ERROR_CODE_FALSE;
+                    }
+                }
+            }
+            data->position += length;
+        }
+        break;
+        case BER_TYPE_IA5_STRING:
+            data->position += length;
+            break;
+        case BER_TYPE_UTC_TIME:
+            if (cert != NULL)
+            {
+                if (level == 3 && index == 0)
+                {
+                    cert->validFrom = asn1Parser_getUtcTime((const char*)(data->data + data->position));
+                }
+                else if (level == 3 && index == 1)
+                {
+                    cert->validTo = asn1Parser_getUtcTime((const char*)(data->data + data->position));
+                }
+            }
+            data->position += length;
+            break;
+        case BER_TYPE_GENERALIZED_TIME:
+            data->position += length;
+            break;
+        case BER_TYPE_BOOLEAN:
+            data->position += length;
+            break;
+        case BER_TYPE_OCTET_STRING:
+        {
+            type = data->data[data->position];
+            if (type == (BER_TYPE_CONSTRUCTED | BER_TYPE_SEQUENCE) ||
+                type == (BER_TYPE_BIT_STRING))
+            {
+                if ((ret = asn1Parser_fromByteArray(cert, data, info,
+                    level, index, objectIdentifier)) != 0)
+                {
+                    break;
+                }
+            }
+            else
+            {
+                data->position += length;
+            }
+        }
+        break;
+        case BER_TYPE_BIT_STRING:
+            if (level == 3 && index == 1)
+            {
+                gxByteBuffer bb;
+                //Ignore Pad bits.
+                bb_attach(&bb, data->data + data->position + 1, length - 1, length - 1);
+                ret = pub_fromRawBytes(&cert->publicKey, &bb);
+            }
+            else
+            {
+                static unsigned char KEYUSAGE_ID[] = { 0x55, 0x1D, 0xF };
+                if (level == 5 && *objectIdentifier != NULL &&
+                    memcmp(*objectIdentifier, KEYUSAGE_ID, sizeof(KEYUSAGE_ID)) == 0)
+                {
+                    cert->keyUsage = hlp_swapBits(*(data->data + data->position + 1));
+                }
+            }
+            data->position += length;
+            break;
+        default:
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+    }
+    return ret;
+}
+
+int asn1Parser_parsex509Certificate(
+    gx509Certificate* cert,
+    gxByteBuffer* data,
+    DLMS_X509_CERTIFICATE_DATA target,
+    uint8_t level,
+    uint8_t index)
+{
+    unsigned char* objectIdentifier = NULL;
+    int ret = asn1Parser_fromByteArray(cert, data, 
+        target, level, index, &objectIdentifier);
+    return ret;
+}
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/bigInteger.c src/development/src/bigInteger.c
--- upstream/development/src/bigInteger.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/bigInteger.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,920 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/gxmem.h"
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+#include <assert.h>
+#endif
+
+#if _MSC_VER > 1400
+#include <crtdbg.h>
+#endif
+#include <string.h>
+#include "../include/errorcodes.h"
+#include "../include/bigInteger.h"
+#include "../include/helpers.h"
+
+char bi_isAttached(bigInteger* arr)
+{
+    if (arr == NULL)
+    {
+        return 0;
+    }
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    //If byte buffer is attached.
+    return (arr->capacity & 0x80000000) == 0x80000000;
+#else
+    return (arr->capacity & 0x8000) == 0x8000;
+#endif
+}
+
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+int bi_capacity(
+    bigInteger* arr,
+    uint32_t capacity)
+#else
+int bi_capacity(
+    bigInteger* arr,
+    uint16_t capacity)
+#endif
+{
+#ifndef DLMS_IGNORE_MALLOC
+    //Capacity can't change if it's attached.
+    if (!bi_isAttached(arr))
+    {
+        if (capacity == 0)
+        {
+            if (arr->data != NULL)
+            {
+                gxfree(arr->data);
+                arr->data = NULL;
+                arr->size = 0;
+            }
+        }
+        else
+        {
+            if (arr->capacity == 0)
+            {
+                arr->data = (uint32_t*)gxmalloc(capacity);
+                if (arr->data == NULL)
+                {
+                    return DLMS_ERROR_CODE_OUTOFMEMORY;
+                }
+            }
+            else
+            {
+#ifdef gxrealloc
+                //If compiler supports realloc.
+                uint32_t* tmp = (uint32_t*)gxrealloc(arr->data, capacity);
+                //If not enought memory available.
+                if (tmp == NULL)
+                {
+                    return DLMS_ERROR_CODE_OUTOFMEMORY;
+                }
+                arr->data = tmp;
+#else
+                //If compiler doesn't support realloc.
+                uint32_t* old = arr->data;
+                arr->data = (uint32_t*)gxmalloc(capacity);
+                //If not enought memory available.
+                if (arr->data == NULL)
+                {
+                    arr->data = old;
+                    return DLMS_ERROR_CODE_OUTOFMEMORY;
+                }
+                memcpy(arr->data, old, arr->size);
+                gxfree(old);
+#endif // gxrealloc       
+            }
+            if (arr->size > capacity)
+            {
+                arr->size = capacity;
+            }
+        }
+        arr->capacity = capacity;
+    }
+#endif //DLMS_IGNORE_MALLOC
+    if (bi_getCapacity(arr) < capacity)
+    {
+        return DLMS_ERROR_CODE_OUTOFMEMORY;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+uint16_t bi_getCapacity(bigInteger* arr)
+{
+    return arr->capacity & 0x7FFF;
+}
+
+uint16_t bi_size(bigInteger* bb)
+{
+    return bb != NULL ? bb->size : 0;
+}
+
+void bi_init(bigInteger* arr)
+{
+    bi_attach(arr, arr->buff, 0, sizeof(arr->buff));
+    arr->isNegative = 0;
+}
+
+void bi_append(bigInteger* arr, uint32_t value)
+{
+    arr->data[arr->size] = value;
+    ++arr->size;
+    arr->isNegative |= value < 0;
+}
+
+int bi_attach(
+    bigInteger* arr,
+    uint32_t* value,
+    uint16_t count,
+    uint16_t capacity)
+{
+    arr->data = value;
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    arr->capacity = 0x80000000 | capacity;
+#else
+    if (capacity >= 0x8000)
+    {
+        return DLMS_ERROR_CODE_OUTOFMEMORY;
+    }
+    arr->capacity = (uint16_t)(0x8000 | capacity);
+#endif
+    arr->size = count;
+    arr->isNegative = 0;
+    return 0;
+}
+
+int bi_addRange(
+    bigInteger* arr,
+    const uint32_t* values, uint16_t count)
+{
+    if ((arr->size + count) > bi_getCapacity(arr))
+    {
+        return DLMS_ERROR_CODE_OUTOFMEMORY;
+    }
+    memcpy(arr->data + arr->size, values, sizeof(uint32_t) * count);
+    arr->size += count;
+    return 0;
+}
+
+int bi_add(bigInteger* arr, const uint32_t value)
+{
+    return bi_addRange(arr, &value, 1);
+}
+
+int bi_addValue2(uint32_t* list,
+    uint16_t length,
+    uint32_t value,
+    uint16_t index)
+{
+    uint64_t tmp;
+    if (index < length)
+    {
+        tmp = list[index];
+        tmp += value;
+        list[index] = (uint32_t)tmp;
+        uint32_t reminer = (uint32_t)(tmp >> 32);
+        if (reminer > 0)
+        {
+            bi_addValue2(list, length, reminer, index + 1);
+        }
+    }
+    else
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return 0;
+}
+
+unsigned char bi_isZero(bigInteger* arr)
+{
+    return arr->size == 0 ||
+        (arr->size == 1 && arr->data[0] == 0);
+}
+
+unsigned char bi_isEven(bigInteger* arr)
+{
+    return arr->size != 0 &&
+        arr->data[0] % 2 == 0;
+}
+
+unsigned char bi_isOne(bigInteger* arr)
+{
+    return arr->size == 1 && arr->data[0] == 1;
+}
+
+int bi_toArray(bigInteger* arr, gxByteBuffer* data)
+{
+    int ret = 0;
+    uint32_t pos;
+    uint32_t value;
+    for (pos = 0; pos != arr->size; ++pos)
+    {
+        value = arr->data[pos];
+        if ((ret = bb_setUInt8(data, value)) != 0 ||
+            (ret = bb_setUInt8(data, value >> 8)) != 0 ||
+            (ret = bb_setUInt8(data, value >> 16)) != 0 ||
+            (ret = bb_setUInt8(data, value >> 24)) != 0)
+        {
+            break;
+        }
+    }
+    if (ret == 0)
+    {
+        bb_reverse(data, 0, data->size);
+    }
+    return ret;
+}
+
+void bi_or(bigInteger* arr, bigInteger* value)
+{
+    uint32_t pos;
+    if (arr->size < value->size)
+    {
+        arr->size = value->size;
+    }
+    for (pos = 0; pos < value->size; ++pos)
+    {
+        arr->data[pos] |= value->data[pos];
+    }
+}
+
+int bi_compare(bigInteger* arr, bigInteger* value)
+{
+    int ret = 0;
+    if (arr->isNegative != value->isNegative)
+    {
+        //If other value is isNegative.
+        if (arr->isNegative)
+        {
+            ret = -1;
+        }
+        else
+        {
+            ret = 1;
+        }
+    }
+    else if (bi_isZero(arr) && bi_isZero(value))
+    {
+        ret = 0;
+    }
+    else
+    {
+        int cntA = (int)arr->size;
+        cntA -= 1;
+        //Skip zero values.
+        while (cntA != -1 && arr->data[cntA] == 0)
+        {
+            --cntA;
+        }
+        int cntB = (int)value->size;
+        cntB -= 1;
+        //Skip zero values.
+        while (cntB != -1 && value->data[cntB] == 0)
+        {
+            --cntB;
+        }
+        if (cntA > cntB)
+        {
+            ret = 1;
+        }
+        else if (cntA < cntB)
+        {
+            ret = -1;
+        }
+        else
+        {
+            do
+            {
+                if (arr->data[cntA] > value->data[cntA])
+                {
+                    ret = 1;
+                    break;
+                }
+                else if (arr->data[cntA] < value->data[cntA])
+                {
+                    ret = -1;
+                    break;
+                }
+                cntA -= 1;
+            } while (cntA != -1);
+        }
+    }
+    return ret;
+}
+
+int bi_compareValue(bigInteger* arr, uint32_t value)
+{
+    if (arr->size == 0)
+    {
+        return -1;
+    }
+    if (arr->data[0] == value)
+    {
+        return 0;
+    }
+    return arr->data[0] < value ? -1 : 1;
+}
+
+int bi_addBigInteger(bigInteger* arr, bigInteger* value)
+{
+    if (value->isNegative)
+    {
+        value->isNegative = 0;
+        bi_sub(arr, value);
+        value->isNegative = 1;
+    }
+    else
+    {
+        while (arr->size < value->size)
+        {
+            bi_add(arr, 0);
+        }
+        uint64_t overflow = 0;
+        for (uint32_t pos = 0; pos != arr->size; ++pos)
+        {
+            uint64_t tmp = arr->data[pos];
+            if (pos < value->size)
+            {
+                tmp += value->data[pos];
+            }
+            tmp += overflow;
+            arr->data[pos] = (uint32_t)tmp;
+            overflow = tmp >> 32;
+        }
+        if (overflow != 0)
+        {
+            bi_add(arr, (uint32_t)overflow);
+        }
+    }
+    return 0;
+}
+
+int bi_fromByteBuffer(bigInteger* value, gxByteBuffer* bb)
+{
+    int ret = 0;
+    uint32_t tmp;
+    unsigned char ch;
+    uint16_t ival;
+    int pos;
+    if ((ret = bi_clear(value)) == 0 &&
+        (ret = bi_capacity(value, bb_size(bb) / 4)) == 0)
+    {
+        for (pos = bb_size(bb) - 4; pos > -1; pos = pos - 4)
+        {
+            if ((ret = bb_getUInt32ByIndex(bb, pos, &tmp)) != 0 ||
+                (ret = bi_add(value, tmp)) != 0)
+            {
+                break;
+            }
+        }
+        if (ret == 0)
+        {
+            switch (bb_size(bb) % 4)
+            {
+            case 1:
+                if ((ret = bb_getUInt8(bb, &ch)) != 0 ||
+                    (ret = bi_add(value, ch)) != 0)
+                {
+                    break;
+                }
+                break;
+            case 2:
+                if ((ret = bb_getUInt16(bb, &ival)) != 0 ||
+                    (ret = bi_add(value, ival)) != 0)
+                {
+                    break;
+                }
+                break;
+            case 3:
+                if ((ret = bb_getUInt8(bb, &ch)) != 0 ||
+                    (ret = bb_getUInt16(bb, &ival)) != 0)
+                {
+                    break;
+                }
+                tmp = ch;
+                tmp <<= 16;
+                tmp |= ival;
+                ret = bi_add(value, tmp);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+void bi_sub(bigInteger* arr, bigInteger* value)
+{
+    int c = bi_compare(arr, value);
+    if (c == 0)
+    {
+        bi_clear(arr);
+    }
+    else if (value->isNegative || c == -1)
+    {
+        if (!value->isNegative && !arr->isNegative)
+        {
+            //If biger value is decreased from smaller value.
+            bigInteger tmp;
+            bi_init(&tmp);
+            bi_addBigInteger(&tmp, value);
+            bi_sub(&tmp, arr);
+            bi_clear(arr);
+            bi_addRange(arr, tmp.data, tmp.size);
+            arr->size = tmp.size;
+            arr->isNegative = 1;
+        }
+        else
+        {
+            //If isNegative value is decreased from the value.
+            unsigned char ret = value->isNegative;
+            value->isNegative = 0;
+            bi_addBigInteger(arr, value);
+            value->isNegative = ret;
+            arr->isNegative = !ret;
+        }
+    }
+    else
+    {
+        if (!bi_isZero(value))
+        {
+            if (bi_isZero(arr))
+            {
+                arr->isNegative = 1;
+                bi_clear(arr);
+                bi_addRange(arr, value->data, value->size);
+                arr->size = value->size;
+            }
+            else
+            {
+                while (arr->size < value->size)
+                {
+                    bi_add(arr, (uint32_t)0);
+                }
+                unsigned char borrow = 0;
+                uint64_t tmp;
+                uint32_t pos;
+                for (pos = 0; pos != value->size; ++pos)
+                {
+                    tmp = arr->data[pos];
+                    tmp += 0x100000000;
+                    tmp -= value->data[pos];
+                    tmp -= borrow;
+                    arr->data[pos] = (uint32_t)tmp;
+                    borrow = (unsigned char)((tmp < 0x100000000) ? 1 : 0);
+                }
+                if (borrow != 0)
+                {
+                    for (; pos != arr->size; ++pos)
+                    {
+                        tmp = arr->data[pos];
+                        tmp += 0x100000000;
+                        tmp -= borrow;
+                        arr->data[pos] = (uint32_t)tmp;
+                        borrow = (unsigned char)((tmp < 0x100000000) ? 1 : 0);
+                        if (borrow == 0)
+                        {
+                            break;
+                        }
+                    }
+                }
+                //Remove empty last item(s).
+                while (arr->size != 1 && arr->data[arr->size - 1] == 0)
+                {
+                    --arr->size;
+                }
+            }
+        }
+    }
+}
+
+int bi_multiply(bigInteger* arr, bigInteger* value)
+{
+    if (bi_isZero(value) || bi_isZero(arr))
+    {
+        arr->size = 0;
+    }
+    else if (!bi_isOne(value))
+    {
+        int ret2;
+        uint16_t lenght = 1 + value->size + arr->size;
+        bi_capacity(arr, lenght);
+        uint32_t ret[BIG_INTERER_CAPACITY];
+        memset(ret, 0, BIG_INTERER_CAPACITY * sizeof(uint32_t));
+        uint32_t overflow = 0;
+        uint32_t index = 0;
+        for (uint32_t i = 0; i != value->size; ++i)
+        {
+            overflow = 0;
+            for (uint32_t j = 0; j != arr->size; ++j)
+            {
+                uint64_t result = value->data[i];
+                result *= arr->data[j];
+                result += overflow;
+                overflow = (uint32_t)(result >> 32);
+                index = i + j;
+                if ((ret2 = bi_addValue2(ret, lenght, (uint32_t)result, index)) != 0)
+                {
+                    return ret2;
+                }
+            }
+            if (overflow > 0)
+            {
+                if ((ret2 = bi_addValue2(ret, lenght, overflow, 1 + index)) != 0)
+                {
+                    return ret2;
+                }
+            }
+        }
+        index = lenght - 1;
+        while (index != 0 && ret[index] == 0)
+        {
+            --index;
+        }
+        ++index;
+        memcpy(arr->data, ret, index * sizeof(uint32_t));
+        arr->size = index;
+    }
+    if (value->isNegative != arr->isNegative)
+    {
+        if (!arr->isNegative)
+        {
+            arr->isNegative = 1;
+        }
+    }
+    else if (arr->isNegative)
+    {
+        //If both values are isNegative.
+        arr->isNegative = 0;
+    }
+    return 0;
+}
+
+void bi_multiplyInt32(bigInteger* arr, int32_t value)
+{
+    if (value == 0 || bi_isZero(arr))
+    {
+        arr->size = 0;
+    }
+    else if (value != 1)
+    {
+        uint16_t lenght = 1 + 1 + arr->size;
+        bi_capacity(arr, lenght);
+        uint32_t ret[BIG_INTERER_CAPACITY];
+        memset(ret, 0, BIG_INTERER_CAPACITY * sizeof(uint32_t));
+        uint32_t overflow = 0;
+        uint32_t index;
+        for (index = 0; index != arr->size; ++index)
+        {
+            uint64_t result = value;
+            result *= arr->data[index];
+            result += overflow;
+            overflow = (uint32_t)(result >> 32);
+            bi_addValue2(ret, lenght, (uint32_t)result, index);
+        }
+        if (overflow > 0)
+        {
+            bi_addValue2(ret, lenght, overflow, index);
+        }
+        index = lenght - 1;
+        while (index != 0 && ret[index] == 0)
+        {
+            --index;
+        }
+        ++index;
+        memcpy(arr->data, ret, index * sizeof(uint32_t));
+        arr->size = index;
+    }
+    if (value < 0 && !arr->isNegative)
+    {
+        arr->isNegative = 1;
+    }
+    else if (value < 0 && arr->isNegative)
+    {
+        //If both values are isNegative.
+        arr->isNegative = 0;
+    }
+}
+
+void bi_lshift(bigInteger* arr, uint32_t amount)
+{
+    //Move dwords.
+    uint16_t dwshift = (uint16_t)(amount / (8 * sizeof(uint32_t)));
+    if (dwshift != 0)
+    {
+        memcpy(arr->buff + dwshift, arr->buff, sizeof(uint32_t) * arr->size);
+        memset(arr->buff, 0, sizeof(uint32_t) * dwshift);
+        arr->size += dwshift;
+        amount -= dwshift * 8 * sizeof(uint32_t);
+    }
+    if (amount != 0)
+    {
+        uint32_t overflow = 0;
+        for (uint32_t pos = 0; pos != arr->size; ++pos)
+        {
+            uint64_t tmp = arr->buff[pos];
+            tmp <<= amount;
+            tmp |= overflow;
+            arr->buff[pos] = (uint32_t)tmp;
+            overflow = (uint32_t)(tmp >> 32);
+        }
+        if (overflow != 0)
+        {
+            bi_add(arr, overflow);
+        }
+    }
+}
+
+void bi_rshift(bigInteger* arr, uint32_t amount)
+{
+    while (amount > 8 * sizeof(uint32_t))
+    {
+        bi_rshift(arr, 8 * sizeof(uint32_t));
+        //--m_Count;
+        amount -= 8 * sizeof(uint32_t);
+    }
+    if (amount != 0)
+    {
+        int pos;
+        uint64_t overflow = 0;
+        uint32_t mask = (uint32_t)0xFFFFFFFF;
+        mask = mask >> (32 - amount);
+        uint32_t cnt = arr->size - 1;
+        for (pos = cnt; pos != -1; --pos)
+        {
+            uint64_t tmp = arr->data[pos];
+            arr->data[pos] = (uint32_t)((tmp >> amount) | overflow);
+            overflow = (tmp & mask) << (32 - amount);
+        }
+        //Remove last item if it's empty.
+        while (arr->size != 1 && arr->data[cnt] == 0)
+        {
+            --arr->size;
+            --cnt;
+        }
+    }
+}
+
+int bi_clear(bigInteger* arr)
+{
+    if (arr == NULL)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    arr->size = 0;
+    arr->isNegative = 0;
+    return 0;
+}
+
+int bi_copy(bigInteger* target, bigInteger* source)
+{
+    if (target->capacity < source->capacity)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    memcpy(target->data, source->data, sizeof(uint32_t) * source->size);
+    target->size = source->size;
+    target->isNegative = source->isNegative;
+    return 0;
+}
+
+void bi_pow(bigInteger* arr, uint32_t exponent)
+{
+    if (exponent != 1)
+    {
+        uint32_t pos = 1;
+        bigInteger tmp;
+        bi_copy(&tmp, arr);
+        while (pos <= exponent / 2)
+        {
+            bi_multiply(arr, arr);
+            pos <<= 1;
+        }
+        while (pos < exponent)
+        {
+            bi_multiply(arr, &tmp);
+            ++pos;
+        }
+    }
+}
+
+void bi_div(bigInteger* arr, bigInteger* value)
+{
+    bigInteger current;
+    bi_init(&current);
+    bi_append(&current, 1);
+    bigInteger denom;
+    bi_init(&denom);
+    bi_copy(&denom, value);
+    bigInteger tmp;
+    bi_init(&tmp);
+    bi_copy(&tmp, arr);
+    unsigned char neq = arr->isNegative;
+    arr->isNegative = 0;
+    // while denom < this.
+    while (bi_compare(&denom, arr) == -1)
+    {
+        uint16_t bits = bi_getUsedBits(arr) - bi_getUsedBits(&denom);
+        if (bits != 0)
+        {
+            bi_lshift(&current, bits);
+            bi_lshift(&denom, bits);
+        }
+        else
+        {
+            bi_lshift(&current, 1);
+            bi_lshift(&denom, 1);
+        }
+    }
+    //If overflow.
+    if (bi_compare(&denom, arr) == 1)
+    {
+        if (bi_isOne(&current))
+        {
+            bi_clear(arr);
+            return;
+        }
+        bi_clear(arr);
+        bi_rshift(&current, 1);
+        bi_rshift(&denom, 1);
+        while (!bi_isZero(&current))
+        {
+            uint32_t r = bi_compare(&tmp, &denom);
+            if (r == 1)
+            {
+                bi_sub(&tmp, &denom);
+                bi_addBigInteger(arr, &current);
+            }
+            else if (r == 0)
+            {
+                bi_addBigInteger(arr, &current);
+                break;
+            }
+            uint16_t bits = bi_getUsedBits(&current);
+            bi_rshift(&current, bits);
+            bi_rshift(&denom, bits);
+        }
+        memcpy(current.data, arr->data, sizeof(uint32_t) * arr->size);
+    }
+    arr->isNegative = neq;
+    memcpy(arr->data, current.data, sizeof(uint32_t) * arr->size);
+}
+
+int bi_mod(bigInteger* arr, bigInteger* mod)
+{
+    bigInteger current;
+    bi_init(&current);
+    bi_append(&current, 1);
+    bigInteger denom;
+    bi_init(&denom);
+    bi_copy(&denom, mod);
+    unsigned char neq = arr->isNegative;
+    arr->isNegative = 0;
+    // while denom < this.
+    while (bi_compare(&denom, arr) == -1)
+    {
+        uint16_t bits = bi_getUsedBits(arr) - bi_getUsedBits(&denom);
+        bi_lshift(&current, bits);
+        bi_lshift(&denom, bits);
+    }
+    //If overflow.
+    if (bi_compare(&denom, arr) == 1)
+    {
+        if (bi_isOne(&current))
+        {
+            if (neq)
+            {
+                bi_sub(arr, mod);
+                arr->isNegative = 0;
+            }
+            return 0;
+        }
+        bi_rshift(&current, 1);
+        bi_rshift(&denom, 1);
+        while (!bi_isZero(&current))
+        {
+            uint32_t r = bi_compare(arr, &denom);
+            if (r == 1)
+            {
+                bi_sub(arr, &denom);
+            }
+            else if (r == 0)
+            {
+                break;
+            }
+            bi_rshift(&current, 1);
+            bi_rshift(&denom, 1);
+        }
+    }
+    else
+    {
+        bi_clear(arr);
+    }
+    if (neq)
+    {
+        bi_sub(arr, mod);
+        arr->isNegative = 0;
+    }
+    return 0;
+}
+
+int bi_inv(bigInteger* arr, bigInteger* value)
+{
+    if (!bi_isZero(arr))
+    {
+        bigInteger lm, hm, low, high, r, tmp, nm;
+        bi_init(&lm);
+        bi_init(&hm);
+        bi_init(&low);
+        bi_init(&high);
+        bi_init(&r);
+        bi_init(&tmp);
+        bi_init(&nm);
+        bi_append(&lm, 1);
+        bi_append(&hm, 0);
+        bi_copy(&low, arr);
+        bi_mod(&low, value);
+        bi_copy(&high, value);
+        while (!(bi_isZero(&low) || bi_isOne(&low)))
+        {
+            bi_copy(&r, &high);
+            bi_div(&r, &low);
+            bi_copy(&tmp, &lm);
+            bi_multiply(&tmp, &r);
+            bi_copy(&nm, &hm);
+            bi_sub(&nm, &tmp);
+            bi_copy(&tmp, &low);
+            bi_multiply(&tmp, &r);
+            bi_sub(&high, &tmp);
+
+            bi_copy(&tmp, &low);
+            bi_copy(&low, &high);
+            bi_copy(&high, &tmp);
+            bi_copy(&hm, &lm);
+            bi_copy(&lm, &nm);
+        }
+        memcpy(arr->data, lm.data, sizeof(uint32_t) * lm.size);
+        arr->size = lm.size;
+        arr->isNegative = lm.isNegative;
+        bi_mod(arr, value);
+    }
+    return 0;
+}
+
+uint16_t bi_getUsedBits(bigInteger* bi)
+{
+    uint16_t count = (uint16_t)(32 * bi->size);
+    if (bi->size != 0)
+    {
+        uint32_t tmp = bi->buff[bi->size - 1];
+        uint32_t mask = 0x80000000;
+        while ((tmp & mask) == 0)
+        {
+            mask >>= 1;
+            --count;
+        }
+    }
+    return count;
+}
+
+unsigned char bi_isBitSet(bigInteger* bi, uint16_t index)
+{
+    uint16_t pos = (uint16_t)(index / 32);
+    if (index > 32)
+    {
+        index -= (uint16_t)(32 * index);
+    }
+    return (bi->buff[pos] & (1 << index)) != 0;
+}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/bitarray.c src/development/src/bitarray.c
--- upstream/development/src/bitarray.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/bitarray.c	2024-11-13 12:20:09.000000000 +0000
@@ -181,12 +181,13 @@
 //Set bit by index.
 int ba_setByIndex(bitArray* arr, uint16_t index, unsigned char item)
 {
-    int ret;
-    unsigned char newItem = 0;
     int byteIndex;
-    item = item == 0 ? 0 : 1;
+    //Byte is reset when new item is added.
+    unsigned char newItem = arr->size == 0 || getByteIndex(index) > getByteIndex(arr->size - 1);
     if (!ba_isAttached(arr))
     {
+#ifndef DLMS_IGNORE_MALLOC
+        int ret;
         if (index >= arr->capacity)
         {
             if ((ret = ba_capacity(arr, arr->capacity + BIT_ARRAY_CAPACITY)) != 0)
@@ -194,25 +195,42 @@
                 return ret;
             }
             //If we are adding a bit to the higher than next byte.
-            if (index >= arr->capacity)
+            if (index >= ba_getCapacity(arr))
             {
                 return ba_setByIndex(arr, index, item);
             }
-            newItem = 1;
         }
+#else
+        return DLMS_ERROR_CODE_OUTOFMEMORY;
+#endif //DLMS_IGNORE_MALLOC
     }
-    if (index >= arr->capacity)
+    if (index >= ba_getCapacity(arr))
     {
         return DLMS_ERROR_CODE_OUTOFMEMORY;
     }
     byteIndex = getByteIndex(index);
-    if (index % 8 == 0 || newItem)
+    if (item == 0)
     {
-        arr->data[byteIndex] = (unsigned char)(item << 7);
+        //Reset value.
+        if (newItem)
+        {
+            arr->data[byteIndex] = 0;
+        }
+        else
+        {
+            arr->data[byteIndex] &= ~(1 << (7 - (index % 8)));
+        }
     }
     else
     {
-        arr->data[byteIndex] |= (item << (7 - (index % 8)));
+        if (newItem)
+        {
+            arr->data[byteIndex] = (1 << (7 - (index % 8)));
+        }
+        else
+        {
+            arr->data[byteIndex] |= (1 << (7 - (index % 8)));
+        }
     }
     return 0;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/bytebuffer.c src/development/src/bytebuffer.c
--- upstream/development/src/bytebuffer.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/bytebuffer.c	2024-11-13 12:20:09.000000000 +0000
@@ -142,18 +142,18 @@
             }
             else
             {
+                unsigned char* old = arr->data;
 #ifdef gxrealloc
                 //If compiler supports realloc.
-                unsigned char* tmp = (unsigned char*)gxrealloc(arr->data, capacity);
+                arr->data = (unsigned char*)gxrealloc(arr->data, capacity);
                 //If not enought memory available.
-                if (tmp == NULL)
+                if (arr->data == NULL)
                 {
+                    arr->data = old;
                     return DLMS_ERROR_CODE_OUTOFMEMORY;
                 }
-                arr->data = tmp;
  #else
                 //If compiler doesn't support realloc.
-                unsigned char* old = arr->data;
                 arr->data = (unsigned char*)gxmalloc(capacity);
                 //If not enought memory available.
                 if (arr->data == NULL)
@@ -262,39 +262,39 @@
     {
         unsigned char empty = arr->capacity == 0;
         //If data is append fist time.
-        if (dataSize > VECTOR_CAPACITY || arr->capacity == 0)
-        {
-            arr->capacity += dataSize;
-        }
-        else
+        if (!(dataSize > VECTOR_CAPACITY || arr->capacity == 0))
         {
-            arr->capacity += VECTOR_CAPACITY;
+            dataSize = VECTOR_CAPACITY;
         }
+        arr->capacity += dataSize;
         if (empty)
         {
             arr->data = (unsigned char*)gxmalloc(arr->capacity);
             if (arr->data == NULL)
             {
+                arr->capacity -= dataSize;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
         }
         else
         {
+            unsigned char* old = arr->data;
 #ifdef gxrealloc
             //If compiler supports realloc.
-            unsigned char* tmp = (unsigned char*)gxrealloc(arr->data, arr->capacity);
-            if (tmp == NULL)
+            arr->data = (unsigned char*)gxrealloc(arr->data, arr->capacity);
+            if (arr->data == NULL)
             {
+                arr->capacity -= dataSize;
+                arr->data = old;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
-            arr->data = tmp;
 #else
             //If compiler doesn't supports realloc.
-            unsigned char* old = arr->data;
             arr->data = (unsigned char*)gxmalloc(arr->capacity);
             //If not enought memory available.
             if (arr->data == NULL)
             {
+                arr->capacity -= dataSize;
                 arr->data = old;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
@@ -362,7 +362,7 @@
     int ret = 0;
     if (index + 2 > arr->size)
     {
-        bb_allocate(arr, arr->size, 2);
+        ret = bb_allocate(arr, arr->size, 2);
     }
     if (ret == 0)
     {
@@ -1288,6 +1288,37 @@
     return (uint32_t)-1;
 }
 
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+void bb_reverse(gxByteBuffer* bb,
+    uint32_t index,
+    uint32_t count)
+#else
+void bb_reverse(gxByteBuffer* bb,
+    uint16_t index,
+    uint16_t count)
+#endif
+{
+    unsigned long pos;
+    unsigned long endPos;
+    if (index == 0)
+    {
+        endPos = bb->size - 1;
+    }
+    else
+    {
+        endPos = index + count - 1;
+    }
+    unsigned char tmp;
+    count /= 2;
+    for (pos = 0; pos != count; ++pos)
+    {
+        tmp = bb->data[index + pos];
+        bb->data[index + pos] = bb->data[endPos];
+        bb->data[endPos] = tmp;
+        --endPos;
+    }
+}
+
 #ifndef GX_DLMS_MICROCONTROLLER
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 int bb_print(gxByteBuffer* bb)
@@ -1305,5 +1336,6 @@
     }
     return 0;
 }
+
 #endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 #endif //GX_DLMS_MICROCONTROLLER
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/ciphering.c src/development/src/ciphering.c
--- upstream/development/src/ciphering.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/ciphering.c	2024-11-13 12:20:09.000000000 +0000
@@ -83,7 +83,7 @@
     memcpy(target->authenticationKey, DEFAUlT_AUTHENTICATION_KEY, sizeof(DEFAUlT_AUTHENTICATION_KEY));
     memset(target->dedicatedKey, 0, 16);
 #endif //DLMS_IGNORE_MALLOC
-    target->broacast = 0;
+    target->broadcast = 0;
 }
 
 void cip_clear(ciphering* target)
@@ -215,858 +215,867 @@
     0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
 };
 
-//Note! return value must be uint32_t.
-static inline uint32_t GetRcon(unsigned char offset)
-{
-#ifdef ARDUINO_ARCH_AVR
-    return pgm_read_dword_far(__R_CON + offset);
-#else
-    return __R_CON[offset];
-#endif //ARDUINO_ARCH_AVR
-}
+    //Note! return value must be uint32_t.
+    static inline uint32_t GetRcon(unsigned char offset)
+    {
+    #ifdef ARDUINO_ARCH_AVR
+        return pgm_read_dword_far(__R_CON + offset);
+    #else
+        return __R_CON[offset];
+    #endif //ARDUINO_ARCH_AVR
+    }
 
-static inline uint32_t GetTe(unsigned char offset)
-{
-#ifdef ARDUINO_ARCH_AVR
-    return pgm_read_dword_far(__TE + offset);
-#else
-    return __TE[offset];
-#endif //ARDUINO_ARCH_AVR
-}
+    static inline uint32_t GetTe(unsigned char offset)
+    {
+    #ifdef ARDUINO_ARCH_AVR
+        return pgm_read_dword_far(__TE + offset);
+    #else
+        return __TE[offset];
+    #endif //ARDUINO_ARCH_AVR
+    }
 
-#define RCON(i) (GetRcon(i) << 24)
+    #define RCON(i) (GetRcon(i) << 24)
 
-#define ROTATE(val, bits) ((val >> bits) | (val << (32 - bits)))
+    #define ROTATE(val, bits) ((val >> bits) | (val << (32 - bits)))
 
-#define TE0(i) GetTe(((i) >> 24) & 0xff)
+    #define TE0(i) GetTe(((i) >> 24) & 0xff)
 
-#define TE1(i) ROTATE(GetTe(((i) >> 16) & 0xff), 8)
+    #define TE1(i) ROTATE(GetTe(((i) >> 16) & 0xff), 8)
 
-#define TE2(i) ROTATE(GetTe(((i) >> 8) & 0xff), 16)
+    #define TE2(i) ROTATE(GetTe(((i) >> 8) & 0xff), 16)
 
-#define TE3(i) ROTATE(GetTe((i) & 0xff), 24)
+    #define TE3(i) ROTATE(GetTe((i) & 0xff), 24)
 
-#define TE41(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
+    #define TE41(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
 
-#define TE42(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
+    #define TE42(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
 
-#define TE43(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
+    #define TE43(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
 
-#define TE44(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
+    #define TE44(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
 
-#define TE421(i) ((GetTe(((i) >> 16) & 0xff) << 8) & 0xff000000)
+    #define TE421(i) ((GetTe(((i) >> 16) & 0xff) << 8) & 0xff000000)
 
-#define TE432(i) (GetTe(((i) >> 8) & 0xff) & 0x00ff0000)
+    #define TE432(i) (GetTe(((i) >> 8) & 0xff) & 0x00ff0000)
 
-#define TE443(i) (GetTe((i) & 0xff) & 0x0000ff00)
+    #define TE443(i) (GetTe((i) & 0xff) & 0x0000ff00)
 
-#define TE414(i) ((GetTe(((i) >> 24) & 0xff) >> 8) & 0x000000ff)
+    #define TE414(i) ((GetTe(((i) >> 24) & 0xff) >> 8) & 0x000000ff)
 
-#define TE411(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
+    #define TE411(i) ((GetTe(((i) >> 24) & 0xff) << 8) & 0xff000000)
 
-#define TE422(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
+    #define TE422(i) (GetTe(((i) >> 16) & 0xff) & 0x00ff0000)
 
-#define TE433(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
+    #define TE433(i) (GetTe(((i) >> 8) & 0xff) & 0x0000ff00)
 
-#define TE444(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
+    #define TE444(i) ((GetTe((i) & 0xff) >> 8) & 0x000000ff)
 
-int cip_int(uint32_t* rk,
-    const unsigned char* cipherKey,
-    uint16_t keyBits)
-{
-    uint8_t i;
-    uint32_t temp;
+    int cip_int(uint32_t* rk,
+        const unsigned char* cipherKey,
+        uint16_t keyBits)
+    {
+        uint8_t i;
+        uint32_t temp;
 
-    rk[0] = GETU32(cipherKey);
-    rk[1] = GETU32(cipherKey + 4);
-    rk[2] = GETU32(cipherKey + 8);
-    rk[3] = GETU32(cipherKey + 12);
-
-    if (keyBits == 128)
-    {
-        for (i = 0; i < 10; i++)
-        {
-            temp = rk[3];
-            rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-                TE443(temp) ^ TE414(temp);
-            rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-                TE443(temp) ^ TE414(temp) ^ RCON(i);
-            rk[5] = rk[1] ^ rk[4];
-            rk[6] = rk[2] ^ rk[5];
-            rk[7] = rk[3] ^ rk[6];
-            rk += 4;
+        rk[0] = GETU32(cipherKey);
+        rk[1] = GETU32(cipherKey + 4);
+        rk[2] = GETU32(cipherKey + 8);
+        rk[3] = GETU32(cipherKey + 12);
+
+        if (keyBits == 128)
+        {
+            for (i = 0; i < 10; i++)
+            {
+                temp = rk[3];
+                rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                    TE443(temp) ^ TE414(temp);
+                rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                    TE443(temp) ^ TE414(temp) ^ RCON(i);
+                rk[5] = rk[1] ^ rk[4];
+                rk[6] = rk[2] ^ rk[5];
+                rk[7] = rk[3] ^ rk[6];
+                rk += 4;
+            }
+            return 0;
         }
-        return 0;
-    }
-    if (keyBits != 256)
+        if (keyBits != 256)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        rk[4] = GETU32(cipherKey + 16);
+        rk[5] = GETU32(cipherKey + 20);
+        rk[6] = GETU32(cipherKey + 24);
+        rk[7] = GETU32(cipherKey + 28);
+        for (i = 0; i < 7; i++)
+        {
+            temp = rk[7];
+            rk[8] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
+                TE443(temp) ^ TE414(temp) ^ RCON(i);
+            rk[9] = rk[1] ^ rk[8];
+            rk[10] = rk[2] ^ rk[9];
+            rk[11] = rk[3] ^ rk[10];
+            if (i == 6)
+            {
+                return 0;
+            }
+            temp = rk[11];
+            rk[12] = rk[4] ^ TE411(temp) ^ TE422(temp) ^
+                TE433(temp) ^ TE444(temp);
+            rk[13] = rk[5] ^ rk[12];
+            rk[14] = rk[6] ^ rk[13];
+            rk[15] = rk[7] ^ rk[14];
+            rk += 8;
+        }
+        return DLMS_ERROR_CODE_OK;
+    }
+
+    //Arduino DOIT ESP32 uses aes_encrypt. For that reason aes_Encrypt is used.
+    void aes_Encrypt(const uint32_t* rk, int Nr, const unsigned char* pt, unsigned char* ct)
+    {
+        uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
+        int r;
+        s0 = GETU32(pt) ^ rk[0];
+        s1 = GETU32(pt + 4) ^ rk[1];
+        s2 = GETU32(pt + 8) ^ rk[2];
+        s3 = GETU32(pt + 12) ^ rk[3];
+
+    #define ROUND(i,d,s) \
+    d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
+    d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
+    d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
+    d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
+
+        /* Nr - 1 full rounds: */
+        r = Nr >> 1;
+        for (;;)
+        {
+            ROUND(1, t, s);
+            rk += 8;
+            if (--r == 0)
+                break;
+            ROUND(0, s, t);
+        }
+
+    #undef ROUND
+
+        s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
+        PUT32(ct, s0);
+        s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
+        PUT32(ct + 4, s1);
+        s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
+        PUT32(ct + 8, s2);
+        s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
+        PUT32(ct + 12, s3);
+    }
+
+    /**
+    * Make cip_xor for 128 bits.
+    *
+    * @param block
+    *            block.
+    * @param val
+    */
+    static void cip_xor(
+        unsigned char* dst,
+        const unsigned char* src)
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    rk[4] = GETU32(cipherKey + 16);
-    rk[5] = GETU32(cipherKey + 20);
-    rk[6] = GETU32(cipherKey + 24);
-    rk[7] = GETU32(cipherKey + 28);
-    for (i = 0; i < 7; i++)
-    {
-        temp = rk[7];
-        rk[8] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-            TE443(temp) ^ TE414(temp) ^ RCON(i);
-        rk[9] = rk[1] ^ rk[8];
-        rk[10] = rk[2] ^ rk[9];
-        rk[11] = rk[3] ^ rk[10];
-        if (i == 6)
+        int pos;
+        for (pos = 0; pos != 16; ++pos)
         {
-            return 0;
+            dst[pos] ^= src[pos];
         }
-        temp = rk[11];
-        rk[12] = rk[4] ^ TE411(temp) ^ TE422(temp) ^
-            TE433(temp) ^ TE444(temp);
-        rk[13] = rk[5] ^ rk[12];
-        rk[14] = rk[6] ^ rk[13];
-        rk[15] = rk[7] ^ rk[14];
-        rk += 8;        
+        /*
+        uint32_t *d = (uint32_t *)dst;
+        uint32_t *s = (uint32_t *)src;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        *d++ ^= *s++;
+        */
     }
-    return DLMS_ERROR_CODE_OK;
-}
 
-//Arduino DOIT ESP32 uses aes_encrypt. For that reason aes_Encrypt is used.
-void aes_Encrypt(const uint32_t* rk, int Nr, const unsigned char* pt, unsigned char* ct)
-{
-    uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
-    int r;
-    s0 = GETU32(pt) ^ rk[0];
-    s1 = GETU32(pt + 4) ^ rk[1];
-    s2 = GETU32(pt + 8) ^ rk[2];
-    s3 = GETU32(pt + 12) ^ rk[3];
-
-#define ROUND(i,d,s) \
-d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
-d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
-d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
-d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
-
-    /* Nr - 1 full rounds: */
-    r = Nr >> 1;
-    for (;;)
-    {
-        ROUND(1, t, s);
-        rk += 8;
-        if (--r == 0)
-            break;
-        ROUND(0, s, t);
-    }
+    static void shift_right_block(unsigned char* v)
+    {
+        uint32_t val = GETU32(v + 12);
+        val >>= 1;
+        if (v[11] & 0x01)
+        {
+            val |= 0x80000000;
+        }
+        PUT32(v + 12, val);
 
-#undef ROUND
+        val = GETU32(v + 8);
+        val >>= 1;
+        if (v[7] & 0x01)
+            val |= 0x80000000;
+        PUT32(v + 8, val);
 
-    s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
-    PUT32(ct, s0);
-    s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
-    PUT32(ct + 4, s1);
-    s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
-    PUT32(ct + 8, s2);
-    s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
-    PUT32(ct + 12, s3);
-}
+        val = GETU32(v + 4);
+        val >>= 1;
+        if (v[3] & 0x01)
+            val |= 0x80000000;
+        PUT32(v + 4, val);
 
-/**
-* Make cip_xor for 128 bits.
-*
-* @param block
-*            block.
-* @param val
-*/
-static void cip_xor(
-    unsigned char* dst,
-    const unsigned char* src)
-{
-    int pos;
-    for (pos = 0; pos != 16; ++pos)
-    {
-        dst[pos] ^= src[pos];
+        val = GETU32(v);
+        val >>= 1;
+        PUT32(v, val);
     }
-    /*
-    uint32_t *d = (uint32_t *)dst;
-    uint32_t *s = (uint32_t *)src;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    *d++ ^= *s++;
-    */
-}
 
-static void shift_right_block(unsigned char* v)
-{
-    uint32_t val = GETU32(v + 12);
-    val >>= 1;
-    if (v[11] & 0x01)
-    {
-        val |= 0x80000000;
-    }
-    PUT32(v + 12, val);
-
-    val = GETU32(v + 8);
-    val >>= 1;
-    if (v[7] & 0x01)
-        val |= 0x80000000;
-    PUT32(v + 8, val);
-
-    val = GETU32(v + 4);
-    val >>= 1;
-    if (v[3] & 0x01)
-        val |= 0x80000000;
-    PUT32(v + 4, val);
-
-    val = GETU32(v);
-    val >>= 1;
-    PUT32(v, val);
-}
-
-static void cip_multiplyH(const unsigned char* x, const unsigned char* y, unsigned char* z)
-{
-    unsigned char tmp[16];
-    int i, j;
+    static void cip_multiplyH(const unsigned char* x, const unsigned char* y, unsigned char* z)
+    {
+        unsigned char tmp[16];
+        int i, j;
 
-    memset(z, 0, 16);
-    memcpy(tmp, y, 16);
+        memset(z, 0, 16);
+        memcpy(tmp, y, 16);
 
-    for (i = 0; i < 16; i++)
-    {
-        for (j = 0; j < 8; j++)
+        for (i = 0; i < 16; i++)
         {
-            if (x[i] & 1 << (7 - j))
+            for (j = 0; j < 8; j++)
             {
-                cip_xor(z, tmp);
-            }
-            //If last bit.
-            if (tmp[15] & 0x01)
-            {
-                shift_right_block(tmp);
-                tmp[0] ^= 0xe1;
-            }
-            else
-            {
-                shift_right_block(tmp);
+                if (x[i] & 1 << (7 - j))
+                {
+                    cip_xor(z, tmp);
+                }
+                //If last bit.
+                if (tmp[15] & 0x01)
+                {
+                    shift_right_block(tmp);
+                    tmp[0] ^= 0xe1;
+                }
+                else
+                {
+                    shift_right_block(tmp);
+                }
             }
         }
     }
-}
-
-/**
-* Count GHash.
-*/
-static void cip_getGHash(
-    const unsigned char* h,
-    const unsigned char* x,
-    int xlen,
-    unsigned char* y)
-{
-    int m, i;
-    const unsigned char* xpos = x;
-    unsigned char tmp[16];
-    m = xlen / 16;
-    for (i = 0; i < m; i++)
-    {
-        cip_xor(y, xpos);
-        xpos += 16;
-        cip_multiplyH(y, h, tmp);
-        memcpy(y, tmp, 16);
-    }
-    if (x + xlen > xpos)
-    {
-        size_t last = x + xlen - xpos;
-        memcpy(tmp, xpos, last);
-        memset(tmp + last, 0, sizeof(tmp) - last);
-
-        cip_xor(y, tmp);
-
-        cip_multiplyH(y, h, tmp);
-        memcpy(y, tmp, 16);
-    }
-}
 
-static void cip_init_j0(
-    const unsigned char* iv,
-    unsigned char len,
-    const unsigned char* H,
-    unsigned char* J0)
-{
-    //IV length.
-    if (len == 12)
-    {
-        memcpy(J0, iv, len);
-        memset(J0 + len, 0, 16 - len);
-        J0[15] = 0x01;
-    }
-    else
+    /**
+    * Count GHash.
+    */
+    static void cip_getGHash(
+        const unsigned char* h,
+        const unsigned char* x,
+        int xlen,
+        unsigned char* y)
     {
+        int m, i;
+        const unsigned char* xpos = x;
         unsigned char tmp[16];
-        memset(J0, 0, 16);
-        cip_getGHash(H, iv, len, J0);
-        PUT32(tmp, (uint32_t)0);
-        PUT32(tmp + 4, (uint32_t)0);
-        //Here is expected that data is newer longger than 32 bit.
-        //This is done because microcontrollers show warning here.
-        PUT32(tmp + 8, (uint32_t)0);
-        PUT32(tmp + 12, (uint32_t)(len * 8));
-        cip_getGHash(H, tmp, sizeof(tmp), J0);
-    }
-}
+        m = xlen / 16;
+        for (i = 0; i < m; i++)
+        {
+            cip_xor(y, xpos);
+            xpos += 16;
+            cip_multiplyH(y, h, tmp);
+            memcpy(y, tmp, 16);
+        }
+        if (x + xlen > xpos)
+        {
+            size_t last = x + xlen - xpos;
+            memcpy(tmp, xpos, last);
+            memset(tmp + last, 0, sizeof(tmp) - last);
 
-static void cip_inc32(unsigned char* block)
-{
-    uint32_t val;
-    val = GETU32(block + 16 - 4);
-    val++;
-    PUT32(block + 16 - 4, val);
-}
+            cip_xor(y, tmp);
 
-static void cip_gctr(uint32_t* aes, const unsigned char* icb, unsigned char* in, int len, unsigned char* out)
-{
-    size_t i, n, last;
-    unsigned char cb[16], tmp[16];
-    unsigned char* pin = in;
-    unsigned char* pout = out;
-    if (len == 0)
-    {
-        return;
-    }
-    n = len / 16;
-    memcpy(cb, icb, 16);
-    //Full blocks.
-    for (i = 0; i < n; i++)
+            cip_multiplyH(y, h, tmp);
+            memcpy(y, tmp, 16);
+        }
+    }
+
+    static void cip_init_j0(
+        const unsigned char* iv,
+        unsigned char len,
+        const unsigned char* H,
+        unsigned char* J0)
     {
-        if (out == NULL)
+        //IV length.
+        if (len == 12)
         {
-            aes_Encrypt(aes, aes[60], cb, tmp);
-            cip_xor(pin, tmp);
+            memcpy(J0, iv, len);
+            memset(J0 + len, 0, 16 - len);
+            J0[15] = 0x01;
         }
         else
         {
-            aes_Encrypt(aes, aes[60], cb, pout);
-            cip_xor(pout, pin);
+            unsigned char tmp[16];
+            memset(J0, 0, 16);
+            cip_getGHash(H, iv, len, J0);
+            PUT32(tmp, (uint32_t)0);
+            PUT32(tmp + 4, (uint32_t)0);
+            //Here is expected that data is newer longger than 32 bit.
+            //This is done because microcontrollers show warning here.
+            PUT32(tmp + 8, (uint32_t)0);
+            PUT32(tmp + 12, (uint32_t)(len * 8));
+            cip_getGHash(H, tmp, sizeof(tmp), J0);
         }
-        pin += 16;
-        pout += 16;
-        cip_inc32(cb);
     }
 
-    last = in + len - pin;
-    //Last, partial block.
-    if (last)
+    static void cip_inc32(unsigned char* block)
     {
-        aes_Encrypt(aes, aes[60], cb, tmp);
-        for (i = 0; i < last; i++)
+        uint32_t val;
+        val = GETU32(block + 16 - 4);
+        val++;
+        PUT32(block + 16 - 4, val);
+    }
+
+    static void cip_gctr(uint32_t* aes, const unsigned char* icb, unsigned char* in, int len, unsigned char* out)
+    {
+        size_t i, n, last;
+        unsigned char cb[16], tmp[16];
+        unsigned char* pin = in;
+        unsigned char* pout = out;
+        if (len == 0)
+        {
+            return;
+        }
+        n = len / 16;
+        memcpy(cb, icb, 16);
+        //Full blocks.
+        for (i = 0; i < n; i++)
         {
             if (out == NULL)
             {
-                *pin ^= tmp[i];
-                ++pin;
+                aes_Encrypt(aes, aes[60], cb, tmp);
+                cip_xor(pin, tmp);
             }
             else
             {
-                *pout = *pin++ ^ tmp[i];
-                ++pout;
+                aes_Encrypt(aes, aes[60], cb, pout);
+                cip_xor(pout, pin);
             }
+            pin += 16;
+            pout += 16;
+            cip_inc32(cb);
         }
-    }
-}
-
-static void aes_gcm_gctr(uint32_t* aes, const unsigned char* J0, unsigned char* in, int len, unsigned char* out)
-{
-    unsigned char J0inc[16];
-    if (len == 0)
-    {
-        return;
-    }
-
-    memcpy(J0inc, J0, 16);
-    cip_inc32(J0inc);
-    cip_gctr(aes, J0inc, in, len, out);
-}
-
-static void aes_gcm_ghash(const unsigned char* H, const unsigned char* aad, int aad_len,
-    const unsigned char* crypt, int crypt_len, unsigned char* S)
-{
-    unsigned char len_buf[16];
-    cip_getGHash(H, aad, aad_len, S);
-    cip_getGHash(H, crypt, crypt_len, S);
-    //Here is expected that data is never longer than 32 bit.
-    //This is done because microcontrollers show warning here.
-    PUT32(len_buf, (uint32_t)0);
-    PUT32(len_buf + 4, (uint32_t)(aad_len * 8));
-    PUT32(len_buf + 8, (uint32_t)0);
-    PUT32(len_buf + 12, (uint32_t)(crypt_len * 8));
-    cip_getGHash(H, len_buf, sizeof(len_buf), S);
-}
 
-#ifndef DLMS_IGNORE_MALLOC
-int cip_crypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    gxByteBuffer* key,
-    gxByteBuffer* input,
-    unsigned char encrypt)
-#else
-int cip_crypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    unsigned char* key,
-    gxByteBuffer* input,
-    unsigned char encrypt)
-#endif //DLMS_IGNORE_MALLOC
-{
-    int ret;
-#ifdef GX_DLMS_MICROCONTROLLER
-    static uint32_t aes[61] = { 0 };
-    static unsigned char H[16] = { 0 };
-    static unsigned char J0[16] = { 0 };
-    static unsigned char S[16] = { 0 };
-    //Nonse must be 20 bytes because it's used later.
-    static unsigned char NONSE[20] = { 0 };
-    memset(H, 0, sizeof(H));
-    memset(S, 0, sizeof(S));
-#else
-    uint32_t aes[61] = { 0 };
-    unsigned char H[16] = { 0 };
-    unsigned char J0[16] = { 0 };
-    unsigned char S[16] = { 0 };
-    //Nonse must be 20 bytes because it's used later.
-    unsigned char NONSE[20] = { 0 };
-#endif //GX_DLMS_MICROCONTROLLER
-    gxByteBuffer nonse;
-    if (memcmp(systemTitle, EMPTY_SYSTEM_TITLE, 8) == 0)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    bb_attach(&nonse, NONSE, 0, sizeof(NONSE));
-    if ((ret = cip_getNonse(frameCounter, systemTitle, &nonse)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = cip_int(
-        aes,
-#ifndef DLMS_IGNORE_MALLOC
-        key->data,
-#else
-        key,
-#endif //DLMS_IGNORE_MALLOC
-        settings->suite == DLMS_SECURITY_SUITE_V2 ? 32 * 8 : 16 * 8)) != 0)
-    {
-        return ret;
-    }
-    if (settings->suite == DLMS_SECURITY_SUITE_V2)
-    {
-        aes[60] = 14;
-    }
-    else
-    {
-        aes[60] = 10;
-    }
-    //Hash subkey.
-    aes_Encrypt(aes, aes[60], H, H);
-    cip_init_j0(nonse.data, (unsigned char)nonse.size, H, J0);
-    //Allocate space for authentication tag.
-    if (security != DLMS_SECURITY_ENCRYPTION && !encrypt)
-    {
-        //Save authentication key to nonse.
-        bb_clear(&nonse);
-        ret = bb_set(&nonse, input->data + input->size - 12, 12);
-        input->size -= 12;
-    }
-    unsigned char offset;
-    if (settings->suite == DLMS_SECURITY_SUITE_V2)
-    {
-        offset = 33;
-    }
-    else
-    {
-        offset = 17;
-    }
-    if (security == DLMS_SECURITY_AUTHENTICATION)
-    {
-        if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
+        last = in + len - pin;
+        //Last, partial block.
+        if (last)
         {
-            input->position = 0;
-            bb_setUInt8ByIndex(input, 0, security | settings->suite);
-#ifndef DLMS_IGNORE_MALLOC
-            memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
-#else
-            memcpy(input->data + 1, settings->authenticationKey, offset - 1);
-#endif //DLMS_IGNORE_MALLOC
-            aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
-            if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+            aes_Encrypt(aes, aes[60], cb, tmp);
+            for (i = 0; i < last; i++)
             {
-                cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                if (encrypt)
+                if (out == NULL)
                 {
-                    input->size += 12;                    
+                    *pin ^= tmp[i];
+                    ++pin;
                 }
                 else
                 {
-                    if (memcmp(NONSE, input->data + input->size, 12) != 0)
-                    {
-                        ret = DLMS_ERROR_CODE_INVALID_TAG;
-                    }
+                    *pout = *pin++ ^ tmp[i];
+                    ++pout;
                 }
             }
         }
     }
-    else if (security == DLMS_SECURITY_ENCRYPTION)
+
+    static void aes_gcm_gctr(uint32_t* aes, const unsigned char* J0, unsigned char* in, int len, unsigned char* out)
     {
-        //Encrypt the data.
-        aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
-        if (!encrypt)
+        unsigned char J0inc[16];
+        if (len == 0)
         {
-            ret = bb_move(input, input->position, 0, bb_available(input));
-            input->position = 0;
+            return;
         }
-        aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+
+        memcpy(J0inc, J0, 16);
+        cip_inc32(J0inc);
+        cip_gctr(aes, J0inc, in, len, out);
     }
-    else if (security == DLMS_SECURITY_AUTHENTICATION_ENCRYPTION)
+
+    static void aes_gcm_ghash(const unsigned char* H, const unsigned char* aad, int aad_len,
+        const unsigned char* crypt, int crypt_len, unsigned char* S)
     {
-        if (encrypt)
+        unsigned char len_buf[16];
+        cip_getGHash(H, aad, aad_len, S);
+        cip_getGHash(H, crypt, crypt_len, S);
+        //Here is expected that data is never longer than 32 bit.
+        //This is done because microcontrollers show warning here.
+        PUT32(len_buf, (uint32_t)0);
+        PUT32(len_buf + 4, (uint32_t)(aad_len * 8));
+        PUT32(len_buf + 8, (uint32_t)0);
+        PUT32(len_buf + 12, (uint32_t)(crypt_len * 8));
+        cip_getGHash(H, len_buf, sizeof(len_buf), S);
+    }
+
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_crypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        gxByteBuffer* key,
+        gxByteBuffer* input,
+        unsigned char encrypt)
+    #else
+    int cip_crypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        unsigned char* key,
+        gxByteBuffer* input,
+        unsigned char encrypt)
+    #endif //DLMS_IGNORE_MALLOC
+    {
+        int ret;
+    #ifdef GX_DLMS_MICROCONTROLLER
+        static uint32_t aes[61] = { 0 };
+        static unsigned char H[16] = { 0 };
+        static unsigned char J0[16] = { 0 };
+        static unsigned char S[16] = { 0 };
+        //Nonse must be 20 bytes because it's used later.
+        static unsigned char NONSE[20] = { 0 };
+        memset(H, 0, sizeof(H));
+        memset(S, 0, sizeof(S));
+    #else
+        uint32_t aes[61] = { 0 };
+        unsigned char H[16] = { 0 };
+        unsigned char J0[16] = { 0 };
+        unsigned char S[16] = { 0 };
+        //Nonse must be 20 bytes because it's used later.
+        unsigned char NONSE[20] = { 0 };
+    #endif //GX_DLMS_MICROCONTROLLER
+        gxByteBuffer nonse;
+        if (memcmp(systemTitle, EMPTY_SYSTEM_TITLE, 8) == 0)
         {
-            //Encrypt the data.
-            aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
         }
-        if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
+        bb_attach(&nonse, NONSE, 0, sizeof(NONSE));
+        if ((ret = cip_getNonse(frameCounter, systemTitle, &nonse)) != 0)
         {
-            input->position = 0;
-            ret = bb_setUInt8ByIndex(input, 0, security | settings->suite);
-#ifndef DLMS_IGNORE_MALLOC
-            memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
-#else
-            memcpy(input->data + 1, settings->authenticationKey, offset - 1);
-#endif //DLMS_IGNORE_MALLOC
-            aes_gcm_ghash(H, input->data, offset, input->data + offset, input->size - offset, S);
-            if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+            return ret;
+        }
+        if ((ret = cip_int(
+            aes,
+    #ifndef DLMS_IGNORE_MALLOC
+            key->data,
+    #else
+            key,
+    #endif //DLMS_IGNORE_MALLOC
+            settings->suite == DLMS_SECURITY_SUITE_V2 ? 32 * 8 : 16 * 8)) != 0)
+        {
+            return ret;
+        }
+        if (settings->suite == DLMS_SECURITY_SUITE_V2)
+        {
+            aes[60] = 14;
+        }
+        else
+        {
+            aes[60] = 10;
+        }
+        //Hash subkey.
+        aes_Encrypt(aes, aes[60], H, H);
+        cip_init_j0(nonse.data, (unsigned char)nonse.size, H, J0);
+        //Allocate space for authentication tag.
+        if (security != DLMS_SECURITY_ENCRYPTION && !encrypt)
+        {
+            //Save authentication key to nonse.
+            bb_clear(&nonse);
+            ret = bb_set(&nonse, input->data + input->size - 12, 12);
+            input->size -= 12;
+        }
+        unsigned char offset;
+        if (settings->suite == DLMS_SECURITY_SUITE_V2)
+        {
+            offset = 33;
+        }
+        else
+        {
+            offset = 17;
+        }
+        if (security == DLMS_SECURITY_AUTHENTICATION)
+        {
+            if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
             {
-                if (!encrypt)
+                input->position = 0;
+                bb_setUInt8ByIndex(input, 0, security | settings->suite);
+    #ifndef DLMS_IGNORE_MALLOC
+                memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
+    #else
+                memcpy(input->data + 1, settings->authenticationKey, offset - 1);
+    #endif //DLMS_IGNORE_MALLOC
+                aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
+                if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
                 {
                     cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                    //Decrypt the data.
-                    aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
-                }
-                cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
-                if (encrypt)
-                {
-                    input->size += 12;
-                }
-                else
-                {
-                    //Check authentication tag.
-                    if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                    if (encrypt)
                     {
-                        ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        input->size += 12;
                     }
                     else
                     {
-                        ret = bb_move(input, input->position, 0, bb_available(input));
+                        if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                        {
+                            ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        }
                     }
-                    input->position = 0;
                 }
             }
         }
-    }
-    if (ret == 0 && encrypt)
-    {
-        ++settings->invocationCounter;
-    }
-    if (ret == 0 && encrypt && type == DLMS_COUNT_TYPE_PACKET)
-    {
-        if ((ret = bb_clear(&nonse)) == 0 &&
-            (ret = bb_setUInt8(&nonse, tag)) == 0)
+        else if (security == DLMS_SECURITY_ENCRYPTION)
         {
-            if (tag == DLMS_COMMAND_GENERAL_GLO_CIPHERING ||
-                tag == DLMS_COMMAND_GENERAL_DED_CIPHERING)
+            //Encrypt the data.
+            aes_gcm_ghash(H, input->data, input->size, input->data, 0, S);
+            if (!encrypt)
             {
-                hlp_setObjectCount(8, &nonse);
-                bb_set(&nonse, systemTitle, 8);
+                ret = bb_move(input, input->position, 0, bb_available(input));
+                input->position = 0;
             }
-            tag = security | settings->suite;
-            if (settings->broacast)
+            aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+        }
+        else if (security == DLMS_SECURITY_AUTHENTICATION_ENCRYPTION)
+        {
+            if (encrypt)
             {
-                tag |= 0x40;
+                //Encrypt the data.
+                aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
             }
-            if ((ret = hlp_setObjectCount(5 + input->size, &nonse)) == 0 &&
-                (ret = bb_setUInt8(&nonse, tag)) == 0 &&
-                (ret = bb_setUInt32(&nonse, frameCounter)) == 0 &&
-                (ret = bb_insert(nonse.data, nonse.size, input, 0)) == 0)
+            if ((ret = bb_move(input, input->position, offset, bb_available(input))) == 0)
             {
-                memcpy(input->data, nonse.data, nonse.size);
+                input->position = 0;
+                ret = bb_setUInt8ByIndex(input, 0, (settings->broadcast ? 0x40 : 0) | security | settings->suite);
+    #ifndef DLMS_IGNORE_MALLOC
+                memcpy(input->data + 1, settings->authenticationKey.data, settings->authenticationKey.size);
+    #else
+                memcpy(input->data + 1, settings->authenticationKey, offset - 1);
+    #endif //DLMS_IGNORE_MALLOC
+                aes_gcm_ghash(H, input->data, offset, input->data + offset, input->size - offset, S);
+                if ((ret = bb_move(input, offset, 0, input->size - offset)) == 0)
+                {
+                    if (!encrypt)
+                    {
+                        cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
+                        //Decrypt the data.
+                        aes_gcm_gctr(aes, J0, input->data + input->position, bb_available(input), NULL);
+                    }
+                    cip_gctr(aes, J0, S, sizeof(S), input->data + input->size);
+                    if (encrypt)
+                    {
+                        input->size += 12;
+                    }
+                    else
+                    {
+                        //Check authentication tag.
+                        if (memcmp(NONSE, input->data + input->size, 12) != 0)
+                        {
+#if DLMS_NOTIFY_AUTHENTICATION_ERROR
+                            svr_authenticationError();
+#endif //DLMS_NOTIFY_AUTHENTICATION_ERROR
+                            ret = DLMS_ERROR_CODE_INVALID_TAG;
+                        }
+                        else
+                        {
+                            ret = bb_move(input, input->position, 0, bb_available(input));
+                        }
+                        input->position = 0;
+                    }
+                }
+            }
+        }
+        if (ret == 0 && encrypt)
+        {
+            ++settings->invocationCounter;
+        }
+        if (ret == 0 && encrypt && type == DLMS_COUNT_TYPE_PACKET)
+        {
+            if ((ret = bb_clear(&nonse)) == 0 &&
+                (ret = bb_setUInt8(&nonse, tag)) == 0)
+            {
+                if (tag == DLMS_COMMAND_GENERAL_GLO_CIPHERING ||
+                    tag == DLMS_COMMAND_GENERAL_DED_CIPHERING)
+                {
+                    hlp_setObjectCount(8, &nonse);
+                    bb_set(&nonse, systemTitle, 8);
+                }
+                tag = security | settings->suite;
+                if (settings->broadcast)
+                {
+                    tag |= 0x40;
+                }
+                if ((ret = hlp_setObjectCount(5 + input->size, &nonse)) == 0 &&
+                    (ret = bb_setUInt8(&nonse, tag)) == 0 &&
+                    (ret = bb_setUInt32(&nonse, frameCounter)) == 0 &&
+                    (ret = bb_insert(nonse.data, nonse.size, input, 0)) == 0)
+                {
+                    memcpy(input->data, nonse.data, nonse.size);
+                }
             }
         }
+        return ret;
     }
-    return ret;
-}
 
-#ifndef DLMS_IGNORE_MALLOC
-int cip_encrypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    gxByteBuffer* key,
-    gxByteBuffer* input)
-#else
-int cip_encrypt(
-    ciphering* settings,
-    DLMS_SECURITY security,
-    DLMS_COUNT_TYPE type,
-    uint32_t frameCounter,
-    unsigned char tag,
-    unsigned char* systemTitle,
-    unsigned char* key,
-    gxByteBuffer* input)
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_encrypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        gxByteBuffer* key,
+        gxByteBuffer* input)
+    #else
+    int cip_encrypt(
+        ciphering* settings,
+        DLMS_SECURITY security,
+        DLMS_COUNT_TYPE type,
+        uint32_t frameCounter,
+        unsigned char tag,
+        unsigned char* systemTitle,
+        unsigned char* key,
+        gxByteBuffer* input)
 #endif //DLMS_IGNORE_MALLOC
-{
-    return cip_crypt(
-        settings,
-        security,
-        type,
-        frameCounter,
-        tag,
-        systemTitle,
-        key,
-        input,
-        1);
-}
-
-#ifndef DLMS_IGNORE_MALLOC
-int cip_decrypt(
-    ciphering* settings,
-    unsigned char* title,
-    gxByteBuffer* key,
-    gxByteBuffer* data,
-    DLMS_SECURITY* security,
-    DLMS_SECURITY_SUITE* suite,
-    uint64_t* invocationCounter)
-#else
-int cip_decrypt(
-    ciphering* settings,
-    unsigned char* title,
-    unsigned char* key,
-    gxByteBuffer* data,
-    DLMS_SECURITY* security,
-    DLMS_SECURITY_SUITE* suite,
-    uint64_t* invocationCounter)
-#endif //DLMS_IGNORE_MALLOC
-{
-#ifdef GX_DLMS_MICROCONTROLLER
-    static unsigned char systemTitle[8];
-#else
-    unsigned char systemTitle[8];
-#endif //GX_DLMS_MICROCONTROLLER
-    uint16_t length;
-    int ret;
-    unsigned char ch;
-    uint32_t frameCounter;
-    DLMS_COMMAND cmd;
-    if (data == NULL || data->size - data->position < 2)
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_getUInt8(data, &ch)) != 0)
-    {
-        return ret;
-    }
-    cmd = (DLMS_COMMAND)ch;
-    switch (cmd)
-    {
-    case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
-    case DLMS_COMMAND_GENERAL_DED_CIPHERING:
-        if ((ret = hlp_getObjectCount2(data, &length)) != 0)
+        return cip_crypt(
+            settings,
+            security,
+            type,
+            frameCounter,
+            tag,
+            systemTitle,
+            key,
+            input,
+            1);
+    }
+
+    #ifndef DLMS_IGNORE_MALLOC
+    int cip_decrypt(
+        ciphering* settings,
+        unsigned char* title,
+        gxByteBuffer* key,
+        gxByteBuffer* data,
+        DLMS_SECURITY* security,
+        DLMS_SECURITY_SUITE* suite,
+        uint64_t* invocationCounter)
+    #else
+    int cip_decrypt(
+        ciphering* settings,
+        unsigned char* title,
+        unsigned char* key,
+        gxByteBuffer* data,
+        DLMS_SECURITY* security,
+        DLMS_SECURITY_SUITE* suite,
+        uint64_t* invocationCounter)
+    #endif //DLMS_IGNORE_MALLOC
+    {
+    #ifdef GX_DLMS_MICROCONTROLLER
+        static unsigned char systemTitle[8];
+    #else
+        unsigned char systemTitle[8];
+    #endif //GX_DLMS_MICROCONTROLLER
+        uint16_t length;
+        int ret;
+        unsigned char ch;
+        uint32_t frameCounter;
+        DLMS_COMMAND cmd;
+        if (data == NULL || data->size - data->position < 2)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_getUInt8(data, &ch)) != 0)
         {
             return ret;
         }
-        if (length != 0)
+        cmd = (DLMS_COMMAND)ch;
+        switch (cmd)
         {
-            if (length != 8)
+        case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
+        case DLMS_COMMAND_GENERAL_DED_CIPHERING:
+            if ((ret = hlp_getObjectCount2(data, &length)) != 0)
+            {
+                return ret;
+            }
+            if (length != 0)
             {
-                return DLMS_ERROR_CODE_INVALID_PARAMETER;
+                if (length != 8)
+                {
+                    return DLMS_ERROR_CODE_INVALID_PARAMETER;
+                }
+                bb_get(data, systemTitle, length);
+                title = systemTitle;
             }
-            bb_get(data, systemTitle, length);
-            title = systemTitle;
+            break;
+        case DLMS_COMMAND_GLO_INITIATE_REQUEST:
+        case DLMS_COMMAND_GLO_INITIATE_RESPONSE:
+        case DLMS_COMMAND_GLO_READ_REQUEST:
+        case DLMS_COMMAND_GLO_READ_RESPONSE:
+        case DLMS_COMMAND_GLO_WRITE_REQUEST:
+        case DLMS_COMMAND_GLO_WRITE_RESPONSE:
+        case DLMS_COMMAND_GLO_GET_REQUEST:
+        case DLMS_COMMAND_GLO_GET_RESPONSE:
+        case DLMS_COMMAND_GLO_SET_REQUEST:
+        case DLMS_COMMAND_GLO_SET_RESPONSE:
+        case DLMS_COMMAND_GLO_METHOD_REQUEST:
+        case DLMS_COMMAND_GLO_METHOD_RESPONSE:
+        case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
+        case DLMS_COMMAND_DED_INITIATE_REQUEST:
+        case DLMS_COMMAND_DED_INITIATE_RESPONSE:
+        case DLMS_COMMAND_DED_GET_REQUEST:
+        case DLMS_COMMAND_DED_GET_RESPONSE:
+        case DLMS_COMMAND_DED_SET_REQUEST:
+        case DLMS_COMMAND_DED_SET_RESPONSE:
+        case DLMS_COMMAND_DED_METHOD_REQUEST:
+        case DLMS_COMMAND_DED_METHOD_RESPONSE:
+        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
+            break;
+        default:
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
         }
-        break;
-    case DLMS_COMMAND_GLO_INITIATE_REQUEST:
-    case DLMS_COMMAND_GLO_INITIATE_RESPONSE:
-    case DLMS_COMMAND_GLO_READ_REQUEST:
-    case DLMS_COMMAND_GLO_READ_RESPONSE:
-    case DLMS_COMMAND_GLO_WRITE_REQUEST:
-    case DLMS_COMMAND_GLO_WRITE_RESPONSE:
-    case DLMS_COMMAND_GLO_GET_REQUEST:
-    case DLMS_COMMAND_GLO_GET_RESPONSE:
-    case DLMS_COMMAND_GLO_SET_REQUEST:
-    case DLMS_COMMAND_GLO_SET_RESPONSE:
-    case DLMS_COMMAND_GLO_METHOD_REQUEST:
-    case DLMS_COMMAND_GLO_METHOD_RESPONSE:
-    case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
-    case DLMS_COMMAND_DED_INITIATE_REQUEST:
-    case DLMS_COMMAND_DED_INITIATE_RESPONSE:
-    case DLMS_COMMAND_DED_GET_REQUEST:
-    case DLMS_COMMAND_DED_GET_RESPONSE:
-    case DLMS_COMMAND_DED_SET_REQUEST:
-    case DLMS_COMMAND_DED_SET_RESPONSE:
-    case DLMS_COMMAND_DED_METHOD_REQUEST:
-    case DLMS_COMMAND_DED_METHOD_RESPONSE:
-    case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
-        break;
-    default:
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = hlp_getObjectCount2(data, &length)) != 0)
-    {
-        return ret;
-    }
-    if ((ret = bb_getUInt8(data, &ch)) != 0)
-    {
-        return ret;
-    }
-    *security = (DLMS_SECURITY)(ch & 0x30);
-    if (suite != NULL)
-    {
-        *suite = (DLMS_SECURITY_SUITE) (ch & 0x3);
-    }
-    //If Key_Set or authentication or encryption is not used.
-    if (ch & 0x40 || *security == DLMS_SECURITY_NONE)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_getUInt32(data, &frameCounter)) != 0)
-    {
+        if ((ret = hlp_getObjectCount2(data, &length)) != 0)
+        {
+            return ret;
+        }
+        if ((ret = bb_getUInt8(data, &ch)) != 0)
+        {
+            return ret;
+        }
+        *security = (DLMS_SECURITY)(ch & 0x30);
+        if (suite != NULL)
+        {
+            *suite = (DLMS_SECURITY_SUITE)(ch & 0x3);
+        }
+        //If Key_Set or authentication or encryption is not used.
+        if ((settings->broadcast && (ch & 0x40) == 0) || 
+            (!settings->broadcast && (ch & 0x40) != 0) ||
+            *security == DLMS_SECURITY_NONE)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_getUInt32(data, &frameCounter)) != 0)
+        {
+            return ret;
+        }
+        if (invocationCounter != NULL)
+        {
+            *invocationCounter = frameCounter;
+        }
+        ret = cip_crypt(
+            settings,
+            *security,
+            DLMS_COUNT_TYPE_DATA,
+            frameCounter,
+            0,
+            title,
+            key,
+            data,
+            0);
         return ret;
     }
-    if (invocationCounter != NULL)
-    {
-        *invocationCounter = frameCounter;
-    }
-    ret = cip_crypt(
-        settings,
-        *security,
-        DLMS_COUNT_TYPE_DATA,
-        frameCounter,
-        0,
-        title,
-        key,
-        data,
-        0);
-    return ret;
-}
 
-static const unsigned char WRAP_IV[] = { 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
+    static const unsigned char WRAP_IV[] = { 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6 };
 
-int cip_encryptKey(
-    unsigned char* kek,
-    unsigned char size,
-    gxByteBuffer* data,
-    gxByteBuffer* output)
-{
-    unsigned char buf[16] = { 0 };
-    unsigned char buf2[16] = { 0 };
-    unsigned char n, j, i;
-
-    if (kek == NULL || size != 16 ||
-        data == NULL || data->size != 16 ||
-        output == NULL)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    bb_capacity(output, 24);
-    output->size = 24;
-    output->position = 0;
-    // Amount of 64-bit blocks.
-    n = (unsigned char)(data->size >> 3);
-    memcpy(output->data, WRAP_IV, 8);
-    memcpy(output->data + 8, data->data, data->size);
-    for (j = 0; j != 6; j++)
-    {
-        for (i = 1; i <= n; i++)
-        {
-            memcpy(buf, output->data, 8);
-            memcpy(buf + 8, output->data + (8 * i), 8);
-            gxaes_ecb_encrypt(buf, kek, buf2, 16);
-            unsigned int t = n * j + i;
-            for (int k = 1; t != 0; k++)
-            {
-                unsigned char v = (unsigned char)t;
-                buf2[sizeof(WRAP_IV) - k] ^= v;
-                t = (int)((unsigned int)t >> 8);
+    int cip_encryptKey(
+        unsigned char* kek,
+        unsigned char size,
+        gxByteBuffer* data,
+        gxByteBuffer* output)
+    {
+        int ret;
+        unsigned char buf[16] = { 0 };
+        unsigned char buf2[16] = { 0 };
+        unsigned char n, j, i;
+
+        if (kek == NULL || size != 16 ||
+            data == NULL || data->size != 16 ||
+            output == NULL)
+        {
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_capacity(output, 24)) != 0)
+        {
+            return ret;
+        }
+        output->size = 24;
+        output->position = 0;
+        // Amount of 64-bit blocks.
+        n = (unsigned char)(data->size >> 3);
+        memcpy(output->data, WRAP_IV, 8);
+        memcpy(output->data + 8, data->data, data->size);
+        for (j = 0; j != 6; j++)
+        {
+            for (i = 1; i <= n; i++)
+            {
+                memcpy(buf, output->data, 8);
+                memcpy(buf + 8, output->data + (8 * i), 8);
+                gxaes_ecb_encrypt(buf, kek, buf2, 16);
+                unsigned int t = n * j + i;
+                for (int k = 1; t != 0; k++)
+                {
+                    unsigned char v = (unsigned char)t;
+                    buf2[sizeof(WRAP_IV) - k] ^= v;
+                    t = (int)((unsigned int)t >> 8);
+                }
+                memcpy(output->data, buf2, 8);
+                memcpy(output->data + (8 * i), buf2 + 8, 8);
             }
-            memcpy(output->data, buf2, 8);
-            memcpy(output->data + (8 * i), buf2 + 8, 8);
         }
+        return 0;
     }
-    return 0;
-}
 
-int cip_decryptKey(
-    unsigned char* kek,
-    //KEK size.
-    unsigned char size,
-    gxByteBuffer* data,
-    gxByteBuffer* output)
-{
-    int ret;
-    unsigned char a[8];
-    unsigned char buf[16];
-    unsigned char buf2[16];
-    signed char j, i;
-    unsigned char k, v, n;
-    uint16_t t;
-    // Amount of 64-bit blocks.
-    n = (unsigned char)(bb_size(data) >> 3);
-    if (kek == NULL || size != 16 || data == NULL || data->size != n * 8 ||
-        output == NULL)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    if ((ret = bb_capacity(output, 16)) != 0)
-    {
-        return ret;
-    }
-    output->size = 16;
-    output->position = 0;
-    memcpy(a, data->data, sizeof(WRAP_IV));
-    memcpy(output->data, data->data + sizeof(WRAP_IV), data->size - sizeof(WRAP_IV));
-    if (--n == 0)
-    {
-        n = 1;
-    }
-    for (j = 5; j >= 0; j--)
-    {
-        for (i = n; i >= 1; i--)
+    int cip_decryptKey(
+        unsigned char* kek,
+        //KEK size.
+        unsigned char size,
+        gxByteBuffer* data,
+        gxByteBuffer* output)
+    {
+        int ret;
+        unsigned char a[8];
+        unsigned char buf[16];
+        unsigned char buf2[16];
+        signed char j, i;
+        unsigned char k, v, n;
+        uint16_t t;
+        // Amount of 64-bit blocks.
+        n = (unsigned char)(bb_size(data) >> 3);
+        if (kek == NULL || size != 16 || data == NULL || data->size != n * 8 ||
+            output == NULL)
         {
-            memcpy(buf, a, sizeof(WRAP_IV));
-            memcpy(buf + sizeof(WRAP_IV), output->data + 8 * (i - 1), 8);
-            t = n * j + i;
-            for (k = 1; t != 0; k++)
-            {
-                v = (unsigned char)t;
-                buf[sizeof(WRAP_IV) - k] ^= v;
-                t = (uint16_t)(t >> 8);
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        if ((ret = bb_capacity(output, 16)) != 0)
+        {
+            return ret;
+        }
+        output->size = 16;
+        output->position = 0;
+        memcpy(a, data->data, sizeof(WRAP_IV));
+        memcpy(output->data, data->data + sizeof(WRAP_IV), data->size - sizeof(WRAP_IV));
+        if (--n == 0)
+        {
+            n = 1;
+        }
+        for (j = 5; j >= 0; j--)
+        {
+            for (i = n; i >= 1; i--)
+            {
+                memcpy(buf, a, sizeof(WRAP_IV));
+                memcpy(buf + sizeof(WRAP_IV), output->data + 8 * (i - 1), 8);
+                t = n * j + i;
+                for (k = 1; t != 0; k++)
+                {
+                    v = (unsigned char)t;
+                    buf[sizeof(WRAP_IV) - k] ^= v;
+                    t = (uint16_t)(t >> 8);
+                }
+                gxaes_ecb_decrypt(buf, kek, buf2, 16);
+                memcpy(a, buf2, 8);
+                memcpy(output->data + 8 * (i - 1), buf2 + 8, 8);
             }
-            gxaes_ecb_decrypt(buf, kek, buf2, 16);
-            memcpy(a, buf2, 8);
-            memcpy(output->data + 8 * (i - 1), buf2 + 8, 8);
         }
+        if (memcmp(a, WRAP_IV, sizeof(WRAP_IV)) != 0)
+        {
+            output->size = 0;
+            return DLMS_ERROR_CODE_FALSE;
+        }
+        return 0;
     }
-    if (memcmp(a, WRAP_IV, sizeof(WRAP_IV)) != 0)
-    {
-        output->size = 0;
-        return DLMS_ERROR_CODE_FALSE;
-    }
-    return 0;
-}
 
-#endif //DLMS_IGNORE_HIGH_GMAC
+    #endif //DLMS_IGNORE_HIGH_GMAC
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/client.c src/development/src/client.c
--- upstream/development/src/client.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/client.c	2024-11-13 12:20:09.000000000 +0000
@@ -31,7 +31,7 @@
 //---------------------------------------------------------------------------
 
 #include "../include/gxignore.h"
-#if !defined(DLMS_IGNORE_CLIENT)
+#if !(defined(DLMS_IGNORE_CLIENT) || defined(DLMS_IGNORE_MALLOC))
 #include "../include/gxmem.h"
 
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
@@ -77,7 +77,7 @@
         ret = dlms_getMacHdlcFrame(settings, DLMS_COMMAND_SNRM, 0, NULL, reply);
         if (ret == 0)
         {
-            mes_push(messages, reply);
+            ret = mes_push(messages, reply);
         }
         return ret;
     }
@@ -110,7 +110,10 @@
     BYTE_BUFFER_INIT(reply);
     gxByteBuffer bb;
     BYTE_BUFFER_INIT(&bb);
-    bb_capacity(&bb, 30);
+    if ((ret = bb_capacity(&bb, 30)) != 0)
+    {
+        return ret;
+    }
     pData = &bb;
 #endif //DLMS_IGNORE_MALLOC
 
@@ -167,7 +170,7 @@
     }
     bb_clear(pData);
 #ifndef DLMS_IGNORE_MALLOC
-    mes_push(messages, reply);
+    ret = mes_push(messages, reply);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
 }
@@ -413,15 +416,14 @@
     gxByteBuffer challenge;
     gxByteBuffer* pw;
     dlmsVARIANT data;
-#ifndef DLMS_IGNORE_HIGH_GMAC
-#ifdef DLMS_IGNORE_MALLOC
+#if !defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
     gxByteBuffer pw2;
-#endif //DLMS_IGNORE_MALLOC
+    bb_init(&pw2);
 #endif //DLMS_IGNORE_HIGH_GMAC
 #ifndef GX_DLMS_MICROCONTROLLER
-    unsigned char APPLICATION_ASSOCIATION_REQUEST[32];
+    unsigned char APPLICATION_ASSOCIATION_REQUEST[64];
 #else
-    static unsigned char APPLICATION_ASSOCIATION_REQUEST[32];
+    static unsigned char APPLICATION_ASSOCIATION_REQUEST[64];
 #endif //DLMS_IGNORE_HIGH_GMAC
     bb_attach(&challenge, APPLICATION_ASSOCIATION_REQUEST, 0, sizeof(APPLICATION_ASSOCIATION_REQUEST));
     if (settings->authentication != DLMS_AUTHENTICATION_HIGH_ECDSA &&
@@ -444,8 +446,34 @@
         pw = &pw2;
 #endif //DLMS_IGNORE_MALLOC
     }
-    else
 #endif //DLMS_IGNORE_HIGH_GMAC
+#ifndef DLMS_IGNORE_HIGH_SHA256
+    else if (settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256)
+    {
+#ifdef DLMS_IGNORE_MALLOC
+        if ((ret = bb_set(&pw2, settings->password.data, settings->password.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->cipher.systemTitle, 8)) != 0 ||
+            (ret = bb_set(&pw2, settings->sourceSystemTitle, 8)) != 0)
+        {
+            return ret;
+        }
+#else
+        if ((ret = bb_set(&pw2, settings->password.data, settings->password.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->sourceSystemTitle, 8)) != 0)
+        {
+            return ret;
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if ((ret = bb_set(&pw2, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0 ||
+            (ret = bb_set(&pw2, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0)
+        {
+            return ret;
+        }
+        pw = &pw2;
+    }
+    else
+#endif //DLMS_IGNORE_HIGH_SHA256
     {
         pw = &settings->password;
     }
@@ -458,9 +486,14 @@
         & settings->stoCChallenge,
         pw,
         &challenge);
+#if !defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
+    bb_clear(&pw2);
+#endif //!defined(DLMS_IGNORE_HIGH_GMAC) || !defined(DLMS_IGNORE_HIGH_SHA256)
     if (ret == 0)
     {
+#if !defined(DLMS_IGNORE_HIGH_GMAC)
         ++settings->cipher.invocationCounter;
+#endif //!defined(DLMS_IGNORE_HIGH_GMAC)
         var_init(&data);
         data.vt = DLMS_DATA_TYPE_OCTET_STRING;
         data.byteArr = &challenge;
@@ -531,6 +564,22 @@
         }
         else
 #endif //DLMS_IGNORE_HIGH_GMAC
+#ifndef DLMS_IGNORE_HIGH_SHA256
+        if (settings->authentication == DLMS_AUTHENTICATION_HIGH_SHA256)
+        {
+            bb_attach(&bb2, CHALLENGE_BUFF, 0, sizeof(CHALLENGE_BUFF));
+            secret = &bb2;
+            if ((ret = bb_set(secret, settings->password.data, settings->password.size)) != 0 ||
+                (ret = bb_set(secret, settings->sourceSystemTitle, 8)) != 0 ||
+                (ret = bb_set(secret, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
+                (ret = bb_set(secret, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0 ||
+                (ret = bb_set(secret, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0)
+            {
+                return ret;
+            }
+        }
+        else
+#endif //DLMS_IGNORE_HIGH_SHA256        
         {
             secret = &settings->password;
         }
@@ -1471,7 +1520,7 @@
 #ifndef DLMS_IGNORE_MALLOC
         if (ret == 0)
         {
-            mes_push(packets, reply);
+            ret = mes_push(packets, reply);
         }
         else
         {
@@ -1493,7 +1542,7 @@
 #ifndef DLMS_IGNORE_MALLOC
         if (ret == 0)
         {
-            mes_push(packets, reply);
+            ret = mes_push(packets, reply);
         }
         else
         {
@@ -1513,7 +1562,7 @@
 #ifndef DLMS_IGNORE_MALLOC
         if (ret == 0)
         {
-            mes_push(packets, reply);
+            ret = mes_push(packets, reply);
         }
         else
         {
@@ -2026,9 +2075,12 @@
                 if (value->vt == DLMS_DATA_TYPE_OCTET_STRING)
                 {
                     //Space is allocated for type and size
-                    bb_capacity(&data, 5 + bb_size(value->byteArr));
+                    ret = bb_capacity(&data, 5 + bb_size(value->byteArr));
+                }
+                if (ret == 0)
+                {
+                    ret = dlms_setData(&data, value->vt, value);
                 }
-                ret = dlms_setData(&data, value->vt, value);
             }
         }
 #endif //DLMS_IGNORE_MALLOC
@@ -2248,4 +2300,4 @@
     }
     return value;
 }
-#endif //!defined(DLMS_IGNORE_CLIENT)
+#endif //!(defined(DLMS_IGNORE_CLIENT) || defined(DLMS_IGNORE_MALLOC))
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/converters.c src/development/src/converters.c
--- upstream/development/src/converters.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/converters.c	2024-11-13 12:20:09.000000000 +0000
@@ -397,6 +397,11 @@
         ret = GET_STR_FROM_EEPROM("SFSKReportingSystemList");
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = GET_STR_FROM_EEPROM("LTEMonitoring");
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = GET_STR_FROM_EEPROM("TariffPlan");
@@ -1047,6 +1052,47 @@
 }
 
 #ifndef DLMS_IGNORE_PUSH_SETUP
+
+int obj_PushProtectionParametersToString(gxByteBuffer* ba, gxArray* objects)
+{
+    uint16_t pos;
+    int ret = DLMS_ERROR_CODE_OK;
+    gxPushProtectionParameters* it;
+    for (pos = 0; pos != objects->size; ++pos)
+    {
+        if ((ret = arr_getByIndex(objects, pos, (void**)&it)) != DLMS_ERROR_CODE_OK)
+        {
+            break;
+        }
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+        if ((ret = bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->target->objectType))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = hlp_appendLogicalName(ba, it->target->logicalName)) != 0)
+        {
+            break;
+        }
+#else
+        if ((ret = bb_addIntAsString(ba, it->protectionType)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->transactionId.data, bb_size(&it->transactionId))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->originatorSystemTitle, 8)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->recipientSystemTitle, 8)) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = bb_set(ba, it->otherInformation.data, bb_size(&it->otherInformation))) != 0)
+        {
+            break;
+        }
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    }
+    return ret;
+}
+
 int obj_pushSetupToString(gxPushSetup* object, char** buff)
 {
     int ret;
@@ -1064,11 +1110,72 @@
         (ret = bb_addIntAsString(&ba, object->randomisationStartInterval)) == 0 &&
         (ret = bb_addString(&ba, "\nIndex: 6 Value: ")) == 0 &&
         (ret = bb_addIntAsString(&ba, object->numberOfRetries)) == 0 &&
-        (ret = bb_addString(&ba, "\nIndex: 7 Value: ")) == 0 &&
-        (ret = bb_addIntAsString(&ba, object->repetitionDelay)) == 0 &&
-        (ret = bb_addString(&ba, "\n")) == 0)
+        (ret = bb_addString(&ba, "\nIndex: 7 Value: ")) == 0)
     {
-        *buff = bb_toString(&ba);
+        if (object->base.version < 2)
+        {
+            ret = bb_addIntAsString(&ba, object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = bb_addIntAsString(&ba, object->repetitionDelay2.min)) == 0 &&
+                (ret = bb_addString(&ba, ", ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->repetitionDelay2.exponent)) == 0 &&
+                (ret = bb_addString(&ba, ", ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->repetitionDelay2.max)) == 0)
+            {
+
+            }
+        }
+        if (object->base.version > 0)
+        {
+            if ((ret = bb_addString(&ba, "\nIndex: 8 Value: ")) == 0)
+            {
+                if (object->portReference == NULL)
+                {
+                    ret = hlp_appendLogicalName(&ba, EMPTY_LN);
+                }
+                else
+                {
+                    ret = hlp_appendLogicalName(&ba, object->portReference->logicalName);
+                }
+            }
+
+            if (ret == 0 &&
+                (ret = bb_addString(&ba, "\nIndex: 9 Value: ")) == 0 &&
+                (ret = bb_addIntAsString(&ba, object->pushClientSAP)) == 0)
+            {
+
+            }
+
+            if (ret == 0 &&
+                (ret = bb_addString(&ba, "\nIndex: 10 Value: ")) == 0)
+            {
+                ret = obj_PushProtectionParametersToString(&ba, &object->pushProtectionParameters);
+            }
+            if (object->base.version > 1 && ret == 0)
+            {
+                if ((ret = bb_addString(&ba, "\nIndex: 11 Value: ")) == 0 &&
+                    (ret = bb_addIntAsString(&ba, object->pushOperationMethod)) == 0)
+                {
+                    if ((ret = bb_addString(&ba, "\nIndex: 12 Value: ")) == 0 &&
+                        (ret = time_toString(&object->confirmationParameters.startDate, &ba)) == 0 &&
+                        (ret = bb_addString(&ba, ", ")) == 0 &&
+                        (ret = bb_addIntAsString(&ba, object->confirmationParameters.interval)) == 0)
+                    {
+                        if ((ret = bb_addString(&ba, "\nIndex: 13 Value: ")) == 0 &&
+                            (ret = time_toString(&object->lastConfirmationDateTime, &ba)) == 0)
+                        {
+                        }
+                    }
+                }
+            }
+        }
+        if (ret == 0 &&
+            (ret = bb_addString(&ba, "\n")) == 0)
+        {
+            *buff = bb_toString(&ba);
+        }
     }
     bb_clear(&ba);
     return ret;
@@ -2036,28 +2143,34 @@
     bb_addString(ba, "\nIndex: 5 Value: [\r\n");
     for (pos = 0; pos != object->keyTable.size; ++pos)
     {
-        if ((ret = arr_getByIndex(&object->keyTable, pos, (void**)&it)) != 0)
+        if ((ret = arr_getByIndex(&object->keyTable, pos, (void**)&it)) != 0 ||
+            (ret = bb_addString(ba, "{ ")) != 0 ||
+            (ret = bb_addIntAsString(ba, it->id)) != 0 ||
+            (ret = bb_addString(ba, ",")) != 0)
         {
-            return ret;
+            break;
         }
-        bb_addString(ba, "{ ");
-        bb_addIntAsString(ba, it->id);
-        bb_addString(ba, ",");
         //Add MAC keys as a hex string.
         if (bb_getCapacity(ba) - ba->size < 3 * MAX_G3_MAC_KEY_TABLE_KEY_SIZE)
         {
-            bb_capacity(ba, bb_size(ba) + 3 * MAX_G3_MAC_KEY_TABLE_KEY_SIZE);
+            if ((ret = bb_capacity(ba, bb_size(ba) + 3 * MAX_G3_MAC_KEY_TABLE_KEY_SIZE)) != 0)
+            {
+                break;
+            }
         }
         if ((ret = hlp_bytesToHex2(it->key, MAX_G3_MAC_KEY_TABLE_KEY_SIZE,
             (char*)ba->data + ba->size, (uint16_t)bb_available(ba))) != 0)
         {
-            return ret;
+            break;
         }
         ba->size += 3 * MAX_G3_MAC_KEY_TABLE_KEY_SIZE;
         --ba->size;
         bb_addString(ba, "}\n");
     }
-    bb_addString(ba, "]\n");
+    if (ret == 0)
+    {
+        ret = bb_addString(ba, "]\n");
+    }
     return ret;
 }
 
@@ -2683,7 +2796,7 @@
     if (object->mBusPort != NULL)
     {
         bb_addLogicalName(&ba, object->mBusPort->logicalName);
-    }
+}
 #else
     bb_addLogicalName(&ba, object->mBusPortReference);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
@@ -2711,7 +2824,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_MBUS_CLIENT
 #ifndef DLMS_IGNORE_MODEM_CONFIGURATION
 int obj_modemConfigurationToString(gxModemConfiguration* object, char** buff)
@@ -3018,7 +3131,7 @@
     if (object->phy != NULL)
     {
         bb_addLogicalName(&ba, object->phy->logicalName);
-    }
+}
 #else
     bb_addLogicalName(&ba, object->PHYReference);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
@@ -3034,7 +3147,7 @@
     *buff = bb_toString(&ba);
     bb_clear(&ba);
     return 0;
-}
+    }
 #endif //DLMS_IGNORE_PPP_SETUP
 
 #ifndef DLMS_IGNORE_PROFILE_GENERIC
@@ -3679,13 +3792,53 @@
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int obj_lteMonitoringToString(gxLteMonitoring* object, char** buff)
+{
+    int ret = 0;
+    gxByteBuffer bb;
+    BYTE_BUFFER_INIT(&bb);
+    if ((ret = bb_addString(&bb, "\nt3402: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.t3402)) == 0 &&
+        (ret = bb_addString(&bb, "\nt3412: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.t3412)) == 0 &&
+        (ret = bb_addString(&bb, "\nt3412ext2: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.t3412ext2)) == 0 &&
+        (ret = bb_addString(&bb, "\nt3324: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.t3324)) == 0 &&
+        (ret = bb_addString(&bb, "\nteDRX: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.teDRX)) == 0 &&
+        (ret = bb_addString(&bb, "\ntPTW: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.tPTW)) == 0 &&
+        (ret = bb_addString(&bb, "\nqRxlevMin: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.qRxlevMin)) == 0 &&
+        (ret = bb_addString(&bb, "\nqRxlevMinCE: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.qRxlevMinCE)) == 0 &&
+        (ret = bb_addString(&bb, "\nqRxLevMinCE1: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->networkParameters.qRxLevMinCE1)) == 0 &&
+        (ret = bb_addString(&bb, "}\nsignalQuality: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->qualityOfService.signalQuality)) == 0 &&
+        (ret = bb_addString(&bb, "\nsignalLevel: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->qualityOfService.signalLevel)) == 0 &&
+        (ret = bb_addString(&bb, "\nsignalToNoiseRatio: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->qualityOfService.signalToNoiseRatio)) == 0 &&
+        (ret = bb_addString(&bb, "\ncoverageEnhancement: ")) == 0 &&
+        (ret = bb_addIntAsString(&bb, object->qualityOfService.coverageEnhancement)) == 0)
+    {
+        *buff = bb_toString(&bb);
+    }
+    bb_clear(&bb);
+    return ret;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifdef DLMS_ITALIAN_STANDARD
 int obj_TariffPlanToString(gxTariffPlan* object, char** buff)
 {
     gxByteBuffer ba;
     BYTE_BUFFER_INIT(&ba);
     bb_addString(&ba, "Index: 2 Value: ");
-    bb_addString(&ba, object->calendarName);
+    bb_set(&ba, object->calendarName.data, bb_size(&object->calendarName));
     bb_addString(&ba, "\nIndex: 3 Value: ");
     bb_addIntAsString(&ba, object->enabled);
     bb_addString(&ba, "\nIndex: 5 Value: ");
@@ -4099,6 +4252,11 @@
         ret = obj_SFSKReportingSystemListToString((gxSFSKReportingSystemList*)object, buff);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = obj_lteMonitoringToString((gxLteMonitoring*)object, buff);
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = obj_TariffPlanToString((gxTariffPlan*)object, buff);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/cosem.c src/development/src/cosem.c
--- upstream/development/src/cosem.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/cosem.c	2024-11-13 12:20:09.000000000 +0000
@@ -430,6 +430,11 @@
         size = sizeof(gxSFSKReportingSystemList);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_OBJECT_TYPE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        size = sizeof(gxLteMonitoring);
+        break;
+#endif //DLMS_OBJECT_TYPE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         size = sizeof(gxTariffPlan);
@@ -621,6 +626,14 @@
     case DLMS_OBJECT_TYPE_GPRS_SETUP:
         break;
     case DLMS_OBJECT_TYPE_SECURITY_SETUP:
+    {
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_1)
+        ((gxObject*)object)->version = 1;
+        priv_init(&((gxSecuritySetup*)object)->signingKey);
+        priv_init(&((gxSecuritySetup*)object)->keyAgreementKey);
+        priv_init(&((gxSecuritySetup*)object)->tlsKey);
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_1)        
+    }
         break;
 #ifndef DLMS_IGNORE_IEC_HDLC_SETUP
     case DLMS_OBJECT_TYPE_IEC_HDLC_SETUP:
@@ -734,6 +747,9 @@
         break;
     case DLMS_OBJECT_TYPE_FUNCTION_CONTROL:
         break;
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ((gxObject*)object)->version = 1;
+        break;
     default:
         break;
     }
@@ -926,7 +942,10 @@
     return 0;
 }
 
-int cosem_getOctetStringBase(gxByteBuffer* bb, gxByteBuffer* value, unsigned char type, unsigned char exact)
+int cosem_getOctetStringBase(gxByteBuffer* bb, 
+    gxByteBuffer* value, 
+    unsigned char type, 
+    unsigned char exact)
 {
     int ret;
     unsigned char tmp;
@@ -943,7 +962,9 @@
     {
         return ret;
     }
-    if (exact && count != bb_getCapacity(value))
+    if ((exact && count != bb_getCapacity(value)) ||
+        //Octet-string is too big.
+        count > bb_getCapacity(value))
     {
         return DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
     }
@@ -955,7 +976,11 @@
     return 0;
 }
 
-int cosem_getOctetStringBase2(gxByteBuffer* bb, unsigned char* value, uint16_t capacity, uint16_t* size, unsigned char type)
+int cosem_getOctetStringBase2(gxByteBuffer* bb, 
+    unsigned char* value, 
+    uint16_t capacity, 
+    uint16_t* size, 
+    unsigned char type)
 {
     int ret;
     unsigned char tmp;
@@ -1233,6 +1258,31 @@
     return ret;
 }
 
+int cosem_getVariantExact(gxByteBuffer* bb, dlmsVARIANT* value)
+{
+    int ret;
+    unsigned char ch;
+    gxDataInfo info;
+    if ((ret = bb_getUInt8(bb, &ch)) == 0)
+    {
+        if (ch != value->vt)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            var_clear(value);
+            if (ch != DLMS_DATA_TYPE_NONE)
+            {
+                di_init(&info);
+                --bb->position;
+                ret = dlms_getData(bb, &info, value);
+            }
+        }
+    }
+    return ret;
+}
+
 int cosem_getEnum(gxByteBuffer* bb, unsigned char* value)
 {
     int ret;
@@ -1320,7 +1370,7 @@
         (ret = hlp_setObjectCount(count, bb)) == 0)
     {
         bitArray ba;
-        ba_attach(&ba, bb->data + bb->size, 0, (uint16_t)(8 * (bb->size - bb->size)));
+        ba_attach(&ba, bb->data + bb->size, 0, (uint16_t)(8 * bb_getCapacity(bb)));
         for (pos = 0; pos != count; ++pos)
         {
             if ((ret = ba_setByIndex(&ba, pos, value & 01)) != 0)
@@ -1359,7 +1409,7 @@
         }
     }
     else if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_OCTET_STRING)) != 0 ||
-        (ret = bb_setUInt8(bb, (unsigned char)value->size)) != 0 ||
+        (ret = hlp_setObjectCount(value->size, bb)) != 0 ||
         (ret = bb_set(bb, value->data, (uint16_t)value->size)) != 0)
     {
         //Error code is returned at the end of the function.
@@ -1464,7 +1514,7 @@
         }
     }
     else if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_OCTET_STRING)) != 0 ||
-        (ret = bb_setUInt8(bb, (unsigned char)size)) != 0 ||
+        (ret = hlp_setObjectCount(size, bb)) != 0 ||
         (ret = bb_set(bb, value, size)) != 0)
     {
         //Error code is returned at the end of the function.
@@ -1965,4 +2015,186 @@
         ret = 0;
     }
     return ret;
-}
\ No newline at end of file
+}
+
+#ifndef DLMS_IGNORE_DELTA
+int cosem_setDeltaUInt8(gxByteBuffer* bb, unsigned char value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_UINT8)) != 0 ||
+        (ret = bb_setUInt8(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_setDeltaUInt16(gxByteBuffer* bb, uint16_t value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_UINT16)) != 0 ||
+        (ret = bb_setUInt16(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_setDeltaUInt32(gxByteBuffer* bb, uint32_t value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_UINT32)) != 0 ||
+        (ret = bb_setUInt32(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_setDeltaInt8(gxByteBuffer* bb, char value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_INT8)) != 0 ||
+        (ret = bb_setInt8(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_setDeltaInt16(gxByteBuffer* bb, int16_t value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_INT16)) != 0 ||
+        (ret = bb_setInt16(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_setDeltaInt32(gxByteBuffer* bb, int32_t value)
+{
+    int ret;
+    if ((ret = bb_setUInt8(bb, DLMS_DATA_TYPE_DELTA_INT32)) != 0 ||
+        (ret = bb_setInt32(bb, value)) != 0)
+    {
+        //Error code is returned at the end of the function.
+    }
+    return ret;
+}
+
+int cosem_getDeltaUInt8(gxByteBuffer* bb, unsigned char* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_UINT8)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getUInt8(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+
+int cosem_getDeltaUInt16(gxByteBuffer* bb, uint16_t* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_UINT16)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getUInt16(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+
+int cosem_getDeltaUInt32(gxByteBuffer* bb, uint32_t* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_UINT32)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getUInt32(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+
+int cosem_getDeltaInt8(gxByteBuffer* bb, signed char* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_INT8)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getInt8(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+
+int cosem_getDeltaInt16(gxByteBuffer* bb, int16_t* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_INT16)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getInt16(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+
+int cosem_getDeltaInt32(gxByteBuffer* bb, int32_t* value)
+{
+    int ret;
+    unsigned char tmp;
+    if ((ret = bb_getUInt8(bb, &tmp)) != 0)
+    {
+        return ret;
+    }
+    if (tmp != DLMS_DATA_TYPE_DELTA_INT32)
+    {
+        return DLMS_ERROR_CODE_UNMATCH_TYPE;
+    }
+    if ((ret = bb_getInt32(bb, value)) != 0)
+    {
+        return ret;
+    }
+    return 0;
+}
+#endif //DLMS_IGNORE_DELTA
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/curve.c src/development/src/curve.c
--- upstream/development/src/curve.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/curve.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,149 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/curve.h"
+#include "../include/errorcodes.h"
+
+int curve_init(gxCurve* curve, ECC scheme)
+{
+    if (scheme == ECC_P256)
+    {
+        //Table A. 1  ECC_P256_Domain_Parameters
+        static const uint32_t INIT_A[] = {
+            0xFFFFFFFC, 0xFFFFFFFF,
+            0xFFFFFFFF, 0x00000000,
+            0x00000000, 0x00000000,
+            0x00000001, 0xFFFFFFFF,
+        };
+        static const uint32_t INIT_G1[] = {
+            0xD898C296, 0xF4A13945,
+            0x2DEB33A0,0x77037D81,
+            0x63A440F2,0xF8BCE6E5,
+            0xE12C4247,0x6B17D1F2,
+        };
+        static const uint32_t INIT_G2[] = {
+            0x37BF51F5, 0xCBB64068,
+            0x6B315ECE,0x2BCE3357,
+            0x7C0F9E16,0x8EE7EB4A,
+            0xFE1A7F9B,0x4FE342E2,
+        };
+        static const uint32_t INIT_N[] = {
+            0xFC632551,0xF3B9CAC2,
+            0xA7179E84,0xBCE6FAAD,
+            0xFFFFFFFF,0xFFFFFFFF,
+            0x00000000,0xFFFFFFFF,
+        };
+        static const uint32_t INIT_P[] = {
+            0xFFFFFFFF,0xFFFFFFFF,
+            0xFFFFFFFF,0x00000000,
+            0x00000000,0x00000000,
+            0x00000001,0xFFFFFFFF,
+        };
+        static const uint32_t INIT_B[] = {
+            0x27D2604B, 0x3BCE3C3E,
+            0xCC53B0F6,0x651D06B0,
+            0x769886BC,0xB3EBBD55,
+            0xAA3A93E7,0x5AC635D8,
+        };
+        uint16_t size = sizeof(INIT_A) / sizeof(uint32_t);
+        bi_attach(&curve->a, (uint32_t*) INIT_A, size, size);
+        bi_attach(&curve->g.x, (uint32_t*) INIT_G1, size, size);
+        bi_attach(&curve->g.y, (uint32_t*)INIT_G2, size, size);
+        bi_attach(&curve->n, (uint32_t*)INIT_N, size, size);
+        bi_attach(&curve->p, (uint32_t*)INIT_P, size, size);
+        bi_attach(&curve->b, (uint32_t*)INIT_B, size, size);
+    }
+    else if (scheme == ECC_P384)
+    {
+        //Table A. 2  ECC_P384_Domain_Parameters
+        static const uint32_t INIT_A[] = {
+            0xFFFFFFFC, 0x00000000,
+            0x00000000, 0xFFFFFFFF,
+            0xFFFFFFFE, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+        };
+        static  const uint32_t INIT_G1[] = {
+            0x72760AB7, 0x3A545E38,
+            0xBF55296C, 0x5502F25D,
+            0x82542A38, 0x59F741E0,
+            0x8BA79B98, 0x6E1D3B62,
+            0xF320AD74, 0x8EB1C71E,
+            0xBE8B0537, 0xAA87CA22,
+        };
+        static const uint32_t INIT_G2[] = {
+            0x90EA0E5F, 0x7A431D7C,
+            0x1D7E819D, 0x0A60B1CE,
+            0xB5F0B8C0, 0xE9DA3113,
+            0x289A147C, 0xF8F41DBD,
+            0x9292DC29, 0x5D9E98BF,
+            0x96262C6F, 0x3617DE4A,
+        };
+        static const uint32_t INIT_N[] = {
+            0xCCC52973, 0xECEC196A,
+            0x48B0A77A, 0x581A0DB2,
+            0xF4372DDF, 0xC7634D81,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+        };
+        static const uint32_t INIT_P[] = {
+            0xFFFFFFFF, 0x00000000,
+            0x00000000, 0xFFFFFFFF,
+            0xFFFFFFFE, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF,
+        };
+        static const uint32_t INIT_B[] = {
+            0xD3EC2AEF, 0x2A85C8ED,
+            0x8A2ED19D, 0xC656398D,
+            0x5013875A, 0x0314088F,
+            0xFE814112, 0x181D9C6E,
+            0xE3F82D19, 0x988E056B,
+            0xE23EE7E4, 0xB3312FA7,
+        };
+        uint16_t size = sizeof(INIT_A) / sizeof(uint32_t);
+        bi_attach(&curve->a, (uint32_t*)INIT_A, size, size);
+        bi_attach(&curve->g.x, (uint32_t*)INIT_G1, size, size);
+        bi_attach(&curve->g.y, (uint32_t*)INIT_G2, size, size);
+        bi_attach(&curve->n, (uint32_t*)INIT_N, size, size);
+        bi_attach(&curve->p, (uint32_t*)INIT_P, size, size);
+        bi_attach(&curve->b, (uint32_t*)INIT_B, size, size);
+    }
+    else
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return 0;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/datainfo.c src/development/src/datainfo.c
--- upstream/development/src/datainfo.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/datainfo.c	2024-11-13 12:20:09.000000000 +0000
@@ -38,9 +38,4 @@
     info->count = 0;
     info->type = DLMS_DATA_TYPE_NONE;
     info->complete = 1;
-#ifdef DLMS_ITALIAN_STANDARD
-        //Some meters require that there is a array count in data.
-    info->appendAA = 0;
-#endif //DLMS_ITALIAN_STANDARD
-
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/date.c src/development/src/date.c
--- upstream/development/src/date.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/date.c	2024-11-13 12:20:09.000000000 +0000
@@ -191,6 +191,11 @@
         time->extraInfo = DLMS_DATE_TIME_EXTRA_INFO_LAST_DAY2;
         day = 1;
     }
+    else if ((time->skip & DATETIME_SKIPS_MONTH) != 0)
+    {
+        //If month is skipped.
+        day += 2;
+    }
     tmp = month;
     tmp *= 30L;
     time->value += tmp;
@@ -238,12 +243,17 @@
     {
         time->skip |= DATETIME_SKIPS_SECOND;
     }
-    time->skip |= DATETIME_SKIPS_MS;
+    if (millisecond < 1000)
+    {
+        time->skip |= DATETIME_SKIPS_MS;
+        millisecond = 0;
+    }
     if (devitation == (short)0x8000)
     {
         time->skip |= DATETIME_SKIPS_DEVITATION;
     }
     time->deviation = devitation;
+    time->millisecond = millisecond;
 #else
     int skip = DATETIME_SKIPS_NONE;
     memset(&time->value, 0, sizeof(time->value));
@@ -317,6 +327,7 @@
     time->value.tm_min = minute;
     time->value.tm_sec = second;
     time->deviation = devitation;
+    time->millisecond = millisecond;
     if (gxmktime(&time->value) == (time_t)-1)
     {
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
@@ -326,6 +337,15 @@
 #endif //DLMS_USE_EPOCH_TIME
 }
 
+uint32_t time_getDate(uint32_t value)
+{
+    //Remove hours, minutes and seconds
+    value -= value % 60;
+    value -= value % 3600;
+    value -= value % 86400;
+    return value;
+}
+
 void time_clearDate(
     gxtime* value)
 {
@@ -351,6 +371,20 @@
     value->skip &= ~(DATETIME_SKIPS_YEAR | DATETIME_SKIPS_MONTH | DATETIME_SKIPS_DAY | DATETIME_SKIPS_DAYOFWEEK | DATETIME_SKIPS_DEVITATION);
 }
 
+uint32_t time_getTime(uint32_t value)
+{
+    unsigned char seconds = value % 60;
+    uint32_t t = value;
+    t /= 60;
+    unsigned char minutes = t % 60;
+    t /= 60;
+    unsigned char hours = t % 24;
+    value = seconds;
+    value += 60 * minutes;
+    value += 3600 * hours;
+    return value;
+}
+
 void time_clearTime(
     gxtime* value)
 {
@@ -483,6 +517,12 @@
 #endif // DLMS_USE_EPOCH_TIME
 }
 
+unsigned char time_getHours2(
+    uint32_t value)
+{
+    return (unsigned char)((value % 86400L) / 3600L);
+}
+
 unsigned char time_getMinutes(
     const gxtime* value)
 {
@@ -493,6 +533,12 @@
 #endif // DLMS_USE_EPOCH_TIME
 }
 
+unsigned char time_getMinutes2(
+    uint32_t value)
+{
+    return (unsigned char)((value % 3600L) / 60L);
+}
+
 unsigned char time_getSeconds(
     const gxtime* value)
 {
@@ -503,6 +549,12 @@
 #endif // DLMS_USE_EPOCH_TIME
 }
 
+unsigned char time_getSeconds2(
+    uint32_t value)
+{
+    return value % 60;
+}
+
 void time_addDays(
     gxtime* value,
     int days)
@@ -1164,6 +1216,17 @@
         }
         bb_setUInt8(ba, '*');
     }
+    //Add milliseconds.
+    if ((time->skip & DATETIME_SKIPS_MS) == 0 &&
+        time->millisecond != 0)
+    {
+        if (!empty)
+        {
+            bb_setUInt8(ba, '.');
+        }
+        empty = 0;
+        bb_addIntAsString2(ba, time->millisecond, 2);
+    }
     if (time->deviation != (short)0x8000 && (time->skip & DATETIME_SKIPS_DEVITATION) == 0)
     {
         short tmp = time->deviation;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/dlms.c src/development/src/dlms.c
--- upstream/development/src/dlms.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/dlms.c	2024-11-13 12:20:09.000000000 +0000
@@ -126,8 +126,9 @@
 unsigned char dlms_getGloMessage(dlmsSettings* settings, DLMS_COMMAND command, DLMS_COMMAND encryptedCommand)
 {
     unsigned char cmd;
-    unsigned glo = settings->negotiatedConformance & DLMS_CONFORMANCE_GENERAL_PROTECTION ||
-        dlms_usePreEstablishedConnection(settings);
+    unsigned glo = (settings->negotiatedConformance & DLMS_CONFORMANCE_GENERAL_PROTECTION) != 0 ||
+        //If pre-established connection.
+        (settings->connected & DLMS_CONNECTION_STATE_DLMS) == 0;
     unsigned ded = dlms_useDedicatedKey(settings) && (settings->connected & DLMS_CONNECTION_STATE_DLMS) != 0;
     if (encryptedCommand == DLMS_COMMAND_GENERAL_GLO_CIPHERING ||
         encryptedCommand == DLMS_COMMAND_GENERAL_DED_CIPHERING)
@@ -833,17 +834,22 @@
     value->strVal = (gxByteBuffer*)gxmalloc(sizeof(gxByteBuffer));
     BYTE_BUFFER_INIT(value->strVal);
     value->vt = DLMS_DATA_TYPE_STRING;
-    bb_capacity(value->strVal, (uint16_t)(len * 2));
-    for (a = 0; a != len; ++a)
+    if ((ret = bb_capacity(value->strVal, (uint16_t)(len * 2))) == 0)
     {
-        if ((ret = bb_getUInt8(buff, &ch)) != 0)
+        for (a = 0; a != len; ++a)
         {
-            break;
+            if ((ret = bb_getUInt8(buff, &ch)) != 0)
+            {
+                break;
+            }
+            idHigh = ch >> 4;
+            idLow = ch & 0x0F;
+            if ((ret = bb_setInt8(value->strVal, hexArray[idHigh])) != 0 ||
+                (ret = bb_setInt8(value->strVal, hexArray[idLow])) != 0)
+            {
+                break;
+            }
         }
-        idHigh = ch >> 4;
-        idLow = ch & 0x0F;
-        bb_setInt8(value->strVal, hexArray[idHigh]);
-        bb_setInt8(value->strVal, hexArray[idLow]);
     }
 #endif //DLMS_IGNORE_MALLOC
     return ret;
@@ -1866,21 +1872,17 @@
                     variantArray tmp2;
                     va_init(&tmp2);
 #ifdef DLMS_ITALIAN_STANDARD
-                    //Some Italy meters require that there is a array count in data.
-                    if (info->appendAA)
+                    //Italy standard require that there is a array count in data.
+                    if ((ret = hlp_getObjectCount2(buff, &len)) != 0)
                     {
-                        if ((ret = hlp_getObjectCount2(buff, &len)) != 0)
-                        {
-                            va_clear(&cols);
-                            return ret;
-                        }
-                        if (it->Arr->size != len)
-                        {
-                            return DLMS_ERROR_CODE_INVALID_PARAMETER;
-                        }
+                        va_clear(&cols);
+                        return ret;
+                    }
+                    if (it->Arr->size != len)
+                    {
+                        return DLMS_ERROR_CODE_INVALID_PARAMETER;
                     }
 #endif //DLMS_ITALIAN_STANDARD
-
                     if ((ret = getCompactArrayItem2(buff, it->Arr, &tmp2, 1)) != 0 ||
                         (ret = va_getByIndex(&tmp2, 0, &it2)) != 0)
                     {
@@ -2637,6 +2639,7 @@
     gxByteBuffer* data,
     gxByteBuffer* reply)
 {
+    int ret;
     int frameSize = bb_available(data);
     //Max frame size is 124 bytes.
     if (frameSize > 134)
@@ -2645,50 +2648,59 @@
     }
     //PAD Length.
     unsigned char padLen = (unsigned char)((36 - ((11 + frameSize) % 36)) % 36);
-    bb_capacity(reply, 15 + frameSize + padLen);
-    //Add STX
-    bb_setUInt8(reply, 2);
-    //Length.
-    bb_setUInt8(reply, (unsigned char)(11 + frameSize));
-    //Length.
-    bb_setUInt8(reply, 0x50);
-    //Add  Credit fields.
-    bb_setUInt8(reply, creditFields);
-    //Add source and target MAC addresses.
-    bb_setUInt8(reply, (unsigned char)(settings->plcSettings.macSourceAddress >> 4));
-    int val = settings->plcSettings.macSourceAddress << 12;
-    val |= settings->plcSettings.macDestinationAddress & 0xFFF;
-    bb_setUInt16(reply, (uint16_t)val);
-    bb_setUInt8(reply, padLen);
-    //Control byte.
-    bb_setUInt8(reply, DLMS_PLC_DATA_LINK_DATA_REQUEST);
-    bb_setUInt8(reply, (unsigned char)settings->serverAddress);
-    bb_setUInt8(reply, (unsigned char)settings->clientAddress);
-    bb_set(reply, data->data + data->position, frameSize);
-    data->position += frameSize;
-    //Add padding.
-    while (padLen != 0)
-    {
-        bb_setUInt8(reply, 0);
-        --padLen;
-    }
-    //Checksum.
-    uint16_t crc = countCRC(reply, 0, reply->size);
-    bb_setUInt16(reply, crc);
-    //Remove sent data in server side.
-    if (settings->server)
-    {
-        if (data->size == data->position)
-        {
-            bb_clear(data);
-        }
-        else
-        {
-            bb_move(data, data->position, 0, data->size - data->position);
-            data->position = 0;
+    if ((ret = bb_capacity(reply, 15 + frameSize + padLen)) == 0 &&
+        //Add STX
+        (ret = bb_setUInt8(reply, 2)) == 0 &&
+        //Length.
+        (ret = bb_setUInt8(reply, (unsigned char)(11 + frameSize))) == 0 &&
+        //Length.
+        (ret = bb_setUInt8(reply, 0x50)) == 0 &&
+        //Add  Credit fields.
+        (ret = bb_setUInt8(reply, creditFields)) == 0 &&
+        //Add source and target MAC addresses.
+        (ret = bb_setUInt8(reply, (unsigned char)(settings->plcSettings.macSourceAddress >> 4))) == 0)
+    {
+        int val = settings->plcSettings.macSourceAddress << 12;
+        val |= settings->plcSettings.macDestinationAddress & 0xFFF;
+        if ((ret = bb_setUInt16(reply, (uint16_t)val)) == 0 &&
+            (ret = bb_setUInt8(reply, padLen)) == 0 &&
+            //Control byte.
+            (ret = bb_setUInt8(reply, DLMS_PLC_DATA_LINK_DATA_REQUEST)) == 0 &&
+            (ret = bb_setUInt8(reply, (unsigned char)settings->serverAddress)) == 0 &&
+            (ret = bb_setUInt8(reply, (unsigned char)settings->clientAddress)) == 0 &&
+            (ret = bb_set(reply, data->data + data->position, frameSize)) == 0)
+        {
+            data->position += frameSize;
+            //Add padding.
+            while (padLen != 0)
+            {
+                if ((ret = bb_setUInt8(reply, 0)) != 0)
+                {
+                    return ret;
+                }
+                --padLen;
+            }
+            //Checksum.
+            uint16_t crc = countCRC(reply, 0, reply->size);
+            if ((ret = bb_setUInt16(reply, crc)) == 0)
+            {
+                //Remove sent data in server side.
+                if (settings->server)
+                {
+                    if (data->size == data->position)
+                    {
+                        bb_clear(data);
+                    }
+                    else
+                    {
+                        ret = bb_move(data, data->position, 0, data->size - data->position);
+                        data->position = 0;
+                    }
+                }
+            }
         }
     }
-    return 0;
+    return ret;
 }
 
 // Reserved for internal use.
@@ -3162,6 +3174,14 @@
         {
             return ret;
         }
+        if (data->preEstablished)
+        {
+            //Reset addresses if pre-established connection.
+            if (settings->clientAddress != 0 && settings->clientAddress != value)
+            {
+                settings->serverAddress = settings->clientAddress = 0;
+            }
+        }
         // Check that client addresses match.
         if (settings->clientAddress != 0 && settings->clientAddress != value)
         {
@@ -3185,6 +3205,18 @@
         {
             settings->serverAddress = value;
         }
+#ifndef DLMS_IGNORE_SERVER
+        if (settings->connected == DLMS_CONNECTION_STATE_NONE)
+        {
+            // Check is data send to this server.
+            if (!svr_isTarget(settings, settings->serverAddress, settings->clientAddress))
+            {
+                settings->serverAddress = 0;
+                settings->clientAddress = 0;
+                return DLMS_ERROR_CODE_INVALID_CLIENT_ADDRESS;
+            }
+        }
+#endif //DLMS_IGNORE_SERVER
     }
     else
     {
@@ -3681,7 +3713,11 @@
 }
 #endif //DLMS_IGNORE_PLC
 
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+int dlms_getDataFromBlock(gxByteBuffer* data, uint32_t index)
+#else
 int dlms_getDataFromBlock(gxByteBuffer* data, uint16_t index)
+#endif
 {
 #if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
     uint32_t pos, len = data->position - index;
@@ -3886,7 +3922,7 @@
 int dlms_handleGetResponse(
     dlmsSettings* settings,
     gxReplyData* reply,
-    uint16_t index)
+    uint32_t index)
 {
     int ret;
     uint16_t count;
@@ -4852,9 +4888,12 @@
             {
                 return ret;
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         }
         //If pre-set connection is made.
-        else if (dlms_usePreEstablishedConnection(settings) && emptySourceSystemTile)
+        else if (emptySourceSystemTile)
         {
 #ifndef DLMS_IGNORE_SERVER
             if (settings->server && settings->connected == DLMS_CONNECTION_STATE_NONE && !data->preEstablished)
@@ -4877,10 +4916,10 @@
             if ((ret = cip_decrypt(&settings->cipher,
 #ifndef DLMS_IGNORE_MALLOC
                 settings->preEstablishedSystemTitle->data,
-                &settings->cipher.blockCipherKey,
+                (settings->cipher.broadcast ? &settings->cipher.broadcastBlockCipherKey : &settings->cipher.blockCipherKey),
 #else
                 settings->preEstablishedSystemTitle,
-                settings->cipher.blockCipherKey,
+                (settings->cipher.broadcast ? settings->cipher.broadcastBlockCipherKey : settings->cipher.blockCipherKey),
 #endif //DLMS_IGNORE_MALLOC
                 & data->data,
                 &security,
@@ -4889,9 +4928,15 @@
             {
                 return ret;
             }
-            if (data->preEstablished == 0)
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
+            //If pre-established connection.
+            if ((settings->connected & DLMS_CONNECTION_STATE_DLMS) == 0)
             {
                 data->preEstablished = 1;
+                settings->cipher.suite = suite;
+                settings->cipher.security = security;
             }
         }
         else
@@ -4899,10 +4944,10 @@
             if ((ret = cip_decrypt(&settings->cipher,
 #ifndef DLMS_IGNORE_MALLOC
                 settings->sourceSystemTitle,
-                &settings->cipher.blockCipherKey,
+                (settings->cipher.broadcast ? &settings->cipher.broadcastBlockCipherKey : &settings->cipher.blockCipherKey),
 #else
                 settings->sourceSystemTitle,
-                settings->cipher.blockCipherKey,
+                (settings->cipher.broadcast ? settings->cipher.broadcastBlockCipherKey : settings->cipher.blockCipherKey),
 #endif //DLMS_IGNORE_MALLOC
                 & data->data,
                 &security,
@@ -4911,8 +4956,17 @@
             {
                 return ret;
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         }
         //If IC value is wrong.
+#ifdef DLMS_INVOCATION_COUNTER_VALIDATOR
+        if (svr_validateInvocationCounter(settings, invocationCounter) != 0)
+        {
+            return DLMS_ERROR_CODE_INVOCATION_COUNTER_TOO_SMALL;
+        }
+#else
         if (settings->expectedInvocationCounter != NULL)
         {
             if (invocationCounter < *settings->expectedInvocationCounter)
@@ -4926,6 +4980,7 @@
             * settings->expectedInvocationCounter = (uint32_t)(1 + invocationCounter);
 #endif //DLMS_COSEM_INVOCATION_COUNTER_SIZE64
         }
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
         // Get command.
         if ((ret = bb_getUInt8(&data->data, &ch)) != 0)
         {
@@ -4934,10 +4989,6 @@
         data->encryptedCommand = data->command;
         data->command = (DLMS_COMMAND)ch;
     }
-    else
-    {
-        data->data.position -= 1;
-    }
 #endif //DLMS_IGNORE_HIGH_GMAC
     return ret;
 }
@@ -4990,25 +5041,38 @@
                 return ret;
             }
         }
+#ifdef DLMS_TRACE_PDU
+        if (ret == 0)
+        {
+            cip_tracePdu(0, &bb);
+        }
+#endif //DLMS_TRACE_PDU
         data->data.size = bb.size + index;
         //If target is sending data ciphered using different security policy.
         if (settings->cipher.security != security)
         {
             return DLMS_ERROR_CODE_INVALID_DECIPHERING_ERROR;
         }
+#ifdef DLMS_INVOCATION_COUNTER_VALIDATOR
+        if (svr_validateInvocationCounter(settings, invocationCounter) != 0)
+        {
+            return DLMS_ERROR_CODE_INVOCATION_COUNTER_TOO_SMALL;
+        }
+#else
         if (settings->expectedInvocationCounter != NULL)
         {
-            //If data is ciphered using invalid invocation counter value.
-            if (invocationCounter != *settings->expectedInvocationCounter)
+            if (invocationCounter < *settings->expectedInvocationCounter)
             {
                 return DLMS_ERROR_CODE_INVOCATION_COUNTER_TOO_SMALL;
             }
+            //Update IC.
 #ifdef DLMS_COSEM_INVOCATION_COUNTER_SIZE64
             * settings->expectedInvocationCounter = (1 + invocationCounter);
 #else
             * settings->expectedInvocationCounter = (uint32_t)(1 + invocationCounter);
 #endif //DLMS_COSEM_INVOCATION_COUNTER_SIZE64
         }
+#endif //DLMS_INVOCATION_COUNTER_VALIDATOR
         data->command = DLMS_COMMAND_NONE;
         ret = dlms_getPdu(settings, data, 0);
         data->cipherIndex = (uint16_t)data->data.size;
@@ -5049,6 +5113,9 @@
         {
             return ret;
         }
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(0, &data->data);
+#endif //DLMS_TRACE_PDU
         // Get command
         if ((ret = bb_getUInt8(&data->data, &ch)) != 0)
         {
@@ -5068,7 +5135,7 @@
 }
 #endif //!defined(DLMS_IGNORE_GENERAL_CIPHERING) && !defined(DLMS_IGNORE_HIGH_GMAC)
 
-#if !defined(DLMS_IGNORE_SERVER)
+#ifndef DLMS_IGNORE_CLIENT
 int32_t dlms_handleConfirmedServiceError(gxByteBuffer* data)
 {
     int32_t ret;
@@ -5099,24 +5166,17 @@
 {
     int ret;
     unsigned char ch;
-    // DLMS_EXCEPTION_STATE_ERROR state;
-    DLMS_EXCEPTION_SERVICE_ERROR error;
+    // DLMS_EXCEPTION_STATE_ERROR
     if ((ret = bb_getUInt8(data, &ch)) != 0)
     {
         return ret;
     }
-    // state = (DLMS_EXCEPTION_STATE_ERROR)ch;
+    //DLMS_EXCEPTION_STATE_ERROR
     if ((ret = bb_getUInt8(data, &ch)) != 0)
     {
         return ret;
     }
-    error = (DLMS_EXCEPTION_SERVICE_ERROR)ch;
-    uint32_t value = 0;
-    if (error == DLMS_EXCEPTION_SERVICE_ERROR_INVOCATION_COUNTER_ERROR && bb_available(data) > 3)
-    {
-        bb_getUInt32(data, &value);
-    }
-    return DLMS_ERROR_TYPE_EXCEPTION_RESPONSE | value << 8 | error;
+    return DLMS_ERROR_TYPE_EXCEPTION_RESPONSE | ch;
 }
 #endif //!defined(DLMS_IGNORE_SERVER)
 
@@ -5167,7 +5227,7 @@
             break;
 #endif //!defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
         case DLMS_COMMAND_GET_RESPONSE:
-            if ((ret = dlms_handleGetResponse(settings, data, (uint16_t)index)) != 0)
+            if ((ret = dlms_handleGetResponse(settings, data, index)) != 0)
             {
                 if (ret == DLMS_ERROR_CODE_FALSE)
                 {
@@ -5190,6 +5250,12 @@
         case DLMS_COMMAND_GENERAL_BLOCK_TRANSFER:
             ret = dlms_handleGbt(settings, data);
             break;
+        case DLMS_COMMAND_CONFIRMED_SERVICE_ERROR:
+            ret = dlms_handleConfirmedServiceError(&data->data);
+            break;
+        case DLMS_COMMAND_EXCEPTION_RESPONSE:
+            ret = dlms_handleExceptionResponse(&data->data);
+            break;
 #endif //!defined(DLMS_IGNORE_CLIENT)
         case DLMS_COMMAND_AARQ:
         case DLMS_COMMAND_AARE:
@@ -5199,12 +5265,6 @@
         case DLMS_COMMAND_RELEASE_RESPONSE:
             break;
 #if !defined(DLMS_IGNORE_SERVER)
-        case DLMS_COMMAND_CONFIRMED_SERVICE_ERROR:
-            ret = dlms_handleConfirmedServiceError(&data->data);
-            break;
-        case DLMS_COMMAND_EXCEPTION_RESPONSE:
-            ret = dlms_handleExceptionResponse(&data->data);
-            break;
         case DLMS_COMMAND_GET_REQUEST:
 #if !defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
         case DLMS_COMMAND_READ_REQUEST:
@@ -5253,10 +5313,6 @@
 #if !defined(DLMS_IGNORE_SERVER)
             if (settings->server)
             {
-                if ((settings->connected & DLMS_CONNECTION_STATE_DLMS) == 0)
-                {
-                    return DLMS_ERROR_CODE_INVALID_DECIPHERING_ERROR;
-                }
                 ret = dlms_handleGloDedRequest(settings, data);
             }
 #endif// !defined(DLMS_IGNORE_CLIENT)
@@ -5287,7 +5343,7 @@
             break;
         default:
             // Invalid command.
-            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+            return DLMS_ERROR_CODE_UNKNOWN_COMMAND;
         }
     }
     else if ((data->moreData & DLMS_DATA_REQUEST_TYPES_FRAME) == 0)
@@ -5325,6 +5381,9 @@
             case DLMS_COMMAND_GLO_GET_REQUEST:
             case DLMS_COMMAND_GLO_SET_REQUEST:
             case DLMS_COMMAND_GLO_METHOD_REQUEST:
+            case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
+            case DLMS_COMMAND_GENERAL_DED_CIPHERING:
+            case DLMS_COMMAND_GENERAL_CIPHERING:
                 data->command = DLMS_COMMAND_NONE;
                 data->data.position = (data->cipherIndex);
                 ret = dlms_getPdu(settings, data, 0);
@@ -5353,6 +5412,7 @@
             case DLMS_COMMAND_DED_METHOD_RESPONSE:
             case DLMS_COMMAND_GENERAL_GLO_CIPHERING:
             case DLMS_COMMAND_GENERAL_DED_CIPHERING:
+            case DLMS_COMMAND_GENERAL_CIPHERING:
                 data->data.position = data->cipherIndex;
                 ret = dlms_getPdu(settings, data, 0);
                 break;
@@ -5651,6 +5711,9 @@
     if (ciphering && p->command != DLMS_COMMAND_AARQ
         && p->command != DLMS_COMMAND_AARE)
     {
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(1, reply);
+#endif //DLMS_TRACE_PDU
         ret = cip_encrypt(
             &p->settings->cipher,
             p->settings->cipher.security,
@@ -5838,7 +5901,7 @@
         // Add attribute descriptor.
         if (ret == 0 && p->attributeDescriptor != NULL)
         {
-            ret = bb_set(reply, p->attributeDescriptor->data, p->attributeDescriptor->size);
+            ret = bb_set2(reply, p->attributeDescriptor, p->attributeDescriptor->position, p->attributeDescriptor->size);
         }
 #endif //DLMS_IGNORE_MALLOC
         if (ret == 0 &&
@@ -5981,7 +6044,7 @@
 #else
             unsigned char* key;
 #endif //DLMS_IGNORE_MALLOC
-            if (p->settings->cipher.broacast)
+            if (p->settings->cipher.broadcast)
             {
 #ifndef DLMS_IGNORE_MALLOC
                 key = &p->settings->cipher.broadcastBlockCipherKey;
@@ -6001,6 +6064,9 @@
                 key = p->settings->cipher.blockCipherKey;
 #endif //DLMS_IGNORE_MALLOC
             }
+#ifdef DLMS_TRACE_PDU
+            cip_tracePdu(1, reply);
+#endif //DLMS_TRACE_PDU
             ret = cip_encrypt(
                 &p->settings->cipher,
                 p->settings->cipher.security,
@@ -6112,7 +6178,7 @@
                 }
                 else
                 {
-                    return DLMS_ERROR_CODE_OUTOFMEMORY;
+                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
                 }
             }
             else
@@ -6120,10 +6186,17 @@
                 it = (gxByteBuffer*)gxmalloc(sizeof(gxByteBuffer));
                 if (it == NULL)
                 {
-                    return DLMS_ERROR_CODE_OUTOFMEMORY;
+                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                }
+                else
+                {
+                    BYTE_BUFFER_INIT(it);
+                    ret = mes_push(messages, it);
                 }
-                BYTE_BUFFER_INIT(it);
-                mes_push(messages, it);
+            }
+            if (ret != 0)
+            {
+                break;
             }
 #endif //DLMS_IGNORE_MALLOC
             switch (p->settings->interfaceType)
@@ -6239,7 +6312,7 @@
                 break;
             }
 #ifndef DLMS_IGNORE_MALLOC
-            mes_push(messages, it);
+            ret = mes_push(messages, it);
 #endif //DLMS_IGNORE_MALLOC
         }
         bb_clear(&data);
@@ -6357,10 +6430,12 @@
         switch (data->command)
         {
         case DLMS_COMMAND_DATA_NOTIFICATION:
+#ifndef DLMS_IGNORE_HIGH_GMAC
         case DLMS_COMMAND_GLO_EVENT_NOTIFICATION_REQUEST:
+        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
+#endif //DLMS_IGNORE_HIGH_GMAC
         case DLMS_COMMAND_INFORMATION_REPORT:
         case DLMS_COMMAND_EVENT_NOTIFICATION:
-        case DLMS_COMMAND_DED_EVENT_NOTIFICATION:
             *isNotify = 1;
             notify->complete = data->complete;
             notify->moreData = data->moreData;
@@ -6388,9 +6463,9 @@
     gxByteBuffer* challenge)
 {
     // Random challenge is 8 to 64 bytes.
-    // Texas Instruments accepts only 16 byte int32_t challenge.
+    // Texas Instruments accepts only 16 byte long challenge.
     // For this reason challenge size is 16 bytes at the moment.
-    int ret = 0, pos, len = 16;//hlp_rand() % 58 + 8;
+    int ret = 0, pos, len = 16;
     bb_clear(challenge);
     for (pos = 0; pos != len; ++pos)
     {
@@ -6578,40 +6653,6 @@
             //If SHA256 is not used.
 #ifdef DLMS_IGNORE_HIGH_SHA256
             return DLMS_ERROR_CODE_NOT_IMPLEMENTED;
-#else
-#ifndef DLMS_IGNORE_HIGH_GMAC
-#ifdef DLMS_IGNORE_MALLOC
-            if ((ret = bb_set(&challenge, secret->data, secret->size)) != 0 ||
-                (ret = bb_set(&challenge, settings->cipher.systemTitle, 8)) != 0 ||
-                (ret = bb_set(&challenge, settings->sourceSystemTitle, 8)) != 0)
-            {
-                return ret;
-            }
-#else
-            if ((ret = bb_set(&challenge, secret->data, secret->size)) != 0 ||
-                (ret = bb_set(&challenge, settings->cipher.systemTitle.data, settings->cipher.systemTitle.size)) != 0 ||
-                (ret = bb_set(&challenge, settings->sourceSystemTitle, 8)) != 0)
-            {
-                return ret;
-            }
-#endif //DLMS_IGNORE_MALLOC
-            if (settings->server)
-            {
-                if ((ret = bb_set(&challenge, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0 ||
-                    (ret = bb_set(&challenge, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0)
-                {
-                    return ret;
-                }
-            }
-            else
-            {
-                if ((ret = bb_set(&challenge, settings->stoCChallenge.data, settings->stoCChallenge.size)) != 0 ||
-                    (ret = bb_set(&challenge, settings->ctoSChallenge.data, settings->ctoSChallenge.size)) != 0)
-                {
-                    return ret;
-                }
-            }
-#endif //DLMS_IGNORE_HIGH_GMAC
 #endif //DLMS_IGNORE_HIGH_SHA256
         }
         else
@@ -6651,7 +6692,7 @@
 #ifdef DLMS_IGNORE_HIGH_SHA256
         return DLMS_ERROR_CODE_NOT_IMPLEMENTED;
 #else
-        ret = gxsha256_encrypt(&challenge, reply);
+        ret = gxsha256_hash(secret, reply);
         bb_clear(&challenge);
         return ret;
 #endif //DLMS_IGNORE_HIGH_SHA256
@@ -6798,8 +6839,34 @@
     }
     return 0;
 }
+int dlms_pduAvailable(
+    dlmsSettings* settings,
+    gxByteBuffer* data,
+    uint16_t* size)
+{
+    *size = settings->maxPduSize;
+#ifndef DLMS_IGNORE_HIGH_GMAC
+    if (settings->cipher.security != DLMS_SECURITY_NONE)
+    {
+        *size -= 20 + CIPHERING_HEADER_SIZE + (uint16_t)data->size;
+        if ((settings->negotiatedConformance & DLMS_CONFORMANCE_GENERAL_PROTECTION) != 0)
+        {
+            //System title is sent when General Protection is used.
+            *size -= 9;
+        }
+    }
+    else
+#endif //DLMS_IGNORE_HIGH_GMAC
+    {
+        *size -= 20 + (uint16_t)data->size;
+    }
+    return 0;
+}
 
-int dlms_isPduFull(dlmsSettings* settings, gxByteBuffer* data, uint16_t* size)
+int dlms_isPduFull(
+    dlmsSettings* settings, 
+    gxByteBuffer* data, 
+    uint16_t* size)
 {
     unsigned char ret;
     if (bb_isAttached(data))
@@ -6817,6 +6884,11 @@
         if (settings->cipher.security != DLMS_SECURITY_NONE)
         {
             len += 20 + CIPHERING_HEADER_SIZE + (uint16_t)data->size;
+            if ((settings->negotiatedConformance & DLMS_CONFORMANCE_GENERAL_PROTECTION) != 0)
+            {
+                //System title is sent when General Protection is used.
+                len += 9;
+            }
         }
         else
 #endif //DLMS_IGNORE_HIGH_GMAC
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/dlmsSettings.c src/development/src/dlmsSettings.c
--- upstream/development/src/dlmsSettings.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/dlmsSettings.c	2024-11-13 12:20:09.000000000 +0000
@@ -126,14 +126,14 @@
     {
         settings->proposedConformance = (DLMS_CONFORMANCE)
             (DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_ACTION |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
-            DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
-            DLMS_CONFORMANCE_SET | 
-            DLMS_CONFORMANCE_SELECTIVE_ACCESS |
-            DLMS_CONFORMANCE_ACTION | 
-            DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
-            DLMS_CONFORMANCE_GET |
-            DLMS_CONFORMANCE_GENERAL_PROTECTION);
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_SET_OR_WRITE |
+                DLMS_CONFORMANCE_BLOCK_TRANSFER_WITH_GET_OR_READ |
+                DLMS_CONFORMANCE_SET |
+                DLMS_CONFORMANCE_SELECTIVE_ACCESS |
+                DLMS_CONFORMANCE_ACTION |
+                DLMS_CONFORMANCE_MULTIPLE_REFERENCES |
+                DLMS_CONFORMANCE_GET |
+                DLMS_CONFORMANCE_GENERAL_PROTECTION);
     }
     else
     {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/eccPoint.c src/development/src/eccPoint.c
--- upstream/development/src/eccPoint.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/eccPoint.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,40 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/curve.h"
+
+int eccPoint_init(gxEccPoint* point)
+{
+    bi_init(&point->x);
+    bi_init(&point->y);
+    return 0;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gx509Certificate.c src/development/src/gx509Certificate.c
--- upstream/development/src/gx509Certificate.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/gx509Certificate.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,226 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include <string.h>
+#include "../include/gx509Certificate.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "../include/gxdefine.h"
+#include "../include/helpers.h"
+#include "../include/errorcodes.h"
+#include "../include/asn1Parser.h"
+
+void gx509Certificate_init(gx509Certificate* cert)
+{
+    cert->keyUsage = DLMS_KEY_USAGE_NONE;
+    memset(cert->systemTitle, 0, sizeof(cert->systemTitle));
+    cert->signatureAlgorithm = ECC_P256;
+    cert->validFrom = cert->validTo = 0;
+    bi_init(&cert->serialNumber);
+    pub_init(&cert->publicKey);
+}
+
+void gx509Certificate_clear(gx509Certificate* cert)
+{
+    cert->keyUsage = DLMS_KEY_USAGE_NONE;
+    memset(cert->systemTitle, 0, sizeof(cert->systemTitle));
+    cert->signatureAlgorithm = ECC_P256;
+    cert->validFrom = cert->validTo = 0;
+    bi_clear(&cert->serialNumber);
+    pub_clear(&cert->publicKey);
+}
+
+int gx509Certificate_validate(gx509Certificate* cert, uint32_t time)
+{
+    if ((cert->keyUsage & (DLMS_KEY_USAGE_KEY_AGREEMENT | DLMS_KEY_USAGE_DIGITAL_SIGNATURE)) == 0 ||
+        memcmp(cert->systemTitle, EMPTY_SYSTEM_TITLE, sizeof(EMPTY_SYSTEM_TITLE)) == 0 ||
+        (time != 0 && time < cert->validFrom) ||
+        (time != 0 && time > cert->validTo) ||
+        cert->serialNumber.size == 0 ||
+        cert->publicKey.rawValue.size == 0)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return 0;
+}
+
+int gx509Certificate_parse(gx509Certificate* cert, 
+    DLMS_X509_CERTIFICATE_DATA info,
+    const char* data, 
+    uint16_t index, 
+    uint16_t length,
+    gxByteBuffer* out)
+{
+    int ret;
+    if ((ret = hlp_fromBase64(data + index, length, out)) == 0)
+    {
+        ret = asn1Parser_parsex509Certificate(cert, out, info, 0, 0);       
+    }
+    return ret;
+}
+
+int gx509Certificate_fromBytes(gx509Certificate* cert, 
+    DLMS_X509_CERTIFICATE_DATA info, 
+    gxByteBuffer* data)
+{
+    int ret = asn1Parser_parsex509Certificate(cert, data, info, 0, 0);
+    data->position = 0;
+    return ret;
+}
+
+int gx509Certificate_fromDer(gx509Certificate* cert, 
+    DLMS_X509_CERTIFICATE_DATA info,
+    const char* data)
+{
+    unsigned char buff[DLMS_X509_CETRIFICATE_MAX_SIZE];
+    gxByteBuffer bb;
+    BB_ATTACH(bb, buff, 0);
+    return gx509Certificate_parse(cert, info, data, 0, (uint16_t)strlen(data), &bb);
+}
+
+int gx509Certificate_fromPem2(gx509Certificate* cert,
+    DLMS_X509_CERTIFICATE_DATA info,
+    const char* data,
+    gxByteBuffer *bb)
+{
+    const char* START = GET_STR_FROM_EEPROM("CERTIFICATE-----\n");
+    const char* END = GET_STR_FROM_EEPROM("-----END");
+    int start = strstr(data, START) - data;
+    int end = strstr(data, END) - data;
+    if (start == -1 || end == -1)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    unsigned char buff[DLMS_X509_CETRIFICATE_MAX_SIZE];
+    gxByteBuffer tmp;
+    BB_ATTACH(tmp, buff, 0);
+    int ret = gx509Certificate_parse(cert, info, data, start + 17, end - start - 17, &tmp);
+    if (ret == DLMS_ERROR_CODE_FALSE && bb != NULL)
+    {
+        bb_empty(bb);
+        ret = bb_set(bb, tmp.data + tmp.position, bb_available(&tmp));
+    }
+    return ret;
+}
+
+int gx509Certificate_fromPem(gx509Certificate* cert, 
+    DLMS_X509_CERTIFICATE_DATA info,
+    const char* data)
+{
+    return gx509Certificate_fromPem2(cert, info, data, NULL);
+ }
+
+int gx509Certificate_getTag(gxByteBuffer* data, DLMS_X509_CERTIFICATE_DATA tag, gxByteBuffer* st)
+{
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    uint32_t size = data->size;
+    uint32_t pos = data->position;
+#else
+    uint16_t size = data->size;
+    uint16_t pos = data->position;
+#endif
+    int ret = asn1Parser_parsex509Certificate(NULL, data, tag, 0, 0);
+    if (ret == DLMS_ERROR_CODE_FALSE)
+    {
+        ret = bb_attach(st, data->data + data->position, data->size - data->position, data->size - data->position);
+    }
+    data->position = pos;
+    data->size = size;
+    return ret;
+}
+
+
+int gx509Certificate_getSystemTitle(gxByteBuffer* data, gxByteBuffer* st)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_SYSTEM_TITLE, st);
+}
+
+int gx509Certificate_getValidFrom(gxByteBuffer* data, gxByteBuffer* st)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_VALID_FROM, st);
+}
+
+int gx509Certificate_getValidTo(gxByteBuffer* data, gxByteBuffer* st)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_VALID_TO, st);
+}
+
+int gx509Certificate_getSerialNumber(gxByteBuffer* data, gxByteBuffer* sn)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_SERIAL_NUMBER, sn);
+}
+
+int gx509Certificate_getIssuer(gxByteBuffer* data, gxByteBuffer* issuer)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_ISSUER, issuer);
+}
+
+int gx509Certificate_getSubject(gxByteBuffer* data, gxByteBuffer* subject)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_SUBJECT, subject);
+}
+
+int gx509Certificate_getSubjectAltName(gxByteBuffer* data, gxByteBuffer* subject)
+{
+    return gx509Certificate_getTag(data, DLMS_X509_CERTIFICATE_DATA_SUBJECT_ALT_NAME, subject);
+}
+
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+int gx509Certificate_load(gx509Certificate* cert, 
+    const char* path)
+{
+    char buff[DLMS_X509_CETRIFICATE_MAX_SIZE];
+    uint16_t length = sizeof(buff);
+    int ret = hlp_load(path, buff, &length);
+    if (ret == 0)
+    {
+        ret = gx509Certificate_fromPem(cert, DLMS_X509_CERTIFICATE_DATA_NONE, buff);
+    }
+    return ret;
+}
+
+int gx509Certificate_load2(const char* path,
+    DLMS_X509_CERTIFICATE_DATA info,
+    gxByteBuffer* value)
+{
+    value->size = value->position = 0;
+    uint16_t length = value->capacity;
+    int ret = hlp_load(path, (char*) value->data, &length);
+    if (ret == 0)
+    {
+        ret = gx509Certificate_fromPem2(NULL, info, (const char*) value->data, value);
+    }
+    return ret;
+}
+
+#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxPkcs10.c src/development/src/gxPkcs10.c
--- upstream/development/src/gxPkcs10.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/gxPkcs10.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,181 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include <stddef.h>
+#include "../include/gxPkcs10.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "../include/errorcodes.h"
+#include "../include/gxecdsa.h"
+#include "../include/helpers.h"
+
+int pkcs10_createCertificateSigningRequest(
+    gxPrivateKey* priv, 
+    const unsigned char* subject,
+    gxByteBuffer* value)
+{
+    int ret = 0;
+#ifdef GX_DLMS_MICROCONTROLLER
+    static char system_title[16];
+#else
+    char system_title[16];
+#endif //GX_DLMS_MICROCONTROLLER
+    uint16_t size = priv->scheme == ECC_P256 ? 32 : 48;
+    bb_clear(value);
+    if (subject == NULL || priv == NULL || priv->rawValue.size == 0)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (priv->publicKey.rawValue.size == 0)
+    {
+        ret = priv_getPublicKey(priv, &priv->publicKey);
+    }
+    if (ret == 0)
+    {
+        //CertificationRequestInfo
+        bb_setUInt8(value, 0x30);
+        bb_setUInt8(value, 0x7D);
+        //Version
+        bb_setUInt8(value, 0x2);
+        bb_setUInt8(value, 0x1);
+        bb_setUInt8(value, 0x0);
+        //Subject name SEQUENCE.
+        bb_setUInt8(value, 0x30);
+        bb_setUInt8(value, 0x1B);
+        bb_setUInt8(value, 0x31);
+        bb_setUInt8(value, 0x19);
+        bb_setUInt8(value, 0x30);
+        bb_setUInt8(value, 0x17);
+        //OBJECT IDENTIFIER
+        bb_setUInt8(value, 0x06);
+        bb_setUInt8(value, 0x03);
+        bb_setUInt8(value, 0x55);
+        bb_setUInt8(value, 0x04);
+        bb_setUInt8(value, 0x03);
+        //CN.
+        bb_setUInt8(value, 0x0C);
+        bb_setUInt8(value, sizeof(system_title));
+        hlp_bytesToHex3(subject, 8, system_title, sizeof(system_title), 0);
+        bb_set(value, (unsigned char*)system_title, sizeof(system_title));
+        //SubjectPublicKeyInfo SEQUENCE
+        bb_setUInt8(value, 0x30);
+        bb_setUInt8(value, 0x59);
+        bb_setUInt8(value, 0x30);
+        bb_setUInt8(value, 0x13);
+        //OBJECT IDENTIFIER 1.2.840.10045.2.1
+        bb_setUInt8(value, 0x06);
+        bb_setUInt8(value, 0x07);
+        bb_setUInt8(value, 0x2A);
+        bb_setUInt8(value, 0x86);
+        bb_setUInt8(value, 0x48);
+        bb_setUInt8(value, 0xCE);
+        bb_setUInt8(value, 0x3D);
+        bb_setUInt8(value, 0x02);
+        bb_setUInt8(value, 0x01);
+        //OBJECT IDENTIFIER 1.2.840.10045.3.1.7 prime256v1                     
+        bb_setUInt8(value, 0x06);
+        bb_setUInt8(value, 0x08);
+        bb_setUInt8(value, 0x2A);
+        bb_setUInt8(value, 0x86);
+        bb_setUInt8(value, 0x48);
+        bb_setUInt8(value, 0xCE);
+        bb_setUInt8(value, 0x3D);
+        bb_setUInt8(value, 0x03);
+        bb_setUInt8(value, 0x01);
+        bb_setUInt8(value, 0x07);
+        //Public key.
+        bb_setUInt8(value, BER_TYPE_BIT_STRING);
+        bb_setUInt8(value, 1 + priv->publicKey.rawValue.size);
+        bb_setUInt8(value, 0x00);
+        bb_set(value, priv->publicKey.rawValue.data, priv->publicKey.rawValue.size);
+        //Attributes 0 elements.
+        bb_setUInt8(value, 0xA0);
+        bb_setUInt8(value, 0x0);
+        gxByteBuffer signature;
+#ifdef GX_DLMS_MICROCONTROLLER
+        static unsigned char SIGNATURE[0x40];
+#else
+        unsigned char SIGNATURE[0x40];
+#endif //GX_DLMS_MICROCONTROLLER
+        BB_ATTACH(signature, SIGNATURE, 0);
+        //Sign version, subject, objectIdentifier, attributes and signature algorithm.
+        if ((ret = gxecdsa_sign(priv, value, &signature)) == 0)
+        {
+            //SignatureAlgorithm AlgorithmIdentifier
+            bb_setUInt8(value, 0x30);
+            bb_setUInt8(value, 0x0A);
+            bb_setUInt8(value, 0x06);
+            bb_setUInt8(value, 0x08);
+            bb_setUInt8(value, 0x2A);
+            bb_setUInt8(value, 0x86);
+            bb_setUInt8(value, 0x48);
+            bb_setUInt8(value, 0xCE);
+            bb_setUInt8(value, 0x3D);
+            bb_setUInt8(value, 0x04);
+            bb_setUInt8(value, 0x03);
+            bb_setUInt8(value, 0x02);
+            //Signature BIT STRING.
+            bb_setUInt8(value, BER_TYPE_BIT_STRING);
+            //Sign length.
+            bb_setUInt8(value, 7 + signature.size);
+            //Pad bits.
+            bb_setUInt8(value, 0x00);
+            //X
+            bb_setUInt8(value, 0x30);
+            bb_setUInt8(value, 0x44);
+            bb_setUInt8(value, 0x02);
+            bb_setUInt8(value, 0x20);
+            bb_set(value, signature.data, size);
+            //Y
+            bb_setUInt8(value, 0x02);
+            bb_setUInt8(value, 0x20);
+            if ((ret = bb_set(value, signature.data + size, size)) == 0)
+            {
+                bb_clear(&signature);
+                size = value->size;
+                uint16_t len = 1 + hlp_getObjectCountSizeInBytes(value->size);
+                if ((ret = bb_move(value, 0, len, bb_size(value))) == 0)
+                {
+                    value->size = 0;
+                    //BerType.Constructed | BerType.Sequence
+                    bb_setUInt8(value, 0x30);
+                    //Length
+                    if ((ret = hlp_setObjectCount(size, value)) == 0)
+                    {
+                        value->size += size;
+                    }
+                }
+            }
+        }
+    }
+    return ret;
+}
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxecdsa.c src/development/src/gxecdsa.c
--- upstream/development/src/gxecdsa.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/gxecdsa.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,250 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/gxecdsa.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "../include/helpers.h"
+#include "../include/errorcodes.h"
+#include "../include/bigInteger.h"
+#include "../include/eccPoint.h"
+#include "../include/curve.h"
+#include "../include/shamirs.h"
+#ifdef DLMS_SECURITY_SUITE_1
+#include "../include/gxsha256.h"
+#endif //DLMS_SECURITY_SUITE_1
+#ifdef DLMS_SECURITY_SUITE_2
+#include "../include/gxsha384.h"
+#endif //DLMS_SECURITY_SUITE_2
+
+#ifdef DLMS_SECURITY_SUITE_1
+#define HASH_SIZE 32
+#else
+#define HASH_SIZE 48
+#endif //DLMS_SECURITY_SUITE_1
+
+int gxecdsa_getSchemeSize(ECC scheme)
+{
+    return scheme == ECC_P256 ? 32 : 48;
+}
+
+// Generate random number.
+int gxecdsa_getRandomNumber(bigInteger* N, gxByteBuffer* value)
+{
+    int ret = bb_capacity(value, 4 * N->size);
+    unsigned char val;
+    for (uint16_t pos = 0; pos != (uint16_t)value->capacity; ++pos)
+    {
+        val = hlp_rand();
+        if (val == 0 && pos == 0)
+        {
+            val = (1 + hlp_rand()) % 100;
+        }
+        bb_setUInt8(value, val);
+    }
+    return ret;
+}
+
+int gxecdsa_verify(gxPublicKey* key,
+    gxByteBuffer* signature,
+    gxByteBuffer* data)
+{
+    int ret;
+    unsigned char BUFFER[HASH_SIZE];
+    gxByteBuffer bb;
+    BB_ATTACH(bb, BUFFER, 0);
+    if (key->rawValue.size == 0)
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (key->scheme == ECC_P256)
+    {
+#ifdef DLMS_SECURITY_SUITE_1
+        ret = gxsha256_hash(data, &bb);
+#else
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+#endif //DLMS_SECURITY_SUITE_1
+    }
+#ifdef DLMS_SECURITY_SUITE_2
+    else if (key->scheme == ECC_P384)
+    {
+        ret = gxsha384_hash(data, bb);
+    }
+#endif //DLMS_SECURITY_SUITE_2
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (ret == 0)
+    {
+        bigInteger u1;
+        bi_init(&u1);
+        gxCurve curve;
+        if ((ret = curve_init(&curve, key->scheme)) == 0 &&
+            (ret = bi_fromByteBuffer(&u1, &bb)) == 0)
+        {
+            int size = gxecdsa_getSchemeSize(key->scheme);
+            //u2 = sigR
+            bigInteger u2, sigR;
+            bi_init(&u2);
+            bi_init(&sigR);
+            if ((ret = bb_subArray(signature, 0, size, &bb)) == 0 &&
+                (ret = bi_fromByteBuffer(&u2, &bb)) == 0)
+            {
+                ret = bb_subArray(signature, size, size, &bb);
+                //w = sigS;
+                bigInteger w;
+                bi_init(&w);
+                if ((ret = bi_fromByteBuffer(&w, &bb)) == 0)
+                {
+                    bi_inv(&w, &curve.n);
+                    bi_multiply(&u1, &w);
+                    bi_mod(&u1, &curve.n);
+                    bi_copy(&sigR, &u2);
+                    bi_multiply(&u2, &w);
+                    bi_mod(&u2, &curve.n);
+                    gxEccPoint tmp;
+                    if ((ret = eccPoint_init(&tmp)) == 0 &&
+                        (ret = shamirs_trick(&curve, key, &tmp, &u1, &u2)) == 0)
+                    {
+                        bi_mod(&tmp.x, &curve.n);
+                        ret = bi_compare(&tmp.x, &sigR) == 0 ? 0 : DLMS_ERROR_CODE_VERIFY_FAILED;
+                    }
+                }
+            }
+        }
+    }
+    return ret;
+}
+
+int gxecdsa_sign(gxPrivateKey* key, 
+    gxByteBuffer* data, 
+    gxByteBuffer* signature)
+{
+    bb_empty(signature);
+    int ret;
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+    uint32_t pos = data->position;
+#else
+    uint16_t pos = data->position;
+#endif
+    if (key->rawValue.size == 0)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (key->scheme == ECC_P256)
+    {
+#ifdef DLMS_SECURITY_SUITE_1
+        ret = gxsha256_hash(data, signature);
+#else
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+#endif //DLMS_SECURITY_SUITE_1
+    }
+#ifdef DLMS_SECURITY_SUITE_2
+    else
+    {
+        ret = gxsha384_hash(data, signature);
+    }
+#endif //DLMS_SECURITY_SUITE_2
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (ret == 0)
+    {
+        data->position = pos;
+        bigInteger msg;
+        bi_init(&msg);
+        if ((ret = bi_fromByteBuffer(&msg, signature)) == 0)
+        {
+            bb_clear(signature);
+            gxByteBuffer tmp;
+#ifdef GX_DLMS_MICROCONTROLLER
+            static unsigned char RANDOM_NUMBER[PRIVATE_KEY_SIZE];
+#else
+            unsigned char RANDOM_NUMBER[PRIVATE_KEY_SIZE];
+#endif //GX_DLMS_MICROCONTROLLER
+            BB_ATTACH(tmp, RANDOM_NUMBER, 0);
+            gxCurve curve;
+            if ((ret = curve_init(&curve, key->scheme)) == 0 &&
+                (ret = gxecdsa_getRandomNumber(&curve.n, &tmp)) == 0)
+            {
+                bigInteger k, pk;
+                bi_init(&k);
+                bi_init(&pk);
+                if ((ret = bi_fromByteBuffer(&pk, &key->rawValue)) == 0 &&
+                    (ret = bi_fromByteBuffer(&k, &tmp)) == 0)
+                {
+                    gxEccPoint R;
+                    eccPoint_init(&R);
+                    if ((ret = shamirs_pointMulti(&curve, &R, &curve.g, &k)) == 0 &&
+                        (ret = bi_mod(&R.x, &curve.n)) == 0 &&
+                        //s = (k ^ -1 * (e + d * r)) mod n
+                        (ret = bi_multiply(&pk, &R.x)) == 0 &&
+                        (ret = bi_addBigInteger(&pk, &msg)) == 0 &&
+                        (ret = bi_inv(&k, &curve.n)) == 0 &&
+                        (ret = bi_multiply(&pk, &k)) == 0 &&
+                        (ret = bi_mod(&pk, &curve.n)) == 0 &&
+                        (ret = bb_clear(&tmp)) == 0 &&
+                        (ret = bi_toArray(&R.x, signature)) == 0 &&
+                        (ret = bi_toArray(&pk, &tmp)) == 0)
+                    {
+                        ret = bb_set(signature, tmp.data, tmp.size);
+                    }
+                }
+            }
+        }
+    }
+    return ret;
+}
+
+int gxecdsa_generateKeyPair(
+    ECC scheme,
+    gxPublicKey* pub, gxPrivateKey* priv)
+{
+    gxByteBuffer rn;
+#ifdef GX_DLMS_MICROCONTROLLER
+    static unsigned char RANDOM_NUMBER[PRIVATE_KEY_SIZE];
+#else
+    unsigned char RANDOM_NUMBER[PRIVATE_KEY_SIZE];
+#endif //GX_DLMS_MICROCONTROLLER
+    BB_ATTACH(rn, RANDOM_NUMBER, 0);
+    gxCurve curve;
+    int ret;
+    if ((ret = curve_init(&curve, scheme)) == 0 &&
+        (ret = gxecdsa_getRandomNumber(&curve.n, &rn)) == 0 &&
+        (ret = priv_fromRawBytes(&rn, priv)) == 0 &&
+        (ret = priv_getPublicKey(priv, pub)) == 0)
+    {
+    }
+    return ret;
+}
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxget.c src/development/src/gxget.c
--- upstream/development/src/gxget.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxget.c	2024-11-13 12:20:09.000000000 +0000
@@ -51,6 +51,10 @@
 #include "../include/helpers.h"
 #include "../include/serverevents.h"
 
+#ifndef DLMS_IGNORE_COMPACT_DATA
+#include "../include/gxinvoke.h"
+#endif // DLMS_IGNORE_COMPACT_DATA
+
 #ifdef DLMS_IGNORE_OBJECT_POINTERS
 #define OBJECT_TYPE it->objectType
 #define SCRIPT_LOGICAL_NAME action->scriptLogicalName
@@ -1420,48 +1424,120 @@
     {
         ret = cosem_setOctetString(data, &object->serverSystemTitle);
     }
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
     else if (e->index == 6)
     {
         gxCertificateInfo* it;
-        uint16_t pos, len;
+        uint16_t pos;
         if ((ret = cosem_setArray(data, object->certificates.size)) == 0)
         {
             for (pos = 0; pos != object->certificates.size; ++pos)
             {
 #ifdef DLMS_IGNORE_MALLOC
-                if ((ret = arr_getByIndex(&object->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0 ||
-#else
-                if ((ret = arr_getByIndex(&object->certificates, pos, (void**)&it)) != 0 ||
-#endif //DLMS_IGNORE_MALLOC
-                    (ret = cosem_setStructure(data, 6)) != 0 ||
-                    (ret = cosem_setEnum(data, it->entity)) != 0 ||
-                    (ret = cosem_setEnum(data, it->type)) != 0)
+                if ((ret = arr_getByIndex(&object->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0)
                 {
                     break;
                 }
-                len = (uint16_t)strlen(it->serialNumber);
-                if ((ret = cosem_setOctetString2(data, (unsigned char*)it->serialNumber, len)) != 0)
+#else
+                if ((ret = arr_getByIndex(&object->certificates, pos, (void**)&it)) != 0)
                 {
                     break;
                 }
-                len = (uint16_t)strlen(it->issuer);
-                if ((ret = cosem_setOctetString2(data, (unsigned char*)it->issuer, len)) != 0)
+#endif //DLMS_IGNORE_MALLOC
+#ifndef DLMS_IGNORE_SERVER
+                if (bb_size(&it->cert) != 0)
                 {
-                    break;
+                    gx509Certificate cert;
+                    gx509Certificate_init(&cert);
+                    if ((ret = gx509Certificate_fromBytes(&cert, 
+                                DLMS_X509_CERTIFICATE_DATA_NONE, &it->cert)) == 0)
+                    {
+                        DLMS_CERTIFICATE_TYPE type;
+                        if (cert.keyUsage == DLMS_KEY_USAGE_DIGITAL_SIGNATURE)
+                        {
+                            type = DLMS_CERTIFICATE_TYPE_DIGITAL_SIGNATURE;
+                        }
+                        else if (cert.keyUsage == DLMS_KEY_USAGE_KEY_AGREEMENT)
+                        {
+                            type = DLMS_CERTIFICATE_TYPE_KEY_AGREEMENT;
+                        }
+                        else if (cert.keyUsage == (DLMS_KEY_USAGE_DIGITAL_SIGNATURE | DLMS_KEY_USAGE_KEY_AGREEMENT))
+                        {
+                            type = DLMS_CERTIFICATE_TYPE_TLS;
+                        }
+                        else
+                        {
+                            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+                        }
+                        DLMS_CERTIFICATE_ENTITY entity;
+                        if (memcmp(object->serverSystemTitle.data, cert.systemTitle, 8) == 0)
+                        {
+                            entity = DLMS_CERTIFICATE_ENTITY_SERVER;
+                        }
+                        else
+                        {
+                            entity = DLMS_CERTIFICATE_ENTITY_CLIENT;
+                        }
+                        if ((ret = cosem_setStructure(data, 6)) == 0 &&
+                            (ret = cosem_setEnum(data, entity)) == 0 &&
+                            (ret = cosem_setEnum(data, type)) == 0)
+                        {
+                            gxByteBuffer tmp;
+                            if ((ret = gx509Certificate_getSerialNumber(&it->cert, &tmp)) == 0 &&
+                                (ret = cosem_setOctetString2(data, tmp.data, tmp.size)) == 0)
+                            {
+                                if ((ret = gx509Certificate_getIssuer(&it->cert, &tmp)) == 0 &&
+                                    (ret = cosem_setOctetString2(data, tmp.data, tmp.size)) == 0)
+                                {
+                                    if ((ret = gx509Certificate_getSubject(&it->cert, &tmp)) == 0 &&
+                                        (ret = cosem_setOctetString2(data, tmp.data, tmp.size)) == 0)
+                                    {
+                                        ret = cosem_setOctetString2(data, NULL, 0);
+                                    }
+                                }
+                            }
+                        }
+                    }
                 }
-                len = (uint16_t)strlen(it->subject);
-                if ((ret = cosem_setOctetString2(data, (unsigned char*)it->subject, len)) != 0)
+                if (bb_size(&it->cert) == 0)
+#endif //DLMS_IGNORE_SERVER
                 {
-                    break;
+
                 }
-                len = (uint16_t)strlen(it->subjectAltName);
-                if ((ret = cosem_setOctetString2(data, (unsigned char*)it->subjectAltName, len)) != 0)
+#ifndef DLMS_IGNORE_CLIENT
                 {
-                    break;
+                    if ((ret = cosem_setStructure(data, 6)) != 0 ||
+                        (ret = cosem_setEnum(data, it->entity)) != 0 ||
+                        (ret = cosem_setEnum(data, it->type)) != 0)
+                    {
+                        break;
+                    }
+                    uint16_t len = it->serialNumber == NULL ? 0 : (uint16_t)strlen(it->serialNumber);
+                    if ((ret = cosem_setOctetString2(data, (unsigned char*)it->serialNumber, len)) != 0)
+                    {
+                        break;
+                    }
+                    len = (uint16_t)strlen(it->issuer);
+                    if ((ret = cosem_setOctetString2(data, (unsigned char*)it->issuer, len)) != 0)
+                    {
+                        break;
+                    }
+                    len = (uint16_t)strlen(it->subject);
+                    if ((ret = cosem_setOctetString2(data, (unsigned char*)it->subject, len)) != 0)
+                    {
+                        break;
+                    }
+                    len = (uint16_t)strlen(it->subjectAltName);
+                    if ((ret = cosem_setOctetString2(data, (unsigned char*)it->subjectAltName, len)) != 0)
+                    {
+                        break;
+                    }
                 }
+#endif //DLMS_IGNORE_CLIENT
             }
         }
     }
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
     else
     {
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -4437,16 +4513,16 @@
                     {
                         break;
                     }
-                    }
                 }
             }
         }
+    }
     else
     {
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
     return ret;
-    }
+}
 #endif //DLMS_IGNORE_FUNCTION_CONTROL
 
 #ifndef DLMS_IGNORE_ARRAY_MANAGER
@@ -4581,7 +4657,7 @@
                     (ret = cosem_setUInt16(data, it->dataIndex)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->pushObjectList, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 4)) != 0 ||
@@ -4597,9 +4673,9 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
+            }
+        }
     }
-}
-}
     else if (e->index == 3)
     {
         if ((ret = cosem_setStructure(data, 3)) != 0 ||
@@ -4630,7 +4706,7 @@
                     (ret = cosem_setDateTimeAsOctetString(data, &d->second)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->communicationWindow, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 2)) != 0 ||
@@ -4642,7 +4718,7 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
+            }
         }
     }
     else if (e->index == 5)
@@ -4655,7 +4731,101 @@
     }
     else if (e->index == 7)
     {
-        ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay);
+        if (object->base.version < 2)
+        {
+            ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = cosem_setStructure(e->value.byteArr, 3)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.min)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.exponent)) == 0 &&
+                (ret = cosem_setUInt16(e->value.byteArr, object->repetitionDelay2.max)) == 0)
+            {
+            }
+        }
+    }
+    else if (e->index == 8)
+    {
+#ifdef DLMS_IGNORE_MALLOC
+        ret = cosem_setOctetString2(data, object->portReference, 6);
+#else
+        ret = cosem_setOctetString2(data, obj_getLogicalName(object->portReference), 6);
+#endif //DLMS_IGNORE_MALLOC
+    }
+    else if (e->index == 9)
+    {
+        ret = cosem_setInt8(e->value.byteArr, object->pushClientSAP);
+    }
+    else if (e->index == 10)
+    {
+        if ((ret = cosem_setArray(data, object->pushProtectionParameters.size)) != 0)
+        {
+            return ret;
+        }
+        gxPushProtectionParameters* it2;
+        for (pos = 0; pos != object->pushProtectionParameters.size; ++pos)
+        {
+#ifdef DLMS_IGNORE_MALLOC
+            if ((ret = arr_getByIndex(&object->pushProtectionParameters, pos, (void**)&it2, sizeof(gxPushProtectionParameters))) != 0 ||
+#else
+            if ((ret = arr_getByIndex(&object->pushProtectionParameters, pos, (void**)&it2)) != 0 ||
+#endif //DLMS_IGNORE_MALLOC
+                (ret = cosem_setStructure(data, 2)) != 0 ||
+                (ret = cosem_setEnum(data, it2->protectionType)) != 0 ||
+                (ret = cosem_setStructure(data, 5)) != 0 ||
+                (ret = cosem_setOctetString(data, &it2->transactionId)) != 0 ||
+                (ret = cosem_setOctetString2(data, it2->originatorSystemTitle, 8)) != 0 ||
+                (ret = cosem_setOctetString2(data, it2->recipientSystemTitle, 8)) != 0 ||
+                (ret = cosem_setOctetString(data, &it2->otherInformation)) != 0 ||
+                (ret = cosem_setStructure(data, 2)) != 0 ||
+                (ret = cosem_setEnum(data, it2->keyInfo.dataProtectionKeyType)) != 0)
+            {
+                break;
+            }
+            if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+            {
+                if ((ret = cosem_setStructure(data, 1)) != 0 ||
+                    (ret = cosem_setEnum(data, it2->keyInfo.identifiedKey.keyType)) != 0)
+                {
+                    break;
+                }
+            }
+            else if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+            {
+                if ((ret = cosem_setStructure(data, 2)) != 0 ||
+                    (ret = cosem_setEnum(data, it2->keyInfo.wrappedKey.keyType)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.wrappedKey.key)) != 0)
+                {
+                    break;
+                }
+            }
+            else if (it2->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+            {
+                if ((ret = cosem_setStructure(data, 2)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.agreedKey.parameters)) != 0 ||
+                    (ret = cosem_setOctetString(data, &it2->keyInfo.agreedKey.data)) != 0)
+                {
+                    break;
+                }
+            }
+        }
+    }
+    else if (e->index == 11)
+    {
+        ret = cosem_setEnum(e->value.byteArr, object->pushOperationMethod);
+    }
+    else if (e->index == 12)
+    {
+        if ((ret = cosem_setStructure(e->value.byteArr, 2)) == 0 &&
+            (ret = cosem_setDateTime(e->value.byteArr, &object->confirmationParameters.startDate)) == 0 &&
+            (ret = cosem_setUInt32(e->value.byteArr, object->confirmationParameters.interval)) == 0)
+        {
+        }
+    }
+    else if (e->index == 13)
+    {
+        ret = cosem_setDateTime(e->value.byteArr, &object->lastConfirmationDateTime);
     }
     else
     {
@@ -4726,8 +4896,8 @@
             {
                 break;
             }
+        }
     }
-}
     else
     {
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -4784,7 +4954,7 @@
             (ret = cosem_setInt16(data, it->chargePerUnit)) != 0)
         {
             break;
-}
+        }
 #else
         if ((ret = arr_getByIndex(&target->chargeTables, pos, (void**)&it)) != 0 ||
             (ret = cosem_setStructure(data, 2)) != 0 ||
@@ -4894,7 +5064,7 @@
                 if ((ret = cosem_setOctetString2(data, it->value, it->size)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->descriptions, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setOctetString(data, it)) != 0)
@@ -4902,8 +5072,8 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
-}
+            }
+        }
         break;
     case 5:
         ret = cosem_setEnum(e->value.byteArr, object->deliveryMethod);
@@ -5037,9 +5207,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-}
     else if (e->index == 10)
     {
         if ((ret = cosem_setArray(data, object->chargeReferences.size)) == 0)
@@ -5055,9 +5225,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-    }
     else if (e->index == 11)
     {
         if ((ret = cosem_setArray(data, object->creditChargeConfigurations.size)) == 0)
@@ -5099,9 +5269,9 @@
                 {
                     break;
                 }
+            }
         }
     }
-    }
     else if (e->index == 13)
     {
         ret = cosem_setDateTimeAsOctetString(e->value.byteArr, &object->accountActivationTime);
@@ -5166,12 +5336,11 @@
 #ifndef DLMS_IGNORE_COMPACT_DATA
 
 //Convert compact data buffer to array of values.
-int compactData_getValues2(
+int compactData_getValues(
     dlmsSettings* settings,
     gxByteBuffer* templateDescription,
     gxByteBuffer* buffer,
-    variantArray* values,
-    unsigned char appendAA)
+    variantArray* values)
 {
     int ret;
     gxDataInfo info;
@@ -5189,9 +5358,6 @@
     bb_set(&data, buffer->data, buffer->size);
     var_init(&tmp);
     di_init(&info);
-#ifdef DLMS_ITALIAN_STANDARD
-    info.appendAA = appendAA;
-#endif //DLMS_ITALIAN_STANDARD
     info.type = DLMS_DATA_TYPE_COMPACT_ARRAY;
     if ((ret = dlms_getData(&data, &info, &tmp)) == 0 && tmp.Arr != NULL)
     {
@@ -5202,36 +5368,39 @@
     return ret;
 }
 
-//Convert compact data buffer to array of values.
-int compactData_getValues(
-    dlmsSettings* settings,
-    gxByteBuffer* templateDescription,
-    gxByteBuffer* buffer,
-    variantArray* values)
-{
-    return compactData_getValues2(settings, templateDescription, buffer, values, 0);
-}
-
 int cosem_getCompactData(
     dlmsSettings* settings,
     gxValueEventArg* e)
 {
-    gxByteBuffer* data = data = e->value.byteArr;
     gxCompactData* object = (gxCompactData*)e->target;
-    int ret;
+    int ret = 0;
     switch (e->index)
     {
     case 2:
-        ret = cosem_setOctetString(data, &object->buffer);
+        if (object->captureMethod == DLMS_CAPTURE_METHOD_IMPLICIT)
+        {
+#ifndef DLMS_IGNORE_SERVER
+            if (object->captureObjects.size != 0)
+            {
+                //Some meters implment only template description and not capture objects.
+                //Then the buffer must update in svr_preRead.
+                ret = cosem_captureCompactData(settings, object);
+            }
+#endif //DLMS_IGNORE_SERVER
+        }
+        if (ret == 0)
+        {
+            ret = cosem_setOctetString(e->value.byteArr, &object->buffer);
+        }
         break;
     case 3:
-        ret = getColumns(settings, &object->captureObjects, data, e);
+        ret = getColumns(settings, &object->captureObjects, e->value.byteArr, e);
         break;
     case 4:
         ret = cosem_setUInt8(e->value.byteArr, object->templateId);
         break;
     case 5:
-        ret = cosem_setOctetString(data, &object->templateDescription);
+        ret = cosem_setOctetString(e->value.byteArr, &object->templateDescription);
         break;
     case 6:
         ret = cosem_setEnum(e->value.byteArr, object->captureMethod);
@@ -5655,6 +5824,11 @@
         ret = cosem_getSFSKReportingSystemList(e);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = cosem_getLteMonitoring(e);
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = cosem_getTariffPlan(e);
@@ -5717,71 +5891,45 @@
 
 int cosem_getTariffPlan(gxValueEventArg* e)
 {
-    uint16_t it;
-    int pos, ret;
-    gxByteBuffer* data;
+    int ret;
     gxTariffPlan* object = (gxTariffPlan*)e->target;
     switch (e->index)
     {
     case 2:
-        if (object->calendarName == NULL)
-        {
-            ret = cosem_setString(e->value.byteArr, object->calendarName, 0);
-        }
-        else
-        {
-            ret = cosem_setString(e->value.byteArr, object->calendarName, (uint16_t)strlen(object->calendarName));
-        }
+        ret = cosem_setOctetString(e->value.byteArr, &object->calendarName);
         break;
     case 3:
         ret = cosem_setBoolean(e->value.byteArr, object->enabled);
         break;
     case 4:
     {
-        data = e->value.byteArr;
-        if ((ret = bb_setUInt8(data, DLMS_DATA_TYPE_STRUCTURE)) != 0 ||
-            (ret = bb_setUInt8(data, 4)) != 0 ||
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_UINT8)) != 0 ||
-            (ret = bb_setUInt8(data, object->plan.defaultTariffBand)) != 0 ||
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_ARRAY)) != 0 ||
-            (ret = bb_setUInt8(data, 2)) != 0 ||
-            (ret = getSeason(&object->plan.winterSeason, data)) != 0 ||
-            (ret = getSeason(&object->plan.summerSeason, data)) != 0 ||
-
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_BIT_STRING)) != 0 ||
-            (ret = hlp_setObjectCount(object->plan.weeklyActivation.size, data)) != 0 ||
-            (ret = bb_set(data, object->plan.weeklyActivation.data, ba_getByteCount(object->plan.weeklyActivation.size))) != 0 ||
-
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_ARRAY)) != 0 ||
-            (ret = bb_setUInt8(data, (unsigned char)object->plan.specialDays.size)) != 0)
+        if ((ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_STRUCTURE)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, 4)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_UINT8)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, object->plan.defaultTariffBand)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_ARRAY)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, 2)) == 0 &&
+            (ret = getSeason(&object->plan.winterSeason, e->value.byteArr)) == 0 &&
+            (ret = getSeason(&object->plan.summerSeason, e->value.byteArr)) == 0 &&
+            (ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_BIT_STRING)) == 0 &&
+            (ret = hlp_setObjectCount(object->plan.weeklyActivation.size, e->value.byteArr)) == 0 &&
+            (ret = bb_set(e->value.byteArr, object->plan.weeklyActivation.data, ba_getByteCount(object->plan.weeklyActivation.size))) == 0)
         {
-            return ret;
-        }
-        for (pos = 0; pos != object->plan.specialDays.size; ++pos)
-        {
-            if ((ret = arr_getByIndex(&object->plan.specialDays, pos, (void**)&it)) != 0 ||
-                (ret = bb_setUInt8(data, DLMS_DATA_TYPE_UINT16)) != 0 ||
-                (ret = bb_setUInt16(data, it)) != 0)
-            {
-                return ret;
-            }
+            ret = cosem_getUInt16Array(&object->plan.specialDays, e->value.byteArr);
         }
     }
     break;
     case 5:
     {
-        data = e->value.byteArr;
-        if ((ret = bb_setUInt8(data, DLMS_DATA_TYPE_STRUCTURE)) != 0 ||
+        if ((ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_STRUCTURE)) != 0 ||
             //Count
-            (ret = bb_setUInt8(data, 2)) != 0 ||
+            (ret = bb_setUInt8(e->value.byteArr, 2)) != 0 ||
             //Time
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_OCTET_STRING)) != 0 ||
-            (ret = bb_setUInt8(data, 4)) != 0 ||
-            (ret = var_getTime(&object->activationTime, data)) != 0 ||
+            (ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_TIME)) != 0 ||
+            (ret = var_getTime(&object->activationTime, e->value.byteArr)) != 0 ||
             //Date
-            (ret = bb_setUInt8(data, DLMS_DATA_TYPE_OCTET_STRING)) != 0 ||
-            (ret = bb_setUInt8(data, 5)) != 0 ||
-            (ret = var_getDate(&object->activationTime, data)) != 0)
+            (ret = bb_setUInt8(e->value.byteArr, DLMS_DATA_TYPE_DATE)) != 0 ||
+            (ret = var_getDate(&object->activationTime, e->value.byteArr)) != 0)
         {
             return ret;
         }
@@ -5900,15 +6048,15 @@
                 {
                     break;
                 }
+            }
         }
-    }
         break;
     case 8:
         ret = cosem_setDateTime(e->value.byteArr, &object->captureTime);
         break;
     default:
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-}
+    }
     return ret;
 }
 #endif //DLMS_IGNORE_GSM_DIAGNOSTIC
@@ -6000,7 +6148,7 @@
                     (ret = bb_setUInt8(data, it->attributeIndex)) != 0)
                 {
                     break;
-        }
+                }
 #else
                 if ((ret = arr_getByIndex(&object->parameters, pos, (void**)&it)) != 0 ||
                     (ret = cosem_setStructure(data, 3)) != 0 ||
@@ -6014,8 +6162,8 @@
                     break;
                 }
 #endif //DLMS_IGNORE_MALLOC
-    }
-}
+            }
+        }
     }
     break;
     default:
@@ -6023,7 +6171,7 @@
         break;
     }
     return ret;
-    }
+}
 #endif //DLMS_IGNORE_PARAMETER_MONITOR
 
 #ifndef DLMS_IGNORE_LLC_SSCS_SETUP
@@ -6945,3 +7093,43 @@
     return ret;
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int cosem_getLteMonitoring(
+    gxValueEventArg* e)
+{
+    int ret;
+    gxByteBuffer* data = e->value.byteArr;
+    gxLteMonitoring* object = (gxLteMonitoring*)e->target;
+    if (e->index == 2)
+    {
+        if ((ret = cosem_setStructure(data, 9)) == 0 &&
+            (ret = cosem_setUInt16(data, object->networkParameters.t3402)) == 0 &&
+            (ret = cosem_setUInt16(data, object->networkParameters.t3412)) == 0 &&
+            (ret = cosem_setUInt32(data, object->networkParameters.t3412ext2)) == 0 &&
+            (ret = cosem_setUInt16(data, object->networkParameters.t3324)) == 0 &&
+            (ret = cosem_setUInt32(data, object->networkParameters.teDRX)) == 0 &&
+            (ret = cosem_setUInt16(data, object->networkParameters.tPTW)) == 0 &&
+            (ret = cosem_setInt8(data, object->networkParameters.qRxlevMin)) == 0 &&
+            (ret = cosem_setInt8(data, object->networkParameters.qRxlevMinCE)) == 0 &&
+            (ret = cosem_setInt8(data, object->networkParameters.qRxLevMinCE1)) == 0)
+        {
+        }
+    }
+    else if (e->index == 3)
+    {
+        if ((ret = cosem_setStructure(data, 4)) == 0 &&
+            (ret = cosem_setInt8(data, object->qualityOfService.signalQuality)) == 0 &&
+            (ret = cosem_setInt8(data, object->qualityOfService.signalLevel)) == 0 &&
+            (ret = cosem_setInt8(data, object->qualityOfService.signalToNoiseRatio)) == 0 &&
+            (ret = cosem_setEnum(data, object->qualityOfService.coverageEnhancement)) == 0)
+        {
+        }
+    }
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return ret;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxinvoke.c src/development/src/gxinvoke.c
--- upstream/development/src/gxinvoke.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxinvoke.c	2024-11-13 12:20:09.000000000 +0000
@@ -53,6 +53,11 @@
 #include "../include/gxget.h"
 #include "../include/gxkey.h"
 #include "../include/serverevents.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#include "../include/gxecdsa.h"
+#include "../include/gxpkcs10.h"
+#include "../include/gx509Certificate.h"
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
 
 #ifndef DLMS_IGNORE_CHARGE
 
@@ -755,7 +760,21 @@
 #ifndef DLMS_IGNORE_HIGH_GMAC
     int pos;
 #endif //DLMS_IGNORE_HIGH_GMAC
-    if (e->index == 1)
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    gxCertificateInfo* it;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    gxByteBuffer sn2;
+    bb_init(&sn2);
+#ifdef DLMS_IGNORE_MALLOC
+    gxByteBuffer sn, issuer;
+    bb_init(&sn);
+    bb_init(&issuer);
+#endif //DLMS_IGNORE_MALLOC
+    if (target->securitySuite == 0 && e->index > 3)
+    {
+        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+    }
+    else if (e->index == 1)
     {
         //The security policy can only be strengthened.
         if (target->securityPolicy > var_toInteger(&e->parameters))
@@ -809,8 +828,7 @@
                         memcpy(settings->base.cipher.blockCipherKey, BUFF, bb.size);
                         break;
                     case DLMS_GLOBAL_KEY_TYPE_BROADCAST_ENCRYPTION:
-                        //Invalid type
-                        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                        memcpy(settings->base.cipher.broadcastBlockCipherKey, BUFF, bb.size);
                         break;
                     case DLMS_GLOBAL_KEY_TYPE_AUTHENTICATION:
                         memcpy(settings->base.cipher.authenticationKey, BUFF, bb.size);
@@ -858,8 +876,8 @@
                     bb_set(&settings->base.cipher.blockCipherKey, bb.data, bb.size);
                     break;
                 case DLMS_GLOBAL_KEY_TYPE_BROADCAST_ENCRYPTION:
-                    //Invalid type
-                    ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    bb_clear(&settings->base.cipher.broadcastBlockCipherKey);
+                    bb_set(&settings->base.cipher.broadcastBlockCipherKey, bb.data, bb.size);
                     break;
                 case DLMS_GLOBAL_KEY_TYPE_AUTHENTICATION:
                     bb_clear(&settings->base.cipher.authenticationKey);
@@ -880,6 +898,523 @@
 #endif //DLMS_IGNORE_MALLOC
 #endif //DLMS_IGNORE_HIGH_GMAC
     }
+    else if (e->index == 3)
+    {
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+    }
+    else if (e->index == 4)
+    {
+        //Generate key pair.
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+        uint8_t type;
+#ifdef DLMS_IGNORE_MALLOC
+        if (e->parameters.vt != DLMS_DATA_TYPE_ENUM)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            type = e->parameters.bVal;
+        }
+#else
+        if (e->parameters.vt != DLMS_DATA_TYPE_ENUM)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            type = (uint8_t)var_toInteger(&e->parameters);
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if (ret == 0)
+        {
+            gxPrivateKey* key;
+            if (type == DLMS_CERTIFICATE_TYPE_DIGITAL_SIGNATURE)
+            {
+                key = &target->signingKey;
+            }
+            else if (type == DLMS_CERTIFICATE_TYPE_KEY_AGREEMENT)
+            {
+                key = &target->keyAgreementKey;
+            }
+            else if (type == DLMS_CERTIFICATE_TYPE_TLS)
+            {
+                key = &target->tlsKey;
+            }
+            else
+            {
+                ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+            }
+            if (ret == 0)
+            {
+                ret = gxecdsa_generateKeyPair((ECC)(target->securitySuite - 1), &key->publicKey, key);
+            }
+        }
+#else
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    }
+    else if (e->index == 5)
+    {
+        //GenerateCertificateRequest
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+        //Generate key pair.
+        uint8_t type;
+#ifdef DLMS_IGNORE_MALLOC
+        if (e->parameters.vt != DLMS_DATA_TYPE_ENUM)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            type = e->parameters.bVal;
+        }
+#else
+        if (e->parameters.vt != DLMS_DATA_TYPE_ENUM)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            type = (uint8_t)var_toInteger(&e->parameters);
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if (ret == 0)
+        {
+            gxPrivateKey* key;
+            if (type == DLMS_CERTIFICATE_TYPE_DIGITAL_SIGNATURE)
+            {
+                key = &target->signingKey;
+            }
+            else if (type == DLMS_CERTIFICATE_TYPE_KEY_AGREEMENT)
+            {
+                key = &target->keyAgreementKey;
+            }
+            else if (type == DLMS_CERTIFICATE_TYPE_TLS)
+            {
+                key = &target->tlsKey;
+            }
+            else
+            {
+                ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+            }
+            if (ret == 0)
+            {
+                if (key->rawValue.size != 0)
+                {
+                    e->byteArray = 1;
+                    bb_empty(&settings->info.data);
+                    if (key->publicKey.rawValue.size == 0)
+                    {
+                        ret = priv_getPublicKey(key, &key->publicKey);
+                    }
+                    if (ret == 0)
+                    {
+                        ret = pkcs10_createCertificateSigningRequest(key,
+                            target->serverSystemTitle.data, &settings->info.data);
+                        if (ret == 0 && settings->info.data.size != 0)
+                        {
+                            uint16_t size = (uint16_t)settings->info.data.size;
+                            unsigned char cnt = hlp_getObjectCountSizeInBytes(size);
+                            ret = bb_move(&settings->info.data, 0, cnt + 1, size);
+                            settings->info.data.size = 0;
+                            if ((ret = bb_setUInt8(&settings->info.data, DLMS_DATA_TYPE_OCTET_STRING)) == 0 &&
+                                (ret = hlp_setObjectCount(size, &settings->info.data)) == 0)
+                            {
+                                settings->info.data.size += size;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    }
+                }
+            }
+        }
+#else
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    }
+    else if (e->index == 6)
+    {
+        //Import certificate.
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+#ifdef DLMS_IGNORE_MALLOC
+        if (e->parameters.vt != DLMS_DATA_TYPE_OCTET_STRING)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+#else
+        if (e->parameters.vt != DLMS_DATA_TYPE_OCTET_STRING)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if (ret == 0)
+        {
+#ifdef DLMS_IGNORE_MALLOC
+            unsigned char ch;
+            uint16_t count;
+            gxCertificateInfo* it;
+            //Find by system title and key usage.
+            if ((ret = bb_getUInt8(e->parameters.byteArr, &ch)) != 0 ||
+                ch != DLMS_DATA_TYPE_OCTET_STRING ||
+                hlp_getObjectCount2(e->parameters.byteArr, &count) != 0 ||
+                bb_available(e->parameters.byteArr) < count)
+            {
+                return DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+            }
+            if ((ret = gx509Certificate_getSystemTitle(e->parameters.byteArr, &sn)) == 0)
+            {
+                //Remove old server certificate.
+                for (pos = 0; pos != target->certificates.size; ++pos)
+                {
+                    if ((ret = arr_getByIndex(&target->certificates, target->certificates.size - 1, (void**)&it, sizeof(gxCertificateInfo))) != 0)
+                    {
+                        return DLMS_ERROR_CODE_READ_WRITE_DENIED;
+                    }
+                    if ((ret = gx509Certificate_getSystemTitle(&it->cert, &sn2)) != 0)
+                    {
+                        break;
+                    }
+                    if (memcmp(sn2.data, sn.data, 8) == 0)
+                    {
+                        ret = arr_removeByIndex(&target->certificates, pos, sizeof(gxCertificateInfo));
+                        break;
+                    }
+                }
+                if (ret == 0)
+                {
+                    if (!(target->certificates.size < target->certificates.capacity))
+                    {
+                        //If certificates are full.
+                        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+                    }
+                    else
+                    {
+                        ++target->certificates.size;
+                        if ((ret = arr_getByIndex(&target->certificates, target->certificates.size - 1, (void**)&it, sizeof(gxCertificateInfo))) != 0)
+                        {
+                            --target->certificates.size;
+                            ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+                        }
+                        else
+                        {
+                            //Update the new certificate.
+                            bb_clear(&it->cert);
+                            if ((ret = bb_set(&it->cert,
+                                e->parameters.byteArr->data + e->parameters.byteArr->position,
+                                bb_available(e->parameters.byteArr))) != 0)
+                            {
+                                --target->certificates.size;
+                            }
+                        }
+                    }
+                }
+                bb_clear(e->parameters.byteArr);
+            }
+#else
+            gx509Certificate cert;
+            gx509Certificate certInstalled;
+            gxCertificateInfo* it;
+            gxCertificateInfo* cInfo = (gxCertificateInfo*)gxmalloc(sizeof(gxCertificateInfo));
+            if (cInfo == NULL)
+            {
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
+            bb_init(&cInfo->cert);
+            if ((ret = bb_set(&cInfo->cert, e->parameters.byteArr->data, e->parameters.byteArr->size)) == 0)
+            {
+                gx509Certificate_init(&cert);
+                gx509Certificate_init(&certInstalled);
+                uint32_t now = 0;
+                if (settings->defaultClock != NULL)
+                {
+                    now = time_toUnixTime2(&settings->defaultClock->time);
+                }
+                if ((ret = gx509Certificate_fromBytes(&cert, DLMS_X509_CERTIFICATE_DATA_NONE, e->parameters.byteArr)) == 0 &&
+                    (ret = gx509Certificate_validate(&cert, now)) == 0)
+                {
+                    //Remove old server certificate.
+                    for (pos = 0; pos != target->certificates.size; ++pos)
+                    {
+                        if ((ret = arr_getByIndex(&target->certificates, pos, (void**)&it)) != 0)
+                        {
+                            break;
+                        }
+                        if ((ret = gx509Certificate_fromBytes(&certInstalled,
+                            DLMS_X509_CERTIFICATE_DATA_NONE, &it->cert)) == 0)
+                        {
+                            if (certInstalled.keyUsage == cert.keyUsage &&
+                                memcmp(certInstalled.systemTitle, cert.systemTitle, 8) == 0)
+                            {
+                                if ((ret = arr_removeByIndex(&target->certificates, pos, (void**)&it)) == 0)
+                                {
+                                    gxfree(it);
+                                }
+                                break;
+                            }
+                        }
+                    }
+                    if (ret == 0)
+                    {
+                        ret = arr_push(&target->certificates, cInfo);
+                    }
+                }
+            }
+            if (ret != 0 && cInfo != NULL)
+            {
+                gxfree(cInfo);
+            }
+#endif //DLMS_IGNORE_MALLOC
+        }
+#else
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    }
+    else if (e->index == 7)
+    {
+        //Export certificate.
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+        uint8_t type;
+#ifdef DLMS_IGNORE_MALLOC
+        if (e->parameters.vt != DLMS_DATA_TYPE_OCTET_STRING)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) == 0 &&
+                (ret = cosem_getEnum(e->parameters.byteArr, &type)) == 0)
+            {
+            }
+        }
+#else
+        dlmsVARIANT* sn, * tmp, * tmp2;
+        if ((ret = va_getByIndex(e->parameters.Arr, 0, &tmp)) == 0)
+        {
+            type = (uint8_t)var_toInteger(tmp);
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if (ret == 0)
+        {
+            if (type == 0)
+            {
+                //Find certificate by entity.
+            }
+            else if (type == 1)
+            {
+                //Find by serial.
+#ifdef DLMS_IGNORE_MALLOC
+                unsigned char ch;
+                uint16_t count;
+                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) == 0 &&
+                    //serialNumber
+                    (ret = bb_getUInt8(e->parameters.byteArr, &ch)) == 0 &&
+                    ch == DLMS_DATA_TYPE_OCTET_STRING &&
+                    (ret = hlp_getObjectCount2(e->parameters.byteArr, &count)) == 0)
+                {
+                    bb_attach(&sn, e->parameters.byteArr->data + e->parameters.byteArr->position, count, count);
+                    e->parameters.byteArr->position += count;
+                    //Issuer
+                    if ((ret = bb_getUInt8(e->parameters.byteArr, &ch)) == 0 &&
+                        ch == DLMS_DATA_TYPE_OCTET_STRING &&
+                        (ret = hlp_getObjectCount2(e->parameters.byteArr, &count)) == 0)
+                    {
+                        bb_attach(&issuer, e->parameters.byteArr->data + e->parameters.byteArr->position, count, count);
+                        e->parameters.byteArr->position += count;
+                        //Find certificate.
+                        for (pos = 0; pos != target->certificates.size; ++pos)
+                        {
+                            if ((ret = arr_getByIndex(&target->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0)
+                            {
+                                break;
+                            }
+                            if ((ret = gx509Certificate_getSerialNumber(&it->cert, &sn2)) != 0)
+                            {
+                                break;
+                            }
+                            if (bb_size(&sn) == bb_size(&sn2) &&
+                                bb_compare(&sn, sn2.data, sn2.size))
+                            {
+                                e->byteArray = 1;
+                                bb_empty(&settings->info.data);
+                                if ((ret = bb_setUInt8(&settings->info.data, DLMS_DATA_TYPE_OCTET_STRING)) == 0 &&
+                                    (ret = hlp_setObjectCount(it->cert.size, &settings->info.data)) == 0 &&
+                                    (ret = bb_set(&settings->info.data, it->cert.data, it->cert.size)) == 0)
+                                {
+                                }
+                                return ret;
+                            }
+                        }
+                        //Return error if certificate is not found.
+                        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    }
+                }
+            }
+#else
+                if ((ret = va_getByIndex(e->parameters.Arr, 1, &tmp2)) == 0 &&
+                    //serialNumber
+                    (ret = va_getByIndex(tmp2->Arr, 0, &sn)) == 0 &&
+                    //Issuer
+                    (ret = va_getByIndex(tmp2->Arr, 1, &tmp)) == 0)
+                {
+                    //Find certificate.
+                    for (pos = 0; pos != target->certificates.size; ++pos)
+                    {
+                        if ((ret = arr_getByIndex(&target->certificates, pos, (void**)&it)) != 0)
+                        {
+                            break;
+                        }
+                        if ((ret = gx509Certificate_getSerialNumber(&it->cert, &sn2)) != 0)
+                        {
+                            break;
+                        }
+                        if (bb_size(sn->byteArr) == bb_size(&sn2) &&
+                            bb_compare(sn->byteArr, sn2.data, sn2.size))
+                        {
+                            bb_empty(&settings->info.data);
+                            if ((ret = bb_setUInt8(&settings->info.data, DLMS_DATA_TYPE_OCTET_STRING)) == 0 &&
+                                (ret = hlp_setObjectCount(it->cert.size, &settings->info.data)) == 0 &&
+                                (ret = bb_set(&settings->info.data, it->cert.data, it->cert.size)) == 0)
+                            {
+                            }
+                            return ret;
+                        }
+                    }
+                    //Return error if certificate is not found.
+                    ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                }
+            }
+#endif //DLMS_IGNORE_MALLOC
+            else
+            {
+                ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+            }
+        }
+#else
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    }
+    else if (e->index == 8)
+    {
+        //Remove certificate.
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+        uint8_t type;
+#ifdef DLMS_IGNORE_MALLOC
+        if (e->parameters.vt != DLMS_DATA_TYPE_OCTET_STRING)
+        {
+            ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+        }
+        else
+        {
+            if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) == 0 &&
+                (ret = cosem_getEnum(e->parameters.byteArr, &type)) == 0)
+            {
+            }
+        }
+#else
+        dlmsVARIANT* sn, * tmp, * tmp2;
+        if ((ret = va_getByIndex(e->parameters.Arr, 0, &tmp)) == 0)
+        {
+            type = (uint8_t)var_toInteger(tmp);
+        }
+#endif //DLMS_IGNORE_MALLOC
+        if (ret == 0)
+        {
+            if (type == 0)
+            {
+                //Find certificate by entity.
+            }
+            else if (type == 1)
+            {
+                gxCertificateInfo* it;
+#ifdef DLMS_IGNORE_MALLOC
+                unsigned char ch;
+                uint16_t count;
+                if ((ret = cosem_checkStructure(e->parameters.byteArr, 2)) == 0 &&
+                    //serialNumber
+                    (ret = bb_getUInt8(e->parameters.byteArr, &ch)) == 0 &&
+                    ch == DLMS_DATA_TYPE_OCTET_STRING &&
+                    (ret = hlp_getObjectCount2(e->parameters.byteArr, &count)) == 0)
+                {
+                    bb_attach(&sn, e->parameters.byteArr->data + e->parameters.byteArr->position, count, count);
+                    e->parameters.byteArr->position += count;
+                    //Issuer
+                    if ((ret = bb_getUInt8(e->parameters.byteArr, &ch)) == 0 &&
+                        ch == DLMS_DATA_TYPE_OCTET_STRING &&
+                        (ret = hlp_getObjectCount2(e->parameters.byteArr, &count)) == 0)
+                    {
+                        bb_attach(&issuer, e->parameters.byteArr->data + e->parameters.byteArr->position, count, count);
+                        e->parameters.byteArr->position += count;
+                        //Find certificate.
+                        for (pos = 0; pos != target->certificates.size; ++pos)
+                        {
+                            if ((ret = arr_getByIndex(&target->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0)
+                            {
+                                break;
+                            }
+                            if ((ret = gx509Certificate_getSerialNumber(&it->cert, &sn2)) != 0)
+                            {
+                                break;
+                            }
+                            if (bb_size(&sn) == bb_size(&sn2) &&
+                                bb_compare(&sn, sn2.data, sn2.size))
+                            {
+                                bb_empty(&settings->info.data);
+                                return arr_removeByIndex(&target->certificates, pos, sizeof(gxCertificateInfo));
+                            }
+                        }
+                        //Return error if certificate is not found.
+                        ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                    }
+                }
+            }
+#else
+                gxByteBuffer sn2;
+                if ((ret = va_getByIndex(e->parameters.Arr, 1, &tmp2)) == 0 &&
+                    //serialNumber
+                    (ret = va_getByIndex(tmp2->Arr, 0, &sn)) == 0 &&
+                    //Issuer
+                    (ret = va_getByIndex(tmp2->Arr, 1, &tmp)) == 0)
+                {
+                    //Find certificate.
+                    for (pos = 0; pos != target->certificates.size; ++pos)
+                    {
+                        if ((ret = arr_getByIndex(&target->certificates, pos, (void**)&it)) != 0)
+                        {
+                            break;
+                        }
+                        if ((ret = gx509Certificate_getSerialNumber(&it->cert, &sn2)) != 0)
+                        {
+                            break;
+                        }
+                        if (bb_size(sn->byteArr) == bb_size(&sn2) &&
+                            bb_compare(sn->byteArr, sn2.data, sn2.size))
+                        {
+                            bb_empty(&settings->info.data);
+                            if ((ret = arr_removeByIndex(&target->certificates, pos, (void**)&it)) == 0)
+                            {
+                                gxfree(it);
+                            }
+                            return ret;
+                        }
+                    }
+                    //Return error if certificate is not found.
+                    ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+                }
+            }
+#endif //DLMS_IGNORE_MALLOC
+            else
+            {
+                ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
+            }
+        }
+#else
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    }
     else
     {
         ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
@@ -1091,11 +1626,11 @@
                     {
                         break;
                     }
+                    }
                 }
             }
-        }
         vec_clear(&args);
-    }
+        }
     else
     {
         ret = DLMS_ERROR_CODE_INCONSISTENT_CLASS_OR_OBJECT;
@@ -1402,11 +1937,19 @@
     gxRegister* object,
     gxValueEventArg* e)
 {
-    int ret = 0;
+    int ret;
     //Reset.
     if (e->index == 1)
     {
-        ret = var_clear(&object->value);
+        if (e->parameters.vt != DLMS_DATA_TYPE_INT8 ||
+            e->parameters.cVal != 0)
+        {
+            ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+        }
+        else
+        {
+            ret = var_clear(&object->value);
+        }
     }
     else
     {
@@ -1521,47 +2064,35 @@
 #ifndef DLMS_IGNORE_COMPACT_DATA
 int compactDataAppend(unsigned char byteArray, dlmsVARIANT* value3, gxByteBuffer* bb)
 {
+#ifdef DLMS_IGNORE_MALLOC
+    int ret;
     if (byteArray && value3->vt == DLMS_DATA_TYPE_OCTET_STRING)
     {
         if (bb_size(value3->byteArr) == 1)
         {
-            bb_setUInt8(bb, 0);
+            ret = bb_setUInt8(bb, 0);
         }
         else
         {
-            bb_set(bb, value3->byteArr->data + 1, value3->byteArr->size - 1);
+            ret = bb_set(bb, value3->byteArr->data + 1, value3->byteArr->size - 1);
         }
-        return 0;
-    }
-    int ret;
-    uint16_t startPos = (uint16_t)bb->size;
-    if ((ret = dlms_setData(bb, value3->vt, value3)) != 0)
-    {
         return ret;
     }
-    //If data is empty.
-    if (bb->size - startPos == 1)
-    {
-        bb_setUInt8(bb, 0);
-    }
-    else
-    {
-        ret = bb_move(bb, startPos + 1, startPos, bb->size - startPos - 1);
-    }
-    return 0;
+#endif //DLMS_IGNORE_MALLOC
+    return var_getBytes4(value3, value3->vt, bb, 0, 0, 0);
 }
 
 int compactDataAppendArray(dlmsVARIANT* value, gxByteBuffer* bb, uint16_t dataIndex)
 {
     int ret, pos;
     int cnt = value->Arr->size;
-    if (dataIndex != 0)
+    if (dataIndex > 0xFFF)
     {
-        cnt = dataIndex;
-        --dataIndex;
-    }
+        //0x1000 to 0xFFFF is the selective access to the array.
+        cnt = value->Arr->size;
+    }    
     dlmsVARIANT* value2;
-    for (pos = dataIndex; pos != cnt; ++pos)
+    for (pos = 0; pos != cnt; ++pos)
     {
         if ((ret = va_getByIndex(value->Arr, pos, &value2)) != 0)
         {
@@ -1599,83 +2130,70 @@
     dlmsSettings* settings,
     gxCompactData* object)
 {
-    int ret = 0;
-    uint16_t pos;
 #ifdef DLMS_IGNORE_MALLOC
-    gxTarget* kv;
+    return compactData_update(settings, object, 0);
 #else
+    int ret = 0;
+    uint16_t pos;
     gxKey* kv;
-#endif //DLMS_IGNORE_MALLOC
-    gxValueEventArg e;
     gxValueEventCollection args;
     bb_clear(&object->buffer);
-    ve_init(&e);
-    e.action = 1;
-    e.target = &object->base;
-    e.index = 2;
-#ifdef DLMS_IGNORE_MALLOC
+
+    gxValueEventArg* e = (gxValueEventArg*)gxmalloc(sizeof(gxValueEventArg));
+    ve_init(e);
+    vec_init(&args);
+    vec_push(&args, e);
+    e->action = 1;
+    e->target = &object->base;
+    e->index = 2;
     //Allocate space where captured values are saved before they are added to the buffer.
     // We can't use server buffer because there might be transaction on progress when this is called.
     unsigned char tmp[MAX_CAPTURE_OBJECT_BUFFER_SIZE];
     gxByteBuffer bb;
     bb_attach(&bb, tmp, 0, sizeof(tmp));
-    gxValueEventArg p[1] = { e };
-    vec_attach(&args, p, 1, 1);
-#else
-    vec_init(&args);
-    vec_push(&args, &e);
-#endif //DLMS_IGNORE_MALLOC
     svr_preGet(settings, &args);
-    if (!e.handled)
+    if (!e->handled)
     {
         uint16_t dataIndex;
         for (pos = 0; pos != object->captureObjects.size; ++pos)
         {
-#ifdef DLMS_IGNORE_MALLOC
-            ret = arr_getByIndex(&object->captureObjects, pos, (void**)&kv, sizeof(gxTarget));
-#else
             ret = arr_getByIndex(&object->captureObjects, pos, (void**)&kv);
-#endif //DLMS_IGNORE_MALLOC
             if (ret != DLMS_ERROR_CODE_OK)
             {
                 bb_clear(&object->buffer);
                 break;
             }
-#ifdef DLMS_IGNORE_MALLOC
-            e.value.byteArr = &bb;
-            e.value.vt = DLMS_DATA_TYPE_OCTET_STRING;
-            e.target = kv->target;
-            e.index = kv->attributeIndex;
-            dataIndex = kv->dataIndex;
-#else
-            e.target = (gxObject*)kv->key;
-            e.index = ((gxTarget*)kv->value)->attributeIndex;
+            e->target = (gxObject*)kv->key;
+            e->index = ((gxTarget*)kv->value)->attributeIndex;
             dataIndex = ((gxTarget*)kv->value)->dataIndex;
-#endif //DLMS_IGNORE_MALLOC
-            if ((ret = cosem_getValue(settings, &e)) != 0)
+            if ((ret = cosem_getValue(settings, e)) != 0)
             {
                 bb_clear(&object->buffer);
                 break;
             }
-            if (e.byteArray && e.value.vt == DLMS_DATA_TYPE_OCTET_STRING)
+            if (e->byteArray && e->value.vt == DLMS_DATA_TYPE_OCTET_STRING)
             {
                 gxDataInfo info;
                 dlmsVARIANT value;
                 di_init(&info);
                 var_init(&value);
-                if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
+                if ((ret = dlms_getData(e->value.byteArr, &info, &value)) != 0)
                 {
                     var_clear(&value);
                     break;
                 }
-                if (value.vt == DLMS_DATA_TYPE_STRUCTURE ||
-                    value.vt == DLMS_DATA_TYPE_ARRAY)
+                if (info.type == DLMS_DATA_TYPE_STRUCTURE ||
+                    info.type == DLMS_DATA_TYPE_ARRAY)
                 {
 #ifdef DLMS_ITALIAN_STANDARD
-                    //Some meters require that there is a array count in data.
-                    if (value.vt == DLMS_DATA_TYPE_ARRAY && object->appendAA)
+                    //Italian standard requires that there is a array count in data.
+                    if (info.type == DLMS_DATA_TYPE_ARRAY)
                     {
-                        bb_setUInt8(&object->buffer, (unsigned char)value.Arr->size);
+                        if ((ret = hlp_setObjectCount(value.Arr->size, &object->buffer)) != 0)
+                        {
+                            var_clear(&value);
+                            break;
+                        }
                     }
 #endif //DLMS_ITALIAN_STANDARD
                     if ((ret = compactDataAppendArray(&value, &object->buffer, dataIndex)) != 0)
@@ -1686,7 +2204,7 @@
                 }
                 else
                 {
-                    if ((ret = compactDataAppend(1, &e.value, &object->buffer)) != 0)
+                    if ((ret = compactDataAppend(1, &value, &object->buffer)) != 0)
                     {
                         var_clear(&value);
                         break;
@@ -1694,11 +2212,11 @@
                 }
                 var_clear(&value);
             }
-            else if ((ret = compactDataAppend(0, &e.value, &object->buffer)) != 0)
+            else if ((ret = compactDataAppend(0, &e->value, &object->buffer)) != 0)
             {
                 break;
             }
-            ve_clear(&e);
+            ve_clear(e);
         }
     }
     svr_postGet(settings, &args);
@@ -1708,6 +2226,7 @@
     }
     vec_empty(&args);
     return ret;
+#endif //DLMS_IGNORE_MALLOC
 }
 
 int invoke_CompactData(
@@ -1715,7 +2234,7 @@
     gxCompactData* object,
     unsigned char index)
 {
-    int ret = 0;
+    int ret;
     //Reset.
     if (index == 1)
     {
@@ -1725,11 +2244,18 @@
     else if (index == 2)
     {
         // Capture.
-        ret = cosem_captureCompactData(&settings->base, object);
+        if (object->captureMethod == DLMS_CAPTURE_METHOD_INVOKE)
+        {
+            ret = cosem_captureCompactData(&settings->base, object);
+        }
+        else
+        {
+            ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+        }
     }
     else
     {
-        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
     }
     return ret;
 }
@@ -1969,7 +2495,11 @@
 #ifdef DLMS_IGNORE_MALLOC
                 ret = arr_removeByIndex(&object->entries, pos, sizeof(gxSpecialDay));
 #else
-                ret = arr_removeByIndex(&object->entries, pos, NULL);
+                ret = arr_removeByIndex(&object->entries, pos, (void**)&specialDay);
+                if (ret == 0)
+                {
+                    gxfree(specialDay);
+                }
 #endif //DLMS_IGNORE_MALLOC
                 break;
             }
@@ -2074,7 +2604,7 @@
 #else
             arr_push(&object->registerAssignment, it);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-        }
+            }
 #ifdef DLMS_IGNORE_OBJECT_POINTERS
         if (ret != 0 && objectDefinition != NULL)
         {
@@ -2110,10 +2640,10 @@
                     }
                 }
             }
-        }
+    }
 #else
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-    }
+        }
     //Remove mask.
     else if (e->index == 3)
     {
@@ -2210,11 +2740,11 @@
                 it->start = sp->start;
                 bb_set(&it->weekName, sp->weekName.data, sp->weekName.size);
 #endif //#if defined(DLMS_IGNORE_MALLOC)
+                }
             }
         }
-    }
     return ret;
-}
+    }
 
 int invoke_copyWeekProfileTable(gxArray* target, gxArray* source)
 {
@@ -2253,11 +2783,11 @@
                 it->friday = wp->friday;
                 it->saturday = wp->saturday;
                 it->sunday = wp->sunday;
+                }
             }
         }
-    }
     return ret;
-}
+    }
 
 int invoke_copyDayProfileTable(gxArray* target, gxArray* source)
 {
@@ -2312,11 +2842,11 @@
 #endif //DLMS_IGNORE_OBJECT_POINTERS
                     dp2->scriptSelector = dp->scriptSelector;
                 }
+                }
             }
         }
-    }
     return ret;
-}
+    }
 
 int invoke_ActivityCalendar(gxValueEventArg* e)
 {
@@ -2886,14 +3416,14 @@
                 break;
             }
         }
-    }
+}
     if (!found)
     {
         bb_clear(e->value.byteArr);
         ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
     }
     return ret;
-}
+    }
 #endif //DLMS_IGNORE_ARRAY_MANAGER
 
 #ifndef DLMS_IGNORE_G3_PLC_MAC_SETUP
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxmd5.c src/development/src/gxmd5.c
--- upstream/development/src/gxmd5.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxmd5.c	2024-11-13 12:20:09.000000000 +0000
@@ -227,38 +227,38 @@
 
 int gxmd5_encrypt(gxByteBuffer* data, gxByteBuffer* digest)
 {
+    static unsigned char padding[64] = {
+        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+    };
+    int ret;
     // Bytes that didn't fit in last 64 byte chunk
     unsigned char buffer[64];
     // Number of bits (lo, hi)
     uint32_t count[2] = { 0, 0 };
     // Digest
     uint32_t state[4] = { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 };
-    bb_capacity(digest, 16);
-
-    gxmd5_update(data->data, data->size, buffer, count, state);
-
-    static unsigned char padding[64] = {
-        0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-    };
-
-    // Save number of bits
-    unsigned char bits[8];
-    gxmd5_encode(bits, count, 2);
-
-    // Pad out to 56 mod 64.
-    unsigned int index = count[0] / 8 % 64;
-    unsigned int padLen = (index < 56) ? (56 - index) : (120 - index);
-    gxmd5_update(padding, padLen, buffer, count, state);
-
-    // Append length (before padding)
-    gxmd5_update(bits, 8, buffer, count, state);
-
-    // Store state in digest
-    gxmd5_encode(digest->data, state, 4);
-    digest->size = 16;
-    return 0;
+    if ((ret = bb_capacity(digest, 16)) == 0)
+    {
+        gxmd5_update(data->data, data->size, buffer, count, state);
+        // Save number of bits
+        unsigned char bits[8];
+        gxmd5_encode(bits, count, 2);
+
+        // Pad out to 56 mod 64.
+        unsigned int index = count[0] / 8 % 64;
+        unsigned int padLen = (index < 56) ? (56 - index) : (120 - index);
+        gxmd5_update(padding, padLen, buffer, count, state);
+
+        // Append length (before padding)
+        gxmd5_update(bits, 8, buffer, count, state);
+
+        // Store state in digest
+        gxmd5_encode(digest->data, state, 4);
+        digest->size = 16;
+    }
+    return ret;
 }
 
 #endif //DLMS_IGNORE_HIGH_MD5
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxobjects.c src/development/src/gxobjects.c
--- upstream/development/src/gxobjects.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxobjects.c	2024-11-13 12:20:09.000000000 +0000
@@ -204,12 +204,34 @@
 }
 #endif //!(defined(DLMS_IGNORE_PROFILE_GENERIC) && defined(DLMS_IGNORE_COMPACT_DATA))
 
+#if defined(DLMS_SECURITY_SUITE_1) ||defined(DLMS_SECURITY_SUITE_2) 
+int obj_clearCertificates(gxArray* list)
+{
+    int ret = DLMS_ERROR_CODE_OK;
+#ifndef DLMS_IGNORE_MALLOC
+    uint16_t pos;
+    gxCertificateInfo* it;
+    for (pos = 0; pos != list->size; ++pos)
+    {
+        ret = arr_getByIndex(list, pos, (void**)&it);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            break;
+        }
+        bb_clear(&it->cert);
+    }
+#endif //DLMS_IGNORE_MALLOC
+    arr_clear(list);
+    return ret;
+}
+#endif //defined(DLMS_SECURITY_SUITE_1) ||defined(DLMS_SECURITY_SUITE_2) 
+
 #ifndef DLMS_IGNORE_ACTIVITY_CALENDAR
 int obj_clearSeasonProfile(gxArray* list)
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos;
+    uint16_t pos;
     gxSeasonProfile* sp;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -230,7 +252,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos;
+    uint16_t pos;
     gxWeekProfile* wp;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -250,7 +272,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos, pos2;
+    uint16_t pos, pos2;
     gxDayProfile* it;
     gxDayProfileAction* dp;
     for (pos = 0; pos != list->size; ++pos)
@@ -289,7 +311,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos;
+    uint16_t pos;
     gxModemInitialisation* it;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -312,7 +334,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos;
+    uint16_t pos;
     gxScheduleEntry* it;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -334,7 +356,8 @@
     list->size = 0;
     return 0;
 #else
-    int pos, ret = 0;
+    int ret = 0;
+    uint16_t pos;
     gxByteBuffer* it;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -355,7 +378,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos, pos2;
+    uint16_t pos, pos2;
     gxScript* s;
     gxScriptAction* sa;
     for (pos = 0; pos != list->size; ++pos)
@@ -387,7 +410,7 @@
 {
     int ret = DLMS_ERROR_CODE_OK;
 #ifndef DLMS_IGNORE_MALLOC
-    int pos;
+    uint16_t pos;
     gxChargeTable* it;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -440,7 +463,8 @@
     arr_clear(list);
     return ret;
 #else
-    int ret = 0, pos;
+    int ret = 0;
+    uint16_t pos;
     gxKey* it;
     for (pos = 0; pos != list->size; ++pos)
     {
@@ -698,7 +722,7 @@
 int obj_clearCertificateInfo(gxArray* arr)
 {
     int ret = 0;
-#ifndef DLMS_IGNORE_MALLOC
+#if !(defined(DLMS_IGNORE_MALLOC) || defined(DLMS_IGNORE_CLIENT))
     gxCertificateInfo* it;
     uint16_t pos;
     for (pos = 0; pos != arr->size; ++pos)
@@ -712,7 +736,7 @@
         gxfree(it->subject);
         gxfree(it->subjectAltName);
     }
-#endif //DLMS_IGNORE_MALLOC
+#endif //!(defined(DLMS_IGNORE_MALLOC) || defined(DLMS_IGNORE_CLIENT))
     arr_clear(arr);
     return ret;
 }
@@ -836,6 +860,11 @@
             bb_clear(&((gxSecuritySetup*)object)->clientSystemTitle);
             bb_clear(&((gxSecuritySetup*)object)->serverSystemTitle);
             obj_clearCertificateInfo(&((gxSecuritySetup*)object)->certificates);
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+            priv_clear(&((gxSecuritySetup*)object)->signingKey);
+            priv_clear(&((gxSecuritySetup*)object)->keyAgreementKey);
+            priv_clear(&((gxSecuritySetup*)object)->tlsKey);
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
             break;
 #endif //DLMS_IGNORE_SECURITY_SETUP
 #ifndef DLMS_IGNORE_IEC_HDLC_SETUP
@@ -1134,6 +1163,7 @@
 #ifndef DLMS_IGNORE_PUSH_SETUP
         case DLMS_OBJECT_TYPE_PUSH_SETUP:
             obj_clearPushObjectList(&((gxPushSetup*)object)->pushObjectList);
+            arr_clear(&((gxPushSetup*)object)->pushProtectionParameters);
 #ifdef DLMS_IGNORE_MALLOC
             ((gxPushSetup*)object)->destination.size = 0;
 #else
@@ -1289,12 +1319,20 @@
             obj_clearByteBufferList(&((gxSFSKReportingSystemList*)object)->reportingSystemList);
             break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+        case DLMS_OBJECT_TYPE_LTE_MONITORING:
+            break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
         case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         {
-            gxfree(((gxTariffPlan*)object)->calendarName);
+            bb_clear(&((gxTariffPlan*)object)->calendarName);
             ba_clear(&((gxTariffPlan*)object)->plan.weeklyActivation);
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
             arr_clear(&((gxTariffPlan*)object)->plan.specialDays);
+#else
+            va_clear(&((gxTariffPlan*)object)->plan.specialDays);
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
             break;
         }
 #endif //DLMS_ITALIAN_STANDARD
@@ -1513,7 +1551,18 @@
         ret = 2;
         break;
     case DLMS_OBJECT_TYPE_PUSH_SETUP:
-        ret = 7;
+        if (object->version == 0)
+        {
+            ret = 7;
+        }
+        else if (object->version == 1)
+        {
+            ret = 10;
+        }
+        else
+        {
+            ret = 13;
+        }
         break;
     case DLMS_OBJECT_TYPE_DATA_PROTECTION:
         ret = 6;
@@ -1623,6 +1672,11 @@
         ret = 2;
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = 3;
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
     default:
         //Unknown type.
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
@@ -1808,7 +1862,14 @@
         ret = 0;
         break;
     case DLMS_OBJECT_TYPE_SECURITY_SETUP:
-        ret = 2;
+        if (object->version == 0)
+        {
+            ret = 2;
+        }
+        else
+        {
+            ret = 8;
+        }
         break;
     case DLMS_OBJECT_TYPE_IEC_HDLC_SETUP:
         ret = 0;
@@ -1927,7 +1988,14 @@
         ret = 0;
         break;
     case DLMS_OBJECT_TYPE_PUSH_SETUP:
-        ret = 1;
+        if (object->version < 2)
+        {
+            ret = 1;
+        }
+        else
+        {
+            ret = 2;
+        }
         break;
     case DLMS_OBJECT_TYPE_DATA_PROTECTION:
         ret = 3;
@@ -2036,6 +2104,11 @@
         ret = 0;
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = 0;
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = 0;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxserializer.c src/development/src/gxserializer.c
--- upstream/development/src/gxserializer.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxserializer.c	2024-11-13 12:20:09.000000000 +0000
@@ -45,7 +45,7 @@
 #endif //DLMS_DEBUG
 
 //Serialization version is increased every time when structure of serialized data is changed.
-#define SERIALIZATION_VERSION 1
+#define SERIALIZATION_VERSION 2
 
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
 #include <assert.h>
@@ -287,17 +287,20 @@
         return DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
 #endif //DLMS_IGNORE_MALLOC
-#if !defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__))
-    if (fread(value, sizeof(unsigned char), count, serializeSettings->stream) != count)
+    if (count != 0)
     {
-        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
+#if !defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__))
+        if (fread(value, sizeof(unsigned char), count, serializeSettings->stream) != count)
+        {
+            ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
 #else
-    if ((ret = SERIALIZER_LOAD((uint16_t)serializeSettings->position, count, value)) == 0)
-    {
-        serializeSettings->position += count;
-    }
+        if ((ret = SERIALIZER_LOAD((uint16_t)serializeSettings->position, count, value)) == 0)
+        {
+            serializeSettings->position += count;
+        }
 #endif//!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__))
+    }
 #if !(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
 #ifdef DLMS_IGNORE_MALLOC
     if (ret == 0)
@@ -664,11 +667,11 @@
     bb_clear(value);
 #ifdef DLMS_IGNORE_MALLOC
     uint16_t capacity;
-    if ((ret = ser_loadObjectCount(serializeSettings, &capacity)) != 0)
+    if ((ret = ser_loadObjectCount(serializeSettings, &capacity)) != 0 ||
+        (ret = bb_capacity(value, capacity)) != 0)
     {
         return ret;
     }
-    bb_capacity(value, capacity);
 #else
     if ((ret = bb_capacity(value, count)) != 0)
     {
@@ -992,6 +995,26 @@
             ret = ser_loadDateTime(data->dateTime, serializeSettings, DLMS_DATA_TYPE_TIME);
 #endif //DLMS_IGNORE_MALLOC
             break;
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_INT8:
+            ret = ser_loadInt8(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->cVal : data->pcVal);
+            break;
+        case DLMS_DATA_TYPE_DELTA_INT16:
+            ret = ser_loadInt16(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->iVal : data->piVal);
+            break;
+        case DLMS_DATA_TYPE_DELTA_INT32:
+            ret = ser_loadInt32(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->lVal : data->plVal);
+            break;
+        case DLMS_DATA_TYPE_DELTA_UINT8:
+            ret = ser_loadUInt8(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->bVal : data->pbVal);
+            break;
+        case DLMS_DATA_TYPE_DELTA_UINT16:
+            ret = ser_loadUInt16(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->uiVal : data->puiVal);
+            break;
+        case DLMS_DATA_TYPE_DELTA_UINT32:
+            ret = ser_loadUInt32(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) == 0 ? &data->ulVal : data->pulVal);
+            break;
+#endif //DLMS_IGNORE_DELTA
         default:
 #ifdef _DEBUG
             //Assert in debug version.
@@ -1464,6 +1487,26 @@
 #endif //DLMS_IGNORE_MALLOC
         break;
     }
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+        ret = ser_saveUInt8(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->pbVal : data->bVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+        ret = ser_saveUInt16(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->puiVal : data->uiVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+        ret = ser_saveUInt32(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->pulVal : data->ulVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT8:
+        ret = ser_saveUInt8(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->pcVal : data->cVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT16:
+        ret = ser_saveInt16(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->puiVal : data->uiVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT32:
+        ret = ser_saveUInt32(serializeSettings, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->plVal : data->lVal);
+        break;
+#endif //DLMS_IGNORE_DELTA
     default:
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
         assert(0);
@@ -2236,8 +2279,50 @@
         (!isAttributeSet(serializeSettings, ignored, 4) && (ret = ser_saveOctetString(serializeSettings, &object->serverSystemTitle)) != 0) ||
         (!isAttributeSet(serializeSettings, ignored, 5) && (ret = ser_saveOctetString(serializeSettings, &object->clientSystemTitle)) != 0))
     {
-
     }
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    if (!isAttributeSet(serializeSettings, ignored, 6))
+    {
+        gxCertificateInfo* it;
+        uint16_t pos, count;
+        if ((ret = ser_saveArrayCount(serializeSettings, &object->certificates, &count)) == 0)
+        {
+            for (pos = 0; pos != object->certificates.size; ++pos)
+            {
+#ifdef DLMS_IGNORE_MALLOC
+                if ((ret = arr_getByIndex3(&object->certificates, pos, (void**)&it, sizeof(gxCertificateInfo), 0)) != 0)
+                {
+                    break;
+                }
+#else
+                if ((ret = arr_getByIndex3(&object->certificates, pos, (void**)&it, 0)) != 0)
+                {
+                    break;
+                }
+#endif //DLMS_IGNORE_MALLOC
+                if ((ret = ser_saveOctetString(serializeSettings, &it->cert)) != 0)
+                {
+                    break;
+                }
+            }
+#ifdef DLMS_IGNORE_MALLOC
+            object->certificates.size = count;
+#endif //DLMS_IGNORE_MALLOC
+        }
+    }
+    if ((ret = ser_saveOctetString(serializeSettings, &object->signingKey.rawValue)) == 0 &&
+        (ret = ser_saveOctetString(serializeSettings, &object->keyAgreementKey.rawValue)) == 0 &&
+        (ret = ser_saveOctetString(serializeSettings, &object->tlsKey.rawValue)) == 0)
+    {
+    }
+#else
+    if (!isAttributeSet(serializeSettings, ignored, 6) &&
+        ret == 0 && serializeSettings->version == 1)
+    {
+        uint16_t count;
+        ret = ser_saveArrayCount(serializeSettings, &object->certificates, &count);
+    }
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
     return ret;
 }
 #endif //DLMS_IGNORE_SECURITY_SETUP
@@ -4028,16 +4113,35 @@
         {
             for (pos = 0; pos != object->objectList.size; ++pos)
             {
-                if ((ret = oa_getByIndex(&object->objectList, pos, &obj)) != DLMS_ERROR_CODE_OK ||
-                    (ret = ser_saveUInt8(serializeSettings, obj->version)) != DLMS_ERROR_CODE_OK ||
-                    (ret = ser_saveUInt16(serializeSettings, obj->objectType)) != DLMS_ERROR_CODE_OK ||
-                    (ret = ser_set(serializeSettings, obj->logicalName, 6
+                if ((ret = oa_getByIndex(&object->objectList, pos, &obj)) != DLMS_ERROR_CODE_OK)
+                {
+                    break;
+                }
+                if (obj != NULL)
+                {
+                    if ((ret = ser_saveUInt8(serializeSettings, obj->version)) != DLMS_ERROR_CODE_OK ||
+                        (ret = ser_saveUInt16(serializeSettings, obj->objectType)) != DLMS_ERROR_CODE_OK ||
+                        (ret = ser_set(serializeSettings, obj->logicalName, 6
 #ifdef DLMS_IGNORE_MALLOC
-                        , 6
+                            , 6
 #endif //DLMS_IGNORE_MALLOC
-                    )) != 0)
+                        )) != 0)
+                    {
+                        break;
+                    }
+                }
+                else
                 {
-                    break;
+                    if ((ret = ser_saveUInt8(serializeSettings, 0)) != DLMS_ERROR_CODE_OK ||
+                        (ret = ser_saveUInt16(serializeSettings, 0)) != DLMS_ERROR_CODE_OK ||
+                        (ret = ser_set(serializeSettings, EMPTY_LN, 6
+#ifdef DLMS_IGNORE_MALLOC
+                            , 6
+#endif //DLMS_IGNORE_MALLOC
+                        )) != 0)
+                    {
+                        break;
+                    }
                 }
             }
 #ifdef DLMS_IGNORE_MALLOC
@@ -4635,6 +4739,16 @@
     return 0;
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int ser_saveLteMonitoring(
+    gxSerializerSettings* serializeSettings,
+    gxLteMonitoring* object)
+{
+    return 0;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifndef DLMS_IGNORE_SCHEDULE
 int ser_saveSchedule(
     gxSerializerSettings* serializeSettings,
@@ -4650,7 +4764,7 @@
     gxTariffPlan* object)
 {
     int ret;
-    if ((ret = bb_addString(serializeSettings, object->calendarName)) != 0 ||
+    if ((ret = ser_saveOctetString(serializeSettings, &object->calendarName) != 0) ||
         (ret = ser_saveUInt8(serializeSettings, object->enabled)) != 0 ||
         (ret = ser_saveDateTime(&object->activationTime, serializeSettings)) != 0)
     {
@@ -4662,6 +4776,7 @@
 void ser_init(gxSerializerSettings* settings)
 {
     memset(settings, 0, sizeof(gxSerializerSettings));
+    settings->version = SERIALIZATION_VERSION;
 }
 
 int ser_saveObject(
@@ -4669,6 +4784,11 @@
     gxObject* object)
 {
     int ret = 0;
+    if (ser_getIgnoredAttributes(serializeSettings, object) == 0xFFFF)
+    {
+        //If object is ignored.
+        return 0;
+    }
     switch (object->objectType)
     {
 #ifndef DLMS_IGNORE_DATA
@@ -5067,6 +5187,12 @@
         ser_saveSFSKReportingSystemList(serializeSettings, (gxSFSKReportingSystemList*)object);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ser_saveLteMonitoring(serializeSettings, (gxLteMonitoring*)object);
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = ser_saveTariffPlan(serializeSettings, (gxTariffPlan*)object);
@@ -5422,14 +5548,17 @@
                         if (pos2 < count2)
                         {
                             sa->target = NULL;
-                            if ((ret = cosem_findObjectByLN(settings, ot, ln, &sa->target)) != 0)
+                            if (ot != 0)
                             {
-                                break;
-                            }
-                            if (sa->target == NULL)
-                            {
-                                ret = DLMS_ERROR_CODE_OUTOFMEMORY;
-                                break;
+                                if ((ret = cosem_findObjectByLN(settings, ot, ln, &sa->target)) != 0)
+                                {
+                                    break;
+                                }
+                                if (sa->target == NULL)
+                                {
+                                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                                    break;
+                                }
                             }
                         }
 #else
@@ -5926,6 +6055,42 @@
             ret = ser_loadOctetString(serializeSettings, &object->clientSystemTitle);
         }
     }
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+    if (ret == 0 && !isAttributeSet(serializeSettings, ignored, 6))
+    {
+        gxCertificateInfo* it;
+        int pos, ret;
+        uint16_t count;
+        if ((ret = obj_clearCertificates(&object->certificates)) == 0 &&
+            (ret = ser_loadArray(serializeSettings, &object->certificates, &count)) == 0)
+        {
+            for (pos = 0; pos != count; ++pos)
+            {
+                if ((ret = ser_getArrayItem(&object->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0)
+                {
+                    break;
+                }
+                if ((ret = ser_loadOctetString(serializeSettings, &it->cert)) != 0)
+                {
+                    break;
+                }
+            }
+        }
+    }
+    if (ret == 0 &&
+        (ret = ser_loadOctetString(serializeSettings, &object->signingKey.rawValue)) == 0 &&
+        (ret = ser_loadOctetString(serializeSettings, &object->keyAgreementKey.rawValue)) == 0 &&
+        (ret = ser_loadOctetString(serializeSettings, &object->tlsKey.rawValue)) == 0)
+    {
+    }
+#else
+    if (ret == 0 && serializeSettings->version == 1 &&
+        !isAttributeSet(serializeSettings, ignored, 6))
+    {
+        uint16_t count;
+        ret = ser_loadArray(serializeSettings, &object->certificates, &count);
+    }
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
     return ret;
 }
 #endif //DLMS_IGNORE_SECURITY_SETUP
@@ -7636,16 +7801,16 @@
                     {
                         //If unknown object.
                         break;
-                }
+                    }
                     if ((ret = cosem_setLogicalName(it->element.target, ln)) != DLMS_ERROR_CODE_OK)
                     {
                         break;
                     }
 #endif //DLMS_IGNORE_MALLOC
+                }
             }
         }
     }
-}
     return ret;
 }
 
@@ -7927,34 +8092,37 @@
 #ifdef DLMS_IGNORE_MALLOC
                     , 6
 #endif //DLMS_IGNORE_MALLOC
-                )) != 0 ||
-                    (ret = oa_findByLN(&settings->objects, type, ln, &obj)) != 0)
+                )) != 0)
                 {
                     break;
                 }
-                if (obj == NULL)
+                if (type != DLMS_OBJECT_TYPE_NONE)
                 {
-#ifdef DLMS_IGNORE_MALLOC
-                    ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-                    break;
-#else
-                    if ((ret = cosem_createObject(type, &obj)) != DLMS_ERROR_CODE_OK)
+                    ret = oa_findByLN(&settings->objects, type, ln, &obj);
+                    if (obj == NULL)
                     {
-                        //If unknown object.
-                        if (ret == DLMS_ERROR_CODE_INVALID_PARAMETER)
+    #ifdef DLMS_IGNORE_MALLOC
+                        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+                        break;
+    #else
+                        if ((ret = cosem_createObject(type, &obj)) != DLMS_ERROR_CODE_OK)
                         {
-                            ret = 0;
-                            continue;
+                            //If unknown object.
+                            if (ret == DLMS_ERROR_CODE_INVALID_PARAMETER)
+                            {
+                                ret = 0;
+                                continue;
+                            }
+                            break;
                         }
-                        break;
-                    }
-                    if ((ret = cosem_setLogicalName(obj, ln)) != DLMS_ERROR_CODE_OK)
-                    {
-                        break;
+                        if ((ret = cosem_setLogicalName(obj, ln)) != DLMS_ERROR_CODE_OK)
+                        {
+                            break;
+                        }
+                        obj->version = version;
+                        oa_push(&object->objectList, obj);
+    #endif //DLMS_IGNORE_MALLOC
                     }
-                    obj->version = version;
-                    oa_push(&object->objectList, obj);
-#endif //DLMS_IGNORE_MALLOC
                 }
             }
         }
@@ -8035,16 +8203,16 @@
                         (ret = ser_loadOctetString(serializeSettings, value)) != 0)
                     {
                         break;
-                }
+                    }
                     if ((ret = arr_push(&object->userList, key_init2(id, value))) != 0)
                     {
                         break;
                     }
 #endif //DLMS_IGNORE_MALLOC
+                }
             }
         }
     }
-}
     return ret;
 }
 #endif //DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
@@ -8082,9 +8250,9 @@
                 if ((ret = ser_loadUInt16(serializeSettings, &shortName)) != 0 ||
                     (ret = ser_loadUInt8(serializeSettings, &version)) != 0 ||
                     (ret = ser_loadUInt16(serializeSettings, &value)) != 0)
-            {
-                break;
-            }
+                {
+                    break;
+                }
 #ifndef DLMS_IGNORE_MALLOC
                 type = value;
 #endif //DLMS_IGNORE_MALLOC
@@ -8126,18 +8294,18 @@
                         return ret;
                 }
 #endif //DLMS_IGNORE_MALLOC
-            }
+                }
 #ifndef DLMS_IGNORE_MALLOC
                 oa_push(&object->objectList, obj);
 #endif //DLMS_IGNORE_MALLOC
                 // obj->version = (unsigned char)version;
-        }
-    }
+                }
+            }
         if (ret != 0)
         {
             return ret;
         }
-}
+        }
     if (ret == 0 && !isAttributeSet(serializeSettings, ignored, 9))
     {
 #ifndef DLMS_IGNORE_SECURITY_SETUP
@@ -8189,18 +8357,18 @@
                         (ret = ser_loadOctetString(serializeSettings, value)) != 0)
                     {
                         break;
-                }
+                    }
                     if ((ret = arr_push(&object->userList, key_init2(id, value))) != 0)
                     {
                         break;
                     }
 #endif //DLMS_IGNORE_MALLOC
+                }
             }
         }
     }
-    }
     return ret;
-}
+    }
 
 #endif //DLMS_IGNORE_ASSOCIATION_SHORT_NAME
 #ifndef DLMS_IGNORE_PPP_SETUP
@@ -8725,6 +8893,15 @@
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int ser_loadLteMonitoring(
+    gxSerializerSettings * serializeSettings,
+    gxLteMonitoring * object)
+{
+    return 0;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifndef DLMS_IGNORE_SCHEDULE
 int ser_loadSchedule(
     gxSerializerSettings * serializeSettings,
@@ -8740,11 +8917,11 @@
     gxTariffPlan * object)
 {
     int ret;
-    if ((ret = bb_addString(serializeSettings, object->calendarName)) != 0 ||
-        (ret = ser_loadUInt8(serializeSettings, object->enabled)) != 0 ||
+    if ((ret = ser_loadOctetString(serializeSettings, &object->calendarName) != 0) ||
+        (ret = ser_loadUInt8(serializeSettings, &object->enabled)) != 0 ||
         (ret = ser_loadDateTime(&object->activationTime, serializeSettings, DLMS_DATA_TYPE_DATETIME)) != 0)
-{
-}
+    {
+    }
     return ret;
 }
 #endif //DLMS_ITALIAN_STANDARD
@@ -8755,6 +8932,11 @@
     gxObject * object)
 {
     int ret = 0;
+    if (ser_getIgnoredAttributes(serializeSettings, object) == 0xFFFF)
+    {
+        //If object is ignored.
+        return 0;
+    }
     switch (object->objectType)
     {
 #ifndef DLMS_IGNORE_DATA
@@ -9152,6 +9334,11 @@
         ser_loadSFSKReportingSystemList(serializeSettings, (gxSFSKReportingSystemList*)object);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ser_loadLteMonitoring(serializeSettings, (gxLteMonitoring*)object);
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = ser_loadTariffPlan(serializeSettings, (gxTariffPlan*)object);
@@ -9166,22 +9353,20 @@
 int ser_getDataSize(gxSerializerSettings * serializeSettings, void* size)
 {
     int ret;
-    //Serializer version number.
-    unsigned char version;
 #if !(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
     ResetPosition(serializeSettings);
 #endif //!(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
-    if ((ret = ser_loadUInt8(serializeSettings, &version)) == 0)
+    if ((ret = ser_loadUInt8(serializeSettings, &serializeSettings->version)) == 0)
     {
-        if (version == 0 || version > SERIALIZATION_VERSION)
+        if (serializeSettings->version == 0 || serializeSettings->version > SERIALIZATION_VERSION)
         {
 #ifdef DLMS_DEBUG
             svr_notifyTrace(GET_STR_FROM_EEPROM("ser_loadObject failed. Invalid version,"), version);
 #endif //DLMS_DEBUG
             return DLMS_ERROR_CODE_INVALID_PARAMETER;
-        }
-        ret = ser_loadUInt32(serializeSettings, size);
     }
+        ret = ser_loadUInt32(serializeSettings, size);
+}
     return ret;
 }
 
@@ -9204,7 +9389,7 @@
             if (ser_isEof(serializeSettings))
             {
                 break;
-            }
+            }           
 #ifdef DLMS_DEBUG
             svr_notifyTrace(GET_STR_FROM_EEPROM("ser_loadObject"), pos);
 #endif //DLMS_DEBUG
@@ -9220,7 +9405,7 @@
                 }
                 break;
             }
-            }
+        }
 #if !(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
         if (ret == 0 && serializeSettings->position - 5 != size)
         {
@@ -9262,14 +9447,14 @@
 #endif //DLMS_DEBUG
                 break;
             }
-    }
+        }
 #if !(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
         if (serializeSettings->position - 5 != size)
         {
             return DLMS_ERROR_CODE_OUTOFMEMORY;
         }
 #endif //!(!defined(GX_DLMS_SERIALIZER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
-}
+    }
     return ret;
 }
 #endif //DLMS_IGNORE_SERIALIZER
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxset.c src/development/src/gxset.c
--- upstream/development/src/gxset.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxset.c	2024-11-13 12:20:09.000000000 +0000
@@ -459,6 +459,11 @@
         ret = cosem_setSFSKReportingSystemList(settings, (gxSFSKReportingSystemList*)e->target, e->index, &e->value);
         break;
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
+#ifndef DLMS_IGNORE_LTE_MONITORING
+    case DLMS_OBJECT_TYPE_LTE_MONITORING:
+        ret = cosem_setLteMonitoring(settings, (gxLteMonitoring*)e->target, e->index, &e->value);
+        break;
+#endif //DLMS_IGNORE_LTE_MONITORING
 #ifdef DLMS_ITALIAN_STANDARD
     case DLMS_OBJECT_TYPE_TARIFF_PLAN:
         ret = cosem_setTariffPlan((gxTariffPlan*)e->target, e->index, &e->value);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsetignoremalloc.c src/development/src/gxsetignoremalloc.c
--- upstream/development/src/gxsetignoremalloc.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsetignoremalloc.c	2024-11-13 12:20:09.000000000 +0000
@@ -671,10 +671,16 @@
         BYTE_BUFFER_INIT(&object->access->attributeAccessModes);
         BYTE_BUFFER_INIT(&object->access->methodAccessModes);
         cnt = obj_methodCount(object);
-        bb_capacity(&object->access->methodAccessModes, cnt);
+        if ((ret = bb_capacity(&object->access->methodAccessModes, cnt)) != 0)
+        {
+            return ret;
+        }
         object->access->methodAccessModes.size = object->access->methodAccessModes.capacity;
         cnt = obj_attributeCount(object);
-        bb_capacity(&object->access->attributeAccessModes, cnt);
+        if ((ret = bb_capacity(&object->access->attributeAccessModes, cnt)) != 0)
+        {
+            return ret;
+        }
         object->access->attributeAccessModes.size = object->access->attributeAccessModes.capacity;
 #else
         return DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -1531,8 +1537,7 @@
 int cosem_setSecuritySetup(dlmsSettings* settings, gxSecuritySetup* object, unsigned char index, dlmsVARIANT* value)
 {
     unsigned char ch;
-    int pos, ret;
-    gxCertificateInfo* it = NULL;
+    int ret;
     switch (index)
     {
     case 2:
@@ -1558,6 +1563,9 @@
         uint16_t count;
         if ((ret = cosem_verifyArray(value->byteArr, &object->certificates, &count)) == 0)
         {
+#ifdef DLMS_IGNORE_SERVER
+            int pos;
+            gxCertificateInfo* it = NULL;
             for (pos = 0; pos != count; ++pos)
             {
                 if ((ret = cosem_getArrayItem(&object->certificates, pos, (void**)&it, sizeof(gxCertificateInfo))) != 0 ||
@@ -1572,6 +1580,8 @@
                     break;
                 }
             }
+#else          
+#endif //DLMS_IGNORE_SERVER
         }
         break;
     default:
@@ -2034,7 +2044,8 @@
             object->controlState = (DLMS_CONTROL_STATE)value->bVal;
             ret = 0;
         }
-        else if (value->vt == DLMS_DATA_TYPE_OCTET_STRING)
+        else if ((value->vt == DLMS_DATA_TYPE_OCTET_STRING) ||
+            (value->vt == (DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_OCTET_STRING)))
         {
             if ((ret = cosem_getEnum(value->byteArr, &ch)) == 0)
             {
@@ -2053,6 +2064,14 @@
             object->controlMode = (DLMS_CONTROL_MODE)value->bVal;
             ret = 0;
         }
+        else if ((value->vt == DLMS_DATA_TYPE_OCTET_STRING) ||
+            (value->vt == (DLMS_DATA_TYPE_BYREF | DLMS_DATA_TYPE_OCTET_STRING)))
+        {
+            if ((ret = cosem_getEnum(value->byteArr, &ch)) == 0)
+            {
+                object->controlMode = (DLMS_CONTROL_MODE)ch;
+            }
+        }
         else
         {
             ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
@@ -2085,15 +2104,15 @@
     }
     else if (index == 3)
     {
-        ret = cosem_getVariant(value->byteArr, &object->thresholdActive);
+        ret = cosem_getVariantExact(value->byteArr, &object->thresholdActive);
     }
     else if (index == 4)
     {
-        ret = cosem_getVariant(value->byteArr, &object->thresholdNormal);
+        ret = cosem_getVariantExact(value->byteArr, &object->thresholdNormal);
     }
     else if (index == 5)
     {
-        ret = cosem_getVariant(value->byteArr, &object->thresholdEmergency);
+        ret = cosem_getVariantExact(value->byteArr, &object->thresholdEmergency);
     }
     else if (index == 6)
     {
@@ -2121,7 +2140,7 @@
             for (pos = 0; pos != count; ++pos)
             {
                 if ((ret = cosem_getArrayItem(&object->emergencyProfileGroupIDs, pos, (void**)&it, sizeof(uint16_t))) != 0 ||
-                    (ret = bb_getUInt16(value->byteArr, it)) != 0)
+                    (ret = cosem_getUInt16(value->byteArr, it)) != 0)
                 {
                     break;
                 }
@@ -3710,6 +3729,7 @@
 int cosem_setPushSetup(dlmsSettings* settings, gxPushSetup* object, unsigned char index, dlmsVARIANT* value)
 {
     int ret, pos;
+    unsigned char e1, e2;
     gxTarget* it;
     if (index == 2)
     {
@@ -3797,7 +3817,103 @@
     }
     else if (index == 7)
     {
-        ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay);
+        if (object->base.version < 2)
+        {
+            ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay);
+        }
+        else
+        {
+            if ((ret = cosem_checkStructure(value->byteArr, 3)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.min)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.exponent)) != 0 ||
+                (ret = cosem_getUInt16(value->byteArr, &object->repetitionDelay2.max)) != 0)
+            {
+            }
+        }
+    }
+    else if (index == 8)
+    {
+        ret = cosem_getOctetString2(value->byteArr, object->portReference, 6, NULL);
+    }
+    else if (index == 9)
+    {
+        ret = cosem_getInt8(value->byteArr, &object->pushClientSAP);
+    }
+    else if (index == 10)
+    {
+        gxPushProtectionParameters* it;
+        arr_clear(&object->pushProtectionParameters);
+        uint16_t count;
+        if ((ret = cosem_verifyArray(value->byteArr, &object->pushProtectionParameters, &count)) == 0) {
+            for (pos = 0; pos != count; ++pos)
+            {
+                if ((ret = cosem_getArrayItem(&object->pushProtectionParameters, pos,
+                    (void**)&it, sizeof(gxPushProtectionParameters))) == 0)
+                {
+                    if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                        (ret = cosem_getEnum(value->byteArr, &e1)) != 0 ||
+                        (ret = cosem_checkStructure(value->byteArr, 5)) != 0 ||
+                        (ret = cosem_getOctetString(value->byteArr, &it->transactionId)) != 0 ||
+                        (ret = cosem_getOctetString2(value->byteArr, it->originatorSystemTitle, 6, NULL)) != 0 ||
+                        (ret = cosem_getOctetString2(value->byteArr, it->recipientSystemTitle, 6, NULL)) != 0 ||
+                        (ret = cosem_getOctetString(value->byteArr, &it->otherInformation)) != 0 ||
+                        (ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                        (ret = cosem_getEnum(value->byteArr, &e2)) != 0)
+                    {
+                        break;
+                    }
+                    it->protectionType = (DLMS_PROTECTION_TYPE)e1;
+                    it->keyInfo.dataProtectionKeyType = (DLMS_DATA_PROTECTION_KEY_TYPE)e2;
+                    if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 1)) != 0 ||
+                            (ret = cosem_getEnum(value->byteArr, &e1)) != 0)
+                        {
+                            break;
+                        }
+                        it->keyInfo.identifiedKey.keyType = (DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE)e1;
+                    }
+                    else if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 1)) != 0 ||
+                            (ret = cosem_getEnum(value->byteArr, &e1)) != 0)
+                        {
+                            break;
+                        }
+                        it->keyInfo.wrappedKey.keyType = (DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE)e1;
+                    }
+                    else if (it->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+                    {
+                        if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+                            (ret = cosem_getOctetString(value->byteArr, &it->keyInfo.agreedKey.parameters)) != 0 ||
+                            (ret = cosem_getOctetString(value->byteArr, &it->keyInfo.agreedKey.data)) != 0)
+                        {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else if (index == 11)
+    {
+        ret = cosem_getEnum(value->byteArr, &e1);
+        if (ret == 0)
+        {
+            object->pushOperationMethod = (DLMS_PUSH_OPERATION_METHOD)e1;
+        }
+    }
+    else if (index == 12)
+    {
+        if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+            (ret = cosem_getDateTime(value->byteArr, &object->confirmationParameters.startDate)) != 0 ||
+            (ret = cosem_getUInt32(value->byteArr, &object->confirmationParameters.interval)) != 0)
+        {
+        }
+    }
+    else if (index == 13)
+    {
+        ret = cosem_getDateTime(value->byteArr, &object->lastConfirmationDateTime);
     }
     else
     {
@@ -4462,9 +4578,176 @@
 
 #ifndef DLMS_IGNORE_COMPACT_DATA
 
-int compactData_updateTemplateDescription(
+int compactData_updateTemplateArrayOrStructDescription(
+    gxCompactData* object,
+    unsigned char ch,
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    gxTarget* kv,
+#else
+    gxKey* kv,
+#endif //DLMS_IGNORE_MALLOC
+    gxByteBuffer* byteArr,
+    unsigned char isTemplate)
+{
+    int ret;
+    gxDataInfo info;
+    dlmsVARIANT value;
+    uint16_t count, count2, pos;
+    di_init(&info);
+    var_init(&value);
+    if ((ret = hlp_getObjectCount2(byteArr, &count)) != 0 ||
+        kv->dataIndex > count)
+    {
+        return DLMS_ERROR_CODE_FALSE;
+    }
+    //If all data is captured.
+    if (kv->dataIndex == 0)
+    {
+
+        if (isTemplate)
+        {
+            if ((ret = bb_setUInt8(&object->templateDescription, ch)) != 0)
+            {
+                return ret;
+            }
+            if (ch == DLMS_DATA_TYPE_ARRAY)
+            {
+                if ((ret = bb_setUInt16(&object->templateDescription, count)) != 0)
+                {
+                    return ret;
+                }
+            }
+            else
+            {
+                if ((ret = bb_setUInt8(&object->templateDescription, (unsigned char)count)) != 0)
+                {
+                    return ret;
+                }
+            }
+        }
+        for (pos = 0; pos < count; ++pos)
+        {
+            di_init(&info);
+            var_clear(&value);
+#if defined(GX_DLMS_BYTE_BUFFER_SIZE_32) || (!defined(GX_DLMS_MICROCONTROLLER) && (defined(_WIN32) || defined(_WIN64) || defined(__linux__)))
+            uint32_t position = 1 + byteArr->position;
+#else
+            uint16_t position = 1 + byteArr->position;
+#endif
+            if ((ret = dlms_getData(byteArr, &info, &value)) != 0)
+            {
+                break;
+            }
+            if (info.type == DLMS_DATA_TYPE_STRUCTURE || info.type == DLMS_DATA_TYPE_ARRAY)
+            {
+                if ((ret = bb_getUInt8(byteArr, &ch)) != 0 ||
+                    (ret = compactData_updateTemplateArrayOrStructDescription(
+                        object, ch, kv, byteArr, isTemplate)) != 0)
+                {
+                    break;
+                }
+            }
+            else
+            {
+                if (isTemplate)
+                {
+                    if ((ret = bb_setUInt8(&object->templateDescription, info.type)) != 0)
+                    {
+                        break;
+                    }
+                }
+                if (info.type == DLMS_DATA_TYPE_OCTET_STRING ||
+                    info.type == DLMS_DATA_TYPE_STRING ||
+                    info.type == DLMS_DATA_TYPE_BIT_STRING)
+                {
+                    ++byteArr->position;
+                    if ((ret = hlp_getObjectCount2(byteArr, &count2)) != 0)
+                    {
+                        break;
+                    }
+                    if (!isTemplate)
+                    {
+                        //Add length.
+                        ret = hlp_setObjectCount(count2, &object->buffer);
+                    }
+                    if (info.type == DLMS_DATA_TYPE_BIT_STRING)
+                    {
+                        count2 = ba_getByteCount(count2);
+                    }
+                    if (!isTemplate)
+                    {
+                        ret = bb_set(&object->buffer, byteArr->data + position, count2);
+                    }
+                    byteArr->position += count2;
+                }
+                else if (info.type == DLMS_DATA_TYPE_DATETIME ||
+                    info.type == DLMS_DATA_TYPE_TIME ||
+                    info.type == DLMS_DATA_TYPE_DATE)
+                {
+                    ++byteArr->position;
+                    if (!isTemplate)
+                    {
+                        ret = bb_set(&object->buffer, byteArr->data + byteArr->position, var_getSize(value.vt));
+                    }
+                    byteArr->position += var_getSize(value.vt);
+                }
+                else if (!isTemplate)
+                {
+                    ret = bb_set(&object->buffer, byteArr->data + position, var_getSize(value.vt));
+                }
+                if (ret != 0)
+                {
+                    break;
+                }
+            }
+        }
+    }
+    else
+    {
+        for (unsigned char pos = 0; pos < kv->dataIndex; ++pos)
+        {
+            var_clear(&value);
+            di_init(&info);
+            if ((ret = dlms_getData(byteArr, &info, &value)) != 0)
+            {
+                var_clear(&value);
+                bb_clear(&object->buffer);
+                return ret;
+            }
+            if (!info.complete)
+            {
+                return DLMS_ERROR_CODE_READ_WRITE_DENIED;
+            }
+        }
+        if (info.type == DLMS_DATA_TYPE_STRUCTURE)
+        {
+            dlmsVARIANT* value2;
+            bb_setUInt8(&object->templateDescription, DLMS_DATA_TYPE_STRUCTURE);
+            bb_setUInt8(&object->templateDescription, (unsigned char)value.Arr->size);
+            for (uint16_t pos = 0; pos < value.Arr->size; ++pos)
+            {
+                if ((ret = va_getByIndex(value.Arr, pos, &value2)) != 0 ||
+                    (ret = bb_setUInt8(&object->templateDescription, value2->vt)) != 0)
+                {
+                    var_clear(&value);
+                    bb_clear(&object->buffer);
+                    return ret;
+                }
+            }
+        }
+        else
+        {
+            bb_setUInt8(&object->templateDescription, info.type);
+        }
+    }
+    var_clear(&value);
+    return ret;
+}
+
+int compactData_update(
     dlmsSettings* settings,
-    gxCompactData* object)
+    gxCompactData* object,
+    unsigned char isTemplate)
 {
     int ret, pos;
     gxByteBuffer tmp;
@@ -4476,26 +4759,40 @@
 #else
     gxKey* kv;
 #endif //DLMS_IGNORE_MALLOC
-    unsigned char tmp2[100];
+#ifndef GX_DLMS_MICROCONTROLLER
+    static unsigned char tmp3[100];
+    static unsigned char tmp2[200];
+#else
+    unsigned char tmp3[100];
+    unsigned char tmp2[200];
+#endif //GX_DLMS_MICROCONTROLLER
     gxByteBuffer bb;
     bb_attach(&bb, tmp2, 0, sizeof(tmp2));
+    if (isTemplate)
+    {
+        bb_clear(&object->templateDescription);
+    }
     bb_clear(&object->buffer);
-    bb_clear(&object->templateDescription);
     e.action = 1;
     e.target = &object->base;
     e.index = 2;
     vec_init(&args);
-    BYTE_BUFFER_INIT(&tmp);
-    unsigned char tmp3[100];
     bb_attach(&tmp, tmp3, 0, sizeof(tmp3));
     if (!e.handled)
     {
-        if ((ret = bb_setUInt8(&object->templateDescription, DLMS_DATA_TYPE_STRUCTURE)) != DLMS_ERROR_CODE_OK)
+        if (isTemplate)
         {
-            bb_clear(&object->buffer);
-            return ret;
+            if ((ret = bb_setUInt8(&object->templateDescription, DLMS_DATA_TYPE_STRUCTURE)) != DLMS_ERROR_CODE_OK)
+            {
+                bb_clear(&object->buffer);
+                return ret;
+            }
+            if ((ret = hlp_setObjectCount(object->captureObjects.size, &object->templateDescription)) != 0)
+            {
+                bb_clear(&object->buffer);
+                return ret;
+            }
         }
-        hlp_setObjectCount(object->captureObjects.size, &object->templateDescription);
         for (pos = 0; pos != object->captureObjects.size; ++pos)
         {
 #ifdef DLMS_IGNORE_MALLOC
@@ -4509,6 +4806,7 @@
                 break;
             }
 #endif //DLMS_IGNORE_MALLOC
+            bb_clear(&bb);
             e.value.byteArr = &bb;
             e.value.vt = DLMS_DATA_TYPE_OCTET_STRING;
             e.target = kv->target;
@@ -4533,123 +4831,24 @@
                     if (ch == DLMS_DATA_TYPE_ARRAY ||
                         ch == DLMS_DATA_TYPE_STRUCTURE)
                     {
-                        gxDataInfo info;
-                        dlmsVARIANT value;
-                        uint16_t count;
-                        di_init(&info);
-                        var_init(&value);
-                        if ((ret = hlp_getObjectCount2(e.value.byteArr, &count)) != 0 ||
-                            kv->dataIndex > count)
+                        if ((ret = compactData_updateTemplateArrayOrStructDescription(object,
+                            ch, kv, e.value.byteArr, isTemplate)) != 0)
                         {
-                            break;
+                            var_clear(&e.value);
+                            return ret;
                         }
-                        //If all data is captured.
-                        if (kv->dataIndex == 0)
+                    }
+                    else
+                    {
+                        if (isTemplate)
                         {
-                            uint16_t count2;
-                            if ((ret = bb_setUInt8(&object->templateDescription, ch)) != 0)
-                            {
-                                break;
-                            }
-                            if (ch == DLMS_DATA_TYPE_ARRAY)
-                            {
-                                if ((ret = bb_setUInt16(&object->templateDescription, count)) != 0)
-                                {
-                                    break;
-                                }
-                            }
-                            else
-                            {
-                                if ((ret = bb_setUInt8(&object->templateDescription, (unsigned char)count)) != 0)
-                                {
-                                    break;
-                                }
-                            }
-                            for (unsigned char pos = 0; pos < count; ++pos)
-                            {
-                                di_init(&info);
-                                var_clear(&value);
-                                if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
-                                {
-                                    break;
-                                }
-                                if (info.type == DLMS_DATA_TYPE_STRUCTURE || info.type == DLMS_DATA_TYPE_ARRAY)
-                                {
-                                    bb_setUInt8(&object->templateDescription, info.type);
-                                    ++value.byteArr->position;
-                                    if ((ret = hlp_getObjectCount2(value.byteArr, &count2)) != 0 ||
-                                        (ret = hlp_setObjectCount(count2, &object->templateDescription)) != 0)
-                                    {
-                                        break;
-                                    }
-                                    for (uint16_t pos = 0; pos < count2; ++pos)
-                                    {
-                                        var_clear(&value);
-                                        if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0 ||
-                                            (ret = bb_setUInt8(&object->templateDescription, value.vt)) != 0)
-                                        {
-                                            var_clear(&value);
-                                            var_clear(&e.value);
-                                            bb_clear(&object->buffer);
-                                            return ret;
-                                        }
-                                    }
-                                }
-                                else
-                                {
-                                    bb_setUInt8(&object->templateDescription, info.type);
-                                }
-                                if (e.value.byteArr->data[0] == DLMS_DATA_TYPE_ARRAY)
-                                {
-                                    break;
-                                }
-                            }
+                            ret = bb_setUInt8(&object->templateDescription, ch);
                         }
-                        else
+                        else if (e.value.byteArr->size != 1)
                         {
-                            for (unsigned char pos = 0; pos < kv->dataIndex; ++pos)
-                            {
-                                var_clear(&value);
-                                di_init(&info);
-                                if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
-                                {
-                                    var_clear(&value);
-                                    var_clear(&e.value);
-                                    bb_clear(&object->buffer);
-                                    return ret;
-                                }
-                                if (!info.complete)
-                                {
-                                    return DLMS_ERROR_CODE_READ_WRITE_DENIED;
-                                }
-                            }
-                            if (info.type == DLMS_DATA_TYPE_STRUCTURE)
-                            {
-                                dlmsVARIANT* value2;
-                                bb_setUInt8(&object->templateDescription, DLMS_DATA_TYPE_STRUCTURE);
-                                bb_setUInt8(&object->templateDescription, (unsigned char)value.Arr->size);
-                                for (uint16_t pos = 0; pos < value.Arr->size; ++pos)
-                                {
-                                    if ((ret = va_getByIndex(value.Arr, pos, &value2)) != 0)
-                                    {
-                                        var_clear(&value);
-                                        var_clear(&e.value);
-                                        bb_clear(&object->buffer);
-                                        return ret;
-                                    }
-                                    bb_setUInt8(&object->templateDescription, value2->vt);
-                                }
-                            }
-                            else
-                            {
-                                bb_setUInt8(&object->templateDescription, info.type);
-                            }
+                            //Add data.
+                            ret = bb_set(&object->buffer, e.value.byteArr->data + 1, e.value.byteArr->size - 1);
                         }
-                        var_clear(&value);
-                    }
-                    else
-                    {
-                        bb_setUInt8(&object->templateDescription, ch);
                     }
                 }
             }
@@ -4662,7 +4861,15 @@
                     bb_clear(&object->buffer);
                     return ret;
                 }
-                bb_setUInt8(&object->templateDescription, tmp.data[0]);
+                if (isTemplate)
+                {
+                    ret = bb_setUInt8(&object->templateDescription, tmp.data[0]);
+                }
+                else if (tmp.size != 1)
+                {
+                    //Add data.
+                    ret = bb_set(&object->buffer, tmp.data + 1, tmp.size - 1);
+                }
                 bb_clear(&tmp);
             }
             var_clear(&e.value);
@@ -4673,6 +4880,13 @@
     //svr_postGet(settings, &args);
     vec_empty(&args);
     return 0;
+    }
+
+int compactData_updateTemplateDescription(
+    dlmsSettings* settings,
+    gxCompactData* object)
+{
+    return compactData_update(settings, object, 1);
 }
 
 int cosem_setCompactData(
@@ -4746,7 +4960,7 @@
             object->changedParameter.type = type;
             memcpy(object->changedParameter.logicalName, ln, 6);
 #endif //DLMS_IGNORE_OBJECT_POINTERS
-        }
+    }
         break;
     }
     case 3:
@@ -4784,12 +4998,12 @@
                 if ((ret = cosem_findObjectByLN(settings, type, ln, &it->target)) != 0)
                 {
                     break;
-                }
-#endif //DLMS_IGNORE_OBJECT_POINTERS
             }
+#endif //DLMS_IGNORE_OBJECT_POINTERS
         }
+}
         break;
-    }
+}
     default:
         ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
         break;
@@ -5271,7 +5485,7 @@
         break;
     }
     return ret;
-    }
+}
 #endif //DLMS_IGNORE_ARBITRATOR
 #ifndef DLMS_IGNORE_IEC_8802_LLC_TYPE1_SETUP
 int cosem_setIec8802LlcType1Setup(
@@ -5633,6 +5847,51 @@
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int cosem_setLteMonitoring(
+    dlmsSettings* settings,
+    gxLteMonitoring* object,
+    unsigned char index,
+    dlmsVARIANT* value)
+{
+    int ret;
+    unsigned char ch;
+    if (index == 2)
+    {
+        if ((ret = cosem_checkStructure(value->byteArr, 9)) == 0 &&
+            (ret = cosem_getUInt16(value->byteArr, &object->networkParameters.t3402)) == 0 &&
+            (ret = cosem_getUInt16(value->byteArr, &object->networkParameters.t3412)) == 0 &&
+            (ret = cosem_getUInt32(value->byteArr, &object->networkParameters.t3412ext2)) == 0 &&
+            (ret = cosem_getUInt16(value->byteArr, &object->networkParameters.t3324)) == 0 &&
+            (ret = cosem_getUInt32(value->byteArr, &object->networkParameters.teDRX)) == 0 &&
+            (ret = cosem_getUInt16(value->byteArr, &object->networkParameters.tPTW)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->networkParameters.qRxlevMin)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->networkParameters.qRxlevMinCE)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->networkParameters.qRxLevMinCE1)) == 0)
+        {
+
+        }
+    }
+    else if (index == 3)
+    {
+        if ((ret = cosem_checkStructure(value->byteArr, 4)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->qualityOfService.signalQuality)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->qualityOfService.signalLevel)) == 0 &&
+            (ret = cosem_getInt8(value->byteArr, &object->qualityOfService.signalToNoiseRatio)) == 0 &&
+            (ret = cosem_getEnum(value->byteArr, &ch)) == 0)
+        {
+            object->qualityOfService.coverageEnhancement = (DLMS_LTE_COVERAGE_ENHANCEMENT)ch;
+        }
+    }
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return ret;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
+
+
 #ifdef DLMS_ITALIAN_STANDARD
 int updateIntervals(gxInterval* interval, gxByteBuffer* value)
 {
@@ -5709,118 +5968,111 @@
     return ret;
 }
 
+int cosem_setIntervals(gxByteBuffer* byteArr, gxInterval* interval)
+{
+    int ret;
+    uint16_t pos, count;
+    unsigned char ch;
+    if ((ret = cosem_checkArray(byteArr, &count)) == 0)
+    {
+        for (pos = 0; pos != count; ++pos)
+        {
+            if ((ret = cosem_getUInt8(byteArr, &ch)) != 0)
+            {
+                break;
+            }
+            interval->useInterval = (ch & 0x1) != 0;
+            interval->startHour = (unsigned char)(ch >> 3);
+            interval->intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((ch >> 1) & 0x3);
+            ++interval;
+        }
+    }
+    return ret;
+}
+
+int cosem_setSeason(gxByteBuffer* byteArr, gxBandDescriptor* season)
+{
+    int ret;
+    if ((ret = cosem_checkStructure(byteArr, 5)) == 0 &&
+        (ret = cosem_getUInt8(byteArr, &season->dayOfMonth)) == 0 &&
+        (ret = cosem_getUInt8(byteArr, &season->month)) == 0 &&
+        (ret = cosem_setIntervals(byteArr, season->workingDayIntervals)) == 0 &&
+        (ret = cosem_setIntervals(byteArr, season->saturdayIntervals)) == 0 &&
+        (ret = cosem_setIntervals(byteArr, season->holidayIntervals)) == 0)
+    {
+    }
+    return ret;
+}
+
 int cosem_setTariffPlan(gxTariffPlan* object, unsigned char index, dlmsVARIANT* value)
 {
-    dlmsVARIANT tmp3;
-    dlmsVARIANT* tmp, * tmp2;
-    int ret, pos, h, m, s;
+    unsigned char h, m, s;
+    int ret;
+    uint16_t pos;
     switch (index)
     {
     case 2:
-        if (value->vt == DLMS_DATA_TYPE_OCTET_STRING)
-        {
-            object->calendarName = (char*)gxmalloc(value->byteArr->size);
-            memcpy(object->calendarName, value->byteArr->data, value->byteArr->size);
-            object->calendarName[value->byteArr->size] = 0;
-        }
-        else
-        {
-            object->calendarName = (char*)gxmalloc(value->strVal->size + 1);
-            memcpy(object->calendarName, value->strVal->data, value->strVal->size);
-            object->calendarName[value->strVal->size] = 0;
-        }
+        ret = cosem_getOctetString(value->byteArr, &object->calendarName);
         break;
     case 3:
-        object->enabled = value->boolVal;
+        ret = cosem_getBoolean(value->byteArr, &object->enabled);
         break;
     case 4:
     {
-        if (value->Arr->size == 4)
+        uint16_t count;
+        if ((ret = cosem_checkStructure(value->byteArr, 4)) == 0 &&
+            (ret = cosem_getUInt8(value->byteArr, &object->plan.defaultTariffBand)) == 0 &&
+            (ret = cosem_checkArray(value->byteArr, &count)) == 0 &&
+            (ret = cosem_setSeason(value->byteArr, &object->plan.winterSeason)) == 0 &&
+            (ret = cosem_setSeason(value->byteArr, &object->plan.summerSeason)) == 0 &&
+            (ret = cosem_getBitString(value->byteArr, &object->plan.weeklyActivation)) == 0 &&
+            (ret = cosem_verifyArray(value->byteArr, &object->plan.specialDays, &count)) == 0)
         {
-            if ((ret = va_getByIndex(value->Arr, 0, &tmp)) != 0)
-            {
-                return ret;
-            }
-            object->plan.defaultTariffBand = tmp->bVal;
-            if ((ret = va_getByIndex(value->Arr, 1, &tmp)) != 0)
-            {
-                return ret;
-            }
-            if ((ret = va_getByIndex(tmp->Arr, 0, &tmp2)) != 0 ||
-                (ret = updateSeason(&object->plan.winterSeason, tmp2->Arr)) != 0 ||
-                (ret = va_getByIndex(tmp->Arr, 1, &tmp2)) != 0 ||
-                (ret = updateSeason(&object->plan.summerSeason, tmp2->Arr)) != 0)
-            {
-                return ret;
-            }
-            ba_clear(&object->plan.weeklyActivation);
-            if ((ret = va_getByIndex(value->Arr, 2, &tmp)) != 0 ||
-                (ret = ba_copy(&object->plan.weeklyActivation, tmp->bitArr->data, tmp->bitArr->size)) != 0)
-            {
-                return ret;
-            }
-            if ((ret = va_getByIndex(value->Arr, 3, &tmp)) != 0)
-            {
-                return ret;
-            }
-            arr_clear(&object->plan.specialDays);
-            arr_capacity(&object->plan.specialDays, tmp->Arr->size);
-            for (pos = 0; pos != tmp->Arr->size; ++pos)
+            uint16_t* it;
+            for (pos = 0; pos != count; ++pos)
             {
-                if ((ret = va_getByIndex(tmp->Arr, pos, &tmp2)) != 0)
+                if ((ret = cosem_getArrayItem(&object->plan.specialDays, pos, (void**)&it, sizeof(uint16_t))) != 0 ||
+                    (ret = cosem_getUInt16(value->byteArr, it)) != 0)
                 {
-                    return ret;
+                    break;
                 }
-                arr_push(&object->plan.specialDays, (void*)tmp2->ulVal);
             }
         }
         break;
     }
     case 5:
     {
-        if ((ret = va_getByIndex(value->Arr, 0, &tmp)) != 0)
-        {
-            return ret;
-        }
-        var_init(&tmp3);
-        if ((ret = dlms_changeType2(tmp, DLMS_DATA_TYPE_TIME, &tmp3)) != 0)
+        gxtime tmp;
+        if ((ret = cosem_checkStructure(value->byteArr, 2)) != 0 ||
+            (ret = cosem_getTimeFromOctetString(value->byteArr, &tmp)) != 0 ||
+            (ret = cosem_getDateFromOctetString(value->byteArr, &object->activationTime)) != 0)
         {
-            return ret;
+            break;
         }
-        if ((tmp3.dateTime->skip & DATETIME_SKIPS_HOUR) == 0)
+        if ((tmp.skip & DATETIME_SKIPS_HOUR) == 0)
         {
-            h = time_getHours(tmp3.dateTime);
+            h = time_getHours(&tmp);
         }
         else
         {
             h = 0;
         }
-        if ((tmp3.dateTime->skip & DATETIME_SKIPS_MINUTE) == 0)
+        if ((tmp.skip & DATETIME_SKIPS_MINUTE) == 0)
         {
-            m = time_getMinutes(tmp3.dateTime);
+            m = time_getMinutes(&tmp);
         }
         else
         {
             m = 0;
         }
-        if ((tmp3.dateTime->skip & DATETIME_SKIPS_SECOND) == 0)
+        if ((tmp.skip & DATETIME_SKIPS_SECOND) == 0)
         {
-            s = time_getSeconds(tmp3.dateTime);
+            s = time_getSeconds(&tmp);
         }
         else
         {
             s = 0;
         }
-        if ((ret = va_getByIndex(value->Arr, 1, &tmp2)) != 0)
-        {
-            return ret;
-        }
-        var_clear(&tmp3);
-        if ((ret = dlms_changeType2(tmp2, DLMS_DATA_TYPE_DATE, &tmp3)) != 0)
-        {
-            return ret;
-        }
-        time_copy(&object->activationTime, tmp3.dateTime);
         object->activationTime.skip &= ~(DATETIME_SKIPS_HOUR | DATETIME_SKIPS_MINUTE | DATETIME_SKIPS_SECOND | DATETIME_SKIPS_MS);
         time_addHours(&object->activationTime, h);
         time_addMinutes(&object->activationTime, m);
@@ -5828,9 +6080,9 @@
     }
     break;
     default:
-        return DLMS_ERROR_CODE_READ_WRITE_DENIED;
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
     }
-    return DLMS_ERROR_CODE_OK;
+    return ret;
 }
 #endif //DLMS_ITALIAN_STANDARD
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsetmalloc.c src/development/src/gxsetmalloc.c
--- upstream/development/src/gxsetmalloc.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsetmalloc.c	2024-11-13 12:20:09.000000000 +0000
@@ -790,11 +790,17 @@
             object->access = (gxAccess*)gxcalloc(1, sizeof(gxAccess));
         }
         cnt = obj_attributeCount(object);
-        bb_capacity(&object->access->attributeAccessModes, cnt);
+        if ((ret = bb_capacity(&object->access->attributeAccessModes, cnt)) != 0)
+        {
+            return ret;
+        }
         object->access->attributeAccessModes.size = object->access->attributeAccessModes.capacity;
 
         cnt = obj_methodCount(object);
-        bb_capacity(&object->access->methodAccessModes, cnt);
+        if ((ret = bb_capacity(&object->access->methodAccessModes, cnt)) != 0)
+        {
+            return ret;
+        }
         object->access->methodAccessModes.size = object->access->methodAccessModes.capacity;
     }
     for (pos = 0; pos != tmp->Arr->size; ++pos)
@@ -2217,9 +2223,12 @@
 #ifndef DLMS_IGNORE_SECURITY_SETUP
 int cosem_setSecuritySetup(dlmsSettings* settings, gxSecuritySetup* object, unsigned char index, dlmsVARIANT* value)
 {
-    int pos, ret = 0;
-    gxCertificateInfo* it = NULL;
+    int ret = 0;
+#ifndef DLMS_IGNORE_CLIENT
     dlmsVARIANT* tmp, * tmp3;
+    gxCertificateInfo* it = NULL;
+    int pos;
+#endif //DLMS_IGNORE_CLIENT
     switch (index)
     {
     case 2:
@@ -2247,6 +2256,9 @@
         }
         break;
     case 6:
+#ifdef DLMS_IGNORE_CLIENT
+        ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
+#else
         obj_clearCertificateInfo(&object->certificates);
         if (value->Arr != NULL)
         {
@@ -2372,6 +2384,7 @@
                 gxfree(it);
             }
         }
+#endif
         break;
     default:
         ret = DLMS_ERROR_CODE_READ_WRITE_DENIED;
@@ -2555,7 +2568,7 @@
                 tmp3 = (dlmsVARIANT*)gxmalloc(sizeof(dlmsVARIANT));
 
                 if ((ret = var_init(tmp3)) != 0 ||
-                    (ret = var_copy(tmp, tmp3)) != 0 ||
+                    (ret = var_copy(tmp3, tmp)) != 0 ||
                     (ret = va_push(&object->multicastIPAddress, tmp3)) != 0)
                 {
                     break;
@@ -5471,12 +5484,15 @@
 #endif //DLMS_IGNORE_ARRAY_MANAGER
 
 #ifndef DLMS_IGNORE_PUSH_SETUP
-int cosem_setPushSetup(dlmsSettings* settings, gxPushSetup* object, unsigned char index, dlmsVARIANT* value)
+int cosem_setPushSetup(dlmsSettings* settings,
+    gxPushSetup* object,
+    unsigned char index,
+    dlmsVARIANT* value)
 {
-    int ret, pos;
+    int ret = DLMS_ERROR_CODE_OK, pos;
     gxTarget* it;
     gxObject* obj;
-    dlmsVARIANT* tmp, * tmp3;
+    dlmsVARIANT* tmp, * tmp3, * options, * keyInfo, * data;
     gxtime* s, * e;
     if (index == 2)
     {
@@ -5489,12 +5505,12 @@
                 ret = va_getByIndex(value->Arr, pos, &tmp);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 ret = va_getByIndex(tmp->Arr, 0, &tmp3);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 type = (DLMS_OBJECT_TYPE)var_toInteger(tmp3);
                 //Get LN.
@@ -5502,18 +5518,18 @@
                 ret = va_getByIndex(tmp->Arr, 1, &tmp3);
                 if (ret != DLMS_ERROR_CODE_OK)
                 {
-                    return ret;
+                    break;
                 }
                 obj = NULL;
                 if ((ret = oa_findByLN(&settings->objects, type, tmp3->byteArr->data, &obj)) != 0)
                 {
-                    return ret;
+                    break;
                 }
                 if (obj == NULL)
                 {
                     if ((ret = cosem_createObject(type, &obj)) != 0)
                     {
-                        return ret;
+                        break;
                     }
                     oa_push(&settings->releasedObjects, obj);
                     memcpy(obj->logicalName, tmp3->byteArr->data, tmp3->byteArr->size);
@@ -5607,13 +5623,179 @@
     }
     else if (index == 7)
     {
-        object->repetitionDelay = (uint16_t)var_toInteger(value);
+        if (object->base.version < 2 ||
+            value->vt == DLMS_DATA_TYPE_UINT16)
+        {
+            object->repetitionDelay = (uint16_t)var_toInteger(value);
+        }
+        else if (value->vt == DLMS_DATA_TYPE_STRUCTURE)
+        {
+            ret = va_getByIndex(value->Arr, 0, &tmp);
+            if (ret == DLMS_ERROR_CODE_OK)
+            {
+                object->repetitionDelay2.min = (uint16_t)var_toInteger(tmp);
+                ret = va_getByIndex(value->Arr, 1, &tmp);
+                if (ret == DLMS_ERROR_CODE_OK)
+                {
+                    object->repetitionDelay2.exponent = (uint16_t)var_toInteger(tmp);
+                    ret = va_getByIndex(value->Arr, 2, &tmp);
+                    if (ret == DLMS_ERROR_CODE_OK)
+                    {
+                        object->repetitionDelay2.max = (uint16_t)var_toInteger(tmp);
+                    }
+                }
+            }
+        }
+        else
+        {
+            ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+    }
+    else if (index == 8)
+    {
+        object->portReference = NULL;
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+        if (bb_size(value->byteArr) == 6)
+        {
+            ret = oa_findByLN(&settings->objects, DLMS_OBJECT_TYPE_NONE, value->byteArr->data, &object->portReference);
+        }
+#else
+        memset(object->portReference.logicalName, 0, 6);
+        if (it2->byteArr != NULL && it2->byteArr->size == 6)
+        {
+            memcpy(object->portReference.logicalName, it2->byteArr->data, 6);
+        }
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    }
+    else if (index == 9)
+    {
+        object->pushClientSAP = (signed char)var_toInteger(value);
+    }
+    else if (index == 10)
+    {
+        arr_clear(&object->pushProtectionParameters);
+        if (value->Arr != NULL)
+        {
+            gxPushProtectionParameters* p;
+            for (pos = 0; pos != value->Arr->size; ++pos)
+            {
+                p = gxmalloc(sizeof(gxPushProtectionParameters));
+                if (p == NULL)
+                {
+                    ret = DLMS_ERROR_CODE_OUTOFMEMORY;
+                    break;
+                }
+                if ((ret = va_getByIndex(value->Arr, pos, &tmp)) != 0 ||
+                    (ret = va_getByIndex(tmp->Arr, 0, &tmp3)) != 0 ||
+                    (ret = va_getByIndex(tmp->Arr, 1, &options)) != 0 ||
+                    (ret = va_getByIndex(options->Arr, 4, &keyInfo)) != 0 ||
+                    (ret = va_getByIndex(keyInfo->Arr, 1, &data)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                bb_init(&p->transactionId);
+                bb_init(&p->otherInformation);
+                bb_init(&p->keyInfo.agreedKey.parameters);
+                bb_init(&p->keyInfo.agreedKey.data);
+
+                p->protectionType = (DLMS_PROTECTION_TYPE)var_toInteger(tmp3);
+
+                if ((ret = va_getByIndex(options->Arr, 0, &tmp)) != 0 ||
+                    (ret = bb_set(&p->transactionId, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                if ((ret = va_getByIndex(options->Arr, 1, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                memcpy(p->originatorSystemTitle, tmp->byteArr->data, bb_size(tmp->byteArr));
+                if ((ret = va_getByIndex(options->Arr, 2, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                memcpy(p->recipientSystemTitle, tmp->byteArr, bb_size(tmp->byteArr));
+                if ((ret = va_getByIndex(options->Arr, 3, &tmp)) != 0 ||
+                    (ret = bb_set(&p->otherInformation, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                if ((ret = va_getByIndex(keyInfo->Arr, 0, &tmp)) != 0)
+                {
+                    gxfree(p);
+                    break;
+                }
+                p->keyInfo.dataProtectionKeyType = (DLMS_DATA_PROTECTION_KEY_TYPE)var_toInteger(tmp);
+                if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_IDENTIFIED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    p->keyInfo.identifiedKey.keyType = (DLMS_DATA_PROTECTION_IDENTIFIED_KEY_TYPE)var_toInteger(tmp);
+                }
+                else if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_WRAPPED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    p->keyInfo.wrappedKey.keyType = (DLMS_DATA_PROTECTION_WRAPPED_KEY_TYPE)var_toInteger(tmp);
+                }
+                else if (p->keyInfo.dataProtectionKeyType == DLMS_DATA_PROTECTION_KEY_TYPE_AGREED)
+                {
+                    if ((ret = va_getByIndex(data->Arr, 0, &tmp)) != 0 ||
+                        (ret = bb_set(&p->keyInfo.agreedKey.parameters, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                    if ((ret = va_getByIndex(data->Arr, 1, &tmp)) != 0 ||
+                        (ret = bb_set(&p->keyInfo.agreedKey.data, tmp->byteArr->data, bb_size(tmp->byteArr))) != 0)
+                    {
+                        gxfree(p);
+                        break;
+                    }
+                }
+                arr_push(&object->pushProtectionParameters, p);
+            }
+        }
+    }
+    else if (index == 11)
+    {
+        object->pushOperationMethod = (DLMS_PUSH_OPERATION_METHOD)var_toInteger(value);
+    }
+    else if (index == 12)
+    {
+        ret = va_getByIndex(value->Arr, 0, &tmp);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        object->confirmationParameters.startDate = *tmp->dateTime;
+        ret = va_getByIndex(value->Arr, 1, &tmp);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        object->confirmationParameters.interval = (uint32_t)var_toInteger(tmp);
+    }
+    else if (index == 13)
+    {
+        object->lastConfirmationDateTime = *value->dateTime;
     }
     else
     {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
-    return DLMS_ERROR_CODE_OK;
+    return ret;
 }
 #endif //DLMS_IGNORE_PUSH_SETUP
 
@@ -6801,11 +6983,117 @@
 
 #ifndef DLMS_IGNORE_COMPACT_DATA
 
+int compactData_updateTemplateArrayOrStructDescription(
+    gxCompactData* object,
+    dlmsVARIANT* var,
+    gxKey* kv)
+{
+    int ret = 0;
+    dlmsVARIANT* value2;
+    //If all data is captured.
+    if (((gxTarget*)kv->value)->dataIndex == 0)
+    {
+        bb_setUInt8(&object->templateDescription, var->vt);
+        if (var->vt == DLMS_DATA_TYPE_ARRAY)
+        {
+            bb_setUInt16(&object->templateDescription, var->Arr->size);
+        }
+        else
+        {
+            bb_setUInt8(&object->templateDescription, (unsigned char)var->Arr->size);
+        }
+        if (var->vt == DLMS_DATA_TYPE_STRUCTURE || var->vt == DLMS_DATA_TYPE_ARRAY)
+        {
+            uint16_t pos;
+            for (pos = 0; pos != var->Arr->size; ++pos)
+            {
+                if ((ret = va_getByIndex(var->Arr, pos, &value2)) != 0)
+                {
+                    return ret;
+                }
+                if (value2->vt == DLMS_DATA_TYPE_STRUCTURE || value2->vt == DLMS_DATA_TYPE_ARRAY)
+                {
+                    if ((ret = compactData_updateTemplateArrayOrStructDescription(
+                        object, value2, kv)) != 0)
+                    {
+                        return ret;
+                    }
+                    if (var->vt == DLMS_DATA_TYPE_ARRAY ||
+                        (var->vt != DLMS_DATA_TYPE_STRUCTURE && value2->vt == DLMS_DATA_TYPE_ARRAY))
+                    {
+                        //Array data types are added only once.
+                        break;
+                    }
+                }
+                else
+                {
+                    ret = bb_setUInt8(&object->templateDescription, value2->vt);
+                }
+                if (var->vt == DLMS_DATA_TYPE_ARRAY ||
+                    (var->vt != DLMS_DATA_TYPE_STRUCTURE && value2->vt == DLMS_DATA_TYPE_ARRAY))
+                {
+                    //Array data types are added only once.
+                    break;
+                }
+            }
+        }
+        else
+        {
+            ret = bb_setUInt8(&object->templateDescription, var->vt);
+        }
+    }
+    else
+    {
+        if (var->vt == DLMS_DATA_TYPE_STRUCTURE ||
+            var->vt == DLMS_DATA_TYPE_ARRAY)
+        {
+            bb_setUInt8(&object->templateDescription, var->vt);
+            if (var->vt == DLMS_DATA_TYPE_STRUCTURE)
+            {
+                bb_setUInt8(&object->templateDescription, (unsigned char)var->Arr->size);
+            }
+            else
+            {
+                bb_setUInt16(&object->templateDescription, var->Arr->size);
+            }
+            for (uint16_t pos = 0; pos < var->Arr->size; ++pos)
+            {
+                if ((ret = va_getByIndex(var->Arr, pos, &value2)) != 0)
+                {
+                    return ret;
+                }
+                if (value2->vt == DLMS_DATA_TYPE_STRUCTURE || value2->vt == DLMS_DATA_TYPE_ARRAY)
+                {
+                    if ((ret = compactData_updateTemplateArrayOrStructDescription(
+                        object, value2, kv)) != 0)
+                    {
+                        return ret;
+                    }
+                    if (var->vt == DLMS_DATA_TYPE_ARRAY)
+                    {
+                        //Array column data types are added only once.
+                        break;
+                    }
+                }
+                else
+                {
+                    ret = bb_setUInt8(&object->templateDescription, value2->vt);
+                }
+            }
+        }
+        else
+        {
+            ret = bb_setUInt8(&object->templateDescription, var->vt);
+        }
+    }
+    return ret;
+}
+
 int compactData_updateTemplateDescription(
     dlmsSettings* settings,
     gxCompactData* object)
 {
-    int ret;
+    int ret = 0;
     uint16_t pos;
     gxByteBuffer tmp;
     gxValueEventCollection args;
@@ -6852,117 +7140,28 @@
                 }
                 else
                 {
-                    if (e.value.byteArr->data[0] == DLMS_DATA_TYPE_ARRAY ||
-                        e.value.byteArr->data[0] == DLMS_DATA_TYPE_STRUCTURE)
+                    if (e.value.byteArr->data[e.value.byteArr->position] == DLMS_DATA_TYPE_ARRAY ||
+                        e.value.byteArr->data[e.value.byteArr->position] == DLMS_DATA_TYPE_STRUCTURE)
                     {
                         gxDataInfo info;
                         dlmsVARIANT value;
-                        uint16_t count;
                         di_init(&info);
                         var_init(&value);
-                        e.value.byteArr->position = 1;
-                        if ((ret = hlp_getObjectCount2(e.value.byteArr, &count)) != 0 ||
-                            ((gxTarget*)kv->value)->dataIndex > count)
-                        {
-                            var_clear(&e.value);
-                            bb_clear(&object->buffer);
-                            return DLMS_ERROR_CODE_OUTOFMEMORY;
-                        }
-                        //If all data is captured.
-                        if (((gxTarget*)kv->value)->dataIndex == 0)
+                        if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
                         {
-                            bb_setUInt8(&object->templateDescription, e.value.byteArr->data[0]);
-                            if (e.value.byteArr->data[0] == DLMS_DATA_TYPE_ARRAY)
-                            {
-                                bb_setUInt16(&object->templateDescription, e.value.byteArr->data[1]);
-                            }
-                            else
-                            {
-                                bb_setUInt8(&object->templateDescription, e.value.byteArr->data[1]);
-                            }
-                            for (unsigned char pos = 0; pos < count; ++pos)
-                            {
-                                di_init(&info);
-                                var_clear(&value);
-                                if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
-                                {
-                                    var_clear(&value);
-                                    var_clear(&e.value);
-                                    bb_clear(&object->buffer);
-                                    return ret;
-                                }
-                                if (info.type == DLMS_DATA_TYPE_STRUCTURE || info.type == DLMS_DATA_TYPE_ARRAY)
-                                {
-                                    dlmsVARIANT* value2;
-                                    bb_setUInt8(&object->templateDescription, info.type);
-                                    bb_setUInt8(&object->templateDescription, (unsigned char)value.Arr->size);
-                                    for (uint16_t pos = 0; pos < value.Arr->size; ++pos)
-                                    {
-                                        if ((ret = va_getByIndex(value.Arr, pos, &value2)) != 0)
-                                        {
-                                            var_clear(&value);
-                                            var_clear(&e.value);
-                                            bb_clear(&object->buffer);
-                                            return ret;
-                                        }
-                                        bb_setUInt8(&object->templateDescription, value2->vt);
-                                    }
-                                }
-                                else
-                                {
-                                    bb_setUInt8(&object->templateDescription, info.type);
-                                }
-                                if (e.value.byteArr->data[0] == DLMS_DATA_TYPE_ARRAY)
-                                {
-                                    break;
-                                }
-                            }
+                            break;
                         }
-                        else
+                        if ((ret = compactData_updateTemplateArrayOrStructDescription(object,
+                            &value, kv)) != 0)
                         {
-                            for (unsigned char pos = 0; pos < ((gxTarget*)kv->value)->dataIndex; ++pos)
-                            {
-                                var_clear(&value);
-                                di_init(&info);
-                                if ((ret = dlms_getData(e.value.byteArr, &info, &value)) != 0)
-                                {
-                                    var_clear(&value);
-                                    var_clear(&e.value);
-                                    bb_clear(&object->buffer);
-                                    return ret;
-                                }
-                                if (!info.complete)
-                                {
-                                    return DLMS_ERROR_CODE_READ_WRITE_DENIED;
-                                }
-                            }
-                            if (info.type == DLMS_DATA_TYPE_STRUCTURE)
-                            {
-                                dlmsVARIANT* value2;
-                                bb_setUInt8(&object->templateDescription, DLMS_DATA_TYPE_STRUCTURE);
-                                bb_setUInt8(&object->templateDescription, (unsigned char)value.Arr->size);
-                                for (uint16_t pos = 0; pos < value.Arr->size; ++pos)
-                                {
-                                    if ((ret = va_getByIndex(value.Arr, pos, &value2)) != 0)
-                                    {
-                                        var_clear(&value);
-                                        var_clear(&e.value);
-                                        bb_clear(&object->buffer);
-                                        return ret;
-                                    }
-                                    bb_setUInt8(&object->templateDescription, value2->vt);
-                                }
-                            }
-                            else
-                            {
-                                bb_setUInt8(&object->templateDescription, info.type);
-                            }
+                            var_clear(&e.value);
+                            bb_clear(&object->buffer);
+                            return ret;
                         }
-                        var_clear(&value);
                     }
                     else
                     {
-                        bb_setUInt8(&object->templateDescription, e.value.byteArr->data[0]);
+                        bb_setUInt8(&object->templateDescription, e.value.byteArr->data[e.value.byteArr->position]);
                     }
                 }
             }
@@ -6975,7 +7174,7 @@
                     bb_clear(&object->buffer);
                     return ret;
                 }
-                bb_setUInt8(&object->templateDescription, tmp.data[0]);
+                ret = bb_setUInt8(&object->templateDescription, tmp.data[0]);
                 bb_clear(&tmp);
             }
             var_clear(&e.value);
@@ -6983,9 +7182,8 @@
         }
     }
     bb_clear(&tmp);
-    //svr_postGet(settings, &args);
     vec_empty(&args);
-    return 0;
+    return ret;
 }
 
 int cosem_setCompactData(
@@ -7521,8 +7719,8 @@
             }
             it = (gxMacAvailableSwitch*)gxmalloc(sizeof(gxMacAvailableSwitch));
             BYTE_BUFFER_INIT(&it->sna);
-            bb_capacity(&it->sna, tmp2->byteArr->size);
-            if ((ret = bb_set(&it->sna, tmp2->byteArr->data, tmp2->byteArr->size)) != DLMS_ERROR_CODE_OK)
+            if ((ret = bb_capacity(&it->sna, tmp2->byteArr->size)) != DLMS_ERROR_CODE_OK ||
+                (ret = bb_set(&it->sna, tmp2->byteArr->data, tmp2->byteArr->size)) != DLMS_ERROR_CODE_OK)
             {
                 gxfree(it);
                 break;
@@ -8273,46 +8471,150 @@
 }
 #endif //DLMS_IGNORE_SFSK_REPORTING_SYSTEM_LIST
 
+#ifndef DLMS_IGNORE_LTE_MONITORING
+int cosem_setLteMonitoring(
+    dlmsSettings* settings,
+    gxLteMonitoring* object,
+    unsigned char index,
+    dlmsVARIANT* value)
+{
+    int ret = 0;
+    dlmsVARIANT* it;
+    if (index == 2)
+    {
+        if (value->vt == DLMS_DATA_TYPE_STRUCTURE)
+        {
+            if ((ret = va_getByIndex(value->Arr, 0, &it)) == DLMS_ERROR_CODE_OK)
+            {
+                object->networkParameters.t3402 = var_toInteger(it);
+                if ((ret = va_getByIndex(value->Arr, 1, &it)) == DLMS_ERROR_CODE_OK)
+                {
+                    object->networkParameters.t3412 = var_toInteger(it);
+                    if ((ret = va_getByIndex(value->Arr, 2, &it)) == DLMS_ERROR_CODE_OK)
+                    {
+                        object->networkParameters.t3412ext2 = var_toInteger(it);
+                        if ((ret = va_getByIndex(value->Arr, 3, &it)) == DLMS_ERROR_CODE_OK)
+                        {
+                            object->networkParameters.t3324 = var_toInteger(it);
+                            if ((ret = va_getByIndex(value->Arr, 4, &it)) == DLMS_ERROR_CODE_OK)
+                            {
+                                object->networkParameters.teDRX = var_toInteger(it);
+                                if ((ret = va_getByIndex(value->Arr, 5, &it)) == DLMS_ERROR_CODE_OK)
+                                {
+                                    object->networkParameters.tPTW = var_toInteger(it);
+                                    if ((ret = va_getByIndex(value->Arr, 6, &it)) == DLMS_ERROR_CODE_OK)
+                                    {
+                                        object->networkParameters.qRxlevMin = var_toInteger(it);
+                                        if ((ret = va_getByIndex(value->Arr, 7, &it)) == DLMS_ERROR_CODE_OK)
+                                        {
+                                            object->networkParameters.qRxlevMinCE = var_toInteger(it);
+                                            if ((ret = va_getByIndex(value->Arr, 8, &it)) == DLMS_ERROR_CODE_OK)
+                                            {
+                                                object->networkParameters.qRxLevMinCE1 = var_toInteger(it);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        else
+        {
+            object->networkParameters.t3402 = 0;
+            object->networkParameters.t3412 = 0;
+            object->networkParameters.t3412ext2 = 0;
+            object->networkParameters.t3324 = 0;
+            object->networkParameters.teDRX = 0;
+            object->networkParameters.tPTW = 0;
+            object->networkParameters.qRxlevMin = 0;
+            object->networkParameters.qRxlevMinCE = 0;
+            object->networkParameters.qRxLevMinCE1 = 0;
+        }
+    }
+    else if (index == 3)
+    {
+        if (value->vt == DLMS_DATA_TYPE_STRUCTURE)
+        {
+            if ((ret = va_getByIndex(value->Arr, 0, &it)) == DLMS_ERROR_CODE_OK)
+            {
+                object->qualityOfService.signalQuality = var_toInteger(it);
+                if ((ret = va_getByIndex(value->Arr, 1, &it)) == DLMS_ERROR_CODE_OK)
+                {
+                    object->qualityOfService.signalLevel = var_toInteger(it);
+                    if ((ret = va_getByIndex(value->Arr, 2, &it)) == DLMS_ERROR_CODE_OK)
+                    {
+                        object->qualityOfService.signalToNoiseRatio = var_toInteger(it);
+                        if ((ret = va_getByIndex(value->Arr, 3, &it)) == DLMS_ERROR_CODE_OK)
+                        {
+                            object->qualityOfService.coverageEnhancement = (DLMS_LTE_COVERAGE_ENHANCEMENT)var_toInteger(it);
+                        }
+                    }
+                }
+            }
+        }
+        else
+        {
+            object->qualityOfService.signalQuality = 0;
+            object->qualityOfService.signalLevel = 0;
+            object->qualityOfService.signalToNoiseRatio = 0;
+            object->qualityOfService.coverageEnhancement = DLMS_LTE_COVERAGE_ENHANCEMENT_LEVEL0;
+        }
+    }
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return ret;
+}
+#endif //DLMS_IGNORE_LTE_MONITORING
+
 #ifdef DLMS_ITALIAN_STANDARD
-int updateIntervals(gxInterval* interval, gxByteBuffer* value)
+int updateIntervals(gxInterval* interval, variantArray* value)
 {
     int ret;
-    unsigned char b;
-    if ((ret = bb_getUInt8(value, &b)) != 0)
+    dlmsVARIANT* tmp;
+    if (value->size != 5)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if ((ret = va_getByIndex(value, 0, &tmp)) != 0)
     {
         return ret;
     }
-    interval[0].startHour = (unsigned char)(b >> 3);
-    interval[0].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((b >> 1) & 0x3);
-    interval[0].useInterval = (b & 0x1) != 0;
-    if ((ret = bb_getUInt8(value, &b)) != 0)
+    interval[0].startHour = (unsigned char)(tmp->bVal >> 3);
+    interval[0].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((tmp->bVal >> 1) & 0x3);
+    interval[0].useInterval = (tmp->bVal & 0x1) != 0;
+    if ((ret = va_getByIndex(value, 1, &tmp)) != 0)
     {
         return ret;
     }
-    interval[1].startHour = (unsigned char)(b >> 3);
-    interval[1].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((b >> 1) & 0x3);
-    interval[1].useInterval = (b & 0x1) != 0;
-    if ((ret = bb_getUInt8(value, &b)) != 0)
+    interval[1].startHour = (unsigned char)(tmp->bVal >> 3);
+    interval[1].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((tmp->bVal >> 1) & 0x3);
+    interval[1].useInterval = (tmp->bVal & 0x1) != 0;
+    if ((ret = va_getByIndex(value, 2, &tmp)) != 0)
     {
         return ret;
     }
-    interval[2].startHour = (unsigned char)(b >> 3);
-    interval[2].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((b >> 1) & 0x3);
-    interval[2].useInterval = (b & 0x1) != 0;
-    if ((ret = bb_getUInt8(value, &b)) != 0)
+    interval[2].startHour = (unsigned char)(tmp->bVal >> 3);
+    interval[2].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((tmp->bVal >> 1) & 0x3);
+    interval[2].useInterval = (tmp->bVal & 0x1) != 0;
+    if ((ret = va_getByIndex(value, 3, &tmp)) != 0)
     {
         return ret;
     }
-    interval[3].startHour = (unsigned char)(b >> 3);
-    interval[3].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((b >> 1) & 0x3);
-    interval[3].useInterval = (b & 0x1) != 0;
-    if ((ret = bb_getUInt8(value, &b)) != 0)
+    interval[3].startHour = (unsigned char)(tmp->bVal >> 3);
+    interval[3].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((tmp->bVal >> 1) & 0x3);
+    interval[3].useInterval = (tmp->bVal & 0x1) != 0;
+    if ((ret = va_getByIndex(value, 4, &tmp)) != 0)
     {
         return ret;
     }
-    interval[4].startHour = (unsigned char)(b >> 3);
-    interval[4].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((b >> 1) & 0x3);
-    interval[4].useInterval = (b & 0x1) != 0;
+    interval[4].startHour = (unsigned char)(tmp->bVal >> 3);
+    interval[4].intervalTariff = (DLMS_DEFAULT_TARIFF_BAND)((tmp->bVal >> 1) & 0x3);
+    interval[4].useInterval = (tmp->bVal & 0x1) != 0;
     return 0;
 }
 
@@ -8333,11 +8635,11 @@
         }
         season->month = tmp->bVal;
         if ((ret = va_getByIndex(value, 2, &tmp)) != 0 ||
-            (ret = updateIntervals(season->workingDayIntervals, tmp->byteArr)) != 0 ||
+            (ret = updateIntervals(season->workingDayIntervals, tmp->Arr)) != 0 ||
             (ret = va_getByIndex(value, 3, &tmp)) != 0 ||
-            (ret = updateIntervals(season->saturdayIntervals, tmp->byteArr)) != 0 ||
+            (ret = updateIntervals(season->saturdayIntervals, tmp->Arr)) != 0 ||
             (ret = va_getByIndex(value, 4, &tmp)) != 0 ||
-            (ret = updateIntervals(season->holidayIntervals, tmp->byteArr)) != 0)
+            (ret = updateIntervals(season->holidayIntervals, tmp->Arr)) != 0)
         {
             return ret;
         }
@@ -8353,21 +8655,25 @@
 {
     dlmsVARIANT tmp3;
     dlmsVARIANT* tmp, * tmp2;
-    int ret, pos, h, m, s;
+    int ret = 0, pos, h, m, s;
     switch (index)
     {
     case 2:
         if (value->vt == DLMS_DATA_TYPE_OCTET_STRING)
         {
-            object->calendarName = (char*)gxmalloc(value->byteArr->size);
-            memcpy(object->calendarName, value->byteArr->data, value->byteArr->size);
-            object->calendarName[value->byteArr->size] = 0;
+            bb_clear(&object->calendarName);
+            if (value->strVal != NULL)
+            {
+                ret = bb_set(&object->calendarName, value->byteArr->data, value->byteArr->size);
+            }
         }
         else
         {
-            object->calendarName = (char*)gxmalloc(value->strVal->size + 1);
-            memcpy(object->calendarName, value->strVal->data, value->strVal->size);
-            object->calendarName[value->strVal->size] = 0;
+            bb_clear(&object->calendarName);
+            if (value->strVal != NULL)
+            {
+                ret = bb_set(&object->calendarName, value->strVal->data, value->strVal->size);
+            }
         }
         break;
     case 3:
@@ -8403,15 +8709,31 @@
             {
                 return ret;
             }
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
             arr_clear(&object->plan.specialDays);
             arr_capacity(&object->plan.specialDays, tmp->Arr->size);
+#else
+            va_clear(&object->plan.specialDays);
+            va_capacity(&object->plan.specialDays, tmp->Arr->size);
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
             for (pos = 0; pos != tmp->Arr->size; ++pos)
             {
                 if ((ret = va_getByIndex(tmp->Arr, pos, &tmp2)) != 0)
                 {
                     return ret;
                 }
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
                 arr_push(&object->plan.specialDays, (void*)tmp2->ulVal);
+#else
+                dlmsVARIANT* tmp3 = (dlmsVARIANT*)gxmalloc(sizeof(dlmsVARIANT));
+                var_init(tmp3);
+                ret = var_copy(tmp3, tmp2);
+                if (ret != 0)
+                {
+                    break;
+                }
+                va_push(&object->plan.specialDays, tmp3);
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
             }
         }
         break;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsha1.c src/development/src/gxsha1.c
--- upstream/development/src/gxsha1.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsha1.c	2024-11-13 12:20:09.000000000 +0000
@@ -142,7 +142,7 @@
     digest[3] += d;
     digest[4] += e;
 
-    ++* transforms;
+    ++*transforms;
 }
 
 void gxsha1_update(gxByteBuffer* data, uint32_t* digest, uint32_t* transforms)
@@ -161,41 +161,51 @@
 
 int gxsha1_final(gxByteBuffer* data, uint32_t* digest, uint32_t* transforms, gxByteBuffer* reply)
 {
-    int pos;
-    bb_capacity(reply, (uint16_t) *transforms * 64);
-    bb_set(reply, data->data, data->size);
-    /* Total number of hashed bits */
-    uint64_t total_bits = (*transforms * 64 + data->size) * 8;
-
-    /* Padding */
-    bb_setUInt8(reply, 0x80);
-    uint32_t orig_size = reply->size;
-    bb_zero(reply, reply->size, 64 - reply->size);
-    uint32_t block[16];
-    for (pos = 0; pos != 16; ++pos)
-    {
-        bb_getUInt32(reply, &block[pos]);
-    }
-    if (orig_size > 64 - 8)
+    int ret, pos;
+    if ((ret = bb_capacity(reply, (uint16_t)*transforms * 64)) == 0 &&
+        (ret = bb_set(reply, data->data, data->size)) == 0)
     {
-        gxsha1_transform(block, digest, transforms);
-        for (pos = 0; pos < 16 - 2; ++pos)
+        /* Total number of hashed bits */
+        uint64_t total_bits = (*transforms * 64 + data->size) * 8;
+
+        /* Padding */
+        bb_setUInt8(reply, 0x80);
+        uint32_t orig_size = reply->size;
+        bb_zero(reply, reply->size, 64 - reply->size);
+        uint32_t block[16];
+        for (pos = 0; pos != 16; ++pos)
         {
-            block[pos] = 0;
+            if ((ret = bb_getUInt32(reply, &block[pos])) != 0)
+            {
+                return ret;
+            }
+        }
+        if (orig_size > 64 - 8)
+        {
+            gxsha1_transform(block, digest, transforms);
+            for (pos = 0; pos < 16 - 2; ++pos)
+            {
+                block[pos] = 0;
+            }
         }
-    }
 
-    /* Append total_bits, split this uint64 into two uint32 */
-    block[16 - 1] = (uint32_t)total_bits;
-    block[16 - 2] = (uint32_t)(total_bits >> 32);
-    gxsha1_transform(block, digest, transforms);
-    bb_capacity(reply, 20);
-    reply->position = reply->size = 0;
-    for (pos = 0; pos < 5; ++pos)
-    {
-        bb_setUInt32(reply, digest[pos]);
+        /* Append total_bits, split this uint64 into two uint32 */
+        block[16 - 1] = (uint32_t)total_bits;
+        block[16 - 2] = (uint32_t)(total_bits >> 32);
+        gxsha1_transform(block, digest, transforms);
+        if ((ret = bb_capacity(reply, 20)) == 0)
+        {
+            reply->position = reply->size = 0;
+            for (pos = 0; pos < 5; ++pos)
+            {
+                if ((ret = bb_setUInt32(reply, digest[pos])) != 0)
+                {
+                    break;
+                }
+            }
+        }
     }
-    return 0;
+    return ret;
 }
 
 int gxsha1_encrypt(gxByteBuffer* data, gxByteBuffer* result)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsha256.c src/development/src/gxsha256.c
--- upstream/development/src/gxsha256.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxsha256.c	2024-11-13 12:20:09.000000000 +0000
@@ -62,13 +62,7 @@
 #define SHA256_F2(x) (SHA2_ROTR(x,  6) ^ SHA2_ROTR(x, 11) ^ SHA2_ROTR(x, 25))
 #define SHA256_F3(x) (SHA2_ROTR(x,  7) ^ SHA2_ROTR(x, 18) ^ SHA2_SHFR(x,  3))
 #define SHA256_F4(x) (SHA2_ROTR(x, 17) ^ SHA2_ROTR(x, 19) ^ SHA2_SHFR(x, 10))
-#define SHA2_UNPACK32(x, str)                 \
-{                                             \
-    *((str) + 3) = (unsigned char) ((x)      );       \
-    *((str) + 2) = (unsigned char) ((x) >>  8);       \
-    *((str) + 1) = (unsigned char) ((x) >> 16);       \
-    *((str) + 0) = (unsigned char) ((x) >> 24);       \
-}
+
 #define SHA2_PACK32(str, x)                   \
 {                                             \
     *(x) =   ((uint32_t) *((str) + 3)      )    \
@@ -77,104 +71,105 @@
            | ((uint32_t) *((str) + 0) << 24);   \
 }
 
+#define SHA2_UNPACK64(x, str)                 \
+{                                             \
+    *((str) + 7) = (unsigned char) ((x));       \
+    *((str) + 6) = (unsigned char) ((x) >>  8);       \
+    *((str) + 5) = (unsigned char) ((x) >> 16);       \
+    *((str) + 4) = (unsigned char) ((x) >> 24);       \
+    *((str) + 3) = (unsigned char) ((x) >> 32);       \
+    *((str) + 2) = (unsigned char) ((x) >> 40);       \
+    *((str) + 1) = (unsigned char) ((x) >> 48);       \
+    *((str) + 0) = (unsigned char) ((x) >> 56);       \
+}
 
-void gxsha256_transform(uint32_t *h, const unsigned char *message, unsigned int block_nb)
+void gxsha256_transform(uint32_t* h, const unsigned char* message, uint32_t messageLength)
 {
     uint32_t w[64];
     uint32_t wv[8];
     uint32_t t1, t2;
-    const unsigned char *sub_block;
-    unsigned int i;
-    int j;
-    for (i = 0; i < block_nb; i++)
+    unsigned char pos;
+    for (pos = 0; pos < 16; ++pos)
     {
-        sub_block = message + (i << 6);
-        for (j = 0; j < 16; j++)
-        {
-            SHA2_PACK32(&sub_block[j << 2], &w[j]);
-        }
-        for (j = 16; j < 64; j++)
+        SHA2_PACK32(&message[pos << 2], &w[pos]);
+    }
+    for (pos = 16; pos < 64; pos++)
+    {
+        w[pos] = SHA256_F4(w[pos - 2]) + w[pos - 7] + SHA256_F3(w[pos - 15]) + w[pos - 16];
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        wv[pos] = h[pos];
+    }
+    for (pos = 0; pos < 64; pos++) {
+        t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
+            + sha256_k[pos] + w[pos];
+        t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
+        wv[7] = wv[6];
+        wv[6] = wv[5];
+        wv[5] = wv[4];
+        wv[4] = wv[3] + t1;
+        wv[3] = wv[2];
+        wv[2] = wv[1];
+        wv[1] = wv[0];
+        wv[0] = t1 + t2;
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        h[pos] += wv[pos];
+    }
+}
+
+int gxsha256_hash(gxByteBuffer* data, gxByteBuffer* digest)
+{
+    int ret = 0;
+    uint32_t len = data->size;
+    uint32_t position = data->position;
+    uint32_t h[8] = { 0x6a09e667, 0xbb67ae85,
+        0x3c6ef372, 0xa54ff53a,
+        0x510e527f, 0x9b05688c,
+        0x1f83d9ab, 0x5be0cd19 };
+
+    unsigned char block[64];
+    unsigned char pos, size = sizeof(block);
+    unsigned char bidsAdded = 0;
+    while (!bidsAdded)
+    {
+        if (bb_available(data) < 64)
         {
-            w[j] = SHA256_F4(w[j - 2]) + w[j - 7] + SHA256_F3(w[j - 15]) + w[j - 16];
+            size = (unsigned char)bb_available(data);
         }
-        for (j = 0; j < 8; j++)
+        memcpy(block, data->data + data->position, size);
+        memset(block + size, 0, sizeof(block) - size);
+        if (bb_available(data) < 64 && size != 0)
         {
-            wv[j] = h[j];
-        }
-        for (j = 0; j < 64; j++) {
-            t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
-                + sha256_k[j] + w[j];
-            t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
-            wv[7] = wv[6];
-            wv[6] = wv[5];
-            wv[5] = wv[4];
-            wv[4] = wv[3] + t1;
-            wv[3] = wv[2];
-            wv[2] = wv[1];
-            wv[1] = wv[0];
-            wv[0] = t1 + t2;
+            // Append a bit 1
+            block[size] = 0x80;
         }
-        for (j = 0; j < 8; j++)
+        if (bb_available(data) < 56)
         {
-            h[j] += wv[j];
+            bidsAdded = 1;
+            //Add bit length to the end of last block.
+            uint64_t len_b = (uint64_t)len;
+            len_b <<= 3;
+            SHA2_UNPACK64(len_b, block + sizeof(block) - 8);
         }
+        gxsha256_transform(h, block, size);
+        data->position += size;
     }
-}
-
-int gxsha256_update(uint32_t *h, unsigned char *block, gxByteBuffer* data, unsigned int *len, unsigned int *totalLen)
-{
-    unsigned int block_nb;
-    unsigned int new_len, rem_len, tmp_len;
-    const unsigned char *shifted_message;
-    tmp_len = 64 - (data->size - data->position);
-    rem_len = data->size < tmp_len ? data->size : tmp_len;
-    memcpy(&block[data->position], data->data, rem_len);
-    if (data->size - data->position < 64)
-    {
-        data->position = data->size;
-        return 0;
-    }
-    new_len = *len - rem_len;
-    block_nb = new_len / 64;
-    shifted_message = data->data + rem_len;
-    gxsha256_transform(h, block, 1);
-    gxsha256_transform(h, shifted_message, block_nb);
-    rem_len = new_len % 64;
-    memcpy(block, &shifted_message[block_nb << 6], rem_len);
-    *len = rem_len;
-    *totalLen += (block_nb + 1) << 6;
-    return 0;
-}
-
-int gxsha256_final(uint32_t *h, unsigned char *block, unsigned char *digest, unsigned int len, unsigned int totalLen)
-{
-    unsigned int block_nb;
-    unsigned int pm_len;
-    uint32_t len_b;
-    int i;
-    block_nb = (1 + ((64 - 9) < (len % 64)));
-    len_b = (totalLen + len) << 3;
-    pm_len = block_nb << 6;
-    memset(block + len, 0, pm_len - len);
-    block[len] = 0x80;
-    SHA2_UNPACK32(len_b, block + pm_len - 4);
-    gxsha256_transform(h, block, block_nb);
-    for (i = 0; i < 8; i++)
+    digest->size = 0;
+    if ((ret = bb_capacity(digest, 32)) == 0)
     {
-        SHA2_UNPACK32(h[i], &digest[i << 2]);
+        for (pos = 0; pos < 8; ++pos)
+        {
+            if ((ret = bb_setUInt32(digest, h[pos])) != 0)
+            {
+                break;
+            }
+        }
     }
-    return 0;
-}
-
-int gxsha256_encrypt(gxByteBuffer* data, gxByteBuffer* digest)
-{
-    unsigned int len = data->size, totalLen = 0;
-    uint32_t h[8] = { 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 };
-    unsigned char block[128];
-    bb_capacity(digest, 32);
-    digest->size = 32;
-    gxsha256_update((uint32_t*)&h, block, data, &len, &totalLen);
-    return gxsha256_final(h, block, digest->data, len, totalLen);
+    data->position = position;
+    return ret;
 }
 
 #endif //DLMS_IGNORE_HIGH_SHA256
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxsha384.c src/development/src/gxsha384.c
--- upstream/development/src/gxsha384.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/gxsha384.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,185 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/gxignore.h"
+#ifndef DLMS_IGNORE_HIGH_SHA384
+#include <string.h>
+#include "../include/gxsha384.h"
+
+const uint64_t sha384_k[] = {
+    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
+    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
+    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
+    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
+    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
+    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
+    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
+    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
+    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
+    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
+    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
+    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
+    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
+    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
+    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
+    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
+    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
+    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
+    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
+    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
+};
+
+#define SHA2_SHFR(x, n)    (x >> n)
+#define SHA2_ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
+#define SHA2_CH(x, y, z)  ((x & y) ^ (~x & z))
+#define SHA2_MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
+#define SHA364_F1(x) (SHA2_ROTR(x,  28) ^ SHA2_ROTR(x, 34) ^ SHA2_ROTR(x, 39))
+#define SHA364_F2(x) (SHA2_ROTR(x,  14) ^ SHA2_ROTR(x, 18) ^ SHA2_ROTR(x, 41))
+#define SHA364_F3(x) (SHA2_ROTR(x,  1) ^ SHA2_ROTR(x, 8) ^ SHA2_SHFR(x, 7))
+#define SHA364_F4(x) (SHA2_ROTR(x, 19) ^ SHA2_ROTR(x, 61) ^ SHA2_SHFR(x, 6))
+#define SHA2_UNPACK64(x, str)                 \
+{                                             \
+    *((str) + 7) = (unsigned char) ((x));       \
+    *((str) + 6) = (unsigned char) ((x) >>  8);       \
+    *((str) + 5) = (unsigned char) ((x) >> 16);       \
+    *((str) + 4) = (unsigned char) ((x) >> 24);       \
+    *((str) + 3) = (unsigned char) ((x) >> 32);       \
+    *((str) + 2) = (unsigned char) ((x) >> 40);       \
+    *((str) + 1) = (unsigned char) ((x) >> 48);       \
+    *((str) + 0) = (unsigned char) ((x) >> 56);       \
+}
+#define SHA2_PACK64(str, x)                   \
+{                                             \
+    *(x) =   ((uint64_t) *((str) + 7)      )  \
+           | ((uint64_t) *((str) + 6) <<  8)  \
+           | ((uint64_t) *((str) + 5) << 16)  \
+           | ((uint64_t) *((str) + 4) << 24)  \
+           | ((uint64_t) *((str) + 3) << 32)  \
+           | ((uint64_t) *((str) + 2) << 40)  \
+           | ((uint64_t) *((str) + 1) << 48)  \
+           | ((uint64_t) *((str) + 0) << 56); \
+}
+
+void gxsha384_transform(uint32_t* h, const unsigned char* message, uint32_t messageLength)
+{
+    uint64_t w[80];
+    uint64_t wv[8];
+    uint64_t t1, t2;
+    unsigned char pos;
+    for (pos = 0; pos < 16; pos++)
+    {
+        SHA2_PACK64(&message[pos << 3], &w[pos]);
+    }
+    for (pos = 16; pos < 80; pos++)
+    {
+        w[pos] = SHA364_F3(w[pos - 15]) + w[pos - 7] + SHA364_F4(w[pos - 2]) + w[pos - 16];
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        wv[pos] = h[pos];
+    }
+    for (pos = 0; pos < 80; pos++) {
+        t1 = wv[7] + SHA364_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])
+            + sha384_k[pos] + w[pos];
+        t2 = SHA364_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
+        wv[7] = wv[6];
+        wv[6] = wv[5];
+        wv[5] = wv[4];
+        wv[4] = wv[3] + t1;
+        wv[3] = wv[2];
+        wv[2] = wv[1];
+        wv[1] = wv[0];
+        wv[0] = t1 + t2;
+    }
+    for (pos = 0; pos < 8; pos++)
+    {
+        h[pos] += (uint32_t)wv[pos];
+    }
+}
+
+int gxsha384_hash(gxByteBuffer* data, gxByteBuffer* digest)
+{
+    uint32_t len = data->size;
+    uint32_t position = data->position;
+    uint64_t h[8] = {
+        0xcbbb9d5dc1059ed8,
+        0x629a292a367cd507,
+        0x9159015a3070dd17,
+        0x152fecd8f70e5939,
+        0x67332667ffc00b31,
+        0x8eb44a8768581511,
+        0xdb0c2e0d64f98fa7,
+        0x47b5481dbefa4fa4 };
+    unsigned char block[128];
+    unsigned char pos, size = sizeof(block);
+    unsigned char bidsAdded = 0;
+    unsigned char eofAdded = 0;
+    while (!bidsAdded)
+    {
+        if (bb_available(data) < 128)
+        {
+            size = (unsigned char)bb_available(data);
+        }
+        memcpy(block, data->data + data->position, size);
+        memset(block + size, 0, sizeof(block) - size);
+        if (bb_available(data) < 128 && !eofAdded)
+        {
+            // Append a bit 1.
+            block[size] = 0x80;
+            eofAdded = 1;
+        }
+        if (bb_available(data) < 112)
+        {
+            bidsAdded = 1;
+            //Add bit length to the end of last block.
+            uint64_t len_b = len;
+            len_b <<= 3;
+            SHA2_UNPACK64(len_b, block + sizeof(block) - 8);
+        }
+        gxsha384_transform((uint32_t*)h, block, size);
+        data->position += size;
+    }
+    int ret = bb_capacity(digest, 48);
+    if (ret == 0)
+    {
+        digest->size = 0;
+        for (pos = 0; pos < 6; ++pos)
+        {
+            bb_setUInt64(digest, h[pos]);
+        }
+        digest->size = 48;
+    }
+    data->position = position;
+    return ret;
+}
+
+#endif //DLMS_IGNORE_HIGH_SHA384
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/gxvalueeventargs.c src/development/src/gxvalueeventargs.c
--- upstream/development/src/gxvalueeventargs.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/gxvalueeventargs.c	2024-11-13 12:20:09.000000000 +0000
@@ -198,6 +198,7 @@
     ve->handled = 0;
     ve->target = NULL;
     ve->index = 0;
+    ve->dataIndex = 0;
 #if !defined(DLMS_IGNORE_MALLOC) && !defined(DLMS_COSEM_EXACT_DATA_TYPES)
     ve->dataType = DLMS_DATA_TYPE_NONE;
 #endif //!defined(DLMS_IGNORE_MALLOC) && !defined(DLMS_COSEM_EXACT_DATA_TYPES)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/helpers.c src/development/src/helpers.c
--- upstream/development/src/helpers.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/helpers.c	2024-11-13 12:20:09.000000000 +0000
@@ -49,6 +49,15 @@
 #include "../include/helpers.h"
 #include "../include/errorcodes.h"
 
+#if defined(_WIN32) || defined(_WIN64)//Windows
+#include <direct.h>
+#endif
+#if defined(__linux__)
+#include <errno.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#endif
+
 //Check byte order.
 unsigned char hlp_isBigEndian(void)
 {
@@ -258,6 +267,24 @@
         case DLMS_ERROR_CODE_INVALID_SECURITY_SUITE:
             str = GET_STR_FROM_EEPROM("Client try to connect with wrong security suite.");
             break;
+        case DLMS_ERROR_CODE_SERIALIZATION_LOAD_FAILURE:
+            str = GET_STR_FROM_EEPROM("Serialization load failed.");
+            break;
+        case DLMS_ERROR_CODE_SERIALIZATION_SAVE_FAILURE:
+            str = GET_STR_FROM_EEPROM("Serialization save failed.");
+            break;
+        case DLMS_ERROR_CODE_SERIALIZATION_COUNT_FAILURE:
+            str = GET_STR_FROM_EEPROM("Serialization count failed.");
+            break;
+        case DLMS_ERROR_CODE_VERIFY_FAILED:
+            str = GET_STR_FROM_EEPROM("Verify failed.");
+            break;
+        case DLMS_ERROR_CODE_INVALID_CERTIFICATE:
+            str = GET_STR_FROM_EEPROM("Invalid certificate.");
+            break;
+        case DLMS_ERROR_CODE_UNKNOWN_COMMAND:
+            str = GET_STR_FROM_EEPROM("Unknown command.");
+            break;
         default:
             str = GET_STR_FROM_EEPROM("Unknown error.");
             break;
@@ -448,10 +475,21 @@
 
 int hlp_bytesToHex2(const unsigned char* bytes, uint16_t count, char* buff, uint16_t size)
 {
+    return hlp_bytesToHex3(bytes, count, buff, size, 3);
+}
+
+int hlp_bytesToHex3(
+    const unsigned char* bytes,
+    uint16_t count,
+    char* buff,
+    uint16_t size,
+    unsigned char addSpace)
+{
     const char hexArray[] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
     unsigned char tmp;
     int pos;
-    if (3 * count > size)
+    uint16_t amount = addSpace ? 3 : 2;
+    if (amount * count > size)
     {
         return DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
@@ -460,11 +498,17 @@
         for (pos = 0; pos != count; ++pos)
         {
             tmp = bytes[pos] & 0xFF;
-            buff[pos * 3] = hexArray[tmp >> 4];
-            buff[pos * 3 + 1] = hexArray[tmp & 0x0F];
-            buff[pos * 3 + 2] = ' ';
+            buff[pos * amount] = hexArray[tmp >> 4];
+            buff[pos * amount + 1] = hexArray[tmp & 0x0F];
+            if (addSpace)
+            {
+                buff[pos * amount + 2] = ' ';
+            }
+        }
+        if ((amount * count) - (addSpace ? 1 : 0) < size)
+        {
+            buff[(amount * count) - (addSpace ? 1 : 0)] = '\0';
         }
-        buff[(3 * count) - 1] = '\0';
     }
     else
     {
@@ -533,14 +577,14 @@
             {
                 tmp[*count] = (unsigned char)(lastValue << 4 | hlp_getValue(*str));
                 lastValue = -1;
-                ++* count;
+                ++*count;
             }
         }
         else if (lastValue != -1)
         {
             tmp[*count] = hlp_getValue(*str);
             lastValue = -1;
-            ++* count;
+            ++*count;
         }
         ++str;
     }
@@ -548,10 +592,14 @@
     {
 #ifdef gxrealloc
         //If compiler supports realloc.
-        *buffer = gxrealloc(*buffer, *count);
- #else
+        * buffer = gxrealloc(*buffer, *count);
+        if (tmp == NULL)
+        {
+            return DLMS_ERROR_CODE_OUTOFMEMORY;
+        }
+#else
         //A few extra bytes are returned if compiler doesn't support realloc.
- #endif // gxrealloc  
+#endif // gxrealloc  
     }
     return 0;
 }
@@ -590,14 +638,14 @@
             {
                 buffer[*count] = (unsigned char)(lastValue << 4 | hlp_getValue(*str));
                 lastValue = -1;
-                ++* count;
+                ++*count;
             }
         }
         else if (lastValue != -1)
         {
             buffer[*count] = hlp_getValue(*str);
             lastValue = -1;
-            ++* count;
+            ++*count;
         }
         if (max < *count)
         {
@@ -721,11 +769,11 @@
 {
     int ret;
 #if defined(_WIN32) || defined(_WIN64)
-	#if _MSC_VER > 1000
-        ret = sprintf_s(ln, 25, "%d.%d.%d.%d.%d.%d", value[0], value[1], value[2], value[3], value[4], value[5]);
-	#else
-	    ret = sprintf(ln, "%d.%d.%d.%d.%d.%d", value[0], value[1], value[2], value[3], value[4], value[5]);
-	#endif  
+#if _MSC_VER > 1000
+    ret = sprintf_s(ln, 25, "%d.%d.%d.%d.%d.%d", value[0], value[1], value[2], value[3], value[4], value[5]);
+#else
+    ret = sprintf(ln, "%d.%d.%d.%d.%d.%d", value[0], value[1], value[2], value[3], value[4], value[5]);
+#endif  
     if (ret != -1)
     {
         ret = 0;
@@ -792,7 +840,7 @@
     memcpy(pBuff, name, size);
     pBuff[size] = 0;
     //AVR compiler can't handle this if casting to char* is removed.
-    while ((ch = (char*) strchr(pBuff, '.')) != NULL)
+    while ((ch = (char*)strchr(pBuff, '.')) != NULL)
     {
         *ch = '\0';
         val = hlp_stringToInt(pBuff);
@@ -846,7 +894,7 @@
     return pow((float)10, scaler);
 #else
     double ret = 1;
-    if (scaler > 0) 
+    if (scaler > 0)
     {
         while (scaler--)
         {
@@ -860,7 +908,7 @@
             ret /= 10;
         }
     }
-    return ret; 
+    return ret;
 #endif
 }
 
@@ -922,6 +970,20 @@
     case DLMS_DATA_TYPE_UINT8:
         size = 1;
         break;
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT16:
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+        size = 2;
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT32:
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+        size = 4;
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+    case DLMS_DATA_TYPE_DELTA_INT8:
+        size = 1;
+        break;
+#endif //DLMS_IGNORE_DELTA
     default:
         break;
     }
@@ -979,10 +1041,10 @@
         }
         *str = (value % 10) + '0';
         value /= 10;
-		if (value != 0)
-		{
-        	--str;
-		}
+        if (value != 0)
+        {
+            --str;
+        }
         --bufsize;
         ++cnt;
     } while (value != 0);
@@ -1040,6 +1102,11 @@
 
 int32_t hlp_stringToInt(const char* str)
 {
+    return hlp_stringToInt2(str, NULL);
+}
+
+int32_t hlp_stringToInt2(const char* str, const char* end)
+{
     if (str == NULL)
     {
         return -1;
@@ -1051,7 +1118,7 @@
         minus = 1;
         ++str;
     }
-    while (*str != '\0')
+    while (*str != '\0' && str != end)
     {
         if (*str < '0' || *str > '9')
         {
@@ -1134,7 +1201,7 @@
     }
     return value;
 }
-uint16_t lfsr = 0xACE1u;
+static uint16_t lfsr = 0xACE1u;
 unsigned bit;
 
 unsigned char hlp_rand(void)
@@ -1184,4 +1251,187 @@
         ++arr->size;
     }
     return 0;
-}
\ No newline at end of file
+}
+
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+int hlp_load(const char* path, char* value, uint16_t* length)
+{
+#if defined(_WIN32) || defined(_WIN64)//Windows
+    FILE* f = NULL;
+    if (fopen_s(&f, path, "r") != 0)
+    {
+        return errno;
+    }
+#else
+    FILE* f = fopen(path, "r");
+    if (f == NULL)
+    {
+        return errno;
+    }
+#endif
+    uint16_t length2 = *length;
+    *length = 0;
+    while (!feof(f))
+    {
+        if (length2 == 0)
+        {
+            //If buffer is full.
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        char* s = fgets(value, length2, f);
+        if (s == NULL)
+        {
+            break;
+        }
+        uint16_t size = (uint16_t) strlen(s);
+        if (size == 0)
+        {
+            //If buffer is full.
+            return DLMS_ERROR_CODE_INVALID_PARAMETER;
+        }
+        *length += size;
+        length2 -= size;
+        value += size;
+    }
+    fclose(f);
+    return 0;
+}
+
+int hlp_save(const char* path, const char* value)
+{
+#if defined(_WIN32) || defined(_WIN64)//Windows
+    FILE* f = NULL;
+    if (fopen_s(&f, path, "r") != 0)
+    {
+        return errno;
+    }
+#else
+    FILE* f = fopen(path, "r");
+    if (f == NULL)
+    {
+        return errno;
+    }
+#endif
+    if (fputs(value, f) == EOF)
+    {
+        return errno;
+    }
+    fclose(f);
+    return 0;
+}
+
+#ifndef DLMS_IGNORE_DIRECTORY
+int hlp_createDir(const char* path)
+{
+#if defined(_WIN32) || defined(_WIN64)//Windows
+    return _mkdir(path);
+#else
+    return mkdir(path, 0777);
+#endif
+}
+
+unsigned char hlp_directoryExists(const char* path)
+{
+#if defined(_WIN32) || defined(_WIN64)//Windows
+    DWORD ftyp = GetFileAttributesA(path);
+    if (ftyp == INVALID_FILE_ATTRIBUTES)
+    {
+        //Invalid path.
+        return 0;
+    }
+    return (ftyp & FILE_ATTRIBUTE_DIRECTORY) != 0;
+#else
+    struct stat sb;
+    if (stat(path, &sb) == 0)
+    {
+        return 1;
+    }
+#endif
+    return 0;
+}
+#endif //DLMS_IGNORE_DIRECTORY
+
+/**
+    * Get index of given char.
+    *
+    * @param ch
+    * @return
+    */
+static int hlp_getIndex(const char ch, uint16_t* value)
+{
+    if (ch == '+')
+    {
+        *value = 62;
+    }
+    else if (ch == '/')
+    {
+        *value = 63;
+    }
+    else if (ch == '=')
+    {
+        *value = 64;
+    }
+    else if (ch < ':')
+    {
+        *value = (52 + (ch - '0'));
+    }
+    else if (ch < '[')
+    {
+        *value = (ch - 'A');
+    }
+    else if (ch < '{')
+    {
+        *value = (26 + (ch - 'a'));
+    }
+    else
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    return 0;
+}
+
+/**
+ * Convert Base64 string to byte array.
+ *
+ * @param input
+ *            Base64 string.
+ * @return Converted byte array.
+ */
+int hlp_fromBase64(const char* input, uint16_t length, gxByteBuffer* decoded)
+{
+    if (length % 4 != 0)
+    {
+        return DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    int ret = 0;
+    uint16_t pos = (uint16_t)(strstr(input, "=") - input);
+    uint16_t b1, b2, b3, b4;
+    pos = 0;
+    while (pos < length)
+    {
+        if (input[pos] == '\r' || input[pos] == '\n')
+        {
+            ++pos;
+        }
+        else
+        {
+            if ((ret = hlp_getIndex(input[pos], &b1)) != 0 ||
+                (ret = hlp_getIndex(input[pos + 1], &b2)) != 0 ||
+                (ret = hlp_getIndex(input[pos + 2], &b3)) != 0 ||
+                (ret = hlp_getIndex(input[pos + 3], &b4)) != 0 ||
+                (ret = bb_setUInt8(decoded, (b1 << 2) | (b2 >> 4))) != 0)
+            {
+                break;
+            }
+            pos += 4;
+            if (b3 < 64) {
+                bb_setUInt8(decoded, (b2 << 4) | (b3 >> 2));
+                if (b4 < 64) {
+                    bb_setUInt8(decoded, (b3 << 6) | b4);
+                }
+            }
+        }
+    }
+    return ret;
+}
+#endif //defined(_WIN32) || defined(_WIN64) || defined(__linux__)
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/message.c src/development/src/message.c
--- upstream/development/src/message.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/message.c	2024-11-13 12:20:09.000000000 +0000
@@ -79,25 +79,29 @@
             mes->data = (gxByteBuffer**)gxmalloc(mes->capacity * sizeof(gxByteBuffer*));
             if (mes->data == NULL)
             {
+                mes->capacity = 0;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
         }
         else
         {
+            gxByteBuffer** old = mes->data;
 #ifdef gxrealloc
             //If compiler supports realloc.
             mes->data = (gxByteBuffer**)gxrealloc(mes->data, mes->capacity * sizeof(gxByteBuffer*));
             if (mes->data == NULL)
             {
+                mes->capacity -= MESSAGE_CAPACITY;
+                mes->data = old;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
 #else
             //If compiler doesn't support realloc.
-            gxByteBuffer** old = mes->data;
             mes->data = (gxByteBuffer**)gxmalloc(mes->capacity * sizeof(gxByteBuffer*));
             //If not enought memory available.
             if (mes->data == NULL)
             {
+                mes->capacity -= MESSAGE_CAPACITY;
                 mes->data = old;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/objectarray.c src/development/src/objectarray.c
--- upstream/development/src/objectarray.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/objectarray.c	2024-11-13 12:20:09.000000000 +0000
@@ -73,23 +73,38 @@
 #ifndef DLMS_IGNORE_MALLOC
     if (!oa_isAttached(arr))
     {
+        uint16_t orig = capacity;
         arr->capacity = capacity;
         if (arr->data == NULL)
         {
             arr->data = (gxObject**)gxmalloc(arr->capacity * sizeof(gxObject*));
+            //If not enought memory available.
+            if (arr->data == NULL)
+            {
+                arr->capacity = 0;
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
         }
         else
         {
+            gxObject** old = arr->data;
 #ifdef gxrealloc
             //If compiler supports realloc.
             arr->data = (gxObject**)gxrealloc(arr->data, arr->capacity * sizeof(gxObject*));
- #else
+            //If not enought memory available.
+            if (arr->data == NULL)
+            {
+                arr->capacity = orig;
+                arr->data = old;
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
+#else
             //If compiler doesn't support realloc.
-            gxObject** old = arr->data;
             arr->data = (gxObject**)gxmalloc(arr->capacity * sizeof(gxObject*));
             //If not enought memory available.
             if (arr->data == NULL)
             {
+                arr->capacity = orig;
                 arr->data = old;
                 return DLMS_ERROR_CODE_OUTOFMEMORY;
             }
@@ -159,15 +174,26 @@
         if (arr->data == NULL)
         {
             arr->data = (gxObject**)gxmalloc(arr->capacity * sizeof(gxObject*));
+            //If not enought memory available.
+            if (arr->data == NULL)
+            {
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
         }
         else
         {
+            gxObject** old = arr->data;
 #ifdef gxrealloc
             //If compiler supports realloc.
             arr->data = (gxObject**)gxrealloc(arr->data, arr->capacity * sizeof(gxObject*));
- #else
+            //If not enought memory available.
+            if (arr->data == NULL)
+            {
+                arr->data = old;
+                return DLMS_ERROR_CODE_OUTOFMEMORY;
+            }
+#else
             //If compiler doesn't support realloc.
-            gxObject** old = arr->data;
             arr->data = (gxObject**)gxmalloc(arr->capacity * sizeof(gxObject*));
             //If not enought memory available.
             if (arr->data == NULL)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/privateKey.c src/development/src/privateKey.c
--- upstream/development/src/privateKey.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/privateKey.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,143 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/privateKey.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "../include/bytebuffer.h"
+#include "../include/errorcodes.h"
+#include "../include/bigInteger.h"
+#include "../include/curve.h"
+#include "../include/shamirs.h"
+
+void priv_init(gxPrivateKey* key)
+{
+    key->scheme = ECC_P256;
+    BB_ATTACH(key->rawValue, key->buff, 0);
+    pub_init(&key->publicKey);
+}
+void priv_clear(gxPrivateKey* key)
+{
+    key->scheme = ECC_P256;
+    bb_clear(&key->rawValue);
+    pub_clear(&key->publicKey);
+}
+
+int priv_fromRawBytes(
+    gxByteBuffer* value,
+    gxPrivateKey* key)
+{
+    int ret = 0;
+    //If private key is given
+    if (bb_size(value) == 32)
+    {
+        key->scheme = ECC_P256;
+    }
+    else if (bb_size(value) == 48)
+    {
+        key->scheme = ECC_P384;
+    }
+    else
+    {
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (ret == 0)
+    {
+        //Clear the public key associated with the private key.
+        pub_clear(&key->publicKey);
+        bb_clear(&key->rawValue);
+        ret = bb_set(&key->rawValue, value->data, value->size);
+    }
+    return ret;
+}
+
+int priv_getPublicKey(gxPrivateKey* key, gxPublicKey* pub)
+{
+    int ret = 0;
+    if (bb_size(&key->publicKey.rawValue) == 0)
+    {
+        //Public key = private key multiple by curve.G.
+        bigInteger pk;
+        bigInteger tmp;
+        gxCurve curve;
+        bi_init(&pk);
+        bi_init(&tmp);
+        if ((ret = bi_fromByteBuffer(&pk, &key->rawValue)) == 0 &&
+            (ret = curve_init(&curve, key->scheme)) == 0)
+        {
+            gxEccPoint p;
+            eccPoint_init(&p);
+            ret = shamirs_pointMulti(&curve, &p, &curve.g, &pk);
+            if (ret == 0)
+            {
+                int size = key->scheme == ECC_P256 ? 32 : 48;
+                gxByteBuffer bb;
+                gxByteBuffer tmp;
+#ifdef GX_DLMS_MICROCONTROLLER
+#ifdef DLMS_SECURITY_SUITE_1
+                static unsigned char TMP[32];
+#else
+                static unsigned char TMP[48];
+#endif //DLMS_SECURITY_SUITE_1
+                static unsigned char BB[PUBLIC_KEY_SIZE];
+#else                
+#ifdef DLMS_SECURITY_SUITE_1
+                static unsigned char TMP[32];
+#else
+                static unsigned char TMP[48];
+#endif //DLMS_SECURITY_SUITE_1
+                unsigned char BB[PUBLIC_KEY_SIZE];
+#endif //GX_DLMS_MICROCONTROLLER
+                BB_ATTACH(bb, BB, 0);
+                BB_ATTACH(tmp, TMP, 0);
+                //key is un-compressed format.
+                if ((ret = bb_setUInt8(&bb, 4)) == 0 &&
+                    (ret = bi_toArray(&p.x, &tmp)) == 0 &&
+                    (ret = bb_set(&bb, tmp.data + bb_size(&tmp) % size, size)) == 0 &&
+                    (ret = bb_clear(&tmp)) == 0 &&
+                    (ret = bi_toArray(&p.y, &tmp)) == 0 &&
+                    (ret = bb_set(&bb, tmp.data + bb_size(&tmp) % size, size)) == 0)
+                {
+                    ret = pub_fromRawBytes(&key->publicKey, &bb);
+                }
+            }
+        }
+    }
+    if (ret == 0 && pub != &key->publicKey)
+    {
+        pub->scheme = key->publicKey.scheme;
+        bb_clear(&pub->rawValue);
+        ret = bb_set(&pub->rawValue, key->publicKey.rawValue.data, key->publicKey.rawValue.size);
+    }
+    return ret;
+}
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/publicKey.c src/development/src/publicKey.c
--- upstream/development/src/publicKey.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/publicKey.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,107 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/publicKey.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "../include/errorcodes.h"
+
+void pub_init(gxPublicKey *key)
+{
+    key->scheme = ECC_P256;
+    BB_ATTACH(key->rawValue, key->buff, 0);
+}
+
+void pub_clear(gxPublicKey* key)
+{
+    key->scheme = ECC_P256;
+    bb_clear(&key->rawValue);
+}
+
+int pub_fromRawBytes(
+    gxPublicKey* key,
+    gxByteBuffer* value)
+{
+    int ret = 0;
+    bb_clear(&key->rawValue);
+    if (bb_size(value) == 65)
+    {
+        key->scheme = ECC_P256;
+    }
+    else if (bb_size(value) == 97)
+    {
+        key->scheme = ECC_P384;
+    }
+    else if (bb_size(value) == 64)
+    {
+        //Compression tag is not send in DLMS messages.
+        key->scheme = ECC_P256;
+        ret = bb_setUInt8(&key->rawValue, 4);
+    }
+    else if (bb_size(value) == 96)
+    {
+        //Compression tag is not send in DLMS messages.
+        key->scheme = ECC_P384;
+        ret = bb_setUInt8(&key->rawValue, 4);
+    }
+    else
+    {
+        //Invalid key.
+        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+    }
+    if (ret == 0)
+    {
+        ret = bb_set(&key->rawValue, value->data, value->size);
+    }
+    return ret;
+}
+
+
+int pub_getX(gxPublicKey* key, gxByteBuffer* value)
+{
+    bb_clear(value);
+    int size = bb_size(&key->rawValue) / 2;
+    int ret = bb_subArray(&key->rawValue, 1, size, value);
+    key->rawValue.position = 0;
+    return ret;
+}
+
+int pub_getY(gxPublicKey* key, gxByteBuffer* value)
+{
+    bb_clear(value);
+    int size = bb_size(&key->rawValue) / 2;
+    int ret = bb_subArray(&key->rawValue, 1 + size, size, value);
+    key->rawValue.position = 0;
+    return ret;
+}
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/server.c src/development/src/server.c
--- upstream/development/src/server.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/server.c	2024-11-13 12:20:09.000000000 +0000
@@ -317,7 +317,7 @@
 {
     svr_setInitialize(settings);
     resetFrameSequence(&settings->base);
-    reply_clear2(&settings->info, 1);
+    reply_clear2(&settings->info, 0);
     settings->base.serverAddress = 0;
     settings->base.clientAddress = 0;
     settings->dataReceived = 0;
@@ -341,8 +341,8 @@
 #ifdef DLMS_COSEM_INVOCATION_COUNTER_SIZE64
                 ret = bb_setUInt64(data, *settings->expectedInvocationCounter);
 #else
-                ret = bb_setUInt32(data, (uint32_t)*settings->expectedInvocationCounter);
-#endif //DLMS_COSEM_INVOCATION_COUNTER_SIZE64
+                ret = bb_setUInt32(data, *settings->expectedInvocationCounter);
+#endif // DLMS_COSEM_INVOCATION_COUNTER_SIZE64
             }
         }
         else if (error == DLMS_ERROR_CODE_INVALID_COMMAND)
@@ -380,6 +380,9 @@
             key = settings->cipher.blockCipherKey;
 #endif //DLMS_IGNORE_MALLOC
         }
+#ifdef DLMS_TRACE_PDU
+        cip_tracePdu(1, data);
+#endif //DLMS_TRACE_PDU
         ret = cip_encrypt(
             &settings->cipher,
             settings->cipher.security,
@@ -1161,7 +1164,10 @@
     e = &list.data[0];
     ve_clear(e);
 #else
-    bb_capacity(&status, 10);
+    if ((ret = bb_capacity(&status, 10)) != 0)
+    {
+        return ret;
+    }
     vec_init(&list);
     e = (gxValueEventArg*)gxmalloc(sizeof(gxValueEventArg));
     ve_init(e);
@@ -1220,10 +1226,10 @@
                     if (!bb_isAttached(data))
                     {
                         ret = bb_set2(&settings->transaction.data, data, data->position, data->size - data->position);
-                    }
+                }
 #endif //DLMS_IGNORE_MALLOC
                     settings->transaction.command = DLMS_COMMAND_SET_REQUEST;
-                }
+            }
                 if (ret == 0)
                 {
                     if (e->error != 0)
@@ -1247,7 +1253,7 @@
 #ifndef DLMS_IGNORE_MALLOC
                 var_clear(&e->value);
 #endif //DLMS_IGNORE_MALLOC
-            }
+                    }
         }
     }
 #ifndef DLMS_IGNORE_MALLOC
@@ -1263,7 +1269,7 @@
     bb_clear(&status);
     p->requestType = DLMS_SET_RESPONSE_TYPE_WITH_LIST;
     return ret;
-}
+                }
 #endif //DLMS_IGNORE_SET
 
 #ifndef DLMS_IGNORE_MALLOC
@@ -1327,7 +1333,7 @@
     }
     p->multipleBlocks = 1;
     return ret;
-}
+        }
 #endif //DLMS_IGNORE_MALLOC
 
 /**
@@ -1422,6 +1428,11 @@
         p.multipleBlocks = 0;
         p.requestType = 1;
     }
+    else if (settings->base.cipher.broadcast)
+    {
+        //ACK is not send with broadcast.
+        return bb_clear(data);
+    }
     return dlms_getLNPdu(&p, data);
 }
 
@@ -1508,10 +1519,10 @@
         {
             vec_clear(arr);
             return ret;
-        }
+    }
         bb_clear(data);
 #endif //DLMS_IGNORE_MALLOC
-    }
+}
     else
     {
         bb_clear(data);
@@ -1598,15 +1609,15 @@
                         status = DLMS_ERROR_CODE_HARDWARE_FAULT;
                     }
                     var_clear(&e->value);
-                }
+                    }
 #endif //DLMS_IGNORE_MALLOC
-            }
+                }
             else if (status != 0)
             {
                 bb_clear(data);
             }
+            }
         }
-    }
     //PDU is used for serialization. Set data type to none so size is not changed.
     if (e->byteArray || (e->value.vt == DLMS_DATA_TYPE_OCTET_STRING && bb_isAttached(e->value.byteArr)))
     {
@@ -1630,7 +1641,7 @@
         if (!bb_isAttached(data))
         {
             ret = bb_set2(&settings->transaction.data, data, data->position, data->size - data->position);
-        }
+    }
 #endif //DLMS_IGNORE_MALLOC
         e->transaction = 1;
         settings->transaction.command = DLMS_COMMAND_GET_REQUEST;
@@ -1639,7 +1650,7 @@
     vec_clear(arr);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
-}
+    }
 
 int svr_getRequestNextDataBlock(
     dlmsServerSettings* settings,
@@ -1724,18 +1735,18 @@
                 if (!bb_isAttached(data))
                 {
                     bb_set2(&settings->transaction.data, data, data->position, data->size - data->position);
-                }
+    }
 #endif //DLMS_IGNORE_MALLOC
-            }
+}
             else
             {
                 trans_clear(&settings->transaction);
                 resetBlockIndex(&settings->base);
             }
+}
         }
-    }
     return ret;
-}
+    }
 
 int svr_getRequestWithList(
     dlmsServerSettings* settings,
@@ -1837,7 +1848,7 @@
                 }
             }
         }
-    }
+        }
     bb_clear(data);
     svr_preRead(&settings->base, arr);
     hlp_setObjectCount(cnt, data);
@@ -1910,9 +1921,9 @@
             if (!bb_isAttached(data))
             {
                 bb_set2(&settings->transaction.data, data, data->position, data->size - data->position);
-            }
-#endif //DLMS_IGNORE_MALLOC
         }
+#endif //DLMS_IGNORE_MALLOC
+    }
     }
     svr_postRead(&settings->base, arr);
     params_initLN(&p, &settings->base, invokeId, DLMS_COMMAND_GET_RESPONSE, 3, NULL, data, 0xFF, settings->info.encryptedCommand, moreData, !moreData);
@@ -2518,218 +2529,222 @@
         return DLMS_ERROR_CODE_INVALID_PARAMETER;
     }
     BYTE_BUFFER_INIT(&results);
-    bb_capacity(&results, cnt);
-    vec_init(&list);
-    vec_init(&writes);
-    vec_init(&actions);
-    for (pos = 0; pos != cnt; ++pos)
+    if ((ret = bb_capacity(&results, cnt)) == 0)
     {
-        if ((ret = bb_getUInt8(data, &ch)) != 0)
-        {
-            break;
-        }
-        type = (DLMS_VARIABLE_ACCESS_SPECIFICATION)ch;
-        switch (type)
+        vec_init(&list);
+        vec_init(&writes);
+        vec_init(&actions);
+        for (pos = 0; pos != cnt; ++pos)
         {
-        case DLMS_VARIABLE_ACCESS_SPECIFICATION_VARIABLE_NAME:
-            if ((ret = bb_getUInt16(data, &sn)) != 0)
-            {
-                break;
-            }
-            if ((ret = svr_findSNObject(settings, sn, &i)) != 0)
-            {
-                break;
-            }
-            e = (gxValueEventArg*)gxmalloc(sizeof(gxValueEventArg));
-            ve_init(e);
-            e->target = i.item;
-            e->index = i.index;
-            e->action = i.action;
-            vec_push(&list, e);
-            if (e->action)
-            {
-                vec_push(&actions, e);
-            }
-            else
+            if ((ret = bb_getUInt8(data, &ch)) != 0)
             {
-                vec_push(&writes, e);
-            }
-            // Return error if connection is not established.
-            if (!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0
-                && (!e->action || e->target->shortName != 0xFA00 || e->index != 8))
-            {
-                ret = svr_generateConfirmedServiceError(
-                    settings,
-                    DLMS_CONFIRMED_SERVICE_ERROR_INITIATE_ERROR,
-                    DLMS_SERVICE_ERROR_SERVICE,
-                    DLMS_SERVICE_UNSUPPORTED, data);
                 break;
             }
-            // If target is unknown.
-            if (i.item == NULL)
-            {
-                // Device reports a undefined object.
-                bb_setUInt8(&results, DLMS_ERROR_CODE_UNDEFINED_OBJECT);
-            }
-            else
+            type = (DLMS_VARIABLE_ACCESS_SPECIFICATION)ch;
+            switch (type)
             {
-                bb_setUInt8(&results, DLMS_ERROR_CODE_OK);
-            }
-            break;
-        case DLMS_VARIABLE_ACCESS_SPECIFICATION_WRITE_DATA_BLOCK_ACCESS:
-            // Return error if connection is not established.
-            if (!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0)
-            {
-                ret = svr_generateConfirmedServiceError(
-                    settings,
-                    DLMS_CONFIRMED_SERVICE_ERROR_INITIATE_ERROR,
-                    DLMS_SERVICE_ERROR_SERVICE,
-                    DLMS_SERVICE_UNSUPPORTED, data);
+            case DLMS_VARIABLE_ACCESS_SPECIFICATION_VARIABLE_NAME:
+                if ((ret = bb_getUInt16(data, &sn)) != 0)
+                {
+                    break;
+                }
+                if ((ret = svr_findSNObject(settings, sn, &i)) != 0)
+                {
+                    break;
+                }
+                e = (gxValueEventArg*)gxmalloc(sizeof(gxValueEventArg));
+                ve_init(e);
+                e->target = i.item;
+                e->index = i.index;
+                e->action = i.action;
+                vec_push(&list, e);
+                if (e->action)
+                {
+                    vec_push(&actions, e);
+                }
+                else
+                {
+                    vec_push(&writes, e);
+                }
+                // Return error if connection is not established.
+                if (!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0
+                    && (!e->action || e->target->shortName != 0xFA00 || e->index != 8))
+                {
+                    ret = svr_generateConfirmedServiceError(
+                        settings,
+                        DLMS_CONFIRMED_SERVICE_ERROR_INITIATE_ERROR,
+                        DLMS_SERVICE_ERROR_SERVICE,
+                        DLMS_SERVICE_UNSUPPORTED, data);
+                    break;
+                }
+                // If target is unknown.
+                if (i.item == NULL)
+                {
+                    // Device reports a undefined object.
+                    bb_setUInt8(&results, DLMS_ERROR_CODE_UNDEFINED_OBJECT);
+                }
+                else
+                {
+                    bb_setUInt8(&results, DLMS_ERROR_CODE_OK);
+                }
                 break;
+            case DLMS_VARIABLE_ACCESS_SPECIFICATION_WRITE_DATA_BLOCK_ACCESS:
+                // Return error if connection is not established.
+                if (!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0)
+                {
+                    ret = svr_generateConfirmedServiceError(
+                        settings,
+                        DLMS_CONFIRMED_SERVICE_ERROR_INITIATE_ERROR,
+                        DLMS_SERVICE_ERROR_SERVICE,
+                        DLMS_SERVICE_UNSUPPORTED, data);
+                    break;
+                }
+                bb_clear(&results);
+                return svr_handleReadDataBlockAccess(settings, DLMS_COMMAND_WRITE_RESPONSE, data, cnt);
+            default:
+                // Device reports a HW error.
+                ret = DLMS_ERROR_CODE_HARDWARE_FAULT;
             }
-            bb_clear(&results);
-            return svr_handleReadDataBlockAccess(settings, DLMS_COMMAND_WRITE_RESPONSE, data, cnt);
-        default:
-            // Device reports a HW error.
-            ret = DLMS_ERROR_CODE_HARDWARE_FAULT;
         }
-    }
-    // Get data count.
-    if (hlp_getObjectCount2(data, &cnt) != 0)
-    {
-        ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-        cnt = 0;
-    }
-    di_init(&di);
-    for (pos = 0; pos != cnt; ++pos)
-    {
-        if ((ret = bb_getUInt8ByIndex(&results, pos, &ch)) != 0)
+        // Get data count.
+        if (hlp_getObjectCount2(data, &cnt) != 0)
         {
-            break;
+            ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+            cnt = 0;
         }
-        if (ch == 0)
+        di_init(&di);
+        for (pos = 0; pos != cnt; ++pos)
         {
-            // If object has found.
-            if ((ret = vec_getByIndex(&list, pos, &e)) != 0)
+            if ((ret = bb_getUInt8ByIndex(&results, pos, &ch)) != 0)
             {
                 break;
             }
-            if (e->action)
+            if (ch == 0)
             {
-                if ((ret = dlms_getData(data, &di, &e->parameters)) != 0)
+                // If object has found.
+                if ((ret = vec_getByIndex(&list, pos, &e)) != 0)
                 {
                     break;
                 }
-            }
-            else if ((ret = dlms_getData(data, &di, &e->value)) != 0)
-            {
-                break;
-            }
-            di_init(&di);
-            am = svr_getAttributeAccess(&settings->base, e->target, e->index);
-            // If write is denied.
-            if (am != DLMS_ACCESS_MODE_WRITE && am != DLMS_ACCESS_MODE_READ_WRITE)
-            {
-                bb_setUInt8ByIndex(&results, pos, DLMS_ERROR_CODE_READ_WRITE_DENIED);
-            }
-            else
-            {
-                if (writes.size != 0)
+                if (e->action)
                 {
-                    if (pos == 0)
-                    {
-                        svr_preWrite(&settings->base, &list);
-                    }
-                    if (e->error != 0)
+                    if ((ret = dlms_getData(data, &di, &e->parameters)) != 0)
                     {
-                        bb_setUInt8ByIndex(&results, pos, e->error);
+                        break;
                     }
-                    else if (!e->handled)
+                }
+                else if ((ret = dlms_getData(data, &di, &e->value)) != 0)
+                {
+                    break;
+                }
+                di_init(&di);
+                am = svr_getAttributeAccess(&settings->base, e->target, e->index);
+                // If write is denied.
+                if (am != DLMS_ACCESS_MODE_WRITE && am != DLMS_ACCESS_MODE_READ_WRITE)
+                {
+                    bb_setUInt8ByIndex(&results, pos, DLMS_ERROR_CODE_READ_WRITE_DENIED);
+                }
+                else
+                {
+                    if (writes.size != 0)
                     {
-                        if ((ret = cosem_setValue(&settings->base, e)) != 0)
+                        if (pos == 0)
                         {
-                            break;
+                            svr_preWrite(&settings->base, &list);
                         }
-                        //Call post write after all values are written.
-                        if (pos == cnt - 1)
+                        if (e->error != 0)
                         {
-                            svr_postWrite(&settings->base, &list);
-                            if (e->error != 0)
+                            bb_setUInt8ByIndex(&results, pos, e->error);
+                        }
+                        else if (!e->handled)
+                        {
+                            if ((ret = cosem_setValue(&settings->base, e)) != 0)
                             {
-                                bb_setUInt8ByIndex(&results, pos, e->error);
+                                break;
+                            }
+                            //Call post write after all values are written.
+                            if (pos == cnt - 1)
+                            {
+                                svr_postWrite(&settings->base, &list);
+                                if (e->error != 0)
+                                {
+                                    bb_setUInt8ByIndex(&results, pos, e->error);
+                                }
                             }
                         }
                     }
-                }
-                if (actions.size != 0)
-                {
-                    if (pos == 0)
-                    {
-                        svr_preAction(&settings->base, &actions);
-                    }
-                    ret = cosem_invoke(settings, e);
-                    // If High level authentication fails.
-                    if (e->target != NULL && e->target->objectType == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME && e->index == 1)
+                    if (actions.size != 0)
                     {
-                        if ((settings->base.connected & DLMS_CONNECTION_STATE_DLMS) != 0)
+                        if (pos == 0)
                         {
-                            svr_connected(settings);
+                            svr_preAction(&settings->base, &actions);
                         }
-                        else
+                        ret = cosem_invoke(settings, e);
+                        // If High level authentication fails.
+                        if (e->target != NULL && e->target->objectType == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME && e->index == 1)
                         {
-                            svr_invalidConnection(settings);
+                            if ((settings->base.connected & DLMS_CONNECTION_STATE_DLMS) != 0)
+                            {
+                                svr_connected(settings);
+                            }
+                            else
+                            {
+                                svr_invalidConnection(settings);
+                            }
+                        }
+                        //Call post action after all values are invoked.
+                        if (pos == cnt - 1)
+                        {
+                            svr_postAction(&settings->base, &actions);
+                        }
+                        if (ret != 0)
+                        {
+                            break;
                         }
-                    }
-                    //Call post action after all values are invoked.
-                    if (pos == cnt - 1)
-                    {
-                        svr_postAction(&settings->base, &actions);
-                    }
-                    if (ret != 0)
-                    {
-                        break;
                     }
                 }
             }
         }
-    }
-    if (ret != 0)
-    {
-        // Add parameters error code.
-        if (ret > 0 && ret < DLMS_ERROR_CODE_OTHER_REASON + 1)
-        {
-            bb_setUInt8ByIndex(&results, pos, ret);
-        }
-        else
-        {
-            bb_setUInt8ByIndex(&results, pos, DLMS_ERROR_CODE_READ_WRITE_DENIED);
-        }
-    }
-    gxByteBuffer bb;
-    BYTE_BUFFER_INIT(&bb);
-    bb_capacity(&bb, 2 * cnt);
-    for (pos = 0; pos != cnt; ++pos)
-    {
-        if ((ret = bb_getUInt8(&results, &ch)) != 0)
+        if (ret != 0)
         {
-            break;
+            // Add parameters error code.
+            if (ret > 0 && ret < DLMS_ERROR_CODE_OTHER_REASON + 1)
+            {
+                bb_setUInt8ByIndex(&results, pos, ret);
+            }
+            else
+            {
+                bb_setUInt8ByIndex(&results, pos, DLMS_ERROR_CODE_READ_WRITE_DENIED);
+            }
         }
-        // If meter returns error.
-        if (ch != 0)
+        gxByteBuffer bb;
+        BYTE_BUFFER_INIT(&bb);
+        if ((ret = bb_capacity(&bb, 2 * cnt)) == 0)
         {
-            bb_setUInt8(&bb, 1);
+            for (pos = 0; pos != cnt; ++pos)
+            {
+                if ((ret = bb_getUInt8(&results, &ch)) != 0)
+                {
+                    break;
+                }
+                // If meter returns error.
+                if (ch != 0)
+                {
+                    bb_setUInt8(&bb, 1);
+                }
+                bb_setUInt8(&bb, ch);
+            }
+            params_initSN(&p, &settings->base, DLMS_COMMAND_WRITE_RESPONSE, cnt, 0xFF, &bb, NULL, settings->info.encryptedCommand);
+            p.lastBlock = e->transactionStartIndex == e->transactionEndIndex;
+            ret = dlms_getSNPdu(&p, data);
+            bb_clear(&bb);
+            // If all data is transfered.
+            bb_clear(&results);
+            vec_empty(&writes);
+            vec_empty(&actions);
+            vec_clear(&list);
         }
-        bb_setUInt8(&bb, ch);
     }
-    params_initSN(&p, &settings->base, DLMS_COMMAND_WRITE_RESPONSE, cnt, 0xFF, &bb, NULL, settings->info.encryptedCommand);
-    p.lastBlock = e->transactionStartIndex == e->transactionEndIndex;
-    ret = dlms_getSNPdu(&p, data);
-    bb_clear(&bb);
-    // If all data is transfered.
-    bb_clear(&results);
-    vec_empty(&writes);
-    vec_empty(&actions);
-    vec_clear(&list);
     return ret;
 }
 #endif //!defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
@@ -2820,8 +2835,8 @@
             vec_clear(&arr);
 #endif //DLMS_IGNORE_MALLOC
             return ret;
-        }
     }
+}
     if (ci == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
     {
         e->target = NULL;
@@ -2835,8 +2850,8 @@
             vec_clear(&arr);
 #endif //DLMS_IGNORE_MALLOC
             return ret;
-        }
     }
+        }
     if (e->target == NULL)
     {
         ret = svr_findObject(&settings->base, ci, 0, ln, e);
@@ -2877,9 +2892,14 @@
         if (data->position == data->size)
         {
             bb_clear(data);
+            var_clear(&e->value);
         }
 #endif //DLMS_IGNORE_MALLOC
-
+        if (settings->base.cipher.broadcast)
+        {
+            //ACK is not send with broadcast.
+            return bb_clear(data);
+        }
         // Set default action reply if not given.
         if (e->error == DLMS_ERROR_CODE_OK)
         {
@@ -2954,7 +2974,7 @@
     vec_clear(&arr);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
-}
+        }
 #endif //DLMS_IGNORE_ACTION
 
 /**
@@ -2984,7 +3004,7 @@
     bb_clear(data);
 #ifdef DLMS_IGNORE_MALLOC
     unsigned char offset = IS_HDLC(settings->base.interfaceType) ? 12 : 9;
-    bb_attach(&tmp, data->data + offset, 0, data->capacity - offset);
+    bb_attach(&tmp, data->data + offset, 0, bb_getCapacity(data) - offset);
 #else
     BYTE_BUFFER_INIT(&tmp);
 #endif //DLMS_IGNORE_MALLOC
@@ -3014,12 +3034,12 @@
 #ifndef DLMS_IGNORE_MALLOC
                     ret = bb_set(data, tmp.data, tmp.size);
 #endif //DLMS_IGNORE_MALLOC
-                }
             }
         }
     }
-    return 0;
 }
+    return 0;
+    }
 
 #ifndef DLMS_IGNORE_PLC
 int svr_registerRequest(
@@ -3228,7 +3248,7 @@
     {
         //Get next frame.
         frame = getNextSend(&settings->base, 0);
-    }
+}
 #else
     if (dlms_useHdlc(settings->base.interfaceType) && bb_size(reply) != 0)
     {
@@ -3241,9 +3261,10 @@
 #ifndef DLMS_IGNORE_SET
     case DLMS_COMMAND_SET_REQUEST:
         //If connection is not established.
-        if ((!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0) ||
-            //If service is not negotiated.
-            (settings->base.negotiatedConformance & DLMS_CONFORMANCE_SET) == 0)
+        if (!settings->info.preEstablished &&
+            ((settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0 ||
+                //If service is not negotiated.
+                (settings->base.negotiatedConformance & DLMS_CONFORMANCE_SET) == 0))
         {
             ret = DLMS_ERROR_CODE_INVALID_COMMAND;
         }
@@ -3263,14 +3284,15 @@
         else
         {
             ret = svr_handleWriteRequest(settings, data);
-        }
+    }
         break;
 #endif //!defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
     case DLMS_COMMAND_GET_REQUEST:
         //If connection is not established.
-        if ((!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0) ||
-            //If service is not negotiated.
-            (settings->base.negotiatedConformance & DLMS_CONFORMANCE_GET) == 0)
+        if (!settings->info.preEstablished &&
+            ((settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0 ||
+                //If service is not negotiated.
+                (settings->base.negotiatedConformance & DLMS_CONFORMANCE_GET) == 0))
         {
             ret = DLMS_ERROR_CODE_INVALID_COMMAND;
         }
@@ -3291,9 +3313,10 @@
 #if !defined(DLMS_IGNORE_ASSOCIATION_SHORT_NAME) && !defined(DLMS_IGNORE_MALLOC)
     case DLMS_COMMAND_READ_REQUEST:
         //If connection is not established.
-        if ((!settings->info.preEstablished && (settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0) ||
-            //If service is not negotiated.
-            (settings->base.negotiatedConformance & DLMS_CONFORMANCE_READ) == 0)
+        if (!settings->info.preEstablished &&
+            ((settings->base.connected & DLMS_CONNECTION_STATE_DLMS) == 0 ||
+                //If service is not negotiated.
+                (settings->base.negotiatedConformance & DLMS_CONFORMANCE_READ) == 0))
         {
             ret = DLMS_ERROR_CODE_INVALID_COMMAND;
         }
@@ -3315,7 +3338,8 @@
     case DLMS_COMMAND_METHOD_REQUEST:
         //Connection established is checked inside of the function because of HLS.
         //If service is not negotiated.
-        if ((settings->base.negotiatedConformance & DLMS_CONFORMANCE_ACTION) == 0)
+        if (!settings->info.preEstablished &&
+            (settings->base.negotiatedConformance & DLMS_CONFORMANCE_ACTION) == 0)
         {
             ret = DLMS_ERROR_CODE_INVALID_COMMAND;
         }
@@ -3327,8 +3351,8 @@
 #ifdef DLMS_DEBUG
                 svr_notifyTrace("handleMethodRequest failed. ", ret);
 #endif //DLMS_DEBUG
-            }
         }
+    }
         break;
 #endif //DLMS_IGNORE_ACTION
 #ifndef DLMS_IGNORE_HDLC
@@ -3343,7 +3367,7 @@
 #ifdef DLMS_DEBUG
             svr_notifyTrace("handleSnrmRequest failed. ", ret);
 #endif //DLMS_DEBUG
-        }
+            }
         break;
 #endif //DLMS_IGNORE_HDLC
     case DLMS_COMMAND_AARQ:
@@ -3358,7 +3382,7 @@
 #ifdef DLMS_DEBUG
             svr_notifyTrace("HandleAarqRequest failed. ", ret);
 #endif //DLMS_DEBUG
-        }
+            }
         break;
     case DLMS_COMMAND_RELEASE_REQUEST:
         ret = svr_handleReleaseRequest(settings, data);
@@ -3401,7 +3425,7 @@
         svr_notifyTrace("Unknown command. ", cmd);
 #endif //DLMS_DEBUG
         ret = DLMS_ERROR_CODE_INVALID_COMMAND;
-    }
+        }
     if (ret == DLMS_ERROR_CODE_INVALID_COMMAND)
     {
         bb_clear(data);
@@ -3431,7 +3455,11 @@
     {
         settings->info.moreData |= DLMS_DATA_REQUEST_TYPES_FRAME;
     }
-    ret = dlms_addFrame(&settings->base, frame, data, reply);
+    if (!(settings->base.cipher.broadcast && data->size == 0))
+    {
+        //Reply is not send with broadcast.
+        ret = dlms_addFrame(&settings->base, frame, data, reply);
+    }
     if (cmd == DLMS_COMMAND_DISC ||
         (settings->base.interfaceType == DLMS_INTERFACE_TYPE_WRAPPER && cmd == DLMS_COMMAND_RELEASE_REQUEST))
     {
@@ -3444,7 +3472,7 @@
     }
 #endif //DLMS_DEBUG
     return ret;
-}
+    }
 
 int svr_handleRequest(
     dlmsServerSettings* settings,
@@ -3560,7 +3588,7 @@
 #endif //DLMS_DEBUG
         //Server not Initialized.
         return DLMS_ERROR_CODE_NOT_INITIALIZED;
-    }
+}
     //Check frame using inter Charachter Timeout.
 #if !defined(DLMS_IGNORE_HDLC) || !defined(DLMS_IGNORE_IEC_HDLC_SETUP)
     if (IS_HDLC(settings->base.interfaceType) && settings->hdlc != NULL && settings->hdlc->inactivityTimeout != 0)
@@ -3583,21 +3611,21 @@
 #endif //DLMS_DEBUG
 #ifndef DLMS_IGNORE_HDLC
         //Send U-Frame Frame Reject if we have received more data that can fit to one HDLC frame.
-        if (IS_HDLC(settings->base.interfaceType))
-        {
-            ret = dlms_getHdlcFrame(&settings->base, DLMS_COMMAND_REJECTED, NULL, sr->reply);
-            settings->receivedData.position = settings->receivedData.size = 0;
-            reply_clear2(&settings->info, 1);
-        }
-        else
-        {
-            ret = 0;
-        }
+            if (IS_HDLC(settings->base.interfaceType))
+            {
+                ret = dlms_getHdlcFrame(&settings->base, DLMS_COMMAND_REJECTED, NULL, sr->reply);
+                settings->receivedData.position = settings->receivedData.size = 0;
+                reply_clear2(&settings->info, 1);
+            }
+            else
+            {
+                ret = 0;
+            }
 #else
         ret = 0;
 #endif //DLMS_IGNORE_HDLC
         return ret;
-    }
+            }
     if (bb_set(&settings->receivedData, sr->data, sr->dataSize) != 0)
     {
         //If client is sending junk data.
@@ -3723,7 +3751,7 @@
             svr_notifyTrace("Invalid server address. ", -1);
 #endif //DLMS_DEBUG
             return 0;
-        }
+            }
         else if (ret == DLMS_ERROR_CODE_INVALID_CLIENT_ADDRESS)
         {
 #ifdef DLMS_DEBUG
@@ -3753,7 +3781,7 @@
             settings->receivedData.position = settings->receivedData.size = 0;
             reply_clear2(&settings->info, 1);
             return 0;
-        }
+            }
         else if (ret == DLMS_ERROR_CODE_INVALID_FRAME_NUMBER)
         {
 #ifdef DLMS_DEBUG
@@ -3771,7 +3799,7 @@
             settings->receivedData.position = settings->receivedData.size = 0;
             reply_clear2(&settings->info, 1);
             return 0;
-        }
+            }
         else
         {
 #ifndef DLMS_IGNORE_HDLC
@@ -3787,7 +3815,7 @@
             reply_clear2(&settings->info, 1);
             return 0;
         }
-    }
+        }
     // If all data is not received yet.
     if (!settings->info.complete)
     {
@@ -3804,7 +3832,7 @@
 #endif //DLMS_IGNORE_HDLC
         reply_clear2(&settings->info, 1);
         return ret;
-    }
+        }
 
     if ((first || settings->info.command == DLMS_COMMAND_SNRM ||
         (settings->base.interfaceType == DLMS_INTERFACE_TYPE_WRAPPER && settings->info.command == DLMS_COMMAND_AARQ)) &&
@@ -3902,9 +3930,9 @@
                 {
                     svr_disconnected(settings);
                 }
-            }
         }
     }
+        }
 #endif // DLMS_IGNORE_IEC_HDLC_SETUP
 #endif //DLMS_IGNORE_HDLC
 #ifndef DLMS_IGNORE_WRAPPER
@@ -3932,9 +3960,9 @@
                 {
                     svr_disconnected(settings);
                 }
-            }
         }
     }
+        }
 #endif // DLMS_IGNORE_TCP_UDP_SETUP
 #endif //DLMS_IGNORE_WRAPPER
     ret = svr_handleCommand(settings, settings->info.command, &settings->info.data, sr->reply);
@@ -3971,7 +3999,7 @@
     }
     settings->dataReceived = time_elapsed();
     return ret;
-}
+    }
 
 int svr_handleInactivityTimeout(
     dlmsServerSettings* settings,
@@ -4096,7 +4124,7 @@
 #endif //DLMS_IGNORE_MALLOC
         //Increase time by one second so next scheduled date is retreaved.
         ++time;
-    }
+            }
     if (start != NULL)
     {
         uint32_t tmp = time_getNextScheduledDate(time, start);
@@ -4106,7 +4134,7 @@
         }
     }
     return ret;
-}
+        }
 
 #ifndef DLMS_IGNORE_PROFILE_GENERIC
 
@@ -4178,7 +4206,7 @@
         if ((ret = arr_getByIndex(&object->executionTime, pos, (void**)&s)) != 0)
         {
             break;
-        }
+}
 #else
         if ((ret = arr_getByIndex(&object->executionTime, pos, (void**)&s, sizeof(gxtime))) != 0)
         {
@@ -4322,7 +4350,7 @@
     vec_clear(&args);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
-}
+        }
 
 int svr_handleActivityCalendar(
     dlmsServerSettings* settings,
@@ -4590,9 +4618,9 @@
         {
             break;
         }
-    }
+        }
     return ret;
-}
+    }
 #endif //DLMS_IGNORE_AUTO_CONNECT
 
 int svr_run(
@@ -4715,16 +4743,16 @@
             ret = GET_ATTRIBUTE(2);
             break;
         case 2:
-            //Key transfer. TODO: Check this when SS 1 is released.
+            //Key transfer. 
             ret = GET_ATTRIBUTE(7);
             break;
         case 4:
-            //Generate key pair. TODO: Check this when SS 1 is released.
-            ret = GET_ATTRIBUTE(2);
+            //Generate key pair. 
+            ret = GET_ATTRIBUTE(6);
             break;
         case 6:
         case 8:
-            //Import or export certificate.
+            //Import or remove certificate.
             ret = GET_ATTRIBUTE(6);
             break;
         default:
@@ -4863,7 +4891,7 @@
     vec_clear(&args);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
-}
+        }
 
 int svr_monitorAll(dlmsServerSettings* settings)
 {
@@ -5045,7 +5073,7 @@
                         if (va_getByIndex(&object->emergencyProfileGroupIDs, pos, &id) != 0)
                         {
                             break;
-                        }
+                }
 #else
                         if (arr_getByIndex(&object->emergencyProfileGroupIDs, pos, (void**)&id, sizeof(uint16_t)) != 0)
                         {
@@ -5062,9 +5090,9 @@
                             object->emergencyProfileActive = 1;
                             break;
                         }
-                    }
-                }
+                        }
             }
+        }
             else
             {
                 //Limiter is in emergency mode.
@@ -5081,7 +5109,7 @@
     vec_clear(&args);
 #endif //DLMS_IGNORE_MALLOC
     return ret;
-}
+    }
 
 int svr_limiterAll(dlmsServerSettings* settings, uint32_t now)
 {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/shamirs.c src/development/src/shamirs.c
--- upstream/development/src/shamirs.c	1970-01-01 00:00:00.000000000 +0000
+++ src/development/src/shamirs.c	2024-11-13 12:20:09.000000000 +0000
@@ -0,0 +1,263 @@
+//
+// --------------------------------------------------------------------------
+//  Gurux Ltd
+//
+//
+//
+// Filename:        $HeadURL$
+//
+// Version:         $Revision$,
+//                  $Date$
+//                  $Author$
+//
+// Copyright (c) Gurux Ltd
+//
+//---------------------------------------------------------------------------
+//
+//  DESCRIPTION
+//
+// This file is a part of Gurux Device Framework.
+//
+// Gurux Device Framework is Open Source software; you can redistribute it
+// and/or modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; version 2 of the License.
+// Gurux Device Framework is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+// See the GNU General Public License for more details.
+//
+// This code is licensed under the GNU General Public License v2.
+// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
+//---------------------------------------------------------------------------
+
+#include "../include/shamirs.h"
+#if defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
+
+#include "../include/gxmem.h"
+
+#if _MSC_VER > 1400
+#include <crtdbg.h>
+#endif
+
+int shamirs_trick(gxCurve* curve,
+    gxPublicKey* pub,
+    gxEccPoint* value,
+    bigInteger* u1,
+    bigInteger* u2)
+{
+    int ret;
+    gxEccPoint sum;
+    gxByteBuffer x, y;
+    gxEccPoint op2;
+    gxEccPoint tmp;
+    if ((ret = bb_init(&x)) == 0 &&
+        (ret = bb_init(&y)) == 0 &&
+        (ret = pub_getX(pub, &x)) == 0 &&
+        (ret = pub_getY(pub, &y)) == 0 &&
+        (ret = eccPoint_init(&sum)) == 0 &&
+        (ret = eccPoint_init(&op2)) == 0 &&
+        (ret = eccPoint_init(&tmp)) == 0 &&
+        (ret = bi_fromByteBuffer(&op2.x, &x)) == 0 &&
+        (ret = bi_fromByteBuffer(&op2.y, &y)) == 0 &&
+        (ret = shamirs_pointAdd(curve, &sum, &curve->g, &op2)) == 0)
+    {
+        uint16_t bits1 = bi_getUsedBits(u1);
+        uint16_t bits2 = bi_getUsedBits(u2);
+        uint16_t pos = bits1 > bits2 ? bits1 : bits2;
+        --pos;
+        if (bi_isBitSet(u1, pos) && bi_isBitSet(u2, pos))
+        {
+            bi_copy(&value->x, &sum.x);
+            bi_copy(&value->y, &sum.y);
+        }
+        else if (bi_isBitSet(u1, pos))
+        {
+            bi_copy(&value->x, &curve->g.x);
+            bi_copy(&value->y, &curve->g.y);
+        }
+        else if (bi_isBitSet(u2, pos))
+        {
+            bi_copy(&value->x, &op2.x);
+            bi_copy(&value->y, &op2.y);
+        }
+        --pos;
+        while (1)
+        {
+            bi_copy(&tmp.x, &value->x);
+            bi_copy(&tmp.y, &value->y);
+            ret = shamirs_pointDouble(curve, value, &tmp);
+            if (ret == 0)
+            {
+                bi_copy(&tmp.x, &value->x);
+                bi_copy(&tmp.y, &value->y);
+                if (bi_isBitSet(u1, pos) && bi_isBitSet(u2, pos))
+                {
+                    ret = shamirs_pointAdd(curve, value, &tmp, &sum);
+                }
+                else if (bi_isBitSet(u1, pos))
+                {
+                    ret = shamirs_pointAdd(curve, value, &tmp, &curve->g);
+                }
+                else if (bi_isBitSet(u2, pos))
+                {
+                    ret = shamirs_pointAdd(curve, value, &tmp, &op2);
+                }
+            }
+            if (ret != 0 || pos == 0)
+            {
+                break;
+            }
+            --pos;
+        }
+    }
+    return ret;
+}
+
+int shamirs_pointAdd(gxCurve* curve,
+    gxEccPoint* ret,
+    gxEccPoint* p1,
+    gxEccPoint* p2)
+{
+    bigInteger negy;
+    bi_init(&negy);
+    bi_copy(&negy, &curve->p);
+    bi_sub(&negy, &p2->y);
+    // Calculate lambda.
+    bigInteger ydiff;
+    bi_init(&ydiff);
+    bi_copy(&ydiff, &p2->y);
+    bi_sub(&ydiff, &p1->y);
+    bigInteger xdiff;
+    bi_init(&xdiff);
+    bi_copy(&xdiff, &p2->x);
+    bi_sub(&xdiff, &p1->x);
+    bi_inv(&xdiff, &curve->p);
+    bigInteger lambda;
+    bi_init(&lambda);
+    bi_copy(&lambda, &ydiff);
+    bi_multiply(&lambda, &xdiff);
+    bi_mod(&lambda, &curve->p);
+    // calculate resulting x coord.
+    bi_copy(&ret->x, &lambda);
+    bi_multiply(&ret->x, &lambda);
+    bi_sub(&ret->x, &p1->x);
+    bi_sub(&ret->x, &p2->x);
+    bi_mod(&ret->x, &curve->p);
+    //calculate resulting y coord
+    bi_copy(&ret->y, &p1->x);
+    bi_sub(&ret->y, &ret->x);
+    bi_multiply(&ret->y, &lambda);
+    bi_sub(&ret->y, &p1->y);
+    bi_mod(&ret->y, &curve->p);
+    return 0;
+}
+
+int shamirs_pointDouble(gxCurve* curve,
+    gxEccPoint* ret,
+    gxEccPoint* p1)
+{
+    bigInteger numer;
+    bigInteger denom;
+    bi_init(&numer);
+    bi_init(&denom);
+    bi_copy(&numer, &p1->x);
+    bi_multiply(&numer, &p1->x);
+    bi_multiplyInt32(&numer, 3);
+    bi_addBigInteger(&numer, &curve->a);
+    bi_copy(&denom, &p1->y);
+    bi_multiplyInt32(&denom, 2);
+    bi_inv(&denom, &curve->p);
+    bigInteger lambda;
+    bi_init(&lambda);
+    bi_copy(&lambda, &numer);
+    bi_multiply(&lambda, &denom);
+    bi_mod(&lambda, &curve->p);
+    //x coordinate.
+    bi_copy(&ret->x, &lambda);
+    bi_multiply(&ret->x, &lambda);
+    bi_sub(&ret->x, &p1->x);
+    bi_sub(&ret->x, &p1->x);
+    bi_mod(&ret->x, &curve->p);
+    //y coordinate.
+    bi_copy(&ret->y, &p1->x);
+    bi_sub(&ret->y, &ret->x);
+    bi_multiply(&ret->y, &lambda);
+    bi_sub(&ret->y, &p1->y);
+    bi_mod(&ret->y, &curve->p);
+    return 0;
+}
+
+int shamirs_pointMulti(gxCurve* curve,
+    gxEccPoint* value,
+    gxEccPoint* point,
+    bigInteger* scalar)
+{
+    int ret;
+    gxEccPoint R0;
+    gxEccPoint R1;
+    gxEccPoint tmp;
+    eccPoint_init(&R0);
+    eccPoint_init(&R1);
+    eccPoint_init(&tmp);
+    if ((ret = bi_copy(&R0.x, &point->x)) == 0 &&
+        (ret = bi_copy(&R0.y, &point->y)) == 0)
+    {
+        if ((ret = shamirs_pointDouble(curve, &R1, point)) == 0)
+        {
+            uint16_t dbits = bi_getUsedBits(scalar);
+            dbits -= 2;
+            while (1)
+            {
+                if (bi_isBitSet(scalar, dbits))
+                {
+                    if ((ret = bi_copy(&tmp.x, &R0.x)) != 0 ||
+                        (ret = bi_copy(&tmp.y, &R0.y)) != 0)
+                    {
+                        break;
+                    }
+                    if ((ret = shamirs_pointAdd(curve, &R0, &R1, &tmp)) != 0 ||
+                        (ret = bi_copy(&tmp.x, &R1.x)) != 0 ||
+                        (ret = bi_copy(&tmp.y, &R1.y)) != 0)
+                    {
+                        break;
+                    }
+                    if ((ret = shamirs_pointDouble(curve, &R1, &tmp)) != 0)
+                    {
+                        break;
+                    }
+                }
+                else
+                {
+                    if ((ret = bi_copy(&tmp.x, &R1.x)) != 0 ||
+                        (ret = bi_copy(&tmp.y, &R1.y)) != 0)
+                    {
+                        break;
+                    }
+                    if ((ret = shamirs_pointAdd(curve, &R1, &R0, &tmp)) != 0 ||
+                        (ret = bi_copy(&tmp.x, &R0.x)) != 0 ||
+                        (ret = bi_copy(&tmp.y, &R0.y)) != 0)
+                    {
+                        break;
+                    }
+                    if ((ret = shamirs_pointDouble(curve, &R0, &tmp)) != 0)
+                    {
+                        break;
+                    }
+                }
+                if (dbits == 0)
+                {
+                    break;
+                }
+                --dbits;
+            }
+            if ((ret = bi_copy(&value->x, &R0.x)) == 0 &&
+                (ret = bi_copy(&value->y, &R0.y)) == 0)
+            {
+
+            }
+        }
+    }
+    return ret;
+}
+
+#endif //defined(DLMS_SECURITY_SUITE_1) || defined(DLMS_SECURITY_SUITE_2)
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/development/src/variant.c src/development/src/variant.c
--- upstream/development/src/variant.c	2024-01-23 14:13:59.000000000 +0000
+++ src/development/src/variant.c	2024-11-13 12:20:09.000000000 +0000
@@ -821,13 +821,23 @@
     return var_getBytes3(data, type, ba, 1);
 }
 
-//Returns bytes as Big Endian byteorder.
 int var_getBytes3(
     dlmsVARIANT* data,
     DLMS_DATA_TYPE type,
     gxByteBuffer* ba,
     unsigned char addType)
 {
+    return var_getBytes4(data, type, ba, addType, 1, 1);
+}
+
+int var_getBytes4(
+    dlmsVARIANT* data,
+    DLMS_DATA_TYPE type,
+    gxByteBuffer* ba,
+    unsigned char addType,
+    unsigned char addArraySize,
+    unsigned char addStructureSize)
+{
     int ret = 0, pos;
     if ((type & DLMS_DATA_TYPE_BYREF) != 0)
     {
@@ -837,15 +847,26 @@
         type == DLMS_DATA_TYPE_ARRAY)
     {
         dlmsVARIANT* tmp;
-        if ((ret = bb_setUInt8(ba, type)) == 0 &&
-            (ret = hlp_setObjectCount(data->Arr != NULL ? data->Arr->size : 0, ba)) == 0)
+        if (addType)
+        {
+            if ((ret = bb_setUInt8(ba, type)) != 0)
+            {
+                return ret;
+            }
+        }
+        if ((type == DLMS_DATA_TYPE_ARRAY && addArraySize) ||
+            (type == DLMS_DATA_TYPE_STRUCTURE && addStructureSize))
+        {
+            ret = hlp_setObjectCount(data->Arr != NULL ? data->Arr->size : 0, ba);
+        }
+        if (ret == 0)
         {
             if (data->Arr != NULL)
             {
                 for (pos = 0; pos != data->Arr->size; ++pos)
                 {
                     if ((ret = va_getByIndex(data->Arr, pos, &tmp)) != DLMS_ERROR_CODE_OK ||
-                        (ret = var_getBytes(tmp, ba)) != DLMS_ERROR_CODE_OK)
+                        (ret = var_getBytes4(tmp, tmp->vt, ba, addType, addArraySize, addStructureSize)) != DLMS_ERROR_CODE_OK)
                     {
                         break;
                     }
@@ -1053,6 +1074,27 @@
 #endif //DLMS_IGNORE_MALLOC
         break;
     }
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT8:
+        ret = bb_setInt8(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->pcVal : data->cVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT16:
+        ret = bb_setInt16(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->puiVal : data->uiVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT32:
+        ret = bb_setUInt32(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->plVal : data->lVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+        ret = bb_setInt8(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->pcVal : data->cVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+        ret = bb_setInt16(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->puiVal : data->uiVal);
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+        ret = bb_setUInt32(ba, (data->vt & DLMS_DATA_TYPE_BYREF) != 0 ? *data->plVal : data->lVal);
+        break;
+#endif //DLMS_IGNORE_DELTA
+
     default:
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
         assert(0);
@@ -1102,11 +1144,25 @@
     case DLMS_DATA_TYPE_DATETIME:
         nSize = 12;
         break;
-        //case DLMS_DATA_TYPE_DATE:
-        //case DLMS_DATA_TYPE_TIME:
-        //case DLMS_DATA_TYPE_ARRAY:
-        //case DLMS_DATA_TYPE_STRUCTURE:
-        //case DLMS_DATA_TYPE_COMPACT_ARRAY:
+    case DLMS_DATA_TYPE_DATE:
+        nSize = 5;
+        break;
+    case DLMS_DATA_TYPE_TIME:
+        nSize = 4;
+        break;
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT8:
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+        nSize = 1;
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT16:
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+        nSize = 2;
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT32:
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+        break;
+#endif //DLMS_IGNORE_DELTA
     default:
         break;
     }
@@ -1202,6 +1258,26 @@
     }
     break;
 #endif //DLMS_IGNORE_MALLOC
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT8:
+        ret = data->cVal;
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT16:
+        ret = data->iVal;
+        break;
+    case DLMS_DATA_TYPE_DELTA_INT32:
+        ret = data->lVal;
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+        ret = data->bVal;
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+        ret = data->uiVal;
+        break;
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+        ret = data->ulVal;
+        break;
+#endif //DLMS_IGNORE_DELTA
     default:
 #if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
         assert(0);
@@ -1611,6 +1687,9 @@
             return DLMS_ERROR_CODE_OK;
         }
         case DLMS_DATA_TYPE_INT32:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_INT32:
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_intToString(buff, 250, tmp.lVal, 1, 0);
             bb_addString(item->strVal, buff);
@@ -1619,6 +1698,9 @@
             return DLMS_ERROR_CODE_OK;
         }
         case DLMS_DATA_TYPE_UINT32:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_UINT32:
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_uint64ToString(buff, 250, tmp.ulVal, 0);
             if ((ret = bb_addString(item->strVal, buff)) == 0)
@@ -1629,6 +1711,9 @@
             return ret;
         }
         case DLMS_DATA_TYPE_INT8:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_INT8:       
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_intToString(buff, 250, tmp.cVal, 1, 0);
             bb_addString(item->strVal, buff);
@@ -1637,6 +1722,9 @@
             return DLMS_ERROR_CODE_OK;
         }
         case DLMS_DATA_TYPE_INT16:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_INT16:
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_intToString(buff, 250, tmp.iVal, 1, 0);
             bb_addString(item->strVal, buff);
@@ -1645,6 +1733,9 @@
             return DLMS_ERROR_CODE_OK;
         }
         case DLMS_DATA_TYPE_UINT8:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_UINT8:
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_intToString(buff, 250, tmp.bVal, 0, 0);
             bb_addString(item->strVal, buff);
@@ -1653,6 +1744,9 @@
             return DLMS_ERROR_CODE_OK;
         }
         case DLMS_DATA_TYPE_UINT16:
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_UINT16:
+#endif //DLMS_IGNORE_DELTA
         {
             hlp_intToString(buff, 250, tmp.uiVal, 0, 0);
             bb_addString(item->strVal, buff);
@@ -1766,42 +1860,66 @@
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_INT32)
+        else if (type == DLMS_DATA_TYPE_INT32
+#ifndef DLMS_IGNORE_DELTA
+        || type == DLMS_DATA_TYPE_DELTA_INT32
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->lVal = hlp_stringToInt((char*)tmp.strVal->data);
             item->vt = type;
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_UINT32)
+        else if (type == DLMS_DATA_TYPE_UINT32
+#ifndef DLMS_IGNORE_DELTA
+            || type == DLMS_DATA_TYPE_DELTA_UINT32
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->ulVal = hlp_stringToInt((char*)tmp.strVal->data) & 0xFFFFFFFF;
             item->vt = type;
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_INT8)
+        else if (type == DLMS_DATA_TYPE_INT8
+#ifndef DLMS_IGNORE_DELTA
+            || type == DLMS_DATA_TYPE_DELTA_INT8
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->cVal = (char)hlp_stringToInt((char*)tmp.strVal->data);
             item->vt = type;
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_INT16)
+        else if (type == DLMS_DATA_TYPE_INT16 
+#ifndef DLMS_IGNORE_DELTA
+            || type == DLMS_DATA_TYPE_DELTA_INT16
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->iVal = (short)hlp_stringToInt((char*)tmp.strVal->data);
             item->vt = type;
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_UINT8)
+        else if (type == DLMS_DATA_TYPE_UINT8
+#ifndef DLMS_IGNORE_DELTA
+            || type == DLMS_DATA_TYPE_DELTA_UINT8
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->bVal = (unsigned char)hlp_stringToInt((char*)tmp.strVal->data);
             item->vt = type;
             var_clear(&tmp);
             return DLMS_ERROR_CODE_OK;
         }
-        else if (type == DLMS_DATA_TYPE_UINT16)
+        else if (type == DLMS_DATA_TYPE_UINT16
+#ifndef DLMS_IGNORE_DELTA
+            || type == DLMS_DATA_TYPE_DELTA_UINT16
+#endif //DLMS_IGNORE_DELTA
+            )
         {
             item->uiVal = (uint16_t)hlp_stringToInt((char*)tmp.strVal->data);
             item->vt = type;
@@ -1934,6 +2052,14 @@
 #ifndef DLMS_IGNORE_FLOAT64
     case DLMS_DATA_TYPE_FLOAT64:
 #endif //DLMS_IGNORE_FLOAT64
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT8:
+    case DLMS_DATA_TYPE_DELTA_INT16:
+    case DLMS_DATA_TYPE_DELTA_INT32:
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+#endif //DLMS_IGNORE_DELTA
         return convert(value, newType);
     default:
         //Handled later.
@@ -2002,6 +2128,15 @@
             break;
         case DLMS_DATA_TYPE_FLOAT64:
             break;
+#ifndef DLMS_IGNORE_DELTA
+        case DLMS_DATA_TYPE_DELTA_INT8:
+        case DLMS_DATA_TYPE_DELTA_INT16:
+        case DLMS_DATA_TYPE_DELTA_INT32:
+        case DLMS_DATA_TYPE_DELTA_UINT8:
+        case DLMS_DATA_TYPE_DELTA_UINT16:
+        case DLMS_DATA_TYPE_DELTA_UINT32:
+            break;
+#endif //DLMS_IGNORE_DELTA
         default:
             return DLMS_ERROR_CODE_INVALID_PARAMETER;
         }
@@ -2368,8 +2503,8 @@
     {
         target->byteArr = (gxByteBuffer*)gxmalloc(sizeof(gxByteBuffer));
         BYTE_BUFFER_INIT(target->byteArr);
-        bb_capacity(target->byteArr, 12);
-        if ((ret = var_getDateTime2(value, target->byteArr)) == 0)
+        if ((ret = bb_capacity(target->byteArr, 12)) == 0 &&
+            (ret = var_getDateTime2(value, target->byteArr)) == 0)
         {
             target->vt = DLMS_DATA_TYPE_OCTET_STRING;
         }
@@ -2386,8 +2521,8 @@
     {
         target->byteArr = (gxByteBuffer*)gxmalloc(sizeof(gxByteBuffer));
         BYTE_BUFFER_INIT(target->byteArr);
-        bb_capacity(target->byteArr, 5);
-        if ((ret = var_getDate(value, target->byteArr)) == 0)
+        if ((ret = bb_capacity(target->byteArr, 5)) == 0 &&
+            (ret = var_getDate(value, target->byteArr)) == 0)
         {
             target->vt = DLMS_DATA_TYPE_OCTET_STRING;
         }
@@ -2404,8 +2539,8 @@
     {
         target->byteArr = (gxByteBuffer*)gxmalloc(sizeof(gxByteBuffer));
         BYTE_BUFFER_INIT(target->byteArr);
-        bb_capacity(target->byteArr, 4);
-        if ((ret = var_getTime(value, target->byteArr)) == 0)
+        if ((ret = bb_capacity(target->byteArr, 4)) == 0 &&
+            (ret = var_getTime(value, target->byteArr)) == 0)
         {
             target->vt = DLMS_DATA_TYPE_OCTET_STRING;
         }
@@ -2554,6 +2689,32 @@
         return target->dblVal;
     }
 #endif //DLMS_IGNORE_FLOAT64
+#ifndef DLMS_IGNORE_DELTA
+    case DLMS_DATA_TYPE_DELTA_INT8:
+    {
+        return target->cVal;
+    }
+    case DLMS_DATA_TYPE_DELTA_INT16:
+    {
+        return target->iVal;
+    }
+    case DLMS_DATA_TYPE_DELTA_INT32:
+    {
+        return target->lVal;
+    }
+    case DLMS_DATA_TYPE_DELTA_UINT8:
+    {
+        return target->bVal;
+    }
+    case DLMS_DATA_TYPE_DELTA_UINT16:
+    {
+        return target->uiVal;
+    }
+    case DLMS_DATA_TYPE_DELTA_UINT32:
+    {
+        return target->ulVal;
+    }
+#endif //DLMS_IGNORE_DELTA
     default:
         break;
     }
@@ -2612,4 +2773,146 @@
     return ret;
 }
 
+#ifndef DLMS_IGNORE_DELTA
+int var_setDeltaUInt8(dlmsVARIANT* data, unsigned char value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_DELTA_UINT8;
+    data->bVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_setDeltaUInt16(dlmsVARIANT* data, uint16_t value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_DELTA_UINT16;
+    data->uiVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_setDeltaUInt32(dlmsVARIANT* data, uint32_t value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_DELTA_UINT32;
+    data->ulVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_setDeltaInt8(dlmsVARIANT* data, char value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_INT8;
+    data->cVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_setDeltaInt16(dlmsVARIANT* data, short value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_DELTA_INT16;
+    data->iVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_setDeltaInt32(dlmsVARIANT* data, int32_t value)
+{
+    var_clear(data);
+    data->vt = DLMS_DATA_TYPE_DELTA_INT32;
+    data->lVal = value;
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaUInt8(dlmsVARIANT* data, unsigned char* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->bVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaUInt16(dlmsVARIANT* data, uint16_t* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->uiVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaUInt32(dlmsVARIANT* data, uint32_t* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->lVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaUInt64(dlmsVARIANT* data, uint64_t* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->ullVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaInt8(dlmsVARIANT* data, char* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->cVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaInt16(dlmsVARIANT* data, short* value)
+{
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->iVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+int var_getDeltaInt32(dlmsVARIANT* data, int32_t* value)
+{
+    var_clear(data);
+    if (data->vt == DLMS_DATA_TYPE_NONE)
+    {
+        *value = 0;
+    }
+    else
+    {
+        *value = data->lVal;
+    }
+    return DLMS_ERROR_CODE_OK;
+}
+
+#endif //DLMS_IGNORE_DELTA
 #endif //!defined(DLMS_IGNORE_STRING_CONVERTER) && defined(DLMS_IGNORE_MALLOC)
