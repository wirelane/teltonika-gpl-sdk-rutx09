diff --recursive --unified --new-file --no-dereference upstream/Makefile src/Makefile
--- upstream/Makefile	2022-10-27 12:48:35.000000000 +0000
+++ src/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,446 +0,0 @@
-#
-# Copyright (C) 2008-2018 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-#
-
-include $(TOPDIR)/rules.mk
-
-PKG_NAME:=ddns-scripts
-# Version == major.minor.patch
-# increase on new functionality (minor) or patches (patch)
-PKG_VERSION:=2.7.8
-# Release == build
-# increase on changes of services files or tld_names.dat
-PKG_RELEASE:=3
-
-PKG_LICENSE:=GPL-2.0
-PKG_MAINTAINER:=
-
-include $(INCLUDE_DIR)/package.mk
-
-# no default dependencies
-PKG_DEFAULT_DEPENDS=
-
-define Package/ddns-scripts/Default
-    SECTION:=net
-    CATEGORY:=Network
-    SUBMENU:=IP Addresses and Names
-    PKGARCH:=all
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts
-    $(call Package/ddns-scripts/Default)
-    TITLE:=Dynamic DNS Client scripts (with IPv6 support)
-endef
-# shown in LuCI package description
-define Package/ddns-scripts/description
-    Dynamic DNS Client scripts (with IPv6 support) - Info: https://openwrt.org/docs/guide-user/services/ddns/client
-endef
-# shown in menuconfig <Help>
-define Package/ddns-scripts/config
-	help
-		A highly configurable set of scripts for doing dynamic dns updates.
-		  - IPv6 support
-		  - DNS server support
-		  - Glue Record support (require BIND host or KNOT host)
-		  - DNS requests via TCP
-		  - Proxy server support
-		  - log file support
-		  - support to run once
-		Version: $(PKG_VERSION)-$(PKG_RELEASE)
-		Info   : https://openwrt.org/docs/guide-user/services/ddns/client
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_cloudflare.com-v4
-    $(call Package/ddns-scripts/Default)
-    TITLE:=CloudFlare.com API v4 (requires cURL)
-    DEPENDS:=ddns-scripts +curl
-endef
-define Package/ddns-scripts_cloudflare.com-v4/description
-    Dynamic DNS Client scripts extension for CloudFlare.com API-v4 (require/install cURL)
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_freedns_42_pl
-    $(call Package/ddns-scripts/Default)
-    TITLE:=DDNS extension for FreeDNS.42.pl (requires cURL)
-    DEPENDS:=ddns-scripts +curl
-endef
-define Package/ddns-scripts_freedns_42_pl/description
-    Dynamic DNS Client scripts extension for freedns.42.pl
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_godaddy.com-v1
-    $(call Package/ddns-scripts/Default)
-    TITLE:=GoDaddy.com (require cURL)
-    DEPENDS:=ddns-scripts +curl
-endef
-define Package/ddns-scripts_godaddy.com-v1/description
-    Dynamic DNS Client scripts extension for GoDaddy.com (require/install cURL)
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_no-ip_com
-    $(call Package/ddns-scripts/Default)
-    TITLE:=DDNS extension for No-IP.com
-    DEPENDS:=ddns-scripts
-endef
-define Package/ddns-scripts_no-ip_com/description
-    Dynamic DNS Client scripts extension for No-IP.com
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_nsupdate
-    $(call Package/ddns-scripts/Default)
-    TITLE:=DDNS extension using Bind nsupdate
-    DEPENDS:=ddns-scripts +bind-client
-endef
-define Package/ddns-scripts_nsupdate/description
-    Dynamic DNS Client scripts extension for direct updates using Bind nsupdate
-endef
-define Package/ddns-scripts_nsupdate/config
-    help
-	The script directly updates a PowerDNS (or maybe bind server) via nsupdate
-	from bind-client package. It requires
-	"option dns_server" to be set to the server to be used by nsupdate.
-	"option username" should be set to the key name and
-	"option password" to the base64 encoded shared secret.
-
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_route53-v1
-    $(call Package/ddns-scripts/Default)
-    TITLE:=Amazon AWS Route 53 API v1
-    DEPENDS:=ddns-scripts +curl +openssl-util
-endef
-define Package/ddns-scripts_route53-v1/description
-	Dynamic DNS Client scripts extension for Amazon AWS Route53. Note: You
-	must also install ca-certificate or ca-bundle.
-	It requires:
-	"option username" to be a valid AWS access key id
-	"option password" to be the matching AWS secret key id
-	"option domain" to contain the hosted zone ID
-endef
-
-###### *************************************************************************
-define Build/Configure
-endef
-define Build/Compile
-	$(CP) ./files $(PKG_BUILD_DIR)
-	# ensure that VERSION inside dynamic_dns_functions.sh reflect PKG_VERSION of Makefile
-	$(SED) '/^VERSION=*/s/.*/VERSION="$(PKG_VERSION)-$(PKG_RELEASE)"/' $(PKG_BUILD_DIR)/files/dynamic_dns_functions.sh
-	# remove comments, white spaces and empty lines
-	for FILE in `find $(PKG_BUILD_DIR)/files -type f`; do \
-		$(SED) 's/^[[:space:]]*//' \
-		-e '/^#[[:space:]]\|^#$$$$/d' \
-		-e 's/[[:space:]]#[[:space:]].*$$$$//' \
-		-e 's/[[:space:]]*$$$$//' \
-		-e '/^\/\/[[:space:]]/d'	\
-		-e '/^[[:space:]]*$$$$/d'	$$$$FILE; \
-	done
-endef
-
-define Package/ddns-scripts/conffiles
-/etc/config/ddns
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts/install
-	$(INSTALL_DIR)  $(1)/etc/uci-defaults
-	$(INSTALL_BIN)  $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns
-	$(INSTALL_DIR)  $(1)/etc/hotplug.d/iface
-	$(INSTALL_BIN)  $(PKG_BUILD_DIR)/files/ddns.hotplug $(1)/etc/hotplug.d/iface/95-ddns
-	$(INSTALL_DIR)  $(1)/etc/init.d
-	$(INSTALL_BIN)  $(PKG_BUILD_DIR)/files/ddns.init $(1)/etc/init.d/ddns
-	$(INSTALL_DIR)  $(1)/etc/config
-	$(INSTALL_CONF) $(PKG_BUILD_DIR)/files/ddns.config $(1)/etc/config/ddns
-
-	$(INSTALL_DIR)  $(1)/etc/ddns
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/files/services* $(1)/etc/ddns
-
-	$(INSTALL_DIR)  $(1)/usr/lib/ddns
-	$(INSTALL_BIN)  $(PKG_BUILD_DIR)/files/dynamic_dns_*.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts/postinst
-	#!/bin/sh
-	# if NOT run buildroot and PKG_UPGRADE then (re)start service if enabled
-	[ -z "$${IPKG_INSTROOT}" -a "$${PKG_UPGRADE}" = "1" ] && {
-		[ -x /etc/uci-defaults/ddns ] && \
-			/etc/uci-defaults/ddns && \
-				rm -f /etc/uci-defaults/ddns >/dev/null 2>&1
-		/etc/init.d/ddns enabled && \
-			/etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts/prerm
-	#!/bin/sh
-	# if run within buildroot exit
-	[ -n "$${IPKG_INSTROOT}" ] && exit 0
-	# stop running scripts
-	/etc/init.d/ddns stop
-	/etc/init.d/ddns disable
-	# clear LuCI indexcache
-	rm -f /tmp/luci-indexcache >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_cloudflare.com-v4/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_cloudflare.com-v4/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_cloudflare.com-v4
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_cloudflare_com_v4.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_cloudflare.com-v4/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/cloudflare\.com-v4/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i '/cloudflare\.com-v4/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"cloudflare.com-v4"' '"update_cloudflare_com_v4.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	printf "%s\\t%s\\n" '"cloudflare.com-v4"' '"update_cloudflare_com_v4.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services_ipv6
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_cloudflare.com-v4 ] && \
-			/etc/uci-defaults/ddns_cloudflare.com-v4 && \
-				rm -f /etc/uci-defaults/ddns_cloudflare.com-v4 >/dev/null 2>&1
-		/etc/init.d/ddns enabled && \
-			/etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_cloudflare.com-v4/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop				>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i '/cloudflare\.com-v4/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i '/cloudflare\.com-v4/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_freedns_42_pl/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_freedns_42_pl/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_freedns_42_pl
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_freedns_42_pl.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_freedns_42_pl/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/freedns\.42\.pl/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"freedns.42.pl"' '"update_freedns_42_pl.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_freedns_42_pl ] && \
-			/etc/uci-defaults/ddns_freedns_42_pl && \
-				rm -f /etc/uci-defaults/ddns_freedns_42_pl >/dev/null 2>&1
-		/etc/init.d/ddns enabled && \
-			/etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_freedns_42_pl/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop		>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i '/freedns\.42\.pl/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_godaddy.com-v1/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_godaddy.com-v1/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_godaddy.com-v1
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_godaddy_com_v1.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_godaddy.com-v1/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/godaddy\.com-v1/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i '/godaddy\.com-v1/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"godaddy.com-v1"' '"update_godaddy_com_v1.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	printf "%s\\t%s\\n" '"godaddy.com-v1"' '"update_godaddy_com_v1.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services_ipv6
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_godaddy.com-v1 ] && \
-			/etc/uci-defaults/ddns_godaddy.com-v1 && \
-				rm -f /etc/uci-defaults/ddns_godaddy.com-v1 >/dev/null 2>&1
-		/etc/init.d/ddns enabled \
-			&& /etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_godaddy.com-v1/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop				>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i '/godaddy\.com-v1/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i '/godaddy\.com-v1/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_no-ip_com/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_no-ip_com/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_no-ip_com
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_no-ip_com.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_no-ip_com/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/no-ip\.com/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"no-ip.com"' '"update_no-ip_com.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_no-ip_com ] && \
-			/etc/uci-defaults/ddns_no-ip_com && \
-				rm -f /etc/uci-defaults/ddns_no-ip_com >/dev/null 2>&1
-		/etc/init.d/ddns enabled && \
-			/etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_no-ip_com/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop		>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i '/no-ip\.com/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_nsupdate/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_nsupdate/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_nsupdate
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_nsupdate.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_nsupdate/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/bind-nsupdate/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	/bin/sed -i '/bind-nsupdate/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"bind-nsupdate"' '"update_nsupdate.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	printf "%s\\t%s\\n" '"bind-nsupdate"' '"update_nsupdate.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services_ipv6
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_nsupdate ] && \
-			/etc/uci-defaults/ddns_nsupdate && \
-				rm -f /etc/uci-defaults/ddns_nsupdate >/dev/null 2>&1
-		/etc/init.d/ddns enabled && \
-			/etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_nsupdate/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop			>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i '/bind-nsupdate/d' $${IPKG_INSTROOT}/etc/ddns/services	>/dev/null 2>&1
-	/bin/sed -i '/bind-nsupdate/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-define Package/ddns-scripts_route53-v1/preinst
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop >/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_route53-v1/install
-	$(INSTALL_DIR) $(1)/etc/uci-defaults
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/ddns.defaults $(1)/etc/uci-defaults/ddns_route53-v1
-	$(INSTALL_DIR) $(1)/usr/lib/ddns
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/files/update_route53_v1.sh $(1)/usr/lib/ddns
-endef
-define Package/ddns-scripts_route53-v1/postinst
-	#!/bin/sh
-	# remove old services file entries
-	/bin/sed -i '/route53-v1/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i '/route53-v1/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	# and create new
-	printf "%s\\t%s\\n" '"route53-v1"' '"update_route53_v1.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services
-	printf "%s\\t%s\\n" '"route53-v1"' '"update_route53_v1.sh"' >> $${IPKG_INSTROOT}/etc/ddns/services_ipv6
-	# on real system restart service if enabled
-	[ -z "$${IPKG_INSTROOT}" ] && {
-		[ -x /etc/uci-defaults/ddns_route53-v1 ] && \
-			/etc/uci-defaults/ddns_route53-v1 && \
-				rm -f /etc/uci-defaults/route53.com-v1 >/dev/null 2>&1
-		/etc/init.d/ddns enabled \
-			&& /etc/init.d/ddns start >/dev/null 2>&1
-	}
-	exit 0	# suppress errors
-endef
-define Package/ddns-scripts_route53-v1/prerm
-	#!/bin/sh
-	# if NOT run buildroot then stop service
-	[ -z "$${IPKG_INSTROOT}" ] && /etc/init.d/ddns stop				>/dev/null 2>&1
-	# remove services file entries
-	/bin/sed -i 'route53-v1/d' $${IPKG_INSTROOT}/etc/ddns/services		>/dev/null 2>&1
-	/bin/sed -i 'route53-v1/d' $${IPKG_INSTROOT}/etc/ddns/services_ipv6	>/dev/null 2>&1
-	exit 0	# suppress errors
-endef
-
-###### *************************************************************************
-$(eval $(call BuildPackage,ddns-scripts))
-$(eval $(call BuildPackage,ddns-scripts_cloudflare.com-v4))
-$(eval $(call BuildPackage,ddns-scripts_freedns_42_pl))
-$(eval $(call BuildPackage,ddns-scripts_godaddy.com-v1))
-$(eval $(call BuildPackage,ddns-scripts_no-ip_com))
-$(eval $(call BuildPackage,ddns-scripts_nsupdate))
-$(eval $(call BuildPackage,ddns-scripts_route53-v1))
diff --recursive --unified --new-file --no-dereference upstream/README.md src/README.md
--- upstream/README.md	1970-01-01 00:00:00.000000000 +0000
+++ src/README.md	2024-09-23 13:25:52.000000000 +0000
@@ -0,0 +1,2 @@
+# ddns-scripts
+
diff --recursive --unified --new-file --no-dereference upstream/files/ddns.config src/files/ddns.config
--- upstream/files/ddns.config	2022-10-27 12:48:35.000000000 +0000
+++ src/files/ddns.config	2024-09-23 13:25:52.000000000 +0000
@@ -1,15 +1,15 @@
 #
-# Please read https://openwrt.org/docs/guide-user/base-system/ddns
+# Please read http://wiki.openwrt.org/doc/uci/ddns
 #
 config ddns "global"
 	option ddns_dateformat "%F %R"
 #	option ddns_rundir "/var/run/ddns"
 #	option ddns_logdir "/var/log/ddns"
 	option ddns_loglines "250"
-	option upd_privateip "0"
+	option upd_privateip "1"
+	option use_curl "1"
 
-
-config service "myddns_ipv4"
+config service "myddns"
 	option service_name	"dyndns.org"
 	option lookup_host	"yourhost.example.com"
 	option domain		"yourhost.example.com"
@@ -18,15 +18,3 @@
 	option interface	"wan"
 	option ip_source	"network"
 	option ip_network	"wan"
-
-config service "myddns_ipv6"
-	option update_url	"http://[USERNAME]:[PASSWORD]@your.provider.net/nic/update?hostname=[DOMAIN]&myip=[IP]"
-	option lookup_host	"yourhost.example.com"
-	option domain		"yourhost.example.com"
-	option username		"your_username"
-	option password		"your_password"
-	option use_ipv6		"1"
-	option interface	"wan6"
-	option ip_source	"network"
-	option ip_network	"wan6"
-
diff --recursive --unified --new-file --no-dereference upstream/files/ddns.defaults src/files/ddns.defaults
--- upstream/files/ddns.defaults	2022-10-27 12:48:35.000000000 +0000
+++ src/files/ddns.defaults	2024-09-23 13:25:52.000000000 +0000
@@ -1,39 +1,39 @@
 #!/bin/sh
 
+. /lib/functions.sh
+
 g_pslfile=/usr/share/public_suffix_list.dat.gz
-[ -f "$g_pslfile" ] || g_pslfile="$(dirname $0)/public_suffix_list.dat.gz"
+[ -f "$g_pslfile" ] || g_pslfile="$(dirname "$0")/public_suffix_list.dat.gz"
 
-g_pslerr=0
+g_pslerr="0"
 g_cfgfile="ddns"
 
 # modify timer settings from interval and unit to dhms format
 timer2dhms() {
 # $1	Number and
 # $2	Unit of time interval
-	local t=0
-	case $2 in
+	local t="0"
+	case "$2" in
 		days)		t=$(( $1 * 86400 ));;
 		hours)		t=$(( $1 * 3600 ));;
 		minutes)	t=$(( $1 * 60 ));;
 		*)		t=$1;;
 	esac
 
-	local d=$(( $t / 86400 ))
-	local h=$(( $t % 86400 / 3600 ))
-	local m=$(( $t % 3600 / 60 ))
-	local s=$(( $t % 60 ))
-	if [ $d -gt 0 ]; then printf "%dd %02dh %02dm %02ds" "$d" "$h" "$m" "$s"
-	elif [ $h -gt 0 ]; then printf "%dh %02dm %02ds" "$h" "$m" "$s"
-	elif [ $m -gt 0 ]; then printf "%dm %02ds" "$m" "$s"
+	local d=$(( t / 86400 ))
+	local h=$(( t % 86400 / 3600 ))
+	local m=$(( t % 3600 / 60 ))
+	local s=$(( t % 60 ))
+	if [ "$d" -gt 0 ]; then printf "%dd %02dh %02dm %02ds" "$d" "$h" "$m" "$s"
+	elif [ "$h" -gt 0 ]; then printf "%dh %02dm %02ds" "$h" "$m" "$s"
+	elif [ "$m" -gt 0 ]; then printf "%dm %02ds" "$m" "$s"
 	else printf "%ds" "$s"; fi
 
 	unset d h m s t
 	return 0
 }
 
-# using function to not confuse function calls with existing ones inside /lib/functions.sh
 update_config() {
-	uc_uci="$(which uci) -q"	# ignore errors
 	uc_cfg=""
 	uc_name=""
 	uc_var=""
@@ -44,16 +44,16 @@
 		uc_name="$2"
 
 		# Type = ddns	Name = global
-		if [ "$uc_cfg" = "$g_cfgfile" -a "$uc_name" = "global" ]; then
+		if [ "$uc_cfg" = "$g_cfgfile" ] && [ "$uc_name" = "global" ]; then
 			option() {
 				uc_var="$1"; shift
 				uc_val="$*"
 				case "$uc_var" in
-					allow_local_ip)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="upd_privateip";;
-					date_format)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_dateformat";;
-					log_lines)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_loglines";;
-					log_dir)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_logdir";;
-					run_dir)	$uc_uci rename $g_cfgfile.$uc_name.$uc_var="ddns_rundir";;
+					allow_local_ip)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "upd_privateip";;
+					date_format)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_dateformat";;
+					log_lines)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_loglines";;
+					log_dir)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_logdir";;
+					run_dir)	uci_rename "$g_cfgfile" "$uc_name" "$uc_var" "ddns_rundir";;
 					# leave all other options currently unchanged
 					*)	;;
 				esac
@@ -70,25 +70,25 @@
 					service_name|upd_provider)
 						case "$uc_val" in
 							freedns\.afraid\.org|afraid\.org)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="afraid.org-keyauth";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "afraid.org-keyauth";;
 							Bind-nsupdate)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="bind-nsupdate";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "bind-nsupdate";;
 							dyndns\.org|dyndns\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="dyn.com";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "dyn.com";;
 							free\.editdns\.net)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="editdns.net";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "editdns.net";;
 							FreeDNS\.42\.pl)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="freedns.42.pl";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "freedns.42.pl";;
 							domains\.google\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="google.com";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "google.com";;
 							loopia\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="loopia.se";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "loopia.se";;
 							NoIP\.com|No-IP\.com)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="no-ip.com";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "no-ip.com";;
 							spdns\.de)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="spdyn.de";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_va" "spdyn.de";;
 							strato\.de)
-								$uc_uci set $g_cfgfile.$uc_name.$uc_var="strato.com";;
+								uci_set "$g_cfgfile" "$uc_name" "$uc_var" "strato.com";;
 							*)
 								# all others leave unchanged
 								;;
@@ -98,13 +98,13 @@
 						;;
 					domain|upd_object)
 						# verify if lookup_host is set
-						$uc_uci get $g_cfgfile.$uc_name.lookup_host >/dev/null 2>&1 || \
-							$uc_uci set $g_cfgfile.$uc_name.lookup_host="$uc_val"
+						uci_get "$g_cfgfile" "$uc_name" "lookup_host" >/dev/null 2>&1 || \
+							uci_set "$g_cfgfile" "$uc_name" "lookup_host" "$uc_val"
 						if [ -f "$g_pslfile" ]; then
 							# if service_name/upd_provider cloudflare_v1 then change domain/upd_object to new syntax
 							# there is no sort order inside uci data so we need multiple checks
-							uco_provider=$($uc_uci get $g_cfgfile.$uc_name.upd_provider 2>/dev/null) || \
-								uco_provider=$($uc_uci get $g_cfgfile.$uc_name.service_name 2>/dev/null)
+							uco_provider=$(uci_get "$g_cfgfile" "$uc_name" "upd_provider" 2>/dev/null) || \
+								uco_provider=$(uci_get "$g_cfgfile" "$uc_name" "service_name" 2>/dev/null)
 							unset uco_provider
 						fi
 						# rename option domain to option upd_object
@@ -162,35 +162,35 @@
 	}
 
 	# read config file
-	uc_data=$($uc_uci -S -n export "$g_cfgfile")
+	uc_data=$(uci -q -S -n export "$g_cfgfile")
 	uc_ret="$?"
 	# Error then create config file
-	[ $uc_ret -ne 0 ] && {
-		touch /etc/config/$uc_cfgfile
-		chmod 644 /etc/config/$uc_cfgfile
+	[ "$uc_ret" -ne 0 ] && {
+		touch "/etc/config/${uc_cfgfile}"
+		chmod 644 "/etc/config/${uc_cfgfile}"
 	}
 	# No error and uc_data then execute (eval)
 	# this will call functions defined above
-	[ $uc_ret -eq 0 -a -n "$uc_data" ] && eval "$uc_data"
+	[ "$uc_ret" -eq 0 ] && [ -n "$uc_data" ] && eval "$uc_data"
 
 	# add config ddns "global" (ignore error if exists)
-	$uc_uci set ddns.global="$g_cfgfile"
+	uci -q set "ddns.global=${g_cfgfile}"
 
 	# write changes to config file
-	$uc_uci commit "$g_cfgfile"
+	uci_commit "$g_cfgfile"
 
 	unset uc_uci uc_cfg uc_name uc_var uc_val uc_ret uc_data
 	return 0
 }
 
 # clear LuCI indexcache
-rm -f /tmp/luci-indexcache >/dev/null 2>&1
+rm -fr /tmp/luci-indexcache/
 
 # do config update
 update_config
 
 #cleanup
-[ $g_pslerr -ne 0 ] && {
+[ "$g_pslerr" -ne 0 ] && {
 	unset g_pslfile g_pslerr g_cfgfile
 	return 1
 }
diff --recursive --unified --new-file --no-dereference upstream/files/ddns.hotplug src/files/ddns.hotplug
--- upstream/files/ddns.hotplug	2022-10-27 12:48:35.000000000 +0000
+++ src/files/ddns.hotplug	2024-09-23 13:25:52.000000000 +0000
@@ -1,11 +1,18 @@
-#!/bin/sh
+#!/bin/sh /etc/rc.common
 
-# there are other ACTIONs like ifupdate we don't need
-case "$ACTION" in
-	ifup)					# OpenWrt is giving a network not phys. Interface
-		/etc/init.d/ddns enabled && /usr/lib/ddns/dynamic_dns_updater.sh -n "$INTERFACE" -- start
-		;;
-	ifdown)
-		/usr/lib/ddns/dynamic_dns_updater.sh -n "$INTERFACE" -- stop
-		;;
-esac
+enabled="0"
+PROG="/usr/lib/ddns/dynamic_dns_updater.sh"
+[ -x "$PROG" ] || PROG="/usr/local$PROG"
+
+check_enabled() {
+	local service="$1"
+	config_get enabled "$service" enabled "0"
+}
+
+config_load ddns
+config_foreach check_enabled service
+
+if [ "$enabled" = "1" ]; then
+    $PROG -- stop
+    $PROG -- start
+fi
diff --recursive --unified --new-file --no-dereference upstream/files/ddns.init src/files/ddns.init
--- upstream/files/ddns.init	2022-10-27 12:48:35.000000000 +0000
+++ src/files/ddns.init	2024-09-23 13:25:52.000000000 +0000
@@ -1,27 +1,39 @@
 #!/bin/sh /etc/rc.common
+
 START=95
 STOP=10
 
-boot() {
-	return 0
+USE_PROCD=1
+STATUS=""
+PROG="/usr/lib/ddns/dynamic_dns_updater.sh"
+[ -x "$PROG" ] || PROG="/usr/local$PROG"
+
+
+check_enabled() {
+        [ "$STATUS" = "1" ] && return
+        config_get STATUS "$1" "enabled"
 }
 
-reload() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- reload
-	return 0
+start_service() {
+        config_load "ddns"
+        config_foreach check_enabled service
+        [ "$STATUS" != "1" ] && return
+
+        procd_open_instance
+        procd_set_param command $PROG -- start
+        procd_close_instance
 }
 
-restart() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- stop
-	sleep 1	# give time to shutdown
-	/usr/lib/ddns/dynamic_dns_updater.sh -- start
+stop_service() {
+        $PROG -- stop
+        sleep 1
 }
 
-start() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- start
+reload_service() {
+        pgrep -f $PROG | xargs kill
+        start
 }
 
-stop() {
-	/usr/lib/ddns/dynamic_dns_updater.sh -- stop
-	return 0
+service_triggers() {
+        procd_add_reload_trigger "ddns"
 }
diff --recursive --unified --new-file --no-dereference upstream/files/dynamic_dns_functions.sh src/files/dynamic_dns_functions.sh
--- upstream/files/dynamic_dns_functions.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/dynamic_dns_functions.sh	2024-09-23 13:25:52.000000000 +0000
@@ -21,10 +21,12 @@
 . /lib/functions/network.sh
 
 # GLOBAL VARIABLES #
-VERSION="2.7.8-2"
+VERSION="2.7.8-5"
 SECTION_ID=""		# hold config's section name
 VERBOSE=0		# default mode is log to console, but easily changed with parameter
 MYPROG=$(basename $0)	# my program call name
+SCRIPTSDIR="/usr/lib/ddns"	# directory for ddns scripts
+[ -d "$SCRIPTSDIR" ] || SCRIPTSDIR="/usr/local/usr/lib/ddns"
 
 LOGFILE=""		# logfile - all files are set in dynamic_dns_updater.sh
 PIDFILE=""		# pid file
@@ -63,6 +65,12 @@
 # IPv6       ( ( 0-9a-f  1-4char ":") min 1x) ( ( 0-9a-f  1-4char   )optional) ( (":" 0-9a-f 1-4char  ) min 1x)
 IPV6_REGEX="\(\([0-9A-Fa-f]\{1,4\}:\)\{1,\}\)\(\([0-9A-Fa-f]\{1,4\}\)\{0,1\}\)\(\(:[0-9A-Fa-f]\{1,4\}\)\{1,\}\)"
 
+# characters that are dangerous to pass to a shell command line
+SHELL_ESCAPE="[\"\'\`\$\!();><{}?|\[\]\*\\\\]"
+
+# dns character set
+DNS_CHARSET="[@a-zA-Z0-9._-]"
+
 # detect if called by ddns-lucihelper.sh script, disable retrys (empty variable == false)
 LUCI_HELPER=$(printf %s "$MYPROG" | grep -i "luci")
 
@@ -78,7 +86,8 @@
 WGET_SSL=$(which wget-ssl)
 
 CURL=$(which curl)
-
+# CURL_SSL not empty then SSL support available
+CURL_SSL=$($CURL -V 2>/dev/null | grep -F "https")
 # CURL_PROXY not empty then Proxy support available
 CURL_PROXY=$(find /lib /usr/lib -name libcurl.so* -exec strings {} 2>/dev/null \; | grep -im1 "all_proxy")
 
@@ -86,7 +95,7 @@
 
 # Global configuration settings
 # allow NON-public IP's
-upd_privateip=$(uci -q get ddns.global.upd_privateip) || upd_privateip=0
+upd_privateip=$(uci -q get ddns.global.upd_privateip) || upd_privateip=1
 
 # directory to store run information to.
 ddns_rundir=$(uci -q get ddns.global.ddns_rundir) || ddns_rundir="/var/run/ddns"
@@ -179,9 +188,9 @@
 		config_get __IFACE "$__SECTIONID" interface "wan"
 		[ -z "$__EVENTIF" -o "$__IFACE" = "$__EVENTIF" ] || continue
 		if [ $VERBOSE -eq 0 ]; then	# start in background
-			/usr/lib/ddns/dynamic_dns_updater.sh -v 0 -S "$__SECTIONID" -- start &
+			$SCRIPTSDIR/dynamic_dns_updater.sh -v 0 -S "$__SECTIONID" -- start &
 		else
-			/usr/lib/ddns/dynamic_dns_updater.sh -v "$VERBOSE" -S "$__SECTIONID" -- start
+			$SCRIPTSDIR/dynamic_dns_updater.sh -v "$VERBOSE" -S "$__SECTIONID" -- start
 		fi
 	done
 }
@@ -234,18 +243,18 @@
 		__EXIT=0
 	}
 	shift	# remove loglevel
-	[ $__EXIT -eq 0 ] && __MSG="$*" || __MSG="$* - TERMINATE"
+	[ $__EXIT -eq 0 ] && __MSG="$*" || __MSG="$* - terminate"
 	case $__LEVEL in		# create log message and command depending on loglevel
 		0)	__CMD="logger -p user.emerg -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME EMERG : $__MSG" ;;
+			__MSG=" $__TIME emerg : $__MSG" ;;
 		1)	__CMD="logger -p user.alert -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME ALERT : $__MSG" ;;
+			__MSG=" $__TIME alert : $__MSG" ;;
 		2)	__CMD="logger -p user.crit -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  CRIT : $__MSG" ;;
+			__MSG=" $__TIME  crit : $__MSG" ;;
 		3)	__CMD="logger -p user.err -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME ERROR : $__MSG" ;;
+			__MSG=" $__TIME error : $__MSG" ;;
 		4)	__CMD="logger -p user.warn -t ddns-scripts[$$] $SECTION_ID: $__MSG"
-			__MSG=" $__TIME  WARN : $__MSG" ;;
+			__MSG=" $__TIME  warn : $__MSG" ;;
 		5)	__CMD="logger -p user.notice -t ddns-scripts[$$] $SECTION_ID: $__MSG"
 			__MSG=" $__TIME  note : $__MSG" ;;
 		6)	__CMD="logger -p user.info -t ddns-scripts[$$] $SECTION_ID: $__MSG"
@@ -275,11 +284,11 @@
 	[ $__LEVEL -eq 7 ] && return	# no syslog for debug messages
 	__CMD=$(echo -e "$__CMD" | tr -d '\n' | tr '\t' '     ')        # remove \n \t chars
 	[ $__EXIT  -eq 1 ] && {
-		$__CMD		# force syslog before exit
+		eval "$__CMD"	# force syslog before exit
 		exit 1
 	}
 	[ $use_syslog -eq 0 ] && return
-	[ $((use_syslog + __LEVEL)) -le 7 ] && $__CMD
+	[ $((use_syslog + __LEVEL)) -le 7 ] && eval "$__CMD"
 
 	return
 }
@@ -294,32 +303,12 @@
 urlencode() {
 	# $1	Name of Variable to store encoded string to
 	# $2	string to encode
-	local __STR __LEN __CHAR __OUT
-	local __ENC=""
-	local __POS=1
+	local __ENC
 
 	[ $# -ne 2 ] && write_log 12 "Error calling 'urlencode()' - wrong number of parameters"
 
-	__STR="$2"		# read string to encode
-	__LEN=${#__STR}		# get string length
-
-	while [ $__POS -le $__LEN ]; do
-		# read one chat of the string
-		__CHAR=$(expr substr "$__STR" $__POS 1)
-
-		case "$__CHAR" in
-		        [-_.~a-zA-Z0-9] )
-				# standard char
-				__OUT="${__CHAR}"
-				;;
-		        * )
-				# special char get %hex code
-		               __OUT=$(printf '%%%02x' "'$__CHAR" )
-				;;
-		esac
-		__ENC="${__ENC}${__OUT}"	# append to encoded string
-		__POS=$(( $__POS + 1 ))		# increment position
-	done
+	__ENC="$(awk -v str="$2" 'BEGIN{ORS="";for(i=32;i<=127;i++)lookup[sprintf("%c",i)]=i
+		for(k=1;k<=length(str);++k){enc=substr(str,k,1);if(enc!~"[-_.~a-zA-Z0-9]")enc=sprintf("%%%02x", lookup[enc]);print enc}}')"
 
 	eval "$1=\"$__ENC\""	# transfer back to variable
 	return 0
@@ -347,7 +336,7 @@
 		if [ "$__SERVICE" = "$service_name" ]; then
 			# check if URL or SCRIPT is given
 			__URL=$(echo "$__DATA" | grep "^http")
-			[ -z "$__URL" ] && __SCRIPT="/usr/lib/ddns/$__DATA"
+			[ -z "$__URL" ] && __SCRIPT="$SCRIPTSDIR/$__DATA"
 
 			eval "$1=\"$__URL\""
 			eval "$2=\"$__SCRIPT\""
@@ -474,6 +463,27 @@
 	return $status
 }
 
+# sanitize a variable
+# $1	variable name
+# $2	allowed shell pattern
+# $3	disallowed shell pattern
+sanitize_variable() {
+	local __VAR=$1
+	eval __VALUE=\$$__VAR
+	local __ALLOWED=$2
+	local __REJECT=$3
+
+	# removing all allowed should give empty string
+	if [ -n "$__ALLOWED" ]; then
+		[ -z "${__VALUE//$__ALLOWED}" ] || write_log 12 "sanitize on $__VAR found characters outside allowed subset"
+	fi
+
+	# removing rejected pattern should give the same string as the input
+	if [ -n "$__REJECT" ]; then
+		[ "$__VALUE" = "${__VALUE//$__REJECT}" ] || write_log 12 "sanitize on $__VAR found rejected characters"
+	fi
+}
+
 # verify given host and port is connectable
 # $1	Host/IP to verify
 # $2	Port to verify
@@ -726,8 +736,6 @@
 	# 2nd choice is cURL IPv4/IPv6/HTTPS
 	# libcurl might be compiled without Proxy or HTTPS Support
 	elif [ -n "$CURL" ]; then
-		# CURL_SSL not empty then SSL support available
-		CURL_SSL=$($(which curl) -V 2>/dev/null | grep "Protocols:" | grep -F "https")
 		__PROG="$CURL -RsS -o $DATFILE --stderr $ERRFILE"
 		# check HTTPS support
 		[ -z "$CURL_SSL" -a $use_https -eq 1 ] && \
@@ -902,16 +910,28 @@
 	write_log 7 "Detect local IP on '$ip_source'"
 
 	while : ; do
-		if [ -n "$ip_network" ]; then
+		if [ -n "$ip_network" -a "$ip_source" = "network" ]; then
 			# set correct program
 			network_flush_cache	# force re-read data from ubus
 			[ $use_ipv6 -eq 0 ] && __RUNPROG="network_get_ipaddr" \
-					    || __RUNPROG="network_get_ipaddr6"
-			eval "$__RUNPROG __DATA $ip_network" || \
-				write_log 13 "Can not detect local IP using $__RUNPROG '$ip_network' - Error: '$?'"
+						|| __RUNPROG="network_get_ipaddr6"
+			write_log 7 "#> $__RUNPROG __DATA '$ip_network'"
+
+			ifconfig_name=`ubus call network.interface.$ip_network status | grep -m 1 "device" | cut -f 4 -d '"' | tr -d $'\n'`
+			ifconfig_ip=`ifconfig | grep -A1 $ifconfig_name | grep 'inet addr:' | cut -f 2 -d ':' | cut -f 1 -d ' ' | tr -d $'\n'`
+			write_log 7 "ifconfig_name=$ifconfig_name; ifconfig_ip=$ifconfig_ip"
+
+			eval "$__RUNPROG __DATA $ip_network" || [ -n "$ifconfig_ip" ] && __DATA="$ifconfig_ip" && write_log 7 "Used ifconfig IP $ifconfig_ip instead" || write_log 3 "$__RUNPROG Error: '$?'"
 			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on network '$ip_network'"
-		elif [ -n "$ip_interface" ]; then
+		elif [ -n "$ip_interface" -a "$ip_source" = "interface" ]; then
 			local __DATA4=""; local __DATA6=""
+			ip_interface=""
+			for i in $(route -n | awk '$4 == "UG" {print $8,"\n"}' | tr -d $'\n'); do
+                res=$(ping -c 1 -I $i 8.8.8.8 > /dev/null 2> /dev/null; echo $?)
+                if [ "$res" = "0" -a -z "$ip_interface" ]; then
+                    ip_interface=$i
+                fi
+            done
 			if [ -n "$(which ip)" ]; then		# ip program installed
 				write_log 7 "#> ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE"
 				ip -o addr show dev $ip_interface scope global >$DATFILE 2>$ERRFILE
@@ -989,7 +1009,7 @@
 			fi
 			[ $use_ipv6 -eq 0 ] && __DATA="$__DATA4" || __DATA="$__DATA6"
 			[ -n "$__DATA" ] && write_log 7 "Local IP '$__DATA' detected on interface '$ip_interface'"
-		elif [ -n "$ip_script" ]; then
+		elif [ -n "$ip_script" -a "$ip_source" = "script" ]; then
 			write_log 7 "#> $ip_script >$DATFILE 2>$ERRFILE"
 			eval $ip_script >$DATFILE 2>$ERRFILE
 			__ERR=$?
@@ -1000,7 +1020,7 @@
 				write_log 3 "$ip_script Error: '$__ERR'"
 				write_log 7 "$(cat $ERRFILE)"		# report error
 			fi
-		elif [ -n "$ip_url" ]; then
+		elif [ -n "$ip_url" -a "$ip_source" = "web" ]; then
 			do_transfer "$ip_url"
 			# use correct regular expression
 			[ $use_ipv6 -eq 0 ] \
@@ -1204,17 +1224,17 @@
 
 	case $1 in
 		 0)	if [ $__ERR -eq 0 ]; then
-				write_log 5 "PID '$$' exit normal at $(eval $DATE_PROG)${N}"
+				write_log 5 "pid '$$' exit normal at $(eval $DATE_PROG)${N}"
 			else
-				write_log 4 "PID '$$' exit WITH ERROR '$__ERR' at $(eval $DATE_PROG)${N}"
+				write_log 4 "pid '$$' exit with error '$__ERR' at $(eval $DATE_PROG)${N}"
 			fi ;;
-		 1)	write_log 6 "PID '$$' received 'SIGHUP' at $(eval $DATE_PROG)"
+		 1)	write_log 6 "pid '$$' received 'sighup' at $(eval $DATE_PROG)"
 			# reload config via starting the script again
-			/usr/lib/ddns/dynamic_dns_updater.sh -v "0" -S "$__SECTIONID" -- start || true
+			$SCRIPTSDIR/dynamic_dns_updater.sh -v "0" -S "$__SECTIONID" -- start || true
 			exit 0 ;;	# and leave this one
-		 2)	write_log 5 "PID '$$' terminated by 'SIGINT' at $(eval $DATE_PROG)${N}";;
-		 3)	write_log 5 "PID '$$' terminated by 'SIGQUIT' at $(eval $DATE_PROG)${N}";;
-		15)	write_log 5 "PID '$$' terminated by 'SIGTERM' at $(eval $DATE_PROG)${N}";;
+		 2)	write_log 5 "pid '$$' terminated by 'sigint' at $(eval $DATE_PROG)${N}";;
+		 3)	write_log 5 "pid '$$' terminated by 'sigquit' at $(eval $DATE_PROG)${N}";;
+		15)	write_log 5 "pid '$$' terminated by 'sigterm' at $(eval $DATE_PROG)${N}";;
 		 *)	write_log 13 "Unhandled signal '$1' in 'trap_handler()'";;
 	esac
 
diff --recursive --unified --new-file --no-dereference upstream/files/dynamic_dns_lucihelper.sh src/files/dynamic_dns_lucihelper.sh
--- upstream/files/dynamic_dns_lucihelper.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/dynamic_dns_lucihelper.sh	2024-09-23 13:25:52.000000000 +0000
@@ -10,7 +10,8 @@
 # variables in big chars beginning with "__" are local defined inside functions only
 # set -vx  	#script debugger
 
-. /usr/lib/ddns/dynamic_dns_functions.sh	# global vars are also defined here
+[ -e "/usr/lib/ddns" ] && . /usr/lib/ddns/dynamic_dns_functions.sh # global vars are also defined here
+[ -e "/usr/local/usr/lib/ddns" ] && . /usr/local/usr/lib/ddns/dynamic_dns_functions.sh
 
 usage() {
 	cat << EOF
@@ -60,7 +61,7 @@
 LOGFILE="$ddns_logdir/$SECTION_ID.log"
 DATFILE="$ddns_rundir/$SECTION_ID.$$.dat"	# save stdout data of WGet and other extern programs called
 ERRFILE="$ddns_rundir/$SECTION_ID.$$.err"	# save stderr output of WGet and other extern programs called
-DDNSPRG="/usr/lib/ddns/dynamic_dns_updater.sh"
+DDNSPRG="$SCRIPTSDIR/dynamic_dns_updater.sh"
 VERBOSE=0		# no console logging
 # global variables normally set by reading DDNS UCI configuration
 use_syslog=0		# no syslog
@@ -124,7 +125,7 @@
 		__RET=$?
 		;;
 	get_local_ip)
-		[ -z "$ip_source" ] && usage_err "command 'get_local_ip': 'ip_source' not set" 
+		[ -z "$ip_source" ] && usage_err "command 'get_local_ip': 'ip_source' not set"
 		[ -n "$proxy" -a "$ip_source" = "web" ] && {
 			# proxy defined, used for ip_source=web
 			export HTTP_PROXY="http://$proxy"
diff --recursive --unified --new-file --no-dereference upstream/files/dynamic_dns_updater.sh src/files/dynamic_dns_updater.sh
--- upstream/files/dynamic_dns_updater.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/dynamic_dns_updater.sh	2024-09-23 13:25:52.000000000 +0000
@@ -193,7 +193,7 @@
 [ "$ip_source" = "network" -a -z "$ip_network" -a $use_ipv6 -eq 1 ] && ip_network="wan6" # IPv6: default wan6
 [ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 0 ] && ip_url="http://checkip.dyndns.com"
 [ "$ip_source" = "web" -a -z "$ip_url" -a $use_ipv6 -eq 1 ] && ip_url="http://checkipv6.dyndns.com"
-[ "$ip_source" = "interface" -a -z "$ip_interface" ] && ip_interface="eth1"
+[ "$ip_source" = "interface" ] && ip_interface="auto"
 
 # url encode username (might be email or something like this)
 # and password (might have special chars for security reason)
@@ -207,27 +207,27 @@
 	[ $VERBOSE -le 1 ] && VERBOSE=2		# force console out and logfile output
 	[ -f $LOGFILE ] && rm -f $LOGFILE	# clear logfile before first entry
 	write_log  7 "************ ************** ************** **************"
-	write_log  5 "PID '$$' started at $(eval $DATE_PROG)"
+	write_log  5 "pid '$$' started at $(eval $DATE_PROG)"
 	write_log  7 "ddns version  : $VERSION"
 	write_log  7 "uci configuration:${N}$(uci -q show ddns | grep '=service' | sort)"
 	write_log 14 "Service section '$SECTION_ID' not defined"
 }
 
 write_log 7 "************ ************** ************** **************"
-write_log 5 "PID '$$' started at $(eval $DATE_PROG)"
+write_log 5 "pid '$$' started at $(eval $DATE_PROG)"
 write_log 7 "ddns version  : $VERSION"
 write_log 7 "uci configuration:${N}$(uci -q show ddns.$SECTION_ID | sort)"
 # write_log 7 "ddns version  : $(opkg list-installed ddns-scripts | cut -d ' ' -f 3)"
 case $VERBOSE in
-	0) write_log  7 "verbose mode  : 0 - run normal, NO console output";;
+	0) write_log  7 "verbose mode  : 0 - run normal, no console output";;
 	1) write_log  7 "verbose mode  : 1 - run normal, console mode";;
-	2) write_log  7 "verbose mode  : 2 - run once, NO retry on error";;
-	3) write_log  7 "verbose mode  : 3 - run once, NO retry on error, NOT sending update";;
+	2) write_log  7 "verbose mode  : 2 - run once, no retry on error";;
+	3) write_log  7 "verbose mode  : 3 - run once, no retry on error, not sending update";;
 	*) write_log 14 "error detecting VERBOSE '$VERBOSE'";;
 esac
 
 # check enabled state otherwise we don't need to continue
-[ $enabled -eq 0 ] && write_log 14 "Service section disabled!"
+[ $enabled -eq 0 ] && write_log 14 "service section disabled"
 
 # determine what update url we're using if a service_name is supplied
 # otherwise update_url is set inside configuration (custom update url)
@@ -247,6 +247,15 @@
 # without lookup host and possibly other required options we can do nothing for you
 [ -z "$lookup_host" ] && write_log 14 "Service section not configured correctly! Missing 'lookup_host'"
 
+# verify validity of variables
+[ -n "$lookup_host" ] && sanitize_variable lookup_host "$DNS_CHARSET" ""
+[ -n "$dns_server" ] && sanitize_variable dns_server "$DNS_CHARSET" ""
+[ -n "$domain" ] && sanitize_variable domain "$DNS_CHARSET" ""
+
+# Filter shell escape characters, if these are required in the URL, they
+# can still be passed url encoded
+[ -n "$param_opt" ] && sanitize_variable param_opt "" "$SHELL_ESCAPE"
+
 [ -n "$update_url" ] && {
 	# only check if update_url is given, update_scripts have to check themselves
 	[ -z "$domain" ] && $(echo "$update_url" | grep "\[DOMAIN\]" >/dev/null 2>&1) && \
@@ -329,6 +338,8 @@
 
 # loop endlessly, checking ip every check_interval and forcing an updating once every force_interval
 write_log 6 "Starting main loop at $(eval $DATE_PROG)"
+SLEEP_TIME=0
+SLEEP_AFTER_FORCE=0
 while : ; do
 
 	get_local_ip LOCAL_IP		# read local IP
@@ -381,8 +392,22 @@
 	# now we wait for check interval before testing if update was recognized
 	# only sleep if VERBOSE <= 2 because otherwise nothing was send
 	[ $VERBOSE -le 2 ] && {
-		write_log 7 "Waiting $CHECK_SECONDS seconds (Check Interval)"
-		sleep $CHECK_SECONDS &
+		SLEEP_TIME=`expr $SLEEP_TIME + $CHECK_SECONDS`
+        if [ $SLEEP_TIME -ge $FORCE_SECONDS ]; then
+            sleep2=`expr $SLEEP_TIME - $CHECK_SECONDS`
+            SLEEP_AFTER_FORCE=`expr $FORCE_SECONDS - $sleep2`
+            write_log 7 "Waiting $SLEEP_AFTER_FORCE seconds (force interval)"
+		    sleep $SLEEP_AFTER_FORCE &
+		    SLEEP_TIME=0
+		elif [ $SLEEP_AFTER_FORCE -ne 0 ]; then
+		    write_log 7 "Waiting `expr $CHECK_SECONDS - $SLEEP_AFTER_FORCE` seconds (after force interval)"
+		    SLEEP_TIME=`expr $CHECK_SECONDS - $SLEEP_AFTER_FORCE`
+		    sleep $SLEEP_TIME &
+		    SLEEP_AFTER_FORCE=0
+		else
+		    write_log 7 "Waiting $CHECK_SECONDS seconds (check interval)"
+		    sleep $CHECK_SECONDS &
+		fi
 		PID_SLEEP=$!
 		wait $PID_SLEEP	# enable trap-handler
 		PID_SLEEP=0
diff --recursive --unified --new-file --no-dereference upstream/files/services src/files/services
--- upstream/files/services	2022-10-27 12:48:35.000000000 +0000
+++ src/files/services	2024-09-23 13:25:52.000000000 +0000
@@ -43,13 +43,15 @@
 
 "able.or.kr"		"http://able.or.kr/ddns/src/update.php?hostname=[DOMAIN]&myip=[IP]&ddnsuser=[USERNAME]&pwd=[PASSWORD]"
 
-"afraid.org-basicauth"	"https://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-"afraid.org-keyauth"	"https://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
-"afraid.org-v2-basic"	"https://[USERNAME]:[PASSWORD]@sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
-"afraid.org-v2-token"	"https://sync.afraid.org/u/[PASSWORD]/?address=[IP]"
+"afraid.org-basicauth"	"http://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+"afraid.org-keyauth"	"http://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
+"afraid.org-v2-basic"	"http://[USERNAME]:[PASSWORD]@sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
+"afraid.org-v2-token"	"http://sync.afraid.org/u/[PASSWORD]/?address=[IP]"
 
 "all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
 
+"binero.se" 		"http://[USERNAME]:[PASSWORD]@dyndns.binero.se/nic/update?hostname=[DOMAIN]&myip=[IP]"
+
 "changeip.com"		"http://[USERNAME]:[PASSWORD]@nic.changeip.com/nic/update?u=[USERNAME]&p=[PASSWORD]&cmd=update&hostname=[DOMAIN]&ip=[IP]"	"Successful"
 
 "core-networks.de"	"http://[USERNAME]:[PASSWORD]@dyndns.core-networks.de/?hostname=[DOMAIN]&myip=[IP]&keepipv6=1"	"good"
@@ -152,11 +154,14 @@
 
 "schokokeks.org"	"http://[USERNAME]:[PASSWORD]@dyndns.schokokeks.org/nic/update?myip=[IP]"	"good|nochg"
 
+"secure.camera"	"http://[USERNAME]:[PASSWORD]@secure.camera/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+
 "selfhost.de"		"http://carol.selfhost.de/update?username=[USERNAME]&password=[PASSWORD]&myip=[IP]&hostname=1"	"good|nochg|200|204"
 
 "sitelutions.com"	"http://www.sitelutions.com/dnsup?user=[USERNAME]&pass=[PASSWORD]&id=[DOMAIN]&ip=[IP]"	"success"
 
 "spdyn.de"		"http://[USERNAME]:[PASSWORD]@update.spdyn.de/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
+"spdns.de"	"http://[USERNAME]:[PASSWORD]@update.spdns.de/nic/update?hostname=[DOMAIN]&myip=[IP]"
 
 "strato.com"		"http://[USERNAME]:[PASSWORD]@dyndns.strato.com/nic/update?hostname=[DOMAIN]&myip=[IP]"	"good|nochg"
 
diff --recursive --unified --new-file --no-dereference upstream/files/services_ipv6 src/files/services_ipv6
--- upstream/files/services_ipv6	2022-10-27 12:48:35.000000000 +0000
+++ src/files/services_ipv6	2024-09-23 13:25:52.000000000 +0000
@@ -38,10 +38,10 @@
 #.no-ip.com / noip.com	!!! Please install additional package "ddns-scripts_no-ip_com"
 #.route53-v1		!!! Please install additional package "ddns-scripts_route53-v1"
 
-"afraid.org-basicauth"	"https://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
-"afraid.org-keyauth"	"https://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
-"afraid.org-v2-basic"	"https://[USERNAME]:[PASSWORD]@v6.sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
-"afraid.org-v2-token"	"https://v6.sync.afraid.org/u/[PASSWORD]/?address=[IP]"
+"afraid.org-basicauth"	"http://[USERNAME]:[PASSWORD]@freedns.afraid.org/nic/update?hostname=[DOMAIN]&myip=[IP]"
+"afraid.org-keyauth"	"http://freedns.afraid.org/dynamic/update.php?[PASSWORD]&address=[IP]"
+"afraid.org-v2-basic"	"http://[USERNAME]:[PASSWORD]@v6.sync.afraid.org/u/?h=[DOMAIN]&ip=[IP]"
+"afraid.org-v2-token"	"http://v6.sync.afraid.org/u/[PASSWORD]/?address=[IP]"
 
 "all-inkl.com"		"http://[USERNAME]:[PASSWORD]@dyndns.kasserver.com/?myip=[IP]"
 
diff --recursive --unified --new-file --no-dereference upstream/files/update_cloudflare_com_v4.sh src/files/update_cloudflare_com_v4.sh
--- upstream/files/update_cloudflare_com_v4.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/update_cloudflare_com_v4.sh	2024-09-23 13:25:52.000000000 +0000
@@ -15,7 +15,7 @@
 # option password  - cloudflare api key, you can get it from cloudflare.com/my-account/
 # option domain    - "hostname@yourdomain.TLD"	# syntax changed to remove split_FQDN() function and tld_names.dat.gz
 #
-# The proxy status would not be changed by this script. Please change it in Cloudflare dashboard manually. 
+# The proxy status would not be changed by this script. Please change it in Cloudflare dashboard manually.
 #
 # variable __IP already defined with the ip-address to use for update
 #
@@ -29,6 +29,7 @@
 # used variables
 local __HOST __DOMAIN __TYPE __URLBASE __PRGBASE __RUNPROG __DATA __IPV6 __ZONEID __RECID __PROXIED
 local __URLBASE="https://api.cloudflare.com/client/v4"
+local __TTL=120
 
 # split __HOST __DOMAIN from $domain
 # given data:
@@ -84,7 +85,7 @@
 	done
 
 	# check for error
-	grep -q '"success":true' $DATFILE || {
+	grep -q '"success":\s*true' $DATFILE || {
 		write_log 4 "CloudFlare reported an error:"
 		write_log 7 "$(cat $DATFILE)"		# report error
 		return 1	# HTTP-Fehler
@@ -124,16 +125,20 @@
 	write_log 13 "cURL: libcurl compiled without Proxy support"
 fi
 # set headers
-__PRGBASE="$__PRGBASE --header 'X-Auth-Email: $username' "
-__PRGBASE="$__PRGBASE --header 'X-Auth-Key: $password' "
+if [ "$username" = "Bearer" ]; then
+  write_log 7 "Found Username 'Bearer' using Password as Bearer Authorization Token"
+  __PRGBASE="$__PRGBASE --header 'Authorization: Bearer $password' "
+else
+  __PRGBASE="$__PRGBASE --header 'X-Auth-Email: $username' "
+  __PRGBASE="$__PRGBASE --header 'X-Auth-Key: $password' "
+fi
 __PRGBASE="$__PRGBASE --header 'Content-Type: application/json' "
-# __PRGBASE="$__PRGBASE --header 'Accept: application/json' "
 
 # read zone id for registered domain.TLD
 __RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones?name=$__DOMAIN'"
 cloudflare_transfer || return 1
 # extract zone id
-__ZONEID=$(grep -o '"id":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+__ZONEID=$(grep -o '"id":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
 [ -z "$__ZONEID" ] && {
 	write_log 4 "Could not detect 'zone id' for domain.tld: '$__DOMAIN'"
 	return 127
@@ -143,14 +148,14 @@
 __RUNPROG="$__PRGBASE --request GET '$__URLBASE/zones/$__ZONEID/dns_records?name=$__HOST&type=$__TYPE'"
 cloudflare_transfer || return 1
 # extract record id
-__RECID=$(grep -o '"id":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+__RECID=$(grep -o '"id":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
 [ -z "$__RECID" ] && {
 	write_log 4 "Could not detect 'record id' for host.domain.tld: '$__HOST'"
 	return 127
 }
 
 # extract current stored IP
-__DATA=$(grep -o '"content":"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
+__DATA=$(grep -o '"content":\s*"[^"]*' $DATFILE | grep -o '[^"]*$' | head -1)
 
 # check data
 [ $use_ipv6 -eq 0 ] \
@@ -178,11 +183,11 @@
 # update is needed
 # let's build data to send
 # set proxied parameter
-__PROXIED=$(grep -o '"proxied":[^",]*' $DATFILE | grep -o '[^:]*$')
+__PROXIED=$(grep -o '"proxied":\s*[^",]*' $DATFILE | grep -o '[^:]*$')
 
 # use file to work around " needed for json
 cat > $DATFILE << EOF
-{"id":"$__ZONEID","type":"$__TYPE","name":"$__HOST","content":"$__IP","proxied":$__PROXIED}
+{"id":"$__ZONEID","type":"$__TYPE","name":"$__HOST","content":"$__IP","ttl":$__TTL,"proxied":$__PROXIED}
 EOF
 
 # let's complete transfer command
@@ -190,4 +195,3 @@
 cloudflare_transfer || return 1
 
 return 0
-
diff --recursive --unified --new-file --no-dereference upstream/files/update_no-ip_com.sh src/files/update_no-ip_com.sh
--- upstream/files/update_no-ip_com.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/update_no-ip_com.sh	2024-09-23 13:25:52.000000000 +0000
@@ -9,31 +9,31 @@
 # provider did not reactivate records, if no IP change was recognized
 # so we send a dummy (localhost) and a seconds later we send the correct IP addr
 #
-local __DUMMY
+# local __DUMMY
 local __UPDURL="http://[USERNAME]:[PASSWORD]@dynupdate.no-ip.com/nic/update?hostname=[DOMAIN]&myip=[IP]"
 # inside url we need username and password
 [ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing 'username'"
 [ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing 'password'"
 
 # set IP version dependend dummy (localhost)
-[ $use_ipv6 -eq 0 ] && __DUMMY="127.0.0.1" || __DUMMY="::1"
+# [ $use_ipv6 -eq 0 ] && __DUMMY="127.0.0.1" || __DUMMY="::1"
 
 # lets do DUMMY transfer
-write_log 7 "sending dummy IP to 'no-ip.com'"
-__URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
-			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__DUMMY#g")
-[ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
+# write_log 7 "sending dummy IP to 'no-ip.com'"
+# __URL=$(echo $__UPDURL | sed -e "s#\[USERNAME\]#$URL_USER#g" -e "s#\[PASSWORD\]#$URL_PASS#g" \
+# 			       -e "s#\[DOMAIN\]#$domain#g" -e "s#\[IP\]#$__DUMMY#g")
+# [ $use_https -ne 0 ] && __URL=$(echo $__URL | sed -e 's#^http:#https:#')
 
-do_transfer "$__URL" || return 1
+# do_transfer "$__URL" || return 1
 
-write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
+# write_log 7 "'no-ip.com' answered:${N}$(cat $DATFILE)"
 # analyse provider answers
 # "good [IP_ADR]"	= successful
 # "nochg [IP_ADR]"	= no change but OK
-grep -E "good|nochg" $DATFILE >/dev/null 2>&1 || return 1
+# grep -E "good|nochg" $DATFILE >/dev/null 2>&1 || return 1
 
 # lets wait a seconds
-sleep 1
+# sleep 1
 
 # now send the correct data
 write_log 7 "sending real IP to 'no-ip.com'"
diff --recursive --unified --new-file --no-dereference upstream/files/update_nsupdate.sh src/files/update_nsupdate.sh
--- upstream/files/update_nsupdate.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/update_nsupdate.sh	2024-09-23 13:25:52.000000000 +0000
@@ -19,8 +19,9 @@
 local __RRTYPE __PW __TCP
 local __PROG=$(which nsupdate)			# BIND nsupdate ?
 [ -z "$__PROG" ] && __PROG=$(which knsupdate)	# Knot nsupdate ?
+[ -z "$__PROG" ] && __PROG=$(which snsupdate)	# Small nsupdate ?
 
-[ -z "$__PROG" ]     && write_log 14 "'nsupdate' or 'knsupdate' not installed !"
+[ -z "$__PROG" ]     && write_log 14 "'nsupdate' or 'knsupdate' or 'snsupdate' not installed !"
 [ -z "$username" ]   && write_log 14 "Service section not configured correctly! Missing 'username'"
 [ -z "$password" ]   && write_log 14 "Service section not configured correctly! Missing 'password'"
 [ -z "$dns_server" ] && write_log 14 "Service section not configured correctly! Missing 'dns_server'"
@@ -43,6 +44,6 @@
 $__PROG -d $__TCP $DATFILE >$ERRFILE 2>&1
 
 # nsupdate always return success
-write_log 7 "(k)nsupdate reports:${N}$(cat $ERRFILE)"
+write_log 7 "(s/k)nsupdate reports:${N}$(cat $ERRFILE)"
 
 return 0
diff --recursive --unified --new-file --no-dereference upstream/files/update_route53_v1.sh src/files/update_route53_v1.sh
--- upstream/files/update_route53_v1.sh	2022-10-27 12:48:35.000000000 +0000
+++ src/files/update_route53_v1.sh	2024-09-23 13:25:52.000000000 +0000
@@ -1,46 +1,44 @@
 #!/bin/sh
-#.Distributed under the terms of the GNU General Public License (GPL) version 2.0
-#.based on Yuval Adam's route53.sh found at https://github.com/yuvadm/route53-ddns/blob/master/route53.sh
-#.2017 Max Berger <max at berger dot name>
-[ -z "$CURL_SSL" ] && write_log 14 "Amazon AWS Route53 communication require cURL with SSL support. Please install"
-[ -z "$username" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
-[ -z "$password" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
-[ -z "$domain" ] && write_log 14 "Service section not configured correctly! Missing zone id as 'domain'"
-
-set -euo pipefail
-IFS=$'\n\t'
+# Distributed under the terms of the GNU General Public License (GPL) version 2.0
+# based on Yuval Adam's route53.sh found at https://github.com/yuvadm/route53-ddns/blob/master/route53.sh
+# 2017 Max Berger <max at berger dot name>
+
+[ -z "${CURL_SSL}" ] && write_log 14 "Amazon AWS Route53 communication require cURL with SSL support. Please install"
+[ -z "{$username}" ] && write_log 14 "Service section not configured correctly! Missing key as 'username'"
+[ -z "${password}" ] && write_log 14 "Service section not configured correctly! Missing secret as 'password'"
+[ -z "${domain}" ] && write_log 14 "Service section not configured correctly! Missing zone id as 'domain'"
 
 ENDPOINT="route53.amazonaws.com"
 RECORD_TTL=300
-RECORD_NAME="$lookup_host".
-[ $use_ipv6 -eq 0 ] && RECORD_TYPE="A"
-[ $use_ipv6 -eq 1 ] && RECORD_TYPE="AAAA"
-RECORD_VALUE="$LOCAL_IP"
-HOSTED_ZONE_ID="$domain"
+RECORD_NAME="${lookup_host}."
+[ ${use_ipv6} -eq 0 ] && RECORD_TYPE="A"
+[ ${use_ipv6} -eq 1 ] && RECORD_TYPE="AAAA"
+RECORD_VALUE="${LOCAL_IP}"
+HOSTED_ZONE_ID="${domain}"
 API_PATH="/2013-04-01/hostedzone/${HOSTED_ZONE_ID}/rrset/"
 
-AWS_ACCESS_KEY_ID="$username"
-AWS_SECRET_ACCESS_KEY="$password"
+AWS_ACCESS_KEY_ID="${username}"
+AWS_SECRET_ACCESS_KEY="${password}"
 AWS_REGION='us-east-1'
 AWS_SERVICE='route53'
 
 hash() {
-    msg=$1
-    echo -en "$msg" | openssl dgst -sha256 | sed 's/^.* //'
+    msg="$1"
+    echo -en "${msg}" | openssl dgst -sha256 | sed 's/^.* //'
 }
 
 sign_plain() {
     # Sign message using a plaintext key
-    key=$1
-    msg=$2
-    echo -en "$msg" | openssl dgst -hex -sha256 -hmac "$key" | sed 's/^.* //'
+    key="$1"
+    msg="$2"
+    echo -en "${msg}" | openssl dgst -hex -sha256 -hmac "${key}" | sed 's/^.* //'
 }
 
 sign() {
     # Sign message using a hex formatted key
-    key=$1
-    msg=$2
-    echo -en "$msg" | openssl dgst -hex -sha256 -mac HMAC -macopt "hexkey:${key}" | sed 's/^.* //'
+    key="$1"
+    msg="$2"
+    echo -en "${msg}" | openssl dgst -hex -sha256 -mac HMAC -macopt "hexkey:${key}" | sed 's/^.* //'
 }
 
 request_body="<?xml version=\"1.0\" encoding=\"UTF-8\"?> \
@@ -64,34 +62,34 @@
 </ChangeBatch> \
 </ChangeResourceRecordSetsRequest>"
 
-fulldate=$(date --utc +%Y%m%dT%H%M%SZ)
-shortdate=$(date --utc +%Y%m%d)
+fulldate="$(date --utc +%Y%m%dT%H%M%SZ)"
+shortdate="$(date --utc +%Y%m%d)"
 signed_headers="host;x-amz-date"
-request_hash=$(hash "$request_body")
+request_hash="$(hash "${request_body}")"
 canonical_request="POST\n${API_PATH}\n\nhost:route53.amazonaws.com\nx-amz-date:${fulldate}\n\n${signed_headers}\n${request_hash}"
 
-date_key=$(sign_plain "AWS4${AWS_SECRET_ACCESS_KEY}" "${shortdate}")
-region_key=$(sign "$date_key" $AWS_REGION)
-service_key=$(sign "$region_key" $AWS_SERVICE)
-signing_key=$(sign "$service_key" aws4_request)
+date_key="$(sign_plain "AWS4${AWS_SECRET_ACCESS_KEY}" "${shortdate}")"
+region_key="$(sign "${date_key}" ${AWS_REGION})"
+service_key="$(sign "${region_key}" ${AWS_SERVICE})"
+signing_key="$(sign "${service_key}" aws4_request)"
 
 credential="${shortdate}/${AWS_REGION}/${AWS_SERVICE}/aws4_request"
-sigmsg="AWS4-HMAC-SHA256\n${fulldate}\n${credential}\n$(hash "$canonical_request")"
+sigmsg="AWS4-HMAC-SHA256\n${fulldate}\n${credential}\n$(hash "${canonical_request}")"
 
-signature=$(sign "$signing_key" "$sigmsg")
+signature="$(sign "${signing_key}" "${sigmsg}")"
 
 authorization="AWS4-HMAC-SHA256 Credential=${AWS_ACCESS_KEY_ID}/${credential}, SignedHeaders=${signed_headers}, Signature=${signature}"
 
-ANSWER=$(curl \
+ANSWER="$(curl \
     -X "POST" \
     -H "Host: route53.amazonaws.com" \
     -H "X-Amz-Date: ${fulldate}" \
     -H "Authorization: ${authorization}" \
     -H "Content-Type: text/xml" \
     -d "$request_body" \
-    "https://${ENDPOINT}${API_PATH}")
+    "https://${ENDPOINT}${API_PATH}")"
 write_log 7 "${ANSWER}"
 
-echo ${ANSWER} | grep Error >/dev/null && return 1
-echo ${ANSWER} | grep ChangeInfo >/dev/null && return 0
+echo "${ANSWER}" | grep -F "Error" >/dev/null && return 1
+echo "${ANSWER}" | grep -F "ChangeInfo" >/dev/null && return 0
 return 2
