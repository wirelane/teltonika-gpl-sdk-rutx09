diff --recursive --unified --new-file --no-dereference orig/.gitignore src/.gitignore
--- orig/.gitignore	2023-11-09 07:11:45.000000000 +0000
+++ src/.gitignore	2024-04-25 07:20:16.000000000 +0000
@@ -1,10 +1 @@
-uqmi
-.*
-Makefile
-CMakeCache.txt
-CMakeFiles
-*.cmake
-install_manifest.txt
-qmi-message-*.h
-qmi-message-*.c
-qmi-errors.c
+.vscode/
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/.gitlab-ci.yml src/.gitlab-ci.yml
--- orig/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2024-04-25 07:20:16.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/CMakeLists.txt src/CMakeLists.txt
--- orig/CMakeLists.txt	2023-11-09 07:11:45.000000000 +0000
+++ src/CMakeLists.txt	2024-04-25 07:20:16.000000000 +0000
@@ -4,11 +4,11 @@
 
 OPTION(BUILD_STATIC OFF)
 
-ADD_DEFINITIONS(-Os -ggdb -Wall -Werror --std=gnu99 -Wmissing-declarations -Wno-enum-conversion)
+ADD_DEFINITIONS(-Os -Wall -Werror --std=gnu99 -Wmissing-declarations)
 
 SET(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
 
-SET(SOURCES main.c dev.c commands.c qmi-message.c mbim.c)
+SET(SOURCES main.c)
 
 FIND_PATH(ubox_include_dir libubox/usock.h)
 FIND_PATH(blobmsg_json_include_dir libubox/blobmsg_json.h)
@@ -32,7 +32,7 @@
 ENDIF()
 
 IF(DEBUG)
-  ADD_DEFINITIONS(-DDEBUG -g3)
+  ADD_DEFINITIONS(-DDEBUG -ggdb -g3)
 ENDIF()
 
 SET(service_headers)
@@ -58,14 +58,27 @@
 	COMMAND ${CMAKE_SOURCE_DIR}/data/gen-error-list.pl ${CMAKE_SOURCE_DIR}/qmi-errors.h > ${CMAKE_SOURCE_DIR}/qmi-errors.c
 	DEPENDS ${CMAKE_SOURCE_DIR}/data/gen-error-list.pl ${CMAKE_SOURCE_DIR}/qmi-errors.h
 )
+
+ADD_CUSTOM_COMMAND(
+	OUTPUT  ${CMAKE_SOURCE_DIR}/qmi-wds-error-types.c
+	COMMAND ${CMAKE_SOURCE_DIR}/data/gen-verbose-error-list.pl ${CMAKE_SOURCE_DIR}/qmi-enums-wds.h ${CMAKE_SOURCE_DIR}/qmi-wds-error-types.c
+	DEPENDS ${CMAKE_SOURCE_DIR}/data/gen-error-list.pl ${CMAKE_SOURCE_DIR}/qmi-enums-wds.h
+)
 ADD_CUSTOM_TARGET(gen-errors DEPENDS qmi-errors.c)
+ADD_CUSTOM_TARGET(gen-verbose-errors DEPENDS qmi-wds-error-types.c)
 ADD_CUSTOM_TARGET(gen-headers DEPENDS ${service_headers})
 
-ADD_EXECUTABLE(uqmi ${SOURCES} ${service_sources})
-ADD_DEPENDENCIES(uqmi gen-headers gen-errors)
+SET(LIB_SOURCES libuqmi.c dev.c commands.c qmi-message.c mbim.c)
+
+ADD_LIBRARY(tlt_uqmi SHARED ${LIB_SOURCES} ${service_headers} ${service_sources})
+ADD_DEPENDENCIES(tlt_uqmi gen-headers gen-errors gen-verbose-errors)
+
+ADD_EXECUTABLE(uqmi ${SOURCES})
+# ADD_DEPENDENCIES(uqmi gen-headers gen-errors gen-verbose-errors)
 
-TARGET_LINK_LIBRARIES(uqmi ${LIBS})
+TARGET_LINK_LIBRARIES(uqmi ${LIBS} tlt_uqmi)
 
 INSTALL(TARGETS uqmi
+	LIBRARY DESTINATION lib
 	RUNTIME DESTINATION sbin
 )
diff --recursive --unified --new-file --no-dereference orig/commands-dms.c src/commands-dms.c
--- orig/commands-dms.c	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-dms.c	2024-04-25 07:20:16.000000000 +0000
@@ -49,6 +49,7 @@
 		[QMI_DMS_RADIO_INTERFACE_GSM] = "gsm",
 		[QMI_DMS_RADIO_INTERFACE_UMTS] = "umts",
 		[QMI_DMS_RADIO_INTERFACE_LTE] = "lte",
+		[QMI_DMS_RADIO_INTERFACE_5GNR] = "5gnr",
 	};
 	const char *service_cap[] = {
 		[QMI_DMS_DATA_SERVICE_CAPABILITY_NONE] = "none",
diff --recursive --unified --new-file --no-dereference orig/commands-nas.c src/commands-nas.c
--- orig/commands-nas.c	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-nas.c	2024-04-25 07:20:16.000000000 +0000
@@ -924,6 +924,18 @@
 		[QMI_NAS_REGISTRATION_STATE_REGISTRATION_DENIED] = "registering_denied",
 		[QMI_NAS_REGISTRATION_STATE_UNKNOWN] = "unknown",
 	};
+	static const char *ext_serv_system[] = {
+		[QMI_NAS_SERVICE_STATUS_NONE] = "none",
+		[QMI_NAS_SERVICE_STATUS_LIMITED] = "limited",
+		[QMI_NAS_SERVICE_STATUS_AVAILABLE] = "available",
+		[QMI_NAS_SERVICE_STATUS_LIMITED_REGIONAL] = "limited_regional",
+		[QMI_NAS_SERVICE_STATUS_POWER_SAVE] = "power_save",
+	};
+	static const char *attach_states[] = {
+		[QMI_NAS_ATTACH_STATE_UNKNOWN] = "unknown",
+		[QMI_NAS_ATTACH_STATE_ATTACHED] = "attached",
+		[QMI_NAS_ATTACH_STATE_DETACHED] = "detached",
+	};
 	void *c;
 
 	qmi_parse_nas_get_serving_system_response(msg, &res);
@@ -931,11 +943,15 @@
 	c = blobmsg_open_table(&status, NULL);
 	if (res.set.serving_system) {
 		int state = res.data.serving_system.registration_state;
+		int cs_state = res.data.serving_system.cs_attach_state;
+		int ps_state = res.data.serving_system.ps_attach_state;
 
 		if (state > QMI_NAS_REGISTRATION_STATE_UNKNOWN)
 			state = QMI_NAS_REGISTRATION_STATE_UNKNOWN;
 
 		blobmsg_add_string(&status, "registration", reg_states[state]);
+		blobmsg_add_string(&status, "CS", attach_states[cs_state]);
+		blobmsg_add_string(&status, "PS", attach_states[ps_state]);
 	}
 	if (res.set.current_plmn) {
 		blobmsg_add_u32(&status, "plmn_mcc", res.data.current_plmn.mcc);
@@ -947,6 +963,12 @@
 	if (res.set.roaming_indicator)
 		blobmsg_add_u8(&status, "roaming", !res.data.roaming_indicator);
 
+	if (res.set.detailed_service_status) {
+		int ext_status = res.data.detailed_service_status.status;
+
+		blobmsg_add_string(&status, "status", ext_serv_system[ext_status]);
+	}
+
 	blobmsg_close_table(&status, c);
 }
 
diff --recursive --unified --new-file --no-dereference orig/commands-uim.c src/commands-uim.c
--- orig/commands-uim.c	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-uim.c	2024-04-25 07:20:16.000000000 +0000
@@ -19,6 +19,8 @@
  * Boston, MA 02110-1301 USA.
  */
 
+static int uim_slot = 0;
+
 #define cmd_uim_verify_pin1_cb no_cb
 static enum qmi_cmd_result
 cmd_uim_verify_pin1_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
@@ -59,6 +61,16 @@
 {
 	struct qmi_uim_get_card_status_response res;
 	void * const card_table = blobmsg_open_table(&status, NULL);
+	static const char *card_application_states[] = {
+		[QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN] = "unknown",
+		[QMI_UIM_CARD_APPLICATION_STATE_DETECTED] = "detected",
+		[QMI_UIM_CARD_APPLICATION_STATE_PIN1_OR_UPIN_PIN_REQUIRED] = "pin-required",
+		[QMI_UIM_CARD_APPLICATION_STATE_PUK1_OR_UPIN_PUK_REQUIRED] = "puk-required",
+		[QMI_UIM_CARD_APPLICATION_STATE_CHECK_PERSONALIZATION_STATE] = "check-personalization-state",
+		[QMI_UIM_CARD_APPLICATION_STATE_PIN1_BLOCKED] = "pin1-blocked",
+		[QMI_UIM_CARD_APPLICATION_STATE_ILLEGAL] = "illegal",
+		[QMI_UIM_CARD_APPLICATION_STATE_READY] = "ready",
+	};
 
 	qmi_parse_uim_get_card_status_response(msg, &res);
 
@@ -66,6 +78,7 @@
 		if (res.data.card_status.cards[i].card_state != QMI_UIM_CARD_STATE_PRESENT)
 			continue;
 
+		uint8_t card_application_state = QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN;
 		uint8_t pin1_state = res.data.card_status.cards[i].upin_state;
 		uint8_t pin1_retries = res.data.card_status.cards[i].upin_retries;
 		uint8_t puk1_retries = res.data.card_status.cards[i].upuk_retries;
@@ -78,6 +91,8 @@
 			if (res.data.card_status.cards[i].applications[j].type == QMI_UIM_CARD_APPLICATION_TYPE_UNKNOWN)
 				continue;
 
+			card_application_state = pin1_state = res.data.card_status.cards[i].applications[j].state;
+
 			if (!res.data.card_status.cards[i].applications[j].upin_replaces_pin1) {
 				pin1_state = res.data.card_status.cards[i].applications[j].pin1_state;
 				pin1_retries = res.data.card_status.cards[i].applications[j].pin1_retries;
@@ -92,6 +107,11 @@
 			break; /* handle first application only for now */
 		}
 
+		if (card_application_state > QMI_UIM_CARD_APPLICATION_STATE_READY)
+			card_application_state = QMI_UIM_CARD_APPLICATION_STATE_UNKNOWN;
+
+		blobmsg_add_u32(&status, "card_slot", i + 1); /* Slot is idx + 1 */
+		blobmsg_add_string(&status, "card_application_state", card_application_states[card_application_state]);
 		blobmsg_add_string(&status, "pin1_status", get_pin_status(pin1_state));
 		blobmsg_add_u32(&status, "pin1_verify_tries", pin1_retries);
 		blobmsg_add_u32(&status, "pin1_unlock_tries", puk1_retries);
@@ -113,3 +133,53 @@
 	qmi_set_uim_get_card_status_request(msg);
 	return QMI_CMD_REQUEST;
 }
+
+#define cmd_uim_slot_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_slot_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	char *err;
+	int value = strtoul(arg, &err, 10);
+	if ((err && *err) || value < 1 || value > 2) {
+		uqmi_add_error("Invalid UIM-Slot value. Allowed: [1,2]");
+		return QMI_CMD_EXIT;
+	}
+
+	uim_slot = value;
+
+	return QMI_CMD_DONE;
+}
+
+#define cmd_uim_power_off_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_power_off_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	struct qmi_uim_power_off_sim_request data = {
+		QMI_INIT(slot, uim_slot)
+	};
+
+	if (!uim_slot) {
+		uqmi_add_error("UIM-Slot not set. Use --uim-slot <slot> to set it.");
+		return QMI_CMD_EXIT;
+	}
+
+	qmi_set_uim_power_off_sim_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_uim_power_on_cb no_cb
+static enum qmi_cmd_result
+cmd_uim_power_on_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	struct qmi_uim_power_on_sim_request data = {
+		QMI_INIT(slot, uim_slot)
+	};
+
+	if (!uim_slot) {
+		uqmi_add_error("UIM-Slot not set. Use --uim-slot <slot> to set it.");
+		return QMI_CMD_EXIT;
+	}
+
+	qmi_set_uim_power_on_sim_request(msg, &data);
+	return QMI_CMD_REQUEST;
+}
diff --recursive --unified --new-file --no-dereference orig/commands-uim.h src/commands-uim.h
--- orig/commands-uim.h	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-uim.h	2024-04-25 07:20:16.000000000 +0000
@@ -20,13 +20,20 @@
  */
 
 #define __uqmi_uim_commands												\
+	__uqmi_command(uim_slot, uim-slot, required, CMD_TYPE_OPTION), \
 	__uqmi_command(uim_verify_pin1, uim-verify-pin1, required, QMI_SERVICE_UIM), \
 	__uqmi_command(uim_verify_pin2, uim-verify-pin2, required, QMI_SERVICE_UIM), \
-	__uqmi_command(uim_get_sim_state, uim-get-sim-state, no, QMI_SERVICE_UIM) \
+	__uqmi_command(uim_get_sim_state, uim-get-sim-state, no, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_power_off, uim-power-off, no, QMI_SERVICE_UIM), \
+	__uqmi_command(uim_power_on, uim-power-on, no, QMI_SERVICE_UIM) \
 
 
 #define uim_helptext \
 		"  --uim-verify-pin1 <pin>:          Verify PIN1 (new devices)\n" \
 		"  --uim-verify-pin2 <pin>:          Verify PIN2 (new devices)\n" \
-		"  --uim-get-sim-state:                  Get current SIM state\n" \
+		"  --uim-get-sim-state:              Get current SIM state\n" \
+		"  --uim-power-off:                  Power off SIM card\n" \
+		"    --uim-slot:                     SIM slot [1-2]\n" \
+		"  --uim-power-on:                   Power on SIM card\n" \
+		"    --uim-slot:                     SIM slot [1-2]\n" \
 
diff --recursive --unified --new-file --no-dereference orig/commands-wda.c src/commands-wda.c
--- orig/commands-wda.c	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-wda.c	2024-04-25 07:20:16.000000000 +0000
@@ -31,30 +31,231 @@
 	{ "raw-ip", QMI_WDA_LINK_LAYER_PROTOCOL_RAW_IP },
 };
 
+static const struct {
+	const char *name;
+	QmiWdaDataAggregationProtocol aggreg;
+} aggreg_modes[] = {
+	{ "disabled", QMI_WDA_DATA_AGGREGATION_PROTOCOL_DISABLED },
+	{ "tlp", QMI_WDA_DATA_AGGREGATION_PROTOCOL_TLP },
+	{ "qc-cm", QMI_WDA_DATA_AGGREGATION_PROTOCOL_QC_NCM },
+	{ "mbim", QMI_WDA_DATA_AGGREGATION_PROTOCOL_MBIM },
+	{ "rndis", QMI_WDA_DATA_AGGREGATION_PROTOCOL_RNDIS },
+	{ "qmap", QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAP },
+	{ "qmapv5", QMI_WDA_DATA_AGGREGATION_PROTOCOL_QMAPV5 },
+};
+
+static struct {
+	uint32_t iface_number;
+	uint32_t dl_max_size;
+	uint32_t dl_max_datagrams;
+	uint32_t ul_max_size;
+	uint32_t ul_max_datagrams;
+	uint32_t dl_min_padding;
+	uint8_t qos_format;
+	QmiDataEndpointType endpoint_type;
+	QmiWdaDataAggregationProtocol ul_aggreg;
+	QmiWdaDataAggregationProtocol dl_aggreg;
+	QmiWdaLinkLayerProtocol val;
+} wda_endpoint_info;
+
 #define cmd_wda_set_data_format_cb no_cb
 
 static enum qmi_cmd_result
-cmd_wda_set_data_format_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+cmd_wda_set_data_format_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+				struct qmi_msg *msg, char *arg)
 {
-	struct qmi_wda_set_data_format_request data_req = {};
-	int i;
+	struct qmi_wda_set_data_format_request wda_sdf_req = {
+		QMI_INIT(link_layer_protocol, wda_endpoint_info.val),
+		QMI_INIT(uplink_data_aggregation_protocol, wda_endpoint_info.ul_aggreg),
+		QMI_INIT(downlink_data_aggregation_protocol, wda_endpoint_info.dl_aggreg),
+		QMI_INIT(downlink_data_aggregation_max_datagrams, wda_endpoint_info.dl_max_datagrams),
+		QMI_INIT(downlink_data_aggregation_max_size, wda_endpoint_info.dl_max_size),
+		QMI_INIT(uplink_data_aggregation_max_datagrams, wda_endpoint_info.ul_max_datagrams),
+		QMI_INIT(uplink_data_aggregation_max_size, wda_endpoint_info.ul_max_size),
+		QMI_INIT(downlink_minimum_padding, wda_endpoint_info.dl_min_padding),
+		QMI_INIT(qos_format, wda_endpoint_info.qos_format),
+	};
 
-	for (i = 0; i < ARRAY_SIZE(link_modes); i++) {
-		if (strcasecmp(link_modes[i].name, arg) != 0)
+	if (wda_endpoint_info.endpoint_type) {
+		wda_sdf_req.data.endpoint_info.endpoint_type = wda_endpoint_info.endpoint_type;
+	}
+
+	if (wda_endpoint_info.iface_number) {
+		wda_sdf_req.data.endpoint_info.interface_number = wda_endpoint_info.iface_number;
+	}
+
+	qmi_set_wda_set_data_format_request(msg, &wda_sdf_req);
+	return QMI_CMD_REQUEST;
+}
+
+#define cmd_wda_link_layer_protocol_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_link_layer_protocol_prepare(
+	struct qmi_dev * qmi, struct qmi_request * req, struct qmi_msg * msg,
+	char *arg)
+{
+	for (uint32_t i = 0; i < ARRAY_SIZE(link_modes); i++) {
+		if (strcasecmp(link_modes[i].name, arg))
+		    continue;
+
+		wda_endpoint_info.val = link_modes[i].val;
+		return QMI_CMD_DONE;
+	}
+
+	uqmi_add_error("Invalid value (valid: 802.3, raw-ip");
+	return QMI_CMD_EXIT;
+}
+
+#define cmd_wda_uplink_data_aggregation_protocol_cb no_cb
+
+static enum qmi_cmd_result
+cmd_wda_uplink_data_aggregation_protocol_prepare(struct qmi_dev *qmi,
+						 struct qmi_request *req,
+						 struct qmi_msg *msg, char *arg)
+{
+	for (uint32_t i = 0; i < ARRAY_SIZE(aggreg_modes); i++) {
+		if (strcasecmp(aggreg_modes[i].name, arg))
+			continue;
+
+		wda_endpoint_info.ul_aggreg = aggreg_modes[i].aggreg;
+		return QMI_CMD_DONE;
+	}
+
+	uqmi_add_error("Invalid value (valid: disabled, tlp, qc-cm, mbim, rndis, qmap, qmapv5");
+	return QMI_CMD_EXIT;
+}
+
+#define cmd_wda_downlink_data_aggregation_protocol_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_downlink_data_aggregation_protocol_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	for (uint32_t i = 0; i < ARRAY_SIZE(aggreg_modes); i++) {
+		if (strcasecmp(aggreg_modes[i].name, arg))
 			continue;
 
-		qmi_set(&data_req, link_layer_protocol, link_modes[i].val);
-		qmi_set_wda_set_data_format_request(msg, &data_req);
-		return QMI_CMD_REQUEST;
+		wda_endpoint_info.dl_aggreg = aggreg_modes[i].aggreg;
+		return QMI_CMD_DONE;
 	}
 
-	uqmi_add_error("Invalid auth mode (valid: 802.3, raw-ip)");
+	uqmi_add_error("Invalid value (valid: disabled, tlp, qc-cm, mbim, rndis, qmap, qmapv5");
 	return QMI_CMD_EXIT;
 }
 
-static void
-cmd_wda_get_data_format_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+#define cmd_wda_downlink_data_aggregation_max_datagrams_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_downlink_data_aggregation_max_datagrams_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	uint32_t max_datagrams = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.dl_max_datagrams = max_datagrams;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_wda_uplink_data_aggregation_max_datagrams_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_uplink_data_aggregation_max_datagrams_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
 {
+	uint32_t max_datagrams = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.ul_max_datagrams = max_datagrams;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_wda_downlink_data_aggregation_max_size_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_downlink_data_aggregation_max_size_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	uint32_t max_size = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.dl_max_size = max_size;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_wda_uplink_data_aggregation_max_size_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_uplink_data_aggregation_max_size_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	uint32_t max_size = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.ul_max_size = max_size;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_wda_downlink_minimum_padding_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_downlink_minimum_padding_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	uint32_t min_pad = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.dl_min_padding = min_pad;
+	return QMI_CMD_DONE;
+}
+
+#define cmd_wda_qos_format_cb no_cb
+
+static enum qmi_cmd_result cmd_wda_qos_format_prepare(
+	struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg,
+	char *arg)
+{
+	uint8_t format = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.qos_format = format;
+	return QMI_CMD_DONE;
+}
+
+
+#define cmd_wda_endpoint_type_cb no_cb
+
+static enum qmi_cmd_result
+cmd_wda_endpoint_type_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+			      struct qmi_msg *msg, char *arg)
+{
+	static const char *endpoint_type[] = {
+		[QMI_DATA_ENDPOINT_TYPE_HSUSB] = "hsusb",
+		[QMI_DATA_ENDPOINT_TYPE_UNDEFINED] = "undefined",
+	};
+
+	for (uint32_t i = 0; i < ARRAY_SIZE(endpoint_type); i++) {
+		if (endpoint_type[i] && !strcmp(endpoint_type[i], arg)) {
+			wda_endpoint_info.endpoint_type = i;
+			return QMI_CMD_DONE;
+		}
+	}
+
+	uqmi_add_error("Invalid value (valid: undefined, hsusb");
+	return QMI_CMD_EXIT;
+}
+
+#define cmd_wda_endpoint_interface_number_cb no_cb
+
+static enum qmi_cmd_result
+cmd_wda_endpoint_interface_number_prepare(struct qmi_dev *qmi,
+					  struct qmi_request *req,
+					  struct qmi_msg *msg, char *arg)
+{
+	uint32_t iface_num = strtoul(arg, NULL, 10);
+
+	wda_endpoint_info.iface_number = iface_num;
+	return QMI_CMD_DONE;
+}
+
+static void cmd_wda_get_data_format_cb(struct qmi_dev *qmi,
+				       struct qmi_request *req,
+				       struct qmi_msg *msg)
+{
+	void *t;
 	struct qmi_wda_get_data_format_response res;
 	const char *name = "unknown";
 	int i;
@@ -68,7 +269,13 @@
 		break;
 	}
 
-	blobmsg_add_string(&status, NULL, name);
+	t = blobmsg_open_table(&status, NULL);
+
+	blobmsg_add_u32(&status, "dl data aggregation max size", res.data.downlink_data_aggregation_max_size);
+
+	blobmsg_add_string(&status, "Link Layer Protocol", name);
+
+	blobmsg_close_table(&status, t);
 }
 
 static enum qmi_cmd_result
diff --recursive --unified --new-file --no-dereference orig/commands-wda.h src/commands-wda.h
--- orig/commands-wda.h	2023-11-09 07:11:45.000000000 +0000
+++ src/commands-wda.h	2024-04-25 07:20:16.000000000 +0000
@@ -20,11 +20,32 @@
  */
 
 #define __uqmi_wda_commands \
-	__uqmi_command(wda_set_data_format, wda-set-data-format, required, QMI_SERVICE_WDA), \
+	__uqmi_command(wda_set_data_format, wda-set-data-format, no, QMI_SERVICE_WDA), \
+	__uqmi_command(wda_link_layer_protocol, link-layer-protocol, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_uplink_data_aggregation_protocol, ul-protocol, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_downlink_data_aggregation_protocol, dl-protocol, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_endpoint_type, endpoint-type, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_endpoint_interface_number, endpoint-iface-number, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_downlink_data_aggregation_max_datagrams, dl-max-datagrams, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_uplink_data_aggregation_max_datagrams, ul-max-datagrams, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_downlink_data_aggregation_max_size, dl-datagram-max-size, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_uplink_data_aggregation_max_size, ul-datagram-max-size, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_downlink_minimum_padding, dl-min-padding, required, CMD_TYPE_OPTION), \
+	__uqmi_command(wda_qos_format, qos-format, required, CMD_TYPE_OPTION), \
 	__uqmi_command(wda_get_data_format, wda-get-data-format, no, QMI_SERVICE_WDA)
 
-
 #define wda_helptext \
-		"  --wda-set-data-format <type>:     Set data format (type: 802.3|raw-ip)\n" \
+		"  --wda-set-data-format:     	     Set data format (Use with options below)\n" \
+		"    --qos-size <size>:   	     Set qos format (number)\n" \
+		"    --endpoint-type <type>:	     Set EP endpoint type (type: hsusb|pcie)\n" \
+		"    --enpoint-iface-number <number> Set EP endpoint iface number (number)\n" \
+		"    --link-layer-protocol <type>:   Set data format (type: 802.3|raw-ip)\n" \
+		"    --ul-protocol <proto>:	     Set upload protocol (proto: tlp|qc-cm|mbim|rndis|qmap|qmapv5)\n" \
+		"    --dl-protocol <proto>:	     Set downlink protocol (proto: tlp|qc-cm|mbim|rndis|qmap|qmapv5)\n" \
+		"    --dl-max-datagrams <size>:      Set downlink max datagrams (number)\n" \
+		"    --ul-max-datagrams <size>:      Set uplink max datagrams (number)\n" \
+		"    --dl-datagram-max-size <size>:  Set downlink datagram max size (number)\n" \
+		"    --ul-datagram-max-size <size>:  Set uplink datagram max size (number)\n" \
+		"    --dl-min-padding <size>:  	     Set downlink minimum padding (number)\n" \
 		"  --wda-get-data-format:            Get data format\n" \
 
diff --recursive --unified --new-file --no-dereference orig/commands-wds.c src/commands-wds.c
--- orig/commands-wds.c	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-wds.c	2024-04-25 07:20:16.000000000 +0000
@@ -20,44 +20,120 @@
  */
 
 #include <stdlib.h>
+#include <stdint.h>
 #include <arpa/inet.h>
 
 #include "qmi-message.h"
 
+#define LOG(...)                                                                                             \
+	do {                                                                                                 \
+		fprintf(stdout, ##__VA_ARGS__);                                                              \
+		fflush(stdout);                                                                              \
+	} while (0);
+
+#define DD LOG("DD[###\%s:\%d***]\\n", __func__, __LINE__)
+
+#define qmi_set_endpoint_info_sequence(_data, _type, _index)                                                 \
+	do {                                                                                                 \
+		(_data)->data.endpoint_info.endpoint_type    = (_type);                                      \
+		(_data)->data.endpoint_info.interface_number = (_index);                                     \
+	} while (0);
+
+#define qmi_set_profile_identifier_sequence(_data, _type, _index)                                            \
+	do {                                                                                                 \
+		(_data)->data.profile_identifier.profile_type  = (_type);                                    \
+		(_data)->data.profile_identifier.profile_index = (_index);                                   \
+	} while (0);
+
+static const struct {
+	const char *auth_name;
+	QmiWdsAuthentication auth;
+} auth_modes[] = {
+	{ "none", QMI_WDS_AUTHENTICATION_NONE },
+	{ "pap", QMI_WDS_AUTHENTICATION_PAP },
+	{ "chap", QMI_WDS_AUTHENTICATION_CHAP },
+	{ "both", QMI_WDS_AUTHENTICATION_PAP | QMI_WDS_AUTHENTICATION_CHAP },
+};
+
+static const struct {
+	const char *ipfam_name;
+	const QmiWdsIpFamily mode;
+} ipfam_modes[] = {
+	{ "ipv4", QMI_WDS_IP_FAMILY_IPV4 },
+	{ "ipv6", QMI_WDS_IP_FAMILY_IPV6 },
+	{ "unspecified", QMI_WDS_IP_FAMILY_UNSPECIFIED },
+};
+
+static const struct {
+	const char *pdp_name;
+	const QmiWdsPdpType type;
+} pdp_types[] = {
+	{ "ipv4", QMI_WDS_PDP_TYPE_IPV4 },
+	{ "ppp", QMI_WDS_PDP_TYPE_PPP },
+	{ "ipv6", QMI_WDS_PDP_TYPE_IPV6 },
+	{ "ipv4v6", QMI_WDS_PDP_TYPE_IPV4_OR_IPV6 },
+};
+
+static const struct {
+	const char *profile_name;
+	const QmiWdsProfileType profile;
+} profile_types[] = {
+	{ "3gpp", QMI_WDS_PROFILE_TYPE_3GPP },
+	{ "3gpp2", QMI_WDS_PROFILE_TYPE_3GPP2 },
+};
+
+//initializing default global structs
 static struct qmi_wds_start_network_request wds_sn_req = {
-	QMI_INIT(authentication_preference,
-	         QMI_WDS_AUTHENTICATION_PAP | QMI_WDS_AUTHENTICATION_CHAP),
+	QMI_INIT(authentication_preference, QMI_WDS_AUTHENTICATION_PAP | QMI_WDS_AUTHENTICATION_CHAP),
+	QMI_INIT(ip_family_preference, QMI_WDS_IP_FAMILY_IPV4),
+	QMI_INIT(profile_index_3gpp, 1),
 };
+
 static struct qmi_wds_stop_network_request wds_stn_req;
 
-#define cmd_wds_set_apn_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_apn_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+static struct qmi_wds_modify_profile_request wds_mp_req = {
+	QMI_INIT_SEQUENCE(profile_identifier, .profile_type = QMI_WDS_PROFILE_TYPE_3GPP,
+			  .profile_index = 1, ),
+	QMI_INIT(apn_disabled_flag, false),
+};
+
+static struct qmi_wds_create_profile_request wds_cp_req = {
+	QMI_INIT(profile_type, QMI_WDS_PROFILE_TYPE_3GPP),
+	QMI_INIT(apn_disabled_flag, false),
+};
+
+static struct qmi_wds_bind_mux_data_port_request wds_bind_mux_port_req = {
+	QMI_INIT_SEQUENCE(endpoint_info, .endpoint_type = QMI_DATA_ENDPOINT_TYPE_HSUSB,
+			  .interface_number = 1, ),
+	QMI_INIT(client_type, QMI_WDS_CLIENT_TYPE_TETHERED),
+};
+
+/**************************************************************
+	commands preparing for uqmi call global variables
+**************************************************************/
+
+//===================== prepare APN to global structs =================
+static enum qmi_cmd_result cmd_wds_set_apn_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+						   struct qmi_msg *msg, char *arg)
 {
 	qmi_set_ptr(&wds_sn_req, apn, arg);
+	qmi_set_ptr(&wds_mp_req, apn_name, arg);
+	qmi_set_ptr(&wds_cp_req, apn_name, arg);
 	return QMI_CMD_DONE;
 }
 
-#define cmd_wds_set_auth_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_auth_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
-{
-	static const struct {
-		const char *name;
-		QmiWdsAuthentication auth;
-	} modes[] = {
-		{ "pap", QMI_WDS_AUTHENTICATION_PAP },
-		{ "chap", QMI_WDS_AUTHENTICATION_CHAP },
-		{ "both", QMI_WDS_AUTHENTICATION_PAP | QMI_WDS_AUTHENTICATION_CHAP },
-		{ "none", QMI_WDS_AUTHENTICATION_NONE },
-	};
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(modes); i++) {
-		if (strcasecmp(modes[i].name, arg) != 0)
+//===================== prepare AUTHORIZATION mode to global structs =================
+static enum qmi_cmd_result cmd_wds_set_auth_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+						    struct qmi_msg *msg, char *arg)
+{
+	for (int i = 0; i < ARRAY_SIZE(auth_modes); i++) {
+		if (strcasecmp(auth_modes[i].auth_name, arg) != 0) {
 			continue;
+		}
 
-		qmi_set(&wds_sn_req, authentication_preference, modes[i].auth);
+		qmi_set(&wds_sn_req, authentication_preference, auth_modes[i].auth);
+		qmi_set(&wds_mp_req, authentication, auth_modes[i].auth);
+		qmi_set(&wds_cp_req, authentication, auth_modes[i].auth);
 		return QMI_CMD_DONE;
 	}
 
@@ -65,50 +141,45 @@
 	return QMI_CMD_EXIT;
 }
 
-#define cmd_wds_set_username_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_username_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare AUTHORIZATION USERNAME to global structs =================
+static enum qmi_cmd_result cmd_wds_set_username_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							struct qmi_msg *msg, char *arg)
 {
 	qmi_set_ptr(&wds_sn_req, username, arg);
+	qmi_set_ptr(&wds_mp_req, username, arg);
+	qmi_set_ptr(&wds_cp_req, username, arg);
 	return QMI_CMD_DONE;
 }
 
-#define cmd_wds_set_password_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_password_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare AUTHORIZATION PASSWORD to global structs =================
+static enum qmi_cmd_result cmd_wds_set_password_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							struct qmi_msg *msg, char *arg)
 {
 	qmi_set_ptr(&wds_sn_req, password, arg);
+	qmi_set_ptr(&wds_mp_req, password, arg);
+	qmi_set_ptr(&wds_cp_req, password, arg);
 	return QMI_CMD_DONE;
 }
 
-#define cmd_wds_set_autoconnect_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_autoconnect_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare AUTOCONNECT to global structs =================
+static enum qmi_cmd_result cmd_wds_set_autoconnect_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							   struct qmi_msg *msg, char *arg)
 {
 	qmi_set(&wds_sn_req, enable_autoconnect, true);
 	qmi_set(&wds_stn_req, disable_autoconnect, true);
 	return QMI_CMD_DONE;
 }
 
-#define cmd_wds_set_ip_family_pref_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_ip_family_pref_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
-{
-	static const struct {
-		const char *name;
-		const QmiWdsIpFamily mode;
-	} modes[] = {
-		{ "ipv4", QMI_WDS_IP_FAMILY_IPV4 },
-		{ "ipv6", QMI_WDS_IP_FAMILY_IPV6 },
-		{ "unspecified", QMI_WDS_IP_FAMILY_UNSPECIFIED },
-	};
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(modes); i++) {
-		if (strcasecmp(modes[i].name, arg) != 0)
+//===================== prepare IP FAMILY to global structs =================
+static enum qmi_cmd_result cmd_wds_set_ip_family_pref_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							      struct qmi_msg *msg, char *arg)
+{
+	for (int i = 0; i < ARRAY_SIZE(ipfam_modes); i++) {
+		if (strcasecmp(ipfam_modes[i].ipfam_name, arg) != 0) {
 			continue;
+		}
 
-		qmi_set(&wds_sn_req, ip_family_preference, modes[i].mode);
+		qmi_set(&wds_sn_req, ip_family_preference, ipfam_modes[i].mode);
 		return QMI_CMD_DONE;
 	}
 
@@ -116,36 +187,125 @@
 	return QMI_CMD_EXIT;
 }
 
-#define cmd_wds_set_profile_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_profile_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare PDP-TYPE to global structs =================
+static enum qmi_cmd_result cmd_wds_set_pdp_type_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							struct qmi_msg *msg, char *arg)
 {
-	uint32_t idx = strtoul(arg, NULL, 10);
+	for (int i = 0; i < ARRAY_SIZE(pdp_types); i++) {
+		if (strcasecmp(pdp_types[i].pdp_name, arg) != 0) {
+			continue;
+		}
 
-	qmi_set(&wds_sn_req, profile_index_3gpp, idx);
+		qmi_set(&wds_mp_req, pdp_type, pdp_types[i].type);
+		qmi_set(&wds_cp_req, pdp_type, pdp_types[i].type);
+		return QMI_CMD_DONE;
+	}
+
+	uqmi_add_error("Invalid value (valid: ppp, ipv4, ipv6, ipv4v6)");
+	return QMI_CMD_EXIT;
+}
+
+//===================== prepare prifile-number to global structs =================
+static enum qmi_cmd_result cmd_wds_set_profile_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+						       struct qmi_msg *msg, char *arg)
+{
+	char *endptr = NULL;
+
+	unsigned long idx = strtoul(arg, &endptr, 10);
+	if (*endptr != '\0') {
+		uqmi_add_error("Error: Invalid input");
+		return QMI_CMD_EXIT;
+	} else if (idx > UINT8_MAX) {
+		uqmi_add_error("Error: Input value out of range");
+		return QMI_CMD_EXIT;
+	}
+
+	qmi_set(&wds_sn_req, profile_index_3gpp, (uint8_t)idx);
 	return QMI_CMD_DONE;
 }
 
-static void
-cmd_wds_start_network_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
-{
-	struct qmi_wds_start_network_response res;
+//===================== prepare mux-id-number to global structs =================
+static enum qmi_cmd_result cmd_wds_mux_id_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+						  struct qmi_msg *msg, char *arg)
+{
+	char *endptr = NULL;
+
+	unsigned long idx = strtoul(arg, &endptr, 10);
+	if (*endptr != '\0') {
+		uqmi_add_error("Error: Invalid input");
+		return QMI_CMD_EXIT;
+	} else if (idx > UINT8_MAX) {
+		uqmi_add_error("Error: Input value out of range");
+		return QMI_CMD_EXIT;
+	}
 
-	qmi_parse_wds_start_network_response(msg, &res);
-	if (res.set.packet_data_handle)
-		blobmsg_add_u32(&status, NULL, res.data.packet_data_handle);
+	qmi_set(&wds_bind_mux_port_req, mux_id, (uint8_t)idx);
+	return QMI_CMD_DONE;
+}
+
+//===================== prepare iface-number to global structs =================
+static enum qmi_cmd_result cmd_wds_ep_iface_number_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							   struct qmi_msg *msg, char *arg)
+{
+	char *endptr = NULL;
+
+	unsigned long idx = strtoul(arg, &endptr, 10);
+	if (*endptr != '\0') {
+		uqmi_add_error("Error: Invalid input");
+		return QMI_CMD_EXIT;
+	} else if (idx > UINT8_MAX) {
+		uqmi_add_error("Error: Input value out of range");
+		return QMI_CMD_EXIT;
+	}
+
+	qmi_set_endpoint_info_sequence(&wds_bind_mux_port_req, QMI_DATA_ENDPOINT_TYPE_HSUSB,
+					       (uint8_t)idx);
+	return QMI_CMD_DONE;
+}
+
+//===================== prepare ROAMING flag to global structs =================
+static enum qmi_cmd_result cmd_wds_set_roaming_disallowed_flag_prepare(struct qmi_dev *qmi,
+								       struct qmi_request *req,
+								       struct qmi_msg *msg, char *arg)
+{
+	if (!strcasecmp(arg, "yes") || !strcasecmp(arg, "true")) {
+		qmi_set(&wds_mp_req, roaming_disallowed_flag, true);
+		qmi_set(&wds_cp_req, roaming_disallowed_flag, true);
+	} else if (!strcasecmp(arg, "no") || !strcasecmp(arg, "false")) {
+		qmi_set(&wds_mp_req, roaming_disallowed_flag, false);
+		qmi_set(&wds_cp_req, roaming_disallowed_flag, false);
+	} else {
+		uqmi_add_error("Invalid flag (valid: yes, true, no, false)");
+		return QMI_CMD_EXIT;
+	}
+
+	return QMI_CMD_DONE;
 }
 
-static enum qmi_cmd_result
-cmd_wds_start_network_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare profile-name to global structs =================
+static enum qmi_cmd_result cmd_wds_set_profile_name_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							    struct qmi_msg *msg, char *arg)
+{
+	qmi_set_ptr(&wds_mp_req, profile_name, arg);
+	qmi_set_ptr(&wds_cp_req, profile_name, arg);
+	return QMI_CMD_DONE;
+}
+
+/***************************************************
+	commands preparing for uqmi call functions
+****************************************************/
+
+//===================== prepare start-network request call =================
+static enum qmi_cmd_result cmd_wds_start_network_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							 struct qmi_msg *msg, char *arg)
 {
 	qmi_set_wds_start_network_request(msg, &wds_sn_req);
 	return QMI_CMD_REQUEST;
 }
 
-#define cmd_wds_stop_network_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_stop_network_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare stop-network request call =================
+static enum qmi_cmd_result cmd_wds_stop_network_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							struct qmi_msg *msg, char *arg)
 {
 	uint32_t pdh = strtoul(arg, NULL, 0);
 
@@ -154,87 +314,230 @@
 	return QMI_CMD_REQUEST;
 }
 
-static void
-cmd_wds_get_packet_service_status_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+//===================== prepare get-dormancy-status request call =================
+static enum qmi_cmd_result cmd_wds_get_dormancy_status_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							       struct qmi_msg *msg, char *arg)
 {
-	struct qmi_wds_get_packet_service_status_response res;
-	const char *data_status[] = {
-		[QMI_WDS_CONNECTION_STATUS_UNKNOWN] = "unknown",
-		[QMI_WDS_CONNECTION_STATUS_DISCONNECTED] = "disconnected",
-		[QMI_WDS_CONNECTION_STATUS_CONNECTED] = "connected",
-		[QMI_WDS_CONNECTION_STATUS_SUSPENDED] = "suspended",
-		[QMI_WDS_CONNECTION_STATUS_AUTHENTICATING] = "authenticating",
-	};
-	int s = 0;
+	qmi_set_wds_get_dormancy_status_request(msg);
+	return QMI_CMD_REQUEST;
+}
 
-	qmi_parse_wds_get_packet_service_status_response(msg, &res);
-	if (res.set.connection_status &&
-	    res.data.connection_status < ARRAY_SIZE(data_status))
-		s = res.data.connection_status;
+//===================== prepare get0default-profile request call =================
+static enum qmi_cmd_result cmd_wds_get_default_profile_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							       struct qmi_msg *msg, char *arg)
+{
+	for (int i = 0; i < ARRAY_SIZE(profile_types); i++) {
+		if (strcasecmp(profile_types[i].profile_name, arg) != 0) {
+			continue;
+		}
 
-	blobmsg_add_string(&status, NULL, data_status[s]);
+		struct qmi_wds_get_default_profile_number_request type_family = { QMI_INIT_SEQUENCE(
+			profile_type, .type = profile_types[i].profile,
+			.family = QMI_WDS_PROFILE_FAMILY_TETHERED, ) };
+
+		qmi_set_wds_get_default_profile_number_request(msg, &type_family);
+		return QMI_CMD_REQUEST;
+	}
+
+	uqmi_add_error("Invalid value (valid: 3gpp or 3gpp2)");
+	return QMI_CMD_EXIT;
+}
+
+//===================== prepare modify profile request call =================
+static enum qmi_cmd_result cmd_wds_modify_profile_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							  struct qmi_msg *msg, char *arg)
+{
+	int id;
+	char *s;
+	char *p_type;
+
+	s = strchr(arg, ',');
+	if (!s) {
+		fprintf(stderr, "Invalid argument\n");
+		return QMI_CMD_EXIT;
+	}
+	*s = 0;
+	s++;
+
+	id = strtoul(s, &s, 0);
+	if (s && *s) {
+		fprintf(stderr, "Invalid argument\n");
+		return QMI_CMD_EXIT;
+	}
+	if (id > UINT8_MAX) {
+		uqmi_add_error("Error: Input value out of range");
+		return QMI_CMD_EXIT;
+	}
+
+	p_type = strtok(arg, ",");
+
+	for (int i = 0; i < ARRAY_SIZE(profile_types); i++) {
+		if (strcasecmp(profile_types[i].profile_name, p_type) != 0) {
+			continue;
+		}
+
+		qmi_set_profile_identifier_sequence(&wds_mp_req, profile_types[i].profile, (uint8_t)id);
+
+		qmi_set_wds_modify_profile_request(msg, &wds_mp_req);
+		return QMI_CMD_REQUEST;
+	}
+
+	uqmi_add_error("Invalid value (valid: 3gpp or 3gpp2)");
+	return QMI_CMD_EXIT;
+}
+
+//===================== prepare get-profile-settings request call =================
+static enum qmi_cmd_result cmd_wds_get_profile_settings_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+								struct qmi_msg *msg, char *arg)
+{
+	int id;
+	char *s;
+	char *p_type;
+
+	s = strchr(arg, ',');
+	if (!s) {
+		fprintf(stderr, "Invalid argument: %s\n", arg);
+		return QMI_CMD_EXIT;
+	}
+	*s = 0;
+	s++;
+
+	id = strtoul(s, &s, 0);
+	if (s && *s) {
+		fprintf(stderr, "Invalid argument: %s\n", arg);
+		return QMI_CMD_EXIT;
+	}
+	if (id > UINT8_MAX) {
+		uqmi_add_error("Error: Input value out of range");
+		return QMI_CMD_EXIT;
+	}
+
+	p_type = strtok(arg, ",");
+
+	for (int i = 0; i < ARRAY_SIZE(profile_types); i++) {
+		if (strcasecmp(profile_types[i].profile_name, p_type) != 0) {
+			continue;
+		}
+		struct qmi_wds_get_profile_settings_request p_num = { QMI_INIT_SEQUENCE(
+			profile_id, .profile_type = profile_types[i].profile,
+			.profile_index = (uint8_t)id, ) };
+		qmi_set_wds_get_profile_settings_request(msg, &p_num);
+		return QMI_CMD_REQUEST;
+	}
+
+	uqmi_add_error("Invalid value (valid: 3gpp or 3gpp2)");
+	return QMI_CMD_EXIT;
+}
+
+//===================== prepare get-current-settings request call =================
+static enum qmi_cmd_result cmd_wds_get_current_settings_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+								struct qmi_msg *msg, char *arg)
+{
+	struct qmi_wds_get_current_settings_request gcs_req;
+	memset(&gcs_req, '\0', sizeof(struct qmi_wds_get_current_settings_request));
+	qmi_set(&gcs_req, requested_settings,
+		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PDP_TYPE |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DNS_ADDRESS |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GRANTED_QOS |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_ADDRESS |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GATEWAY_INFO |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_MTU |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DOMAIN_NAME_LIST |
+			QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_FAMILY);
+	qmi_set_wds_get_current_settings_request(msg, &gcs_req);
+	return QMI_CMD_REQUEST;
 }
 
-static enum qmi_cmd_result
-cmd_wds_get_packet_service_status_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare bind-mux-data-port request call =================
+static enum qmi_cmd_result cmd_wds_bind_mux_data_port_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							      struct qmi_msg *msg, char *arg)
+{
+	qmi_set_wds_bind_mux_data_port_request(msg, &wds_bind_mux_port_req);
+	return QMI_CMD_REQUEST;
+}
+
+//===================== prepare create-profile request call =================
+static enum qmi_cmd_result cmd_wds_create_profile_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							  struct qmi_msg *msg, char *arg)
+{
+	for (int i = 0; i < ARRAY_SIZE(profile_types); i++) {
+		if (strcasecmp(profile_types[i].profile_name, arg) != 0) {
+			continue;
+		}
+		qmi_set_ptr(&wds_cp_req, profile_type, profile_types[i].profile);
+
+		qmi_set_wds_create_profile_request(msg, &wds_cp_req);
+		return QMI_CMD_REQUEST;
+	}
+
+	uqmi_add_error("Invalid value (valid: 3gpp or 3gpp2)");
+	return QMI_CMD_EXIT;
+}
+
+//===================== prepare get-package-service-status request call =================
+static enum qmi_cmd_result cmd_wds_get_packet_service_status_prepare(struct qmi_dev *qmi,
+								     struct qmi_request *req,
+								     struct qmi_msg *msg, char *arg)
 {
 	qmi_set_wds_get_packet_service_status_request(msg);
 	return QMI_CMD_REQUEST;
 }
 
-#define cmd_wds_set_autoconnect_settings_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_autoconnect_settings_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare get-autoconnect-settings request call =================
+static enum qmi_cmd_result cmd_wds_set_autoconnect_settings_prepare(struct qmi_dev *qmi,
+								    struct qmi_request *req,
+								    struct qmi_msg *msg, char *arg)
 {
 	struct qmi_wds_set_autoconnect_settings_request ac_req;
-	const char *modes[] = {
+	const char *auto_modes[] = {
 		[QMI_WDS_AUTOCONNECT_SETTING_DISABLED] = "disabled",
-		[QMI_WDS_AUTOCONNECT_SETTING_ENABLED] = "enabled",
-		[QMI_WDS_AUTOCONNECT_SETTING_PAUSED] = "paused",
+		[QMI_WDS_AUTOCONNECT_SETTING_ENABLED]  = "enabled",
+		[QMI_WDS_AUTOCONNECT_SETTING_PAUSED]   = "paused",
 	};
-	int i;
 
-	for (i = 0; i < ARRAY_SIZE(modes); i++) {
-		if (strcasecmp(modes[i], arg) != 0)
+	for (int i = 0; i < ARRAY_SIZE(auto_modes); i++) {
+		if (strcasecmp(auto_modes[i], arg) != 0) {
 			continue;
+		}
 
 		qmi_set(&ac_req, status, i);
 		qmi_set_wds_set_autoconnect_settings_request(msg, &ac_req);
-		return QMI_CMD_DONE;
+		return QMI_CMD_REQUEST;
 	}
 
-	uqmi_add_error("Invalid value (valid: disabled, enabled, paused)");
+	uqmi_add_error("Invalid autoconnect value (valid: disabled, enabled, paused)");
 	return QMI_CMD_EXIT;
 }
 
-#define cmd_wds_reset_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_reset_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare get-autoconnect-settings request call =================
+static enum qmi_cmd_result cmd_wds_get_autoconnect_settings_prepare(struct qmi_dev *qmi,
+								    struct qmi_request *req,
+								    struct qmi_msg *msg, char *arg)
+{
+	qmi_set_wds_get_autoconnect_settings_request(msg);
+	return QMI_CMD_REQUEST;
+}
+
+//===================== prepare set-wst-reset request call =================
+static enum qmi_cmd_result cmd_wds_reset_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+						 struct qmi_msg *msg, char *arg)
 {
 	qmi_set_wds_reset_request(msg);
 	return QMI_CMD_REQUEST;
 }
 
-#define cmd_wds_set_ip_family_cb no_cb
-static enum qmi_cmd_result
-cmd_wds_set_ip_family_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== prepare set-ip-family request call =================
+static enum qmi_cmd_result cmd_wds_set_ip_family_prepare(struct qmi_dev *qmi, struct qmi_request *req,
+							 struct qmi_msg *msg, char *arg)
 {
 	struct qmi_wds_set_ip_family_request ipf_req;
-	const struct ip_modes {
-		const char *name;
-		const QmiWdsIpFamily mode;
-	} modes[] = {
-		{ "ipv4", QMI_WDS_IP_FAMILY_IPV4 },
-		{ "ipv6", QMI_WDS_IP_FAMILY_IPV6 },
-		{ "unspecified", QMI_WDS_IP_FAMILY_UNSPECIFIED },
-	};
-	int i;
 
-	for (i = 0; i < ARRAY_SIZE(modes); i++) {
-		if (strcasecmp(modes[i].name, arg) != 0)
+	for (int i = 0; i < ARRAY_SIZE(ipfam_modes); i++) {
+		if (strcasecmp(ipfam_modes[i].ipfam_name, arg) != 0) {
 			continue;
+		}
 
-		qmi_set(&ipf_req, preference, modes[i].mode);
+		qmi_set(&ipf_req, preference, ipfam_modes[i].mode);
 		qmi_set_wds_set_ip_family_request(msg, &ipf_req);
 		return QMI_CMD_REQUEST;
 	}
@@ -243,6 +546,147 @@
 	return QMI_CMD_EXIT;
 }
 
+/***************************************************
+	Handler parsing callbacks from uqmi call
+****************************************************/
+#define cmd_wds_set_auth_cb		       no_cb
+#define cmd_wds_set_apn_cb		       no_cb
+#define cmd_wds_set_username_cb		       no_cb
+#define cmd_wds_set_password_cb		       no_cb
+#define cmd_wds_set_autoconnect_cb	       no_cb
+#define cmd_wds_set_ip_family_pref_cb	       no_cb
+#define cmd_wds_set_pdp_type_cb		       no_cb
+#define cmd_wds_no_roaming_cb		       no_cb
+#define cmd_wds_set_profile_cb		       no_cb
+#define cmd_wds_set_autoconnect_settings_cb    no_cb
+#define cmd_wds_reset_cb		       no_cb
+#define cmd_wds_set_ip_family_cb	       no_cb
+#define cmd_wds_mux_id_cb		       no_cb
+#define cmd_wds_ep_iface_number_cb	       no_cb
+#define cmd_wds_set_profile_identifier_cb      no_cb
+#define cmd_wds_set_roaming_disallowed_flag_cb no_cb
+#define cmd_wds_set_profile_name_cb	       no_cb
+#define cmd_wds_bind_mux_data_port_cb	       no_cb
+#define cmd_wds_stop_network_cb		       no_cb
+
+//===================== start-network CB handler =================
+void cmd_wds_start_network_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_wds_start_network_response res;
+	qmi_parse_wds_start_network_response(msg, &res);
+
+	if (res.set.packet_data_handle && res.data.packet_data_handle != 0) {
+		blobmsg_add_u32(&status, NULL, res.data.packet_data_handle);
+	} else {
+		LOG("%s\"\n",
+		    qmi_wds_verbose_call_end_reason_get_string(res.data.verbose_call_end_reason.type,
+							       res.data.verbose_call_end_reason.reason));
+	}
+}
+
+//===================== modify-profile CB handler =================
+static void cmd_wds_modify_profile_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_wds_modify_profile_response res;
+	qmi_parse_wds_modify_profile_response(msg, &res);
+}
+
+//===================== create-profile CB handler =================
+static void cmd_wds_create_profile_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_wds_create_profile_response res;
+	void *p;
+
+	qmi_parse_wds_create_profile_response(msg, &res);
+
+	if (res.set.profile_identifier) {
+		p = blobmsg_open_table(&status, NULL);
+		blobmsg_add_u32(&status, "created-profile", res.data.profile_identifier.profile_index);
+		blobmsg_close_table(&status, p);
+	}
+}
+
+//===================== get-package-service-status CB handler =================
+static void cmd_wds_get_packet_service_status_cb(struct qmi_dev *qmi, struct qmi_request *req,
+						 struct qmi_msg *msg)
+{
+	struct qmi_wds_get_packet_service_status_response res;
+	const char *data_status[] = {
+		[QMI_WDS_CONNECTION_STATUS_UNKNOWN]	   = "unknown",
+		[QMI_WDS_CONNECTION_STATUS_DISCONNECTED]   = "disconnected",
+		[QMI_WDS_CONNECTION_STATUS_CONNECTED]	   = "connected",
+		[QMI_WDS_CONNECTION_STATUS_SUSPENDED]	   = "suspended",
+		[QMI_WDS_CONNECTION_STATUS_AUTHENTICATING] = "authenticating",
+	};
+	int s = 0;
+
+	qmi_parse_wds_get_packet_service_status_response(msg, &res);
+	if (res.set.connection_status && res.data.connection_status < ARRAY_SIZE(data_status)) {
+		s = res.data.connection_status;
+	}
+
+	blobmsg_add_string(&status, NULL, data_status[s]);
+}
+
+//===================== get-autoconnect-settings CB handler =================
+static void cmd_wds_get_autoconnect_settings_cb(struct qmi_dev *qmi, struct qmi_request *req,
+						struct qmi_msg *msg)
+{
+	struct qmi_wds_get_autoconnect_settings_response res;
+	void *p;
+
+	const char *modes[] = {
+		[QMI_WDS_AUTOCONNECT_SETTING_DISABLED] = "disabled",
+		[QMI_WDS_AUTOCONNECT_SETTING_ENABLED]  = "enabled",
+		[QMI_WDS_AUTOCONNECT_SETTING_PAUSED]   = "paused",
+	};
+
+	const char *autoconnect_roaming_settings[] = {
+		[QMI_WDS_AUTOCONNECT_SETTING_ROAMING_ALLOWED]	= "allowed",
+		[QMI_WDS_AUTOCONNECT_SETTING_ROAMING_HOME_ONLY] = "home only",
+	};
+
+	qmi_parse_wds_get_autoconnect_settings_response(msg, &res);
+
+	p = blobmsg_open_table(&status, NULL);
+
+	if (res.set.status && (int)res.data.status < ARRAY_SIZE(modes)) {
+		blobmsg_add_string(&status, "status", modes[res.data.status]);
+	}
+	if (res.set.roaming && (int)res.data.roaming < ARRAY_SIZE(autoconnect_roaming_settings)) {
+		blobmsg_add_string(&status, "roaming", autoconnect_roaming_settings[res.data.roaming]);
+	}
+
+	blobmsg_close_table(&status, p);
+}
+
+//===================== get-profile-settings CB handler =================
+static void cmd_wds_get_profile_settings_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_wds_get_profile_settings_response res;
+
+	void *p;
+
+	qmi_parse_wds_get_profile_settings_response(msg, &res);
+
+	p = blobmsg_open_table(&status, NULL);
+
+	blobmsg_add_string(&status, "apn", res.data.apn_name);
+	if (res.set.pdp_type && (int)res.data.pdp_type < ARRAY_SIZE(pdp_types)) {
+		blobmsg_add_string(&status, "pdp-type", pdp_types[res.data.pdp_type].pdp_name);
+	}
+	blobmsg_add_string(&status, "username", res.data.username);
+	blobmsg_add_string(&status, "password", res.data.password);
+	if (res.set.authentication && (int)res.data.authentication < ARRAY_SIZE(auth_modes)) {
+		blobmsg_add_string(&status, "auth", auth_modes[res.data.authentication].auth_name);
+	}
+	blobmsg_add_u8(&status, "no-roaming", res.data.roaming_disallowed_flag);
+	blobmsg_add_u8(&status, "apn-disabled", res.data.apn_disabled_flag);
+	blobmsg_close_table(&status, p);
+}
+
+//===================== get-current-setting-status CB handler =================
+
 static void wds_to_ipv4(const char *name, const uint32_t addr)
 {
 	struct in_addr ip_addr;
@@ -258,65 +702,59 @@
 	uint16_t ip_addr[8];
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(ip_addr); i++)
+	for (i = 0; i < ARRAY_SIZE(ip_addr); i++) {
 		ip_addr[i] = htons(addr[i]);
+	}
 
 	blobmsg_add_string(&status, name, inet_ntop(AF_INET6, &ip_addr, buf, sizeof(buf)));
 }
 
-static void
-cmd_wds_get_current_settings_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+static void cmd_wds_get_current_settings_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
 {
 	void *v4, *v6, *d, *t;
 	struct qmi_wds_get_current_settings_response res;
-	const char *pdptypes[] = {
-		[QMI_WDS_PDP_TYPE_IPV4] = "ipv4",
-		[QMI_WDS_PDP_TYPE_PPP] = "ppp",
-		[QMI_WDS_PDP_TYPE_IPV6] = "ipv6",
-		[QMI_WDS_PDP_TYPE_IPV4_OR_IPV6] = "ipv4-or-ipv6",
-	};
-	const struct ip_modes {
-		const char *name;
-		const QmiWdsIpFamily mode;
-	} modes[] = {
-		{ "ipv4", QMI_WDS_IP_FAMILY_IPV4 },
-		{ "ipv6", QMI_WDS_IP_FAMILY_IPV6 },
-		{ "unspecified", QMI_WDS_IP_FAMILY_UNSPECIFIED },
-	};
 	int i;
 
 	qmi_parse_wds_get_current_settings_response(msg, &res);
 
 	t = blobmsg_open_table(&status, NULL);
 
-	if (res.set.pdp_type && (int) res.data.pdp_type < ARRAY_SIZE(pdptypes))
-		blobmsg_add_string(&status, "pdp-type", pdptypes[res.data.pdp_type]);
+	if (res.set.pdp_type && (int)res.data.pdp_type < ARRAY_SIZE(pdp_types)) {
+		blobmsg_add_string(&status, "pdp-type", pdp_types[res.data.pdp_type].pdp_name);
+	}
 
 	if (res.set.ip_family) {
-		for (i = 0; i < ARRAY_SIZE(modes); i++) {
-			if (modes[i].mode != res.data.ip_family)
+		for (i = 0; i < ARRAY_SIZE(ipfam_modes); i++) {
+			if (ipfam_modes[i].mode != res.data.ip_family) {
 				continue;
-			blobmsg_add_string(&status, "ip-family", modes[i].name);
+			}
+			blobmsg_add_string(&status, "ip-family", ipfam_modes[i].ipfam_name);
 			break;
 		}
 	}
 
-	if (res.set.mtu)
+	if (res.set.mtu) {
 		blobmsg_add_u32(&status, "mtu", res.data.mtu);
+	}
 
 	/* IPV4 */
 	v4 = blobmsg_open_table(&status, "ipv4");
 
-	if (res.set.ipv4_address)
+	if (res.set.ipv4_address) {
 		wds_to_ipv4("ip", res.data.ipv4_address);
-	if (res.set.primary_ipv4_dns_address)
+	}
+	if (res.set.primary_ipv4_dns_address) {
 		wds_to_ipv4("dns1", res.data.primary_ipv4_dns_address);
-	if (res.set.secondary_ipv4_dns_address)
+	}
+	if (res.set.secondary_ipv4_dns_address) {
 		wds_to_ipv4("dns2", res.data.secondary_ipv4_dns_address);
-	if (res.set.ipv4_gateway_address)
+	}
+	if (res.set.ipv4_gateway_address) {
 		wds_to_ipv4("gateway", res.data.ipv4_gateway_address);
-	if (res.set.ipv4_gateway_subnet_mask)
+	}
+	if (res.set.ipv4_gateway_subnet_mask) {
 		wds_to_ipv4("subnet", res.data.ipv4_gateway_subnet_mask);
+	}
 	blobmsg_close_table(&status, v4);
 
 	/* IPV6 */
@@ -330,10 +768,12 @@
 		wds_to_ipv6("gateway", res.data.ipv6_gateway_address.address);
 		blobmsg_add_u32(&status, "gw-prefix-length", res.data.ipv6_gateway_address.prefix_length);
 	}
-	if (res.set.ipv6_primary_dns_address)
+	if (res.set.ipv6_primary_dns_address) {
 		wds_to_ipv6("dns1", res.data.ipv6_primary_dns_address);
-	if (res.set.ipv6_secondary_dns_address)
+	}
+	if (res.set.ipv6_secondary_dns_address) {
 		wds_to_ipv6("dns2", res.data.ipv6_secondary_dns_address);
+	}
 
 	blobmsg_close_table(&status, v6);
 
@@ -346,20 +786,39 @@
 	blobmsg_close_table(&status, t);
 }
 
-static enum qmi_cmd_result
-cmd_wds_get_current_settings_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+//===================== get-dormancy-status CB handler =================
+static void cmd_wds_get_dormancy_status_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
 {
-	struct qmi_wds_get_current_settings_request gcs_req;
-	memset(&gcs_req, '\0', sizeof(struct qmi_wds_get_current_settings_request));
-	qmi_set(&gcs_req, requested_settings,
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_PDP_TYPE |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DNS_ADDRESS |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GRANTED_QOS |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_ADDRESS |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_GATEWAY_INFO |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_MTU |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_DOMAIN_NAME_LIST |
-		QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_IP_FAMILY);
-	qmi_set_wds_get_current_settings_request(msg, &gcs_req);
-	return QMI_CMD_REQUEST;
+	struct qmi_wds_get_dormancy_status_response res;
+	const char *dormancy_types[] = {
+		[QMI_WDS_DORMANCY_STATUS_UNKNOWN]		  = "unknown",
+		[QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_ACTIVE]  = "traffic-channel-active",
+		[QMI_WDS_DORMANCY_STATUS_TRAFFIC_CHANNEL_DORMANT] = "traffic-channel-dormant",
+	};
+	void *c;
+
+	qmi_parse_wds_get_dormancy_status_response(msg, &res);
+
+	c = blobmsg_open_table(&status, NULL);
+	if (res.set.dormancy_status) {
+		int dormancy_state = res.data.dormancy_status;
+
+		blobmsg_add_string(&status, "dormancy_status", dormancy_types[dormancy_state]);
+	}
+
+	blobmsg_close_table(&status, c);
+}
+
+//===================== get-default-profile CB handler =================
+static void cmd_wds_get_default_profile_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg)
+{
+	struct qmi_wds_get_default_profile_number_response res;
+	void *p;
+	qmi_parse_wds_get_default_profile_number_response(msg, &res);
+
+	p = blobmsg_open_table(&status, NULL);
+
+	blobmsg_add_u32(&status, "default-profile", res.data.index);
+
+	blobmsg_close_table(&status, p);
 }
diff --recursive --unified --new-file --no-dereference orig/commands-wds.h src/commands-wds.h
--- orig/commands-wds.h	2023-11-09 07:17:16.000000000 +0000
+++ src/commands-wds.h	2024-04-25 07:20:16.000000000 +0000
@@ -19,36 +19,73 @@
  * Boston, MA 02110-1301 USA.
  */
 
-#define __uqmi_wds_commands \
-	__uqmi_command(wds_start_network, start-network, no, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_set_apn, apn, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_auth, auth-type, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_username, username, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_password, password, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_ip_family_pref, ip-family, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_autoconnect, autoconnect, no, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_set_profile, profile, required, CMD_TYPE_OPTION), \
-	__uqmi_command(wds_stop_network, stop-network, required, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_get_packet_service_status, get-data-status, no, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_set_ip_family, set-ip-family, required, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_set_autoconnect_settings, set-autoconnect, required, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_reset, reset-wds, no, QMI_SERVICE_WDS), \
-	__uqmi_command(wds_get_current_settings, get-current-settings, no, QMI_SERVICE_WDS) \
+#define __uqmi_wds_commands                                                                                  \
+	__uqmi_command(wds_start_network, start-network, no, QMI_SERVICE_WDS),                               \
+		__uqmi_command(wds_set_apn, apn, required, CMD_TYPE_OPTION),                                 \
+		__uqmi_command(wds_set_auth, auth-type, required, CMD_TYPE_OPTION),                          \
+		__uqmi_command(wds_set_username, username, required, CMD_TYPE_OPTION),                       \
+		__uqmi_command(wds_set_password, password, required, CMD_TYPE_OPTION),                       \
+		__uqmi_command(wds_set_ip_family_pref, ip-family, required, CMD_TYPE_OPTION),                \
+		__uqmi_command(wds_set_autoconnect, autoconnect, no, CMD_TYPE_OPTION),                       \
+		__uqmi_command(wds_set_profile, profile, required, CMD_TYPE_OPTION),                         \
+		__uqmi_command(wds_set_roaming_disallowed_flag, roaming-disallowed-flag, required,           \
+			       CMD_TYPE_OPTION),                                                             \
+		__uqmi_command(wds_set_profile_name, profile-name, required, CMD_TYPE_OPTION),               \
+		__uqmi_command(wds_set_pdp_type, pdp-type, required, CMD_TYPE_OPTION),                       \
+		__uqmi_command(wds_stop_network, stop-network, required, QMI_SERVICE_WDS),                   \
+		__uqmi_command(wds_get_packet_service_status, get-data-status, no, QMI_SERVICE_WDS),         \
+		__uqmi_command(wds_set_ip_family, set-ip-family, required, QMI_SERVICE_WDS),                 \
+		__uqmi_command(wds_set_autoconnect_settings, set-autoconnect, required, QMI_SERVICE_WDS),    \
+		__uqmi_command(wds_get_autoconnect_settings, get-autoconnect, no, QMI_SERVICE_WDS),          \
+		__uqmi_command(wds_reset, reset-wds, no, QMI_SERVICE_WDS),                                   \
+		__uqmi_command(wds_get_dormancy_status, get-dormancy-status, no, QMI_SERVICE_WDS),           \
+		__uqmi_command(wds_bind_mux_data_port, wds-bind-mux-data-port, no, QMI_SERVICE_WDS),         \
+		__uqmi_command(wds_mux_id, mux-id, required, CMD_TYPE_OPTION),                               \
+		__uqmi_command(wds_ep_iface_number, ep-iface-number, required, CMD_TYPE_OPTION),             \
+		__uqmi_command(wds_get_profile_settings, get-profile-settings, required,                     \
+			       QMI_SERVICE_WDS),                                                             \
+		__uqmi_command(wds_get_default_profile, get-default-profile, required, QMI_SERVICE_WDS),     \
+		__uqmi_command(wds_create_profile, create-profile, required, QMI_SERVICE_WDS),               \
+		__uqmi_command(wds_modify_profile, modify-profile, required, QMI_SERVICE_WDS),               \
+		__uqmi_command(wds_get_current_settings, get-current-settings, no, QMI_SERVICE_WDS)
 
+#define wds_helptext                                                                                                     \
+	"  --start-network:                         Start network connection (use with options below)\n"                 \
+	"       --apn <apn>:                        Use APN\n"                                                           \
+	"       --auth-type pap|chap|both|none:     Use network authentication type\n"                                   \
+	"       --username <name>:                  Use network username\n"                                              \
+	"       --password <password>:              Use network password\n"                                              \
+	"       --ip-family <family>:               Use ip-family for the connection (ipv4, ipv6, unspecified)\n"        \
+	"       --autoconnect:                      Enable automatic connect/reconnect\n"                                \
+	"       --profile <index>:                  Use connection profile\n"                                            \
+	"  --stop-network <pdh>:                    Stop network connection (use with option below)\n"                   \
+	"       --autoconnect:                      Disable automatic connect/reconnect\n"                               \
+	"  --get-data-status:                       Get current data access status\n"                                    \
+	"  --set-ip-family <val>:                   Set ip-family (ipv4, ipv6, unspecified)\n"                           \
+	"  --set-autoconnect <val>:                 Set autoconnect settings (roaming settings optional)\n"              \
+	"  --get-autoconnect:                       Get automatic settings status\n"                                     \
+	"  --get-current-settings:                  Get current connection settings\n"                                   \
+	"  --get-dormancy-status:	            Get current dormancy status\n"                                       \
+	"  --wds-bind-mux-data-port:	            Bind qmux data port to controller device (use with options below)\n" \
+	"       --mux-id <id>:		            Set qmux port id\n"                                                  \
+	"       --ep-iface-number <number>:         Set endpoint interface number\n"                                     \
+	"  --get-profile-settings <val,pdp>:        Get APN profile settings (3gpp, 3gpp2),pdp\n"                        \
+	"  --get-default-profile <val>:             Get default profile number (3gpp, 3gpp2)\n"                          \
+	"  --create-profile <val>                   Create profile (3gpp, 3gpp2)\n"                                      \
+	"       --apn <apn>:                        Use APN\n"                                                           \
+	"       --pdp-type ipv4|ipv6|ipv4v6>:       Use pdp-type for the connection\n"                                   \
+	"       --username <name>:                  Use network username\n"                                              \
+	"       --password <password>:              Use network password\n"                                              \
+	"       --auth-type pap|chap|both|none:     Use network authentication type\n"                                   \
+	"       --roaming-disallowed-flag <bool> :  Use roaming disallowed flag (yes, true, no, false)\n"                \
+	"       --profile-name <name>:	            Use profile name\n"                                                  \
+	"  --modify-profile <val>,#                 Modify profile number (3gpp, 3gpp2)\n"                               \
+	"       --apn <apn>:                        Use APN\n"                                                           \
+	"       --pdp-type ipv4|ipv6|ipv4v6>:       Use pdp-type for the connection\n"                                   \
+	"       --username <name>:                  Use network username\n"                                              \
+	"       --password <password>:              Use network password\n"                                              \
+	"       --auth-type pap|chap|both|none:     Use network authentication type\n"                                   \
+	"       --roaming-disallowed-flag <bool> :  Use roaming disallowed flag (yes, true, no, false)\n"                \
+	"       --profile-name <name>:	            Use profile name\n"
 
-#define wds_helptext \
-		"  --start-network:                  Start network connection (use with options below)\n" \
-		"    --apn <apn>:                    Use APN\n" \
-		"    --auth-type pap|chap|both|none: Use network authentication type\n" \
-		"    --username <name>:              Use network username\n" \
-		"    --password <password>:          Use network password\n" \
-		"    --ip-family <family>:           Use ip-family for the connection (ipv4, ipv6, unspecified)\n" \
-		"    --autoconnect:                  Enable automatic connect/reconnect\n" \
-		"    --profile <index>:              Use connection profile\n" \
-		"  --stop-network <pdh>:             Stop network connection (use with option below)\n" \
-		"    --autoconnect:                  Disable automatic connect/reconnect\n" \
-		"  --get-data-status:                Get current data access status\n" \
-		"  --set-ip-family <val>:            Set ip-family (ipv4, ipv6, unspecified)\n" \
-		"  --set-autoconnect <val>:          Set automatic connect/reconnect (disabled, enabled, paused)\n" \
-		"  --get-current-settings:           Get current connection settings\n" \
-
+void cmd_wds_start_network_cb(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg);
diff --recursive --unified --new-file --no-dereference orig/commands.c src/commands.c
--- orig/commands.c	2023-11-09 07:11:45.000000000 +0000
+++ src/commands.c	2024-04-25 07:20:16.000000000 +0000
@@ -19,11 +19,13 @@
  * Boston, MA 02110-1301 USA.
  */
 
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <string.h>
 #include <strings.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <dirent.h>
 
 #include <libubox/blobmsg.h>
 #include <libubox/blobmsg_json.h>
@@ -164,6 +166,174 @@
 	return QMI_CMD_DONE;
 }
 
+static void
+reload_wwan_iface_name(struct qmi_dev *qmi)
+{
+	const char *cdc_wdm_device_name;
+	static const char *driver_names[] = { "usbmisc", "usb" };
+	uint32_t i;
+
+	cdc_wdm_device_name = strrchr(qmi->fd_path, '/');
+	if (!cdc_wdm_device_name) {
+		uqmi_add_error("invalid path for cdc-wdm control port");
+		return;
+	}
+	cdc_wdm_device_name++;
+
+	for (i = 0; i < ARRAY_SIZE(driver_names) && !qmi->wwan_iface; i++) {
+		char *sysfs_path;
+		struct dirent *sysfs_entry;
+		DIR *sysfs_fold;
+
+		asprintf(&sysfs_path, "/sys/class/%s/%s/device/net",
+			 driver_names[i], cdc_wdm_device_name);
+		sysfs_fold = opendir(sysfs_path);
+		if (!sysfs_fold) {
+//			uqmi_add_error("Failed to open");
+			continue;
+		}
+
+		while ((sysfs_entry = readdir(sysfs_fold))) {
+			if (strstr(sysfs_entry->d_name, ".")) {
+				continue;
+			}
+			/* We only expect ONE file in the sysfs directory corresponding
+                         * to this control port, if more found for any reason, warn about it */
+			if (qmi->wwan_iface) {
+				uqmi_add_error("Invalid additional wwan iface found");
+			} else {
+				qmi->wwan_iface = strdup(sysfs_entry->d_name);
+				break;
+			}
+		}
+
+		closedir(sysfs_fold);
+		free(sysfs_path);
+	}
+
+	if (!qmi->wwan_iface) {
+		uqmi_add_error("wwan iface not found");
+	}
+}
+
+static enum qmi_cmd_result
+set_expected_data_format(char *sysfs_path,
+			 QmiCtlDataLinkProtocol requested)
+{
+	enum qmi_cmd_result ret = QMI_CMD_EXIT;
+	char value;
+	FILE *f = NULL;
+
+	if (requested == QMI_CTL_DATA_LINK_PROTOCOL_RAW_IP)
+		value = 'Y';
+	else if (requested == QMI_CTL_DATA_LINK_PROTOCOL_802_3)
+		value = 'N';
+	else
+		goto out;
+
+	if (!(f = fopen(sysfs_path, "w"))) {
+		uqmi_add_error("Failed to open file for R/W");
+		goto out;
+	}
+
+	if (fwrite(&value, 1, 1, f) != 1) {
+		uqmi_add_error("Failed to write to file");
+		goto out;
+	}
+
+	ret = QMI_CMD_DONE;
+out:
+	if (f)
+		fclose(f);
+	return ret;
+}
+
+static QmiCtlDataLinkProtocol get_expected_data_format(char *sysfs_path)
+{
+	QmiCtlDataLinkProtocol expected = QMI_CTL_DATA_LINK_PROTOCOL_UNKNOWN;
+	char value = '\0';
+	FILE *f;
+
+	if (!(f = fopen(sysfs_path, "r"))) {
+		uqmi_add_error("Failed to open file");
+		goto out;
+	}
+
+	if (fread(&value, 1, 1, f) != 1) {
+		uqmi_add_error("Failed to read from file");
+		goto out;
+	}
+
+	if (value == 'Y')
+		expected = QMI_CTL_DATA_LINK_PROTOCOL_RAW_IP;
+	else if (value == 'N')
+		expected = QMI_CTL_DATA_LINK_PROTOCOL_802_3;
+	else
+		uqmi_add_error("Unexpected sysfs file contents");
+
+out:
+	if (f)
+		fclose(f);
+	return expected;
+}
+
+static enum qmi_cmd_result
+cmd_ctl_get_set_expected_data_format(struct qmi_dev *qmi,
+				     QmiCtlDataLinkProtocol requested)
+{
+	char *sysfs_path = NULL;
+	QmiCtlDataLinkProtocol expected = QMI_CTL_DATA_LINK_PROTOCOL_UNKNOWN;
+	bool read_only;
+	enum qmi_cmd_result ret = QMI_CMD_EXIT;
+
+	read_only = (requested == QMI_CTL_DATA_LINK_PROTOCOL_UNKNOWN);
+
+	reload_wwan_iface_name(qmi);
+	if (!qmi->wwan_iface) {
+		uqmi_add_error("Unknown wwan iface");
+		goto out;
+	}
+
+	asprintf(&sysfs_path, "/sys/class/net/%s/qmi/raw_ip", qmi->wwan_iface);
+
+	if (!read_only && set_expected_data_format(sysfs_path, requested))
+		goto out;
+
+	if ((expected = get_expected_data_format(sysfs_path)) ==
+	    QMI_CTL_DATA_LINK_PROTOCOL_UNKNOWN)
+		goto out;
+
+	if (!read_only && (requested != expected)) {
+		uqmi_add_error("Expected data format not updated properly");
+		expected = QMI_CTL_DATA_LINK_PROTOCOL_UNKNOWN;
+		goto out;
+	}
+
+	ret = QMI_CMD_DONE;
+out:
+	free(sysfs_path);
+	return ret;
+}
+
+#define cmd_ctl_set_expected_data_format_cb no_cb
+static enum qmi_cmd_result
+cmd_ctl_set_expected_data_format_prepare(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg, char *arg)
+{
+	const char *modes[] = {
+		[QMI_CTL_DATA_LINK_PROTOCOL_802_3] = "802.3",
+		[QMI_CTL_DATA_LINK_PROTOCOL_RAW_IP] = "raw-ip",
+	};
+	int mode = qmi_get_array_idx(modes, ARRAY_SIZE(modes), arg);
+
+	if (mode < 0) {
+		uqmi_add_error("Invalid mode (modes: 802.3, raw-ip)");
+		return QMI_CMD_EXIT;
+	}
+
+	cmd_ctl_get_set_expected_data_format(qmi, mode);
+	return QMI_CMD_DONE;
+}
+
 #include "commands-wds.c"
 #include "commands-dms.c"
 #include "commands-nas.c"
@@ -257,6 +427,13 @@
 	blobmsg_add_string(&status, NULL, msg);
 	return QMI_CMD_EXIT;
 }
+
+int uqmi_overwrite_error(const char *msg)
+{
+	blob_buf_init(&status, 0);
+	blobmsg_add_string(&status, NULL, msg);
+	return QMI_CMD_EXIT;
+}
 
 bool uqmi_run_commands(struct qmi_dev *qmi)
 {
diff --recursive --unified --new-file --no-dereference orig/commands.h src/commands.h
--- orig/commands.h	2023-11-09 07:11:45.000000000 +0000
+++ src/commands.h	2024-04-25 07:20:16.000000000 +0000
@@ -59,6 +59,7 @@
 	__uqmi_command(set_client_id, set-client-id, required, CMD_TYPE_OPTION), \
 	__uqmi_command(get_client_id, get-client-id, required, QMI_SERVICE_CTL), \
 	__uqmi_command(ctl_set_data_format, set-data-format, required, QMI_SERVICE_CTL), \
+	__uqmi_command(ctl_set_expected_data_format, set-expected-data-format, required, QMI_SERVICE_CTL), \
 	__uqmi_wds_commands, \
 	__uqmi_dms_commands, \
 	__uqmi_nas_commands, \
@@ -78,5 +79,6 @@
 void uqmi_add_command(char *arg, int longidx);
 bool uqmi_run_commands(struct qmi_dev *qmi);
 int uqmi_add_error(const char *msg);
+int uqmi_overwrite_error(const char *msg);
 
 #endif
diff --recursive --unified --new-file --no-dereference orig/data/gen-verbose-error-list.pl src/data/gen-verbose-error-list.pl
--- orig/data/gen-verbose-error-list.pl	1970-01-01 00:00:00.000000000 +0000
+++ src/data/gen-verbose-error-list.pl	2024-04-25 07:20:16.000000000 +0000
@@ -0,0 +1,116 @@
+#!/usr/bin/env perl
+use strict;
+
+my $read_fd = @ARGV[0];
+my $write_fd = @ARGV[1];
+
+my $doc_start;
+my $error_data;
+my $line;
+my @errors;
+
+my $print_header;
+my $header_was_printed;
+my $reason_type;
+my $r_type;
+my $ori_r_type = "";
+my $function_name = "";
+my @wds_verbose_type = ("Mip", "Internal", "Cm", "3gpp", "Ppp", "Ehrpd", "Ipv6");
+
+open(RH, '<', $read_fd) or die $!;
+open(WF, '>', $write_fd) or die $!;
+
+print WF <<EOF;
+#define LOG(...) do { \\
+	fprintf(stdout, ##__VA_ARGS__); fflush(stdout); \\
+} while (0);
+
+#define F_IN LOG("START[***\%s:\%d]\\n", __func__, __LINE__)
+#define F_OUT LOG("END[***\%s:\%d]\\n\\n", __func__, __LINE__)
+#define DD LOG("DD[***\%s:\%d]\\n", __func__, __LINE__)
+
+struct Gen_ErrorEnumValue {
+	int code;
+	const char *text;
+};
+
+
+EOF
+
+while ($line = <RH>) {
+	chomp $line;
+
+	$line =~ /^\/\*\*/ and do {
+		$doc_start = 1;
+		next;
+	};
+
+	$line =~ /^\s*\*\// and do {
+		undef $error_data;
+		if ( $header_was_printed == 1 ) {
+			$function_name = 'qmi_wds_verbose_call_end_reason_' . $r_type . '_values';
+			print WF "};\n\n";
+			print WF "static char *qmi_wds_verbose_call_end_reason_" . $r_type . "_get_string(QmiWdsVerboseCallEndReason" . $ori_r_type . " val)\n";
+print WF <<EOF;
+{
+	int i;
+	char *error_str = NULL;
+
+	for(i = 0; $function_name\[i].text; i++ ) {
+		if (val == $function_name\[i].code) {
+			error_str = calloc(1, strlen($function_name\[i].text) + 1);
+			if (error_str) {
+				strcpy(error_str, $function_name\[i].text);
+				return error_str;
+			}
+			break;
+		}
+	}
+	if (!error_str) {
+		error_str = calloc(1, strlen("Unknown reason") + 1);
+			if (error_str) {
+				strcpy(error_str, "Unknown reason");
+				return error_str;
+			}
+	}
+	return error_str;
+}
+
+
+EOF
+			$function_name = "";
+			undef $header_was_printed;
+		}
+	};
+
+	foreach $reason_type ( @wds_verbose_type ) {
+		$doc_start and $line =~ /^\s*\*\s*QmiWdsVerboseCallEndReason$reason_type:/ and do {
+			$r_type = lc($reason_type);
+			$ori_r_type = "$reason_type";
+			$error_data = 1;
+			$print_header = 1;
+			undef $doc_start;
+			next;
+		};
+	}
+
+	$line =~ /^\s*\*\s*@(.+): (.+)\./ and do {
+		push @errors, [ $1, $2 ];
+		undef $doc_start;
+
+		if ( $error_data == 1 && $print_header == 1) {
+			$header_was_printed = 1;
+			print WF "struct Gen_ErrorEnumValue qmi_wds_verbose_call_end_reason_";
+			print WF "$r_type";
+			print WF "_values[] = {\n";
+			print WF "\t{ ".$1.", \"".$2."\" },\n";
+			undef $print_header
+		} elsif ( $error_data == 1 ) {
+			print WF "\t{ ".$1.", \"".$2."\" },\n";
+		}
+	};
+
+}
+close(RH);
+close(WF);
+
diff --recursive --unified --new-file --no-dereference orig/data/qmi-service-wda.json src/data/qmi-service-wda.json
--- orig/data/qmi-service-wda.json	2023-11-09 07:17:16.000000000 +0000
+++ src/data/qmi-service-wda.json	2024-04-25 07:20:16.000000000 +0000
@@ -80,10 +80,25 @@
                      "since"         : "1.18",
                      "format"        : "sequence",
                      "contents"  : [ { "name"          : "Endpoint Type",
-                                       "format"        : "guint32",
-                                       "public-format" : "QmiDataEndpointType"},
+                                     "format"        : "guint32",
+                                     "public-format" : "QmiDataEndpointType"},
                                      { "name"          : "Interface Number",
-                                       "format"        : "guint32"}] }],
+                                       "format"        : "guint32"}] },
+                   { "name"          : "Downlink Minimum Padding",
+                     "id"            : "0x19",
+                     "mandatory"     : "no",
+                     "type"          : "TLV",
+                     "format"        : "guint32" },
+                   { "name"          : "Uplink Data Aggregation Max Datagrams",
+                     "id"            : "0x1B",
+                     "mandatory"     : "no",
+                     "type"          : "TLV",
+                     "format"        : "guint32" },
+                   { "name"          : "Uplink Data Aggregation Max Size",
+                     "id"            : "0x1C",
+                     "mandatory"     : "no",
+                     "Type"          : "TLV",
+                     "format"        : "guint32"}],
      "output"  : [ { "common-ref" : "Operation Result" },
                    { "name"          : "QoS Format",
                      "id"            : "0x10",
diff --recursive --unified --new-file --no-dereference orig/dev.c src/dev.c
--- orig/dev.c	2023-11-09 07:11:45.000000000 +0000
+++ src/dev.c	2024-04-25 07:20:16.000000000 +0000
@@ -28,6 +28,11 @@
 #include "qmi-errors.h"
 #include "qmi-errors.c"
 #include "mbim.h"
+#include "commands-wds.h"
+#include "libuqmi.h"
+
+#define DEFAULT_CALL_TIMEOUT 8 * 1000
+#define DEFAULT_MAX_REQUEST  8
 
 bool cancel_all_requests = false;
 
@@ -37,19 +42,6 @@
 };
 #undef __qmi_service
 
-#ifdef DEBUG_PACKET
-void dump_packet(const char *prefix, void *ptr, int len)
-{
-	unsigned char *data = ptr;
-	int i;
-
-	fprintf(stderr, "%s:", prefix);
-	for (i = 0; i < len; i++)
-		fprintf(stderr, " %02x", data[i]);
-	fprintf(stderr, "\n");
-}
-#endif
-
 static int
 qmi_get_service_idx(QmiService svc)
 {
@@ -76,14 +68,19 @@
 	if (msg) {
 		tlv_buf = qmi_msg_get_tlv_buf(msg, &tlv_len);
 		req->ret = qmi_check_message_status(tlv_buf, tlv_len);
-		if (req->ret)
-			msg = NULL;
+
+		if (req->ret) {
+			if (req->cb != cmd_wds_start_network_cb)
+				msg = NULL;
+		}
 	} else {
 		req->ret = QMI_ERROR_CANCELLED;
 	}
 
-	if (req->cb && (msg || !req->no_error_cb))
+	if ((req->cb && (msg || !req->no_error_cb))
+		|| (req->cb == cmd_wds_start_network_cb)) {
 		req->cb(qmi, req, msg);
+	}
 
 	if (req->complete) {
 		*req->complete = true;
@@ -96,8 +93,10 @@
 	struct qmi_request *req;
 	uint16_t tid;
 
-	if (msg->flags != QMI_CTL_FLAG_RESPONSE && msg->flags != QMI_SERVICE_FLAG_RESPONSE)
+	if (msg->flags != QMI_CTL_FLAG_RESPONSE && msg->flags != QMI_SERVICE_FLAG_RESPONSE) {
+		uloop_timeout_set(&qmi->request_timeout, DEFAULT_CALL_TIMEOUT);
 		return;
+	}
 
 	if (msg->qmux.service == QMI_SERVICE_CTL)
 		tid = msg->ctl.transaction;
@@ -105,12 +104,29 @@
 		tid = le16_to_cpu(msg->svc.transaction);
 
 	list_for_each_entry(req, &qmi->req, list) {
-		if (req->service != msg->qmux.service)
+		if (req->service != msg->qmux.service) {
+			qmi->read_req_retry++;
+			if (qmi->read_req_retry >= DEFAULT_MAX_REQUEST) {
+				qmi->request_timeout.cb = _cancel_request_timeout;
+				uloop_timeout_set(&qmi->request_timeout, 0);
+				return;
+			}
+			uloop_timeout_set(&qmi->request_timeout, DEFAULT_CALL_TIMEOUT);
 			continue;
+		}
 
-		if (req->tid != tid)
+		if (req->tid != tid) {
+			qmi->read_req_retry++;
+			if (qmi->read_req_retry >= DEFAULT_MAX_REQUEST) {
+				qmi->request_timeout.cb = _cancel_request_timeout;
+				uloop_timeout_set(&qmi->request_timeout, 0);
+				return;
+			}
+			uloop_timeout_set(&qmi->request_timeout, DEFAULT_CALL_TIMEOUT);
 			continue;
+		}
 
+		qmi->read_req_retry = 0;
 		__qmi_request_complete(qmi, req, msg);
 		return;
 	}
@@ -123,6 +139,9 @@
 	char *buf;
 	int len, msg_len;
 
+	if (qmi->request_timeout.pending) {
+		uloop_timeout_cancel(&qmi->request_timeout);
+	}
 
 	while (1) {
 		buf = ustream_get_read_buf(us, &len);
@@ -194,6 +213,11 @@
 
 	dump_packet("Send packet", buf, len);
 	ustream_write(&qmi->sf.stream, buf, len, false);
+
+	if (!qmi->request_timeout.pending) {
+		qmi->request_timeout.cb = _request_timeout_handler;
+		uloop_timeout_set(&qmi->request_timeout, DEFAULT_CALL_TIMEOUT);
+	}
 	return 0;
 }
 
@@ -322,7 +346,6 @@
 	for (idx = 0; connected; idx++, connected >>= 1) {
 		if (!(connected & 1))
 			continue;
-
 		if (qmi->service_keep_cid & (1 << idx))
 			continue;
 
@@ -364,6 +387,7 @@
 	INIT_LIST_HEAD(&qmi->req);
 	qmi->ctl_tid = 1;
 	qmi->buf = msgbuf.u.buf;
+	qmi->fd_path = path;
 
 	return 0;
 }
diff --recursive --unified --new-file --no-dereference orig/libuqmi.c src/libuqmi.c
--- orig/libuqmi.c	1970-01-01 00:00:00.000000000 +0000
+++ src/libuqmi.c	2024-04-25 07:20:16.000000000 +0000
@@ -0,0 +1,57 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "libuqmi.h"
+#include "commands.h"
+
+#ifdef DEBUG_PACKET
+void dump_packet(const char *prefix, void *ptr, int len)
+{
+	unsigned char *data = ptr;
+	int i;
+
+	fprintf(stderr, "%s:", prefix);
+	for (i = 0; i < len; i++)
+		fprintf(stderr, " %02x", data[i]);
+	fprintf(stderr, "\n");
+}
+#endif
+
+void keep_client_id(struct qmi_dev *qmi, const char *optarg)
+{
+	QmiService svc = qmi_service_get_by_name(optarg);
+	if (svc < 0) {
+		fprintf(stderr, "Invalid service %s\n", optarg);
+		exit(1);
+	}
+	qmi_service_get_client_id(qmi, svc);
+}
+
+void release_client_id(struct qmi_dev *qmi, const char *optarg)
+{
+	QmiService svc = qmi_service_get_by_name(optarg);
+	if (svc < 0) {
+		fprintf(stderr, "Invalid service %s\n", optarg);
+		exit(1);
+	}
+	qmi_service_release_client_id(qmi, svc);
+}
+
+void handle_exit_signal(int signal)
+{
+	cancel_all_requests = true;
+	uloop_end();
+}
+
+void _request_timeout_handler(struct uloop_timeout *timeout)
+{
+	fprintf(stderr, "Request timed out\n");
+	handle_exit_signal(0);
+}
+
+void _cancel_request_timeout(struct uloop_timeout *timeout)
+{
+	uqmi_overwrite_error("Request canceled");
+	fprintf(stderr, "Request canceled\n");
+	handle_exit_signal(0);
+}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/libuqmi.h src/libuqmi.h
--- orig/libuqmi.h	1970-01-01 00:00:00.000000000 +0000
+++ src/libuqmi.h	2024-04-25 07:20:16.000000000 +0000
@@ -0,0 +1,16 @@
+#ifndef __LIBUQMI_H
+#define __LIBUQMI_H
+
+#include "uqmi.h"
+#include "commands.h"
+
+
+void handle_exit_signal(int signal);
+void _request_timeout_handler(struct uloop_timeout *timeout);
+void _cancel_request_timeout(struct uloop_timeout *timeout);
+
+void dump_packet(const char *prefix, void *ptr, int len);
+
+void keep_client_id(struct qmi_dev *qmi, const char *optarg);
+void release_client_id(struct qmi_dev *qmi, const char *optarg);
+#endif
diff --recursive --unified --new-file --no-dereference orig/main.c src/main.c
--- orig/main.c	2023-11-09 07:11:45.000000000 +0000
+++ src/main.c	2024-04-25 07:20:16.000000000 +0000
@@ -28,9 +28,11 @@
 #include <errno.h>
 #include <getopt.h>
 #include <signal.h>
+#include <sys/file.h>
 
-#include "uqmi.h"
-#include "commands.h"
+#include "libuqmi.h"
+
+#define UQMI_PID "/var/run/uqmi.pid"
 
 static const char *device;
 
@@ -69,6 +71,7 @@
 		"  --get-client-id <name>:           Connect and get Client ID for service <name>\n"
 		"                                    (implies --keep-client-id)\n"
 		"  --sync:                           Release all Client IDs\n"
+		"  --set-expected-data-format <type>: Set expected data format (type: 802.3, raw-ip)\n"
 		wds_helptext
 		dms_helptext
 		uim_helptext
@@ -79,50 +82,17 @@
 	return 1;
 }
 
-static void keep_client_id(struct qmi_dev *qmi, const char *optarg)
-{
-	QmiService svc = qmi_service_get_by_name(optarg);
-	if (svc < 0) {
-		fprintf(stderr, "Invalid service %s\n", optarg);
-		exit(1);
-	}
-	qmi_service_get_client_id(qmi, svc);
-}
-
-static void release_client_id(struct qmi_dev *qmi, const char *optarg)
-{
-	QmiService svc = qmi_service_get_by_name(optarg);
-	if (svc < 0) {
-		fprintf(stderr, "Invalid service %s\n", optarg);
-		exit(1);
-	}
-	qmi_service_release_client_id(qmi, svc);
-}
-
-static void handle_exit_signal(int signal)
-{
-	cancel_all_requests = true;
-	uloop_end();
-}
-
-static void _request_timeout_handler(struct uloop_timeout *timeout)
-{
-	fprintf(stderr, "Request timed out\n");
-	handle_exit_signal(0);
-}
-
-struct uloop_timeout request_timeout = { .cb = _request_timeout_handler, };
-
 int main(int argc, char **argv)
 {
-	static struct qmi_dev dev;
-	int ch, ret;
+	static struct qmi_dev dev = { 0 };
+	int ch, pid, ret;
+	char uq_pid[32] = { 0 };
 
 	uloop_init();
 	signal(SIGINT, handle_exit_signal);
 	signal(SIGTERM, handle_exit_signal);
 
-	while ((ch = getopt_long(argc, argv, "d:k:smt:", uqmi_getopt, NULL)) != -1) {
+	while ((ch = getopt_long(argc, argv, "d:k:smt:r:", uqmi_getopt, NULL)) != -1) {
 		int cmd_opt = CMD_OPT(ch);
 
 		if (ch < 0 && cmd_opt >= 0 && cmd_opt < __UQMI_COMMAND_LAST) {
@@ -147,26 +117,34 @@
 			dev.is_mbim = true;
 			break;
 		case 't':
-			uloop_timeout_set(&request_timeout, atol(optarg));
+			dev.request_timeout.cb = _request_timeout_handler;
+			uloop_timeout_set(&dev.request_timeout, strtol(optarg, NULL, 10));
 			break;
 		default:
 			return usage(argv[0]);
 		}
 	}
 
+	snprintf(uq_pid, sizeof(uq_pid), UQMI_PID);
+	pid = open(uq_pid, O_CREAT | O_RDWR, 0666);
+	while (flock(pid, LOCK_EX | LOCK_NB) && (errno == EWOULDBLOCK)) {
+		sleep(1);
+	}
+
 	if (!device) {
 		fprintf(stderr, "No device given\n");
 		return usage(argv[0]);
 	}
 
 	if (qmi_device_open(&dev, device)) {
-		fprintf(stderr, "Failed to open device\n");
+		fprintf(stderr, "Failed to open device, errno: %d\n", errno);
 		return 2;
 	}
 
 	ret = uqmi_run_commands(&dev) ? 0 : -1;
 
 	qmi_device_close(&dev);
+	close(pid);
 
 	return ret;
 }
diff --recursive --unified --new-file --no-dereference orig/qmi-enums-wds.h src/qmi-enums-wds.h
--- orig/qmi-enums-wds.h	2023-11-09 07:17:16.000000000 +0000
+++ src/qmi-enums-wds.h	2024-04-25 07:20:16.000000000 +0000
@@ -37,14 +37,14 @@
 
 /**
  * QmiWdsIpFamily:
- * @QMI_WDS_IP_FAMILY_UNKNOWN: unknown. Since: 1.18.
+ * @QMI_WDS_IP_FAMILY_UNKNOWN: unknown.
  * @QMI_WDS_IP_FAMILY_IPV4: IPv4.
  * @QMI_WDS_IP_FAMILY_IPV6: IPv6.
  * @QMI_WDS_IP_FAMILY_UNSPECIFIED: None specified.
  *
  * Type of IP family.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_IP_FAMILY_UNKNOWN     = 0,
@@ -60,7 +60,7 @@
  *
  * Type of network allowed when trying to connect.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_TECHNOLOGY_PREFERENCE_ALLOW_3GPP  = 1 << 0,
@@ -77,7 +77,7 @@
  *
  * Type of network allowed when trying to connect.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_EXTENDED_TECHNOLOGY_PREFERENCE_CDMA             = 32769,
@@ -94,7 +94,7 @@
  *
  * Type of call to originate.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_CALL_TYPE_LAPTOP   = 0,
@@ -178,7 +178,7 @@
  *
  * Reason for ending the call.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     /* Generic reasons */
@@ -274,7 +274,7 @@
  *
  * Type of verbose call end reason.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP      = 1,
@@ -322,7 +322,7 @@
  *
  * Mobile IP specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_MIP_ERROR_REASON_UNKNOWN                                = -1,
@@ -371,52 +371,52 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CLOSE_IN_PROGRESS: Close in progress.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NETWORK_INITIATED_TERMINATION: Network initiated termination.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APP_PREEMPTED: App preempted.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_DISALLOWED: PDN IPv4 call disallowed. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_THROTTLED: PDN IPv4 call throttled. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_DISALLOWED: PDN IPv6 call disallowed. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_THROTTLED: PDN IPv6 call throttled. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MODEM_RESTART: Modem restart. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDP_PPP_NOT_SUPPORTED: PDP PPP not supported. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNPREFERRED_RAT: Unpreferred RAT. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PHYSICAL_LINK_CLOSE_IN_PROGRESS: Physical link close in progress. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PENDING_HANDOVER: APN pending handover. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PROFILE_BEARER_INCOMPATIBLE: Profile bearer incompatible. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MMGDSI_CARD_EVENT: MMGDSI Card event. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_LPM_OR_POWER_DOWN: LPM or power down. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISABLED: APN disabled. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MPIT_EXPIRED: MPIT expired. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IPV6_ADDRESS_TRANSFER_FAILED: IPv6 address transfer failed. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_TRAT_SWAP_FAILED: TRAT swap failed. Since: 1.14.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EHRPD_TO_HRPD_FALLBACK: eHRPD to HRPD fallback. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MANDATORY_APN_DISABLED: Mandatory APN disabled. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MIP_CONFIG_FAILURE: MIP config failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED: PDN inactivity timeout expired. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V4_CONNECTIONS: Max IPv4 connections. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V6_CONNECTIONS: Max IPv6 connections. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_MISMATCH: APN mismatch. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_VERSION_MISMATCH: IP version mismatch. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DUN_CALL_DISALLOWED: DUN call disallowed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE: Invalid profile. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EPC_NONEPC_TRANSITION: EPC to non-EPC transition. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE_ID: Invalid profile ID. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ALREADY_PRESENT: Call already present. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE: Interface in use. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_PDP_MISMATCH: IP PDP mismatch. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISALLOWED_ON_ROAMING: APN disallowed on roaming. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PARAMETER_CHANGE: APN parameter change. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE_CONFIG_MATCH: Interface in use config match. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NULL_APN_DISALLOWED: NULL APN disallowed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_THERMAL_MITIGATION: Thermal mitigation. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_DISALLOWED: PDN IPv4 call disallowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV4_CALL_THROTTLED: PDN IPv4 call throttled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_DISALLOWED: PDN IPv6 call disallowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_IPV6_CALL_THROTTLED: PDN IPv6 call throttled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MODEM_RESTART: Modem restart.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDP_PPP_NOT_SUPPORTED: PDP PPP not supported.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_UNPREFERRED_RAT: Unpreferred RAT.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PHYSICAL_LINK_CLOSE_IN_PROGRESS: Physical link close in progress.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PENDING_HANDOVER: APN pending handover.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PROFILE_BEARER_INCOMPATIBLE: Profile bearer incompatible.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MMGDSI_CARD_EVENT: MMGDSI Card event.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_LPM_OR_POWER_DOWN: LPM or power down.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISABLED: APN disabled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MPIT_EXPIRED: MPIT expired.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IPV6_ADDRESS_TRANSFER_FAILED: IPv6 address transfer failed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_TRAT_SWAP_FAILED: TRAT swap failed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EHRPD_TO_HRPD_FALLBACK: eHRPD to HRPD fallback.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MANDATORY_APN_DISABLED: Mandatory APN disabled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MIP_CONFIG_FAILURE: MIP config failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_PDN_INACTIVITY_TIMER_EXPIRED: PDN inactivity timeout expired.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V4_CONNECTIONS: Max IPv4 connections.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_MAX_V6_CONNECTIONS: Max IPv6 connections.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_MISMATCH: APN mismatch.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_VERSION_MISMATCH: IP version mismatch.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DUN_CALL_DISALLOWED: DUN call disallowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE: Invalid profile.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_EPC_NONEPC_TRANSITION: EPC to non-EPC transition.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INVALID_PROFILE_ID: Invalid profile ID.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_CALL_ALREADY_PRESENT: Call already present.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE: Interface in use.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_IP_PDP_MISMATCH: IP PDP mismatch.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_DISALLOWED_ON_ROAMING: APN disallowed on roaming.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_PARAMETER_CHANGE: APN parameter change.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_INTERFACE_IN_USE_CONFIG_MATCH: Interface in use config match.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_NULL_APN_DISALLOWED: NULL APN disallowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_THERMAL_MITIGATION: Thermal mitigation.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_SUBS_ID_MISMATCH: Subs ID mismatch Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_SETTINGS_DISABLED: Data settings disabled. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_ROAMING_SETTINGS_DISABLED: Data roaming settings disabled. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_FORMAT_INVALID: APN format invalid. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DDS_CALL_ABORT: DDS call abort. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_VALIDATION_FAILURE: Validation failure. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_SETTINGS_DISABLED: Data settings disabled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DATA_ROAMING_SETTINGS_DISABLED: Data roaming settings disabled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_APN_FORMAT_INVALID: APN format invalid.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_DDS_CALL_ABORT: DDS call abort.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_VALIDATION_FAILURE: Validation failure.
  *
  * Internal call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_INTERNAL_ERROR                           = 201,
@@ -488,17 +488,17 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_GPS: CDMA specific. Call originated during GPS.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED_DURING_SMS: CDMA specific. Call originated during SMS.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_CDMA_SERVICE: CDMA specific. No service.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_MC_ABORT: MC abort. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PSIST_NG: Persistence test failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_UIM_NOT_PRESENT: UIM not present. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_MC_ABORT: MC abort.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PSIST_NG: Persistence test failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_UIM_NOT_PRESENT: UIM not present.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_RETRY_ORDER: Retry order.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK: Access blocked. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK_ALL: Access blocked for all. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS707B_MAX_ACCESS_PROBES: Maximum access probes for IS-707B call. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_THERMAL_EMERGENCY: Thermal emergency. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_ORIGINATION_THROTTLED: Call origination throttled. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED: Voice call originated and concurrent voice/data not supported. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONFERENCE_FAILED: Conference failed. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK: Access blocked.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_BLOCK_ALL: Access blocked for all.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_IS707B_MAX_ACCESS_PROBES: Maximum access probes for IS-707B call.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_THERMAL_EMERGENCY: Thermal emergency.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_ORIGINATION_THROTTLED: Call origination throttled.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_USER_CALL_ORIGINATED: Voice call originated and concurrent voice/data not supported.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONFERENCE_FAILED: Conference failed.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_INCOMING_REJECTED: Incoming rejected.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GATEWAY_SERVICE: No gateway service.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_GPRS_CONTEXT: No GPRS context.
@@ -516,59 +516,59 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONGESTION: Congestion.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_PDP_CONTEXT_ACTIVATED: No PDP context activated.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_CLASS_DSAC_REJECTION: Access class DSAC rejection.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_ACTIVATE_MAX_RETRY_FAILED: Maximum retries failed to activate PDP context. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_RAB_FAILURE: RAB failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EPS_SERVICE_NOT_ALLOWED: EPS service not allowed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_TRACKING_AREA_NOT_ALLOWED: Tracking area not allowed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ROAMING_NOT_ALLOWED_IN_TRACKING_AREA: Roaming not allowed in tracking area. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SUITABLE_CELLS_IN_TRACKING_AREA: No suitable cells in tracking area. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP: Not authorized in closed subscriber group. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_UNKNOWN_EPS_BEARER_CONTEXT: EPS Session Management, unknown EPS bearer context. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DRB_RELEASED_AT_RRC: DRB released at RRC. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NAS_SIGNAL_CONNECTION_RELEASED: NAS signal connection released. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_DETACHED: EPS Mobility Management, detached. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_FAILED: EPS Mobility Management, attach failed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_STARTED: EPS Mobility Management, attach started. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED: LTE NAS service request failed. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW: EPS Session Management, active dedicated bearer reactivated by network. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOWER_LAYER_FAILURE: EPS Session Management, lower layer failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_SYNC_UP_WITH_NW: EPS Session Management, sync up with network. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER: EPS Session Management, network activated dedicated bearer with id of default bearer. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_BAD_OTA_MESSAGE: EPS Session Management, bad OTA message. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_DS_REJECTED_CALL: EPS Session Management, DS rejected call. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT: EPS Session Management, context transferred due to IRAT. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DS_EXPLICIT_DEACT: DS explicit deactivation. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOCAL_CAUSE_NONE: EPS Session Management, local cause none. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE: LTE NAS service request failed, no throttle. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACL_FAILURE: ACL failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW: LTE NAS service request failed, DS disallow. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXPIRED: EPS Mobility Management, T3417 expired. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXT_EXPIRED: EPS Mobility Management, T3417 ext expired. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN: LTE Radio Resource Control, UL data confirmation failure, txn. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER: LTE Radio Resource Control, UL data confirmation failure, handover. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL: LTE Radio Resource Control, UL data confirmation failure, connection release. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF: LTE Radio Resource Control, UL data confirmation failure, radio link failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN: LTE Radio Resource Control, UL data confirmation failure, ctrl not conn. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE: LTE Radio Resource Control, connection establishment failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED: LTE Radio Resource Control, connection establishment failure, aborted. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED: LTE Radio Resource Control, connection establishment failure, access barred. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION: LTE Radio Resource Control, connection establishment failure, cell reselection. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE: LTE Radio Resource Control, connection establishment failure, config failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED: LTE Radio Resource Control, connection establishment failure, timer expired. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE: LTE Radio Resource Control, connection establishment failure, link failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED: LTE Radio Resource Control, connection establishment failure, not camped. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE: LTE Radio Resource Control, connection establishment failure, SI failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED: LTE Radio Resource Control, connection establishment failure, rejected. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_NORMAL: LTE Radio Resource Control, connection release, normal. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_RLF: LTE Radio Resource Control, connection release, radio link failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_CRE_FAILURE: LTE Radio Resource Control, connection release, cre failure. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_OOS_DURING_CRE: LTE Radio Resource Control, connection release, oos during cre. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_ABORTED: LTE Radio Resource Control, connection release, aborted. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_SIB_READ_ERROR: LTE Radio Resource Control, connection release, SIB read error. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITH_REATTACH_LTE_NW_DETACH: Detach with reattach LTE network detach. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITHOUT_REATTACH_LTE_NW_DETACH: Detach without reattach LTE network detach. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_PROC_TIMEOUT: EPS Session Management, proc timeout. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_MESSAGE_EXCEED_MAX_L2_LIMIT: Message exceed max L2 limit. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PDP_ACTIVATE_MAX_RETRY_FAILED: Maximum retries failed to activate PDP context.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_RAB_FAILURE: RAB failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EPS_SERVICE_NOT_ALLOWED: EPS service not allowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_TRACKING_AREA_NOT_ALLOWED: Tracking area not allowed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ROAMING_NOT_ALLOWED_IN_TRACKING_AREA: Roaming not allowed in tracking area.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SUITABLE_CELLS_IN_TRACKING_AREA: No suitable cells in tracking area.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NOT_AUTHORIZED_CLOSED_SUBSCRIBER_GROUP: Not authorized in closed subscriber group.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_UNKNOWN_EPS_BEARER_CONTEXT: EPS Session Management, unknown EPS bearer context.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DRB_RELEASED_AT_RRC: DRB released at RRC.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NAS_SIGNAL_CONNECTION_RELEASED: NAS signal connection released.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_DETACHED: EPS Mobility Management, detached.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_FAILED: EPS Mobility Management, attach failed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_ATTACH_STARTED: EPS Mobility Management, attach started.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED: LTE NAS service request failed.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_ACTIVE_DEDICATED_BEARER_REACTIVATED_BY_NW: EPS Session Management, active dedicated bearer reactivated by network.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOWER_LAYER_FAILURE: EPS Session Management, lower layer failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_SYNC_UP_WITH_NW: EPS Session Management, sync up with network.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_NW_ACTIVATED_DEDICATED_BEARER_WITH_ID_OF_DEFAULT_BEARER: EPS Session Management, network activated dedicated bearer with id of default bearer.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_BAD_OTA_MESSAGE: EPS Session Management, bad OTA message.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_DS_REJECTED_CALL: EPS Session Management, DS rejected call.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_CONTEXT_TRANSFERRED_DUE_TO_IRAT: EPS Session Management, context transferred due to IRAT.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DS_EXPLICIT_DEACT: DS explicit deactivation.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_LOCAL_CAUSE_NONE: EPS Session Management, local cause none.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_NO_THROTTLE: LTE NAS service request failed, no throttle.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACL_FAILURE: ACL failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LTE_NAS_SERVICE_REQUEST_FAILED_DS_DISALLOW: LTE NAS service request failed, DS disallow.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXPIRED: EPS Mobility Management, T3417 expired.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMM_T3417_EXT_EXPIRED: EPS Mobility Management, T3417 ext expired.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_TXN: LTE Radio Resource Control, UL data confirmation failure, txn.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_HANDOVER: LTE Radio Resource Control, UL data confirmation failure, handover.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CONN_REL: LTE Radio Resource Control, UL data confirmation failure, connection release.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_RLF: LTE Radio Resource Control, UL data confirmation failure, radio link failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_UL_DATA_CONFIRMATION_FAILURE_CTRL_NOT_CONN: LTE Radio Resource Control, UL data confirmation failure, ctrl not conn.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE: LTE Radio Resource Control, connection establishment failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ABORTED: LTE Radio Resource Control, connection establishment failure, aborted.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_ACCESS_BARRED: LTE Radio Resource Control, connection establishment failure, access barred.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CELL_RESELECTION: LTE Radio Resource Control, connection establishment failure, cell reselection.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_CONFIG_FAILURE: LTE Radio Resource Control, connection establishment failure, config failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_TIMER_EXPIRED: LTE Radio Resource Control, connection establishment failure, timer expired.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_LINK_FAILURE: LTE Radio Resource Control, connection establishment failure, link failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_NOT_CAMPED: LTE Radio Resource Control, connection establishment failure, not camped.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_SI_FAILURE: LTE Radio Resource Control, connection establishment failure, SI failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_ESTABLISHMENT_FAILURE_REJECTED: LTE Radio Resource Control, connection establishment failure, rejected.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_NORMAL: LTE Radio Resource Control, connection release, normal.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_RLF: LTE Radio Resource Control, connection release, radio link failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_CRE_FAILURE: LTE Radio Resource Control, connection release, cre failure.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_OOS_DURING_CRE: LTE Radio Resource Control, connection release, oos during cre.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_ABORTED: LTE Radio Resource Control, connection release, aborted.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_LRRC_CONNECTION_RELEASE_SIB_READ_ERROR: LTE Radio Resource Control, connection release, SIB read error.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITH_REATTACH_LTE_NW_DETACH: Detach with reattach LTE network detach.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_DETACH_WITHOUT_REATTACH_LTE_NW_DETACH: Detach without reattach LTE network detach.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ESM_PROC_TIMEOUT: EPS Session Management, proc timeout.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_MESSAGE_EXCEED_MAX_L2_LIMIT: Message exceed max L2 limit.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_GENERAL_OR_BUSY: CDMA/EVDO specific. Received Connection Deny. General or Network busy.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CONNECTION_DENY_BILLING_OR_AUTHENTICATION_FAILURE: CDMA/EVDO specific. Received Connection Deny. Billing or Authentication failure.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CHANGE: CDMA/EVDO specific. Change HDR.
@@ -577,13 +577,13 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ORIGINATION_DURING_GPS_FIX: CDMA/EVDO specific. HDR call ended in favor of a GPS fix.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_CONNECTION_SETUP_TIMEOUT: CDMA/EVDO specific. Connection setup timeout.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_RELEASED_BY_CM: CDMA/EVDO specific. Released HDR call by call manager.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_COLLOCATED_ACQUISITION_FAILED: Failed to acquire co-located HDR for origination. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_OTASP_COMMIT_IN_PROGRESS: CDMA/EVDO specific. OTASP commit in progress. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_COLLOCATED_ACQUISITION_FAILED: Failed to acquire co-located HDR for origination.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_OTASP_COMMIT_IN_PROGRESS: CDMA/EVDO specific. OTASP commit in progress.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_HYBRID_SERVICE: CDMA/EVDO specific. No hybrid HDR service.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_LOCK_GRANTED: CDMA/EVDO specific. No lock granted. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HOLD_OTHER_IN_PROGRESS: CDMA/EVDO specific. hold other in progress. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_FADE: CDMA/EVDO specific. Fade. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ACCESS_FAILURE: CDMA/EVDO specific. Access failure. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_NO_LOCK_GRANTED: CDMA/EVDO specific. No lock granted.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HOLD_OTHER_IN_PROGRESS: CDMA/EVDO specific. hold other in progress.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_FADE: CDMA/EVDO specific. Fade.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_HDR_ACCESS_FAILURE: CDMA/EVDO specific. Access failure.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CLIENT_END: Client end.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_SERVICE: No service.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_FADE: Fade.
@@ -591,17 +591,17 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_ATTEMPT_IN_PROGRESS: Access attempt in progress.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_ACCESS_FAILURE: Access Failure.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_REDIRECTION_OR_HANDOFF: Redirection or handoff.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_OFFLINE: Offline. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMERGENCY_MODE: Emergency mode. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PHONE_IN_USE: Phone in use. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_MODE: Invalid mode. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_SIM_STATE: Invalid SIM state. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_COLLOCATED_HDR: No collocated HDR. Since 1.24.10.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_CONTROL_REJECTED: Call control rejected. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_OFFLINE: Offline.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_EMERGENCY_MODE: Emergency mode.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_PHONE_IN_USE: Phone in use.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_MODE: Invalid mode.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_INVALID_SIM_STATE: Invalid SIM state.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_NO_COLLOCATED_HDR: No collocated HDR.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_CM_CALL_CONTROL_REJECTED: Call control rejected.
  *
  * Call manager specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_CM_CDMA_LOCK                       = 500,
@@ -746,7 +746,7 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_AUTHENTICATION_FAILED: Authentication failed.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_GGSN_REJECT: Activation rejected by GGSN.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_ACTIVATION_REJECT: Activation rejected.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_NOT_SUPPORTED:  Service option not supported.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_NOT_SUPPORTED: Service option not supported.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_UNSUBSCRIBED: Service option not subscribed.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPTION_TEMPORARILY_OUT_OF_ORDER: Service option temporarily out of order.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_NSAPI_ALREADY_USED: NSAPI already used.
@@ -769,7 +769,7 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MULTIPLE_CONNECTION_TO_SAME_PDN_NOT_ALLOWED: Multiple connection to same PDN not allowed.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_TRANSACTION_ID: Invalid transaction ID.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_INCORRECT_SEMANTIC: Message incorrect semantically.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_MANDATORY_INFO:  Invalid mandatory information.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_MANDATORY_INFO: Invalid mandatory information.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_UNSUPPORTED: Message type not implemented.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_TYPE_NONCOMPATIBLE_STATE: Message not compatible with state.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_UNKNOWN_INFO_ELEMENT: Information element unknown.
@@ -777,11 +777,11 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_MESSAGE_AND_PROTOCOL_STATE_UNCOMPATIBLE: Message and protocol state uncompatible.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_PROTOCOL_ERROR: Protocol error.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_APN_TYPE_CONFLICT: APN type conflict.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS: Invalid proxy call session control function address. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_INVALID_PROXY_CALL_SESSION_CONTROL_FUNCTION_ADDRESS: Invalid proxy call session control function address.
  *
  * 3GPP-specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< underscore_name=qmi_wds_verbose_call_end_reason_3gpp,since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_3GPP_OPERATOR_DETERMINED_BARRING = 8,
@@ -839,11 +839,11 @@
  * @QMI_WDS_VERBOSE_CALL_END_REASON_PPP_OPTION_MISMATCH: Option mismatch.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_PPP_PAP_FAILURE: PAP failure.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CHAP_FAILURE: CHAP failure.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CLOSE_IN_PROGRESS: Close in progress. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_PPP_CLOSE_IN_PROGRESS: Close in progress.
  *
  * PPP-specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_PPP_UNKNOWN = -1,
@@ -879,7 +879,7 @@
  *
  * eHRPD-specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_EHRPD_SUBSCRIPTION_LIMITED_TO_IPV4 = 1,
@@ -905,11 +905,11 @@
  * QmiWdsVerboseCallEndReasonIpv6:
  * @QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_PREFIX_UNAVAILABLE: Prefix unavailable.
  * @QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_HRPD_IPV6_DISABLED: HRDP IPv6 disabled.
- * @QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_DISABLED: IPv6 disabled. Since 1.24.10.
+ * @QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_DISABLED: IPv6 disabled.
  *
  * IPv6-specific call end reasons, given when the @QmiWdsVerboseCallEndReasonType is #QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_VERBOSE_CALL_END_REASON_IPV6_PREFIX_UNAVAILABLE = 1,
@@ -930,7 +930,7 @@
  *
  * Status of the network connection.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_CONNECTION_STATUS_UNKNOWN        = 0,
@@ -961,15 +961,15 @@
  * @QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_HSUPA: HSDPA+ and HSUPA.
  * @QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS: DC-HSDPA+ and WCDMA.
  * @QMI_WDS_DATA_BEARER_TECHNOLOGY_DCHSDPAPLUS_HSUPA: DC-HSDPA+ and HSUPA.
- * @QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM: HSDPA+ with 64QAM. Since: 1.18.
- * @QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM_HSUPA: HSDPA+ with 64QAM and HSUPA. Since: 1.18.
- * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA: TD-SCDMA. Since: 1.18.
- * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSDPA: TD-SCDMA and HSDPA. Since: 1.18.
- * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSUPA: TD-SCDMA and HSUPA. Since: 1.18.
+ * @QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM: HSDPA+ with 64QAM.
+ * @QMI_WDS_DATA_BEARER_TECHNOLOGY_HSDPAPLUS_PLUS_64QAM_HSUPA: HSDPA+ with 64QAM and HSUPA.
+ * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA: TD-SCDMA.
+ * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSDPA: TD-SCDMA and HSDPA.
+ * @QMI_WDS_DATA_BEARER_TECHNOLOGY_TDSCDMA_HSUPA: TD-SCDMA and HSUPA.
  *
  * Data bearer technology.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_DATA_BEARER_TECHNOLOGY_UNKNOWN                    = -1,
@@ -1006,7 +1006,7 @@
  *
  * Network type of the data bearer.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_NETWORK_TYPE_UNKNOWN = 0,
@@ -1021,7 +1021,7 @@
  *
  * Network type of the data system.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_DATA_SYSTEM_NETWORK_TYPE_3GPP  = 0,
@@ -1040,7 +1040,7 @@
  *
  * Data system type.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_DATA_SYSTEM_UNKNOWN     = 0,
@@ -1059,14 +1059,14 @@
  * @QMI_WDS_RAT_3GPP2_EVDO_REV0: EVDO Rev0.
  * @QMI_WDS_RAT_3GPP2_EVDO_REVA: EVDO RevA.
  * @QMI_WDS_RAT_3GPP2_EVDO_REVB: EVDO RevB.
- * @QMI_WDS_RAT_3GPP2_EHRPD: eHRPD. Since: 1.18.
- * @QMI_WDS_RAT_3GPP2_FMC: FMC. Since: 1.18.
+ * @QMI_WDS_RAT_3GPP2_EHRPD: eHRPD.
+ * @QMI_WDS_RAT_3GPP2_FMC: FMC.
  * @QMI_WDS_RAT_3GPP2_NULL_BEARER: No bearer.
  *
  * Flags specifying the 3GPP2-specific Radio Access Technology, when the data
  * bearer network type is @QMI_WDS_NETWORK_TYPE_3GPP2.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< underscore_name=qmi_wds_rat_3gpp2,since=1.0 >*/
     QMI_WDS_RAT_3GPP2_NONE        = 0,
@@ -1090,14 +1090,14 @@
  * @QMI_WDS_RAT_3GPP_LTE: LTE.
  * @QMI_WDS_RAT_3GPP_HSDPAPLUS: HSDPA+.
  * @QMI_WDS_RAT_3GPP_DCHSDPAPLUS: DC-HSDPA+.
- * @QMI_WDS_RAT_3GPP_64QAM: 64QAM. Since: 1.18.
- * @QMI_WDS_RAT_3GPP_TDSCDMA: TD-SCDMA. Since: 1.18.
+ * @QMI_WDS_RAT_3GPP_64QAM: 64QAM.
+ * @QMI_WDS_RAT_3GPP_TDSCDMA: TD-SCDMA.
  * @QMI_WDS_RAT_3GPP_NULL_BEARER: No bearer.
  *
  * Flags specifying the 3GPP-specific Radio Access Technology, when the data
  * bearer network type is @QMI_WDS_NETWORK_TYPE_3GPP.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< underscore_name=qmi_wds_rat_3gpp,since=1.0 >*/
     QMI_WDS_RAT_3GPP_NONE        = 0,
@@ -1125,7 +1125,7 @@
  * @QMI_WDS_NETWORK_TYPE_3GPP2 and when the Radio Access Technology mask
  * contains @QMI_WDS_RAT_3GPP2_CDMA1X.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_SO_CDMA1X_NONE         = 0,
@@ -1143,7 +1143,7 @@
  * @QMI_WDS_NETWORK_TYPE_3GPP2 and when the Radio Access Technology mask
  * contains @QMI_WDS_RAT_3GPP2_EVDO_REV0.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_SO_EVDO_REV0_NONE = 0,
@@ -1162,7 +1162,7 @@
  * @QMI_WDS_NETWORK_TYPE_3GPP2 and when the Radio Access Technology mask
  * contains @QMI_WDS_RAT_3GPP2_EVDO_REVA.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< underscore_name=qmi_wds_so_evdo_reva,since=1.0 >*/
     QMI_WDS_SO_EVDO_REVA_NONE       = 0,
@@ -1186,7 +1186,7 @@
  * @QMI_WDS_NETWORK_TYPE_3GPP2 and when the Radio Access Technology mask
  * contains @QMI_WDS_RAT_3GPP2_EVDO_REVB.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< underscore_name=qmi_wds_so_evdo_revb,since=1.18 >*/
     QMI_WDS_SO_EVDO_REVB_NONE       = 0,
@@ -1226,7 +1226,7 @@
  * Flags specifying which specific settings to return when requesting the
  * current WDS bearer settings.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_GET_CURRENT_SETTINGS_REQUESTED_SETTINGS_NONE                      = 0,
@@ -1259,7 +1259,7 @@
  *
  * PDP context type.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_PDP_TYPE_IPV4         = 0,
@@ -1278,7 +1278,7 @@
  *
  * QoS Traffic Classes.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_TRAFFIC_CLASS_SUBSCRIBED     = 0,
@@ -1296,7 +1296,7 @@
  *
  * PDP context authentication protocols.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_AUTHENTICATION_NONE = 0,
@@ -1311,7 +1311,7 @@
  *
  * Profile network type family.
  *
- * Since: 1.0
+ * Since 1.0
  */
 typedef enum { /*< since=1.0 >*/
     QMI_WDS_PROFILE_TYPE_3GPP    = 0,
@@ -1325,7 +1325,7 @@
   *
   * Profile family.
   *
-  * Since: 1.22
+  * Since 1.22
   */
  typedef enum { /*< since=1.22 >*/
      QMI_WDS_PROFILE_FAMILY_EMBEDDED = 0,
@@ -1340,7 +1340,7 @@
  *
  * QoS delivery order.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_QOS_DELIVERY_ORDER_SUBSCRIBE = 0,
@@ -1361,7 +1361,7 @@
  *
  * Target value for the fraction of SDUs lost or detected as erroneous.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_SDU_ERROR_RATIO_SUBSCRIBE = 0,
@@ -1389,7 +1389,7 @@
  *
  * Target value for the undetected bit error ratio in the delivered SDUs.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_SDU_RESIDUAL_BIT_ERROR_RATIO_SUBSCRIBE = 0,
@@ -1413,7 +1413,7 @@
  *
  * Whether SDUs detected as erroneous are delivered or not.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_SDU_ERRONEOUS_DELIVERY_SUBSCRIBE    = 0,
@@ -1440,7 +1440,7 @@
  *
  * Mask to use when requesting packet statistics.
  *
- * Since: 1.6
+ * Since 1.6
  */
 typedef enum { /*< since=1.6 >*/
     QMI_WDS_PACKET_STATISTICS_MASK_FLAG_TX_PACKETS_OK      = 1 << 0,
@@ -1483,7 +1483,7 @@
  *
  * Extended DS profile errors.
  *
- * Since: 1.8
+ * Since 1.8
  */
 typedef enum { /*< since=1.8 >*/
     QMI_WDS_DS_PROFILE_ERROR_UNKNOWN                     = 0,
@@ -1516,7 +1516,7 @@
  *
  * Status of the autoconnect setting.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_AUTOCONNECT_SETTING_DISABLED = 0,
@@ -1531,7 +1531,7 @@
  *
  * Status of the autoconnect setting while roaming.
  *
- * Since: 1.14
+ * Since 1.14
  */
 typedef enum { /*< since=1.14 >*/
     QMI_WDS_AUTOCONNECT_SETTING_ROAMING_ALLOWED   = 0,
@@ -1557,7 +1557,7 @@
  * Flags indicating which WDS Set Event Report Transfer Statistics indicators
  * should be emitted.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_SET_EVENT_REPORT_TRANSFER_STATISTICS_REPORT_TX_PACKETS_OK      = 1 << 0,
@@ -1580,7 +1580,7 @@
  *
  * Dormancy status.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_DORMANCY_STATUS_UNKNOWN                 = 0,
@@ -1596,7 +1596,7 @@
  *
  * Data call status.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_DATA_CALL_STATUS_UNKNOWN    = 0,
@@ -1613,7 +1613,7 @@
  *
  * Data call type.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_DATA_CALL_TYPE_UNKNOWN        = 0,
@@ -1630,7 +1630,7 @@
  *
  * Tethered call type.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_TETHERED_CALL_TYPE_NON_TETHERED = 0,
@@ -1655,7 +1655,7 @@
  *
  * Radio access technology.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_RADIO_ACCESS_TECHNOLOGY_NULL_BEARER   = 0,
@@ -1692,7 +1692,7 @@
  *
  * 3GPP extended data bearer technologies.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< underscore_name=qmi_wds_extended_data_bearer_technology_3gpp,since=1.18 >*/
     QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP_UNKNOWN             = 0,
@@ -1731,7 +1731,7 @@
  *
  * 3GPP2 extended data bearer technologies.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< underscore_name=qmi_wds_extended_data_bearer_technology_3gpp2,since=1.18 >*/
     QMI_WDS_EXTENDED_DATA_BEARER_TECHNOLOGY_3GPP2_UNKNOWN             = 0,
@@ -1763,7 +1763,7 @@
  *
  * PDP header compression types.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_PDP_HEADER_COMPRESSION_TYPE_OFF                    = 0,
@@ -1782,7 +1782,7 @@
  *
  * PDP data compression types.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_PDP_DATA_COMPRESSION_TYPE_OFF                    = 0,
@@ -1805,7 +1805,7 @@
  *
  * QoS Class Identifier.
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_QOS_CLASS_IDENTIFIER_NETWORK_ASSIGN          = 0,
@@ -1826,7 +1826,7 @@
  *
  * Action when setting the attach PDN list.
  *
- * Since: 1.28
+ * Since 1.28
  */
 typedef enum { /*< since=1.28 >*/
     QMI_WDS_ATTACH_PDN_LIST_ACTION_NONE                     = 0x01,
@@ -1840,7 +1840,7 @@
  *
  * Client Type
  *
- * Since: 1.18
+ * Since 1.18
  */
 typedef enum { /*< since=1.18 >*/
     QMI_WDS_CLIENT_TYPE_TETHERED = 0x01,
@@ -1852,7 +1852,7 @@
  *
  * The TX/RX rate information is unavailable or cannot be measured.
  *
- * Since: 1.22.4
+ * Since 1.22.4
  */
 #define QMI_WDS_RATE_UNAVAILABLE 0xFFFFFFFF
 
@@ -1864,7 +1864,7 @@
  *
  * IP support type.
  *
- * Since: 1.28
+ * Since 1.28
  */
 typedef enum {  /*< since=1.28 >*/
     QMI_WDS_IP_SUPPORT_TYPE_IPV4   = 0,
diff --recursive --unified --new-file --no-dereference orig/qmi-message.c src/qmi-message.c
--- orig/qmi-message.c	2023-11-09 07:11:45.000000000 +0000
+++ src/qmi-message.c	2024-04-25 07:20:16.000000000 +0000
@@ -24,6 +24,15 @@
 #include <stdlib.h>
 
 #include "qmi-message.h"
+#include "qmi-wds-error-types.c"
+
+#define LOG(...) do { \
+	fprintf(stdout, ##__VA_ARGS__); fflush(stdout); \
+} while (0);
+
+#define DD LOG("DD[***%s:%d]\n", __func__, __LINE__)
+
+#define ERROR_VERBOSE_STR "QMI call error, reason type"
 
 static uint8_t buf[QMI_BUFFER_LEN];
 static unsigned int buf_ofs;
@@ -173,4 +182,32 @@
 	return ptr;
 }
 
-
+char *qmi_wds_verbose_call_end_reason_get_string (QmiWdsVerboseCallEndReasonType type, uint16_t reason)
+{
+	switch (type) {
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_MIP:
+		LOG("%s MIP: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_mip_get_string ((QmiWdsVerboseCallEndReasonMip)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_INTERNAL:
+		LOG("%s INTERNAL: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_internal_get_string ((QmiWdsVerboseCallEndReasonInternal)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_CM:
+		LOG("%s CM: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_cm_get_string ((QmiWdsVerboseCallEndReasonCm)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_3GPP:
+		LOG("%s 3GPP: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_3gpp_get_string ((QmiWdsVerboseCallEndReason3gpp)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_PPP:
+		LOG("%s PPP: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_ppp_get_string ((QmiWdsVerboseCallEndReasonPpp)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_EHRPD:
+		LOG("%s EHRPD: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_ehrpd_get_string ((QmiWdsVerboseCallEndReasonEhrpd)reason);
+	case QMI_WDS_VERBOSE_CALL_END_REASON_TYPE_IPV6:
+		LOG("%s IPV6: \"", ERROR_VERBOSE_STR);
+	        return qmi_wds_verbose_call_end_reason_ipv6_get_string ((QmiWdsVerboseCallEndReasonIpv6)reason);
+	default:
+        return "Reason type not found";
+	}
+	return NULL;
+}
diff --recursive --unified --new-file --no-dereference orig/qmi-message.h src/qmi-message.h
--- orig/qmi-message.h	2023-11-09 07:11:45.000000000 +0000
+++ src/qmi-message.h	2024-04-25 07:20:16.000000000 +0000
@@ -122,5 +122,6 @@
 int qmi_complete_request_message(struct qmi_msg *qm);
 int qmi_check_message_status(void *buf, unsigned int len);
 void *qmi_msg_get_tlv_buf(struct qmi_msg *qm, int *len);
+char *qmi_wds_verbose_call_end_reason_get_string (QmiWdsVerboseCallEndReasonType type, uint16_t reason);
 
 #endif
diff --recursive --unified --new-file --no-dereference orig/uqmi.h src/uqmi.h
--- orig/uqmi.h	2023-11-09 07:11:45.000000000 +0000
+++ src/uqmi.h	2024-04-25 07:20:16.000000000 +0000
@@ -65,6 +65,12 @@
 };
 #undef __qmi_service
 
+#define ELOG(...) do { \
+	fprintf(stderr, ##__VA_ARGS__); fflush(stderr); \
+} while (0);
+
+#define EE ELOG("EE[###\%s:\%d***]\\n", __func__, __LINE__)
+
 struct qmi_dev;
 struct qmi_request;
 struct qmi_msg;
@@ -72,6 +78,8 @@
 typedef void (*request_cb)(struct qmi_dev *qmi, struct qmi_request *req, struct qmi_msg *msg);
 
 struct qmi_dev {
+	const char *fd_path;
+	char *wwan_iface;
 	struct ustream_fd sf;
 
 	struct list_head req;
@@ -90,6 +98,9 @@
 	void *buf;
 
 	bool is_mbim;
+	int read_req_retry;
+
+	struct uloop_timeout request_timeout;
 };
 
 struct qmi_request {
