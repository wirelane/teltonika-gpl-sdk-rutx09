diff --recursive --unified --new-file --no-dereference upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2016-11-09 19:40:33.000000000 +0000
+++ src/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,62 +0,0 @@
-*.o
-*.la
-*.lo
-*~
-.libs
-.deps
-.dirstamp
-aclocal.m4
-autom4te.cache
-certificate.pem
-compile
-config.cache
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-debian/autoreconf.after
-debian/autoreconf.before
-debian/files
-debian/*.debhelper.log
-debian/*.debhelper
-debian/*.substvars
-debian/shellinabox/
-debian/tmp/
-demo/beep.wav
-demo/demo.js
-demo/enabled.gif
-demo/favicon.ico
-demo/keyboard.png
-demo/print-styles.css
-demo/styles.css
-demo/usercss-*.css
-demo/vt100.js
-depcomp
-INSTALL
-install-sh
-libtool
-ltmain.sh
-Makefile
-Makefile.in
-missing
-m4/
-shellinabox/beep.h
-shellinabox/cgi_root.h
-shellinabox/enabled.h
-shellinabox/favicon.h
-shellinabox/keyboard.h
-shellinabox/keyboard-layout.h
-shellinabox/print-styles.h
-shellinabox/root_page.h
-shellinabox/shell_in_a_box.h
-shellinabox/shell_in_a_box.js
-shellinabox/styles.h
-shellinabox/vt100.h
-shellinabox/vt100.js
-shellinaboxd
-shellinaboxd.1
-shellinaboxd.ps
-stamp-h1
diff --recursive --unified --new-file --no-dereference upstream/.gitlab-ci.yml src/.gitlab-ci.yml
--- upstream/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2024-09-13 09:02:09.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference upstream/cli.conf src/cli.conf
--- upstream/cli.conf	1970-01-01 00:00:00.000000000 +0000
+++ src/cli.conf	2024-09-13 09:02:09.000000000 +0000
@@ -0,0 +1,6 @@
+config status 'status'
+	option enable '1'
+	option port '4200-4220'
+	option shell_limit '5'
+
+config cli
diff --recursive --unified --new-file --no-dereference upstream/config.h src/config.h
--- upstream/config.h	1970-01-01 00:00:00.000000000 +0000
+++ src/config.h	2024-09-13 09:02:09.000000000 +0000
@@ -0,0 +1,189 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have support for symbol aliasing */
+#define HAVE_ATTRIBUTE_ALIAS 1
+
+/* Define to 1 if you have support for the "unused" attribute */
+#define HAVE_ATTRIBUTE_UNUSED 1
+
+/* Set if you want support for calling /bin/login */
+#define HAVE_BIN_LOGIN 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `dlopen' function. */
+#define HAVE_DLOPEN 1
+
+/* Define to 1 if you have the `getgrgid_r' function. */
+#define HAVE_GETGRGID_R 1
+
+/* Define to 1 if you have the `getgrnam_r' function. */
+#define HAVE_GETGRNAM_R 1
+
+/* Define to 1 if getgrouplist() takes ints as arguments */
+/* #undef HAVE_GETGROUPLIST_TAKES_INTS */
+
+/* Define to 1 if you have the `gethostbyname_r' function. */
+/* #undef HAVE_GETHOSTBYNAME_R */
+
+/* Define to 1 if you have the `getpwnam_r' function. */
+#define HAVE_GETPWNAM_R 1
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+#define HAVE_GETPWUID_R 1
+
+/* Define to 1 if you have the `getresgid' function. */
+#define HAVE_GETRESGID 1
+
+/* Define to 1 if you have the `getresuid' function. */
+#define HAVE_GETRESUID 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have support for isnan */
+#define HAVE_ISNAN 1
+
+/* Define to 1 if you have the <libutil.h> header file. */
+/* #undef HAVE_LIBUTIL_H */
+
+/* Define to 1 if you have the `login_tty' function. */
+#define HAVE_LOGIN_TTY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `openpty' function. */
+#define HAVE_OPENPTY 1
+
+/* Define to 1 if you have the <openssl/bio.h> header file. */
+#define HAVE_OPENSSL_BIO_H 1
+
+/* Define to 1 if you have the <openssl/err.h> header file. */
+#define HAVE_OPENSSL_ERR_H 1
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#define HAVE_OPENSSL_SSL_H 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have a re-entrant version of ptsname */
+#define HAVE_PTSNAME_R 1
+
+/* Define to 1 if you have the <pty.h> header file. */
+#define HAVE_PTY_H 1
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define to 1 if you have the <security/pam_client.h> header file. */
+/* #undef HAVE_SECURITY_PAM_CLIENT_H */
+
+/* Define to 1 if you have the <security/pam_misc.h> header file. */
+/* #undef HAVE_SECURITY_PAM_MISC_H */
+
+/* Define to 1 if you have the `setresgid' function. */
+#define HAVE_SETRESGID 1
+
+/* Define to 1 if you have the `setresuid' function. */
+/* #undef HAVE_SETRESUID */
+
+/* Define to 1 if you have a working sigwait */
+#define HAVE_SIGWAIT 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+#define HAVE_STRLCAT 1
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H 1
+
+/* Define to 1 if you have the <sys/prctl.h> header file. */
+#define HAVE_SYS_PRCTL_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have support for updwtmp */
+#define HAVE_UPDWTMP 1
+
+/* Define to 1 if you have support for updwtmpx */
+/* #undef HAVE_UPDWTMPX */
+
+/* Define to 1 if you have the <util.h> header file. */
+/* #undef HAVE_UTIL_H */
+
+/* Define to 1 if you have the <utmpx.h> header file. */
+#define HAVE_UTMPX_H 1
+
+/* Define to 1 if you have the <utmp.h> header file. */
+#define HAVE_UTMP_H 1
+
+/* Define to 1 if you have the `vsyslog' function. */
+#define HAVE_VSYSLOG 1
+
+/* Define to 1 if zlib development files are installed */
+#define HAVE_ZLIB 1
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "shellinabox"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "markus@shellinabox.com"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "shellinabox"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "shellinabox 2.20"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "shellinabox"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.20"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Most recent revision number in the version control system */
+#define VCS_REVISION ""
+
+/* Version number of package */
+#define VERSION "2.20"
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
diff --recursive --unified --new-file --no-dereference upstream/configure.ac src/configure.ac
--- upstream/configure.ac	2016-11-09 19:40:33.000000000 +0000
+++ src/configure.ac	2024-09-13 09:02:09.000000000 +0000
@@ -34,6 +34,9 @@
 AC_CHECK_HEADERS([libutil.h pthread.h pty.h strings.h syslog.h sys/prctl.h \
                   sys/uio.h util.h])
 
+dnl Ubus support
+AC_CHECK_HEADERS(libubus.h, [LIBS="-lubus $LIBS"])
+
 dnl Most systems require linking against libutil.so in order to get login_tty()
 AC_CHECK_FUNCS(login_tty, [],
                [AC_CHECK_LIB(util, login_tty,
diff --recursive --unified --new-file --no-dereference upstream/libhttp/httpconnection.c src/libhttp/httpconnection.c
--- upstream/libhttp/httpconnection.c	2016-11-09 19:40:33.000000000 +0000
+++ src/libhttp/httpconnection.c	2024-09-13 09:02:09.000000000 +0000
@@ -288,33 +288,38 @@
 }
 
 static char *getPeerName(int fd, int *port, int numericHosts) {
-  struct sockaddr peerAddr;
+  struct sockaddr_storage peerAddr;
   socklen_t sockLen = sizeof(peerAddr);
-  if (getpeername(fd, &peerAddr, &sockLen)) {
+  if (getpeername(fd, (struct sockaddr*)&peerAddr, &sockLen)) {
     if (port) {
       *port         = -1;
     }
     return NULL;
   }
+  char ipaddr[INET6_ADDRSTRLEN];
   char *ret;
-  if (peerAddr.sa_family == AF_UNIX) {
+  if (peerAddr.ss_family == AF_INET) {
+    struct sockaddr_in *s = (struct sockaddr_in *)&peerAddr;
+    *port = ntohs(s->sin_port);
+    inet_ntop(AF_INET, &s->sin_addr, ipaddr, sizeof ipaddr);
+  } else if (peerAddr.ss_family == AF_INET6) {
+    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&peerAddr;
+    *port = ntohs(s->sin6_port);
+    inet_ntop(AF_INET6, &s->sin6_addr, ipaddr, sizeof ipaddr);
+  } else {
     if (port) {
       *port         = 0;
     }
     check(ret       = strdup("localhost"));
     return ret;
   }
-  char host[256];
-  if (numericHosts ||
-      getnameinfo(&peerAddr, sockLen, host, sizeof(host), NULL, 0, NI_NOFQDN)){
-    check(inet_ntop(peerAddr.sa_family,
-                    &((struct sockaddr_in *)&peerAddr)->sin_addr,
-                    host, sizeof(host)));
-  }
-  if (port) {
-    *port           = ntohs(((struct sockaddr_in *)&peerAddr)->sin_port);
+
+  char host[1024];
+  if (numericHosts || getnameinfo((struct sockaddr *)&peerAddr, sockLen, host, sizeof(host), 0, 0, NI_NOFQDN)) {
+    check(ret         = strdup(ipaddr));
+  } else {
+    check(ret         = strdup(host));
   }
-  check(ret         = strdup(host));
   return ret;
 }
 
@@ -841,9 +846,9 @@
         *ptr                                 = '\000';
         break;
       }
-      if (ch != '-' && ch != '.' &&
-          (ch < '0' ||(ch > '9' && ch < 'A') ||
-          (ch > 'Z' && ch < 'a')||(ch > 'z' && ch <= 0x7E))) {
+      if (ch != '[' && ch != ']' && ch != '-' && ch != '.' &&
+          (ch < '0' || (ch > '9' && ch < 'A') ||
+          (ch > 'Z' && ch < 'a') || (ch > 'z' && ch <= 0x7E))) {
         httpSendReply(http, 400, "Bad Request", NO_MSG);
         return HTTP_DONE;
       }
diff --recursive --unified --new-file --no-dereference upstream/libhttp/server.c src/libhttp/server.c
--- upstream/libhttp/server.c	2016-11-09 19:40:33.000000000 +0000
+++ src/libhttp/server.c	2024-09-13 09:02:09.000000000 +0000
@@ -171,7 +171,7 @@
                                                  "content-length");
   if (!contentLength ||
       (payload->bytes &&
-       ((contentLength && atoi(contentLength) <= payload->len) || !buf))) {
+       ((contentLength && strtol(contentLength, NULL, 0) <= payload->len) || !buf))) {
     rc = payload->handler(http, payload->arg,
                           payload->bytes ? payload->bytes : "", payload->len);
     free(payload->bytes);
@@ -333,14 +333,14 @@
     return;
   }
 
-  server->serverFd              = socket(PF_INET, SOCK_STREAM, 0);
+  server->serverFd              = socket(PF_INET6, SOCK_STREAM, 0);
   check(server->serverFd >= 0);
   check(!setsockopt(server->serverFd, SOL_SOCKET, SO_REUSEADDR,
                     &true, sizeof(true)));
-  struct sockaddr_in serverAddr = { 0 };
-  serverAddr.sin_family         = AF_INET;
-  serverAddr.sin_addr.s_addr    = htonl(localhostOnly
-                                        ? INADDR_LOOPBACK : INADDR_ANY);
+  struct sockaddr_in6 serverAddr = { 0 };
+  serverAddr.sin6_family         = AF_INET6;
+  serverAddr.sin6_addr    = localhostOnly
+                                        ? in6addr_loopback : in6addr_any;
 
   // Linux unlike BSD does not have support for picking a local port range.
   // So, we have to randomly pick a port from our allowed port range, and then
@@ -355,14 +355,14 @@
     int portStart               = rand() % (portMax - portMin + 1) + portMin;
     for (int p = 0; p <= portMax-portMin; p++) {
       int port                  = (p+portStart)%(portMax-portMin+1)+ portMin;
-      serverAddr.sin_port       = htons(port);
+      serverAddr.sin6_port       = htons(port);
       if (!bind(server->serverFd, (struct sockaddr *)&serverAddr,
                 sizeof(serverAddr))) {
         break;
       }
-      serverAddr.sin_port       = 0;
+      serverAddr.sin6_port       = 0;
     }
-    if (!serverAddr.sin_port) {
+    if (!serverAddr.sin6_port) {
       fatal("[server] Failed to find any available port!");
     }
   }
@@ -372,7 +372,7 @@
   check(!getsockname(server->serverFd, (struct sockaddr *)&serverAddr,
                      &socklen));
   check(socklen == sizeof(serverAddr));
-  server->port                  = ntohs(serverAddr.sin_port);
+  server->port                  = ntohs(serverAddr.sin6_port);
   info("[server] Listening on port %d...", server->port);
 
   check(server->pollFds         = malloc(sizeof(struct pollfd)));
diff --recursive --unified --new-file --no-dereference upstream/libhttp/ssl.c src/libhttp/ssl.c
--- upstream/libhttp/ssl.c	2016-11-09 19:40:33.000000000 +0000
+++ src/libhttp/ssl.c	2024-09-13 09:02:09.000000000 +0000
@@ -117,6 +117,9 @@
 int           (*SSL_CTX_set_cipher_list)(SSL_CTX *, const char *);
 void          (*SSL_CTX_set_info_callback)(SSL_CTX *,
                                            void (*)(const SSL *, int, int));
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+unsigned long (*SSL_CTX_set_options)(SSL_CTX *, unsigned long);
+#endif
 int           (*SSL_CTX_use_PrivateKey_file)(SSL_CTX *, const char *, int);
 int           (*SSL_CTX_use_PrivateKey_ASN1)(int, SSL_CTX *,
                                              const unsigned char *, long);
@@ -130,7 +133,9 @@
 BIO *         (*SSL_get_rbio)(const SSL *);
 const char *  (*SSL_get_servername)(const SSL *, int);
 BIO *         (*SSL_get_wbio)(const SSL *);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 int           (*SSL_library_init)(void);
+#endif
 SSL *         (*SSL_new)(SSL_CTX *);
 int           (*SSL_read)(SSL *, void *, int);
 SSL_CTX *     (*SSL_set_SSL_CTX)(SSL *, SSL_CTX *);
@@ -139,10 +144,16 @@
 int           (*SSL_set_ex_data)(SSL *, int, void *);
 int           (*SSL_shutdown)(SSL *);
 int           (*SSL_write)(SSL *, const void *, int);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 SSL_METHOD *  (*SSLv23_server_method)(void);
+#else
+SSL_METHOD *  (*TLS_server_method)(void);
+#endif
 X509 *        (*d2i_X509)(X509 **px, const unsigned char **in, int len);
 void          (*X509_free)(X509 *a);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 void          (*x_sk_zero)(void *st);
+#endif
 void *        (*x_SSL_COMP_get_compression_methods)(void);
 #endif
 
@@ -208,7 +219,7 @@
   // The feature is currently disabled.
   const char* path_libcrypto = NULL; // getenv ("SHELLINABOX_LIBCRYPTO_SO");
   if (path_libcrypto == NULL)
-    path_libcrypto = "libcrypto.so";
+    path_libcrypto = "/usr/lib/libcrypto.so.1.0.0";
 
   if (!crypto++) {
 #ifdef RTLD_NOLOAD
@@ -267,8 +278,8 @@
   // The feature is currently disabled.
   const char* path_libssl = NULL; // = getenv ("SHELLINABOX_LIBSSL_SO");
   if (path_libssl == NULL)
-    path_libssl = "libssl.so";
-  check(!SSL_library_init);
+    path_libssl = "/usr/lib/libssl.so.1.0.0";
+  check(!SSL_CTX_new);
   struct {
     union {
       void *avoid_gcc_warning_about_type_punning;
@@ -299,6 +310,9 @@
     { { &SSL_CTX_new },                 "SSL_CTX_new" },
     { { &SSL_CTX_set_cipher_list },     "SSL_CTX_set_cipher_list" },
     { { &SSL_CTX_set_info_callback },   "SSL_CTX_set_info_callback" },
+#if OPENSSL_VERSION_NUMBER > 0x10100000L
+    { { &SSL_CTX_set_options },         "SSL_CTX_set_options" },
+#endif
     { { &SSL_CTX_use_PrivateKey_file }, "SSL_CTX_use_PrivateKey_file" },
     { { &SSL_CTX_use_PrivateKey_ASN1 }, "SSL_CTX_use_PrivateKey_ASN1" },
     { { &SSL_CTX_use_certificate_file },"SSL_CTX_use_certificate_file"},
@@ -312,7 +326,9 @@
     { { &SSL_get_servername },          "SSL_get_servername" },
 #endif
     { { &SSL_get_wbio },                "SSL_get_wbio" },
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     { { &SSL_library_init },            "SSL_library_init" },
+#endif
     { { &SSL_new },                     "SSL_new" },
     { { &SSL_read },                    "SSL_read" },
 #ifdef HAVE_TLSEXT
@@ -323,10 +339,16 @@
     { { &SSL_set_ex_data },             "SSL_set_ex_data" },
     { { &SSL_shutdown },                "SSL_shutdown" },
     { { &SSL_write },                   "SSL_write" },
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     { { &SSLv23_server_method },        "SSLv23_server_method" },
+#else
+    { { &TLS_server_method },           "TLS_server_method" },
+#endif
     { { &d2i_X509 },                    "d2i_X509" },
     { { &X509_free },                   "X509_free" },
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     { { &x_sk_zero },                   "sk_zero" }
+#endif
   };
   for (unsigned i = 0; i < sizeof(symbols)/sizeof(symbols[0]); i++) {
     if (!(*symbols[i].var = loadSymbol(path_libssl, symbols[i].fn))) {
@@ -343,7 +365,9 @@
   // ends
 
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   SSL_library_init();
+#endif
   dcheck(!ERR_peek_error());
   debug("[ssl] Loaded SSL suppport...");
 }
@@ -351,8 +375,12 @@
 
 int serverSupportsSSL(void) {
 #if defined(HAVE_OPENSSL) && !defined(HAVE_DLOPEN)
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   return SSL_library_init();
 #else
+  return 1;
+#endif
+#else
 #if defined(HAVE_OPENSSL)
   // We want to call loadSSL() exactly once. For single-threaded applications,
   // this is straight-forward. For threaded applications, we need to call
@@ -372,8 +400,12 @@
       loadSSL();
     }
   }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   return !!SSL_library_init;
 #else
+  return 1;
+#endif
+#else
   return 0;
 #endif
 #endif
@@ -623,7 +655,11 @@
 static SSL_CTX *sslMakeContext(void) {
 
   SSL_CTX *context;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   check(context = SSL_CTX_new(SSLv23_server_method()));
+#else
+  check(context = SSL_CTX_new(TLS_server_method()));
+#endif
 
   long options  = SSL_OP_ALL;
   options      |= SSL_OP_NO_SSLv2;
@@ -641,6 +677,7 @@
   // Set default SSL options.
   SSL_CTX_set_options(context, options);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   // Workaround for SSL_OP_NO_COMPRESSION with older OpenSSL versions.
 #ifdef HAVE_DLOPEN
   if (SSL_COMP_get_compression_methods) {
@@ -649,6 +686,7 @@
 #elif OPENSSL_VERSION_NUMBER >= 0x00908000L
   sk_SSL_COMP_zero(SSL_COMP_get_compression_methods());
 #endif
+#endif
 
   // For Perfect Forward Secrecy (PFS) support we need to enable some additional
   // SSL options, provide eliptic curve key object for handshake and add chipers
@@ -657,23 +695,18 @@
   SSL_CTX_set_options(context, SSL_OP_SINGLE_ECDH_USE);
   SSL_CTX_set_options(context, SSL_OP_CIPHER_SERVER_PREFERENCE);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   EC_KEY *ecKey;
   check(ecKey   = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1));
   SSL_CTX_set_tmp_ecdh(context, ecKey);
   EC_KEY_free(ecKey);
+#endif
 
   debug("[ssl] Support for PFS enabled...");
 #endif
 
   check(SSL_CTX_set_cipher_list(context,
-    "ECDHE-RSA-AES256-GCM-SHA384:"
-    "ECDHE-RSA-AES128-GCM-SHA256:"
-    "ECDHE-RSA-AES256-SHA384:"
-    "ECDHE-RSA-AES128-SHA256:"
-    "ECDHE-RSA-AES256-SHA:"
-    "ECDHE-RSA-AES128-SHA:"
-    "ECDHE-RSA-DES-CBC3-SHA:"
-    "HIGH:MEDIUM:!RC4:!aNULL:!MD5"));
+	"AES256+EECDH:AES256+EDH:AES128+EECDH:AES128+EDH:!RC4:!aNULL:!MD5:!DSS"));
 
   SSL_CTX_set_info_callback(context, sslInfoCallback);
 
diff --recursive --unified --new-file --no-dereference upstream/libhttp/ssl.h src/libhttp/ssl.h
--- upstream/libhttp/ssl.h	2016-11-09 19:40:33.000000000 +0000
+++ src/libhttp/ssl.h	2024-09-13 09:02:09.000000000 +0000
@@ -99,6 +99,9 @@
 extern int     (*x_SSL_CTX_set_cipher_list)(SSL_CTX *, const char *);
 extern void    (*x_SSL_CTX_set_info_callback)(SSL_CTX *,
                                               void (*)(const SSL *, int, int));
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+extern unsigned long (*x_SSL_CTX_set_options)(SSL_CTX *, unsigned long);
+#endif
 extern int     (*x_SSL_CTX_use_PrivateKey_file)(SSL_CTX *, const char *, int);
 extern int     (*x_SSL_CTX_use_PrivateKey_ASN1)(int, SSL_CTX *,
                                                 const unsigned char *, long);
@@ -112,7 +115,9 @@
 extern BIO    *(*x_SSL_get_rbio)(const SSL *);
 extern const char *(*x_SSL_get_servername)(const SSL *, int);
 extern BIO    *(*x_SSL_get_wbio)(const SSL *);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 extern int     (*x_SSL_library_init)(void);
+#endif
 extern SSL    *(*x_SSL_new)(SSL_CTX *);
 extern int     (*x_SSL_read)(SSL *, void *, int);
 extern SSL_CTX*(*x_SSL_set_SSL_CTX)(SSL *, SSL_CTX *);
@@ -121,10 +126,16 @@
 extern int     (*x_SSL_set_ex_data)(SSL *, int, void *);
 extern int     (*x_SSL_shutdown)(SSL *);
 extern int     (*x_SSL_write)(SSL *, const void *, int);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 extern SSL_METHOD *(*x_SSLv23_server_method)(void);
+#else
+extern SSL_METHOD *(*x_TLS_server_method)(void);
+#endif
 extern X509 *  (*x_d2i_X509)(X509 **px, const unsigned char **in, int len);
 extern void    (*x_X509_free)(X509 *a);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 extern void    (*x_sk_zero)(void *st);
+#endif
 extern void   *(*x_SSL_COMP_get_compression_methods)(void);
 
 #define BIO_ctrl                     x_BIO_ctrl
@@ -146,6 +157,9 @@
 #define SSL_CTX_new                  x_SSL_CTX_new
 #define SSL_CTX_set_cipher_list      x_SSL_CTX_set_cipher_list
 #define SSL_CTX_set_info_callback    x_SSL_CTX_set_info_callback
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+#define SSL_CTX_set_options          x_SSL_CTX_set_options
+#endif
 #define SSL_CTX_use_PrivateKey_file  x_SSL_CTX_use_PrivateKey_file
 #define SSL_CTX_use_PrivateKey_ASN1  x_SSL_CTX_use_PrivateKey_ASN1
 #define SSL_CTX_use_certificate_file x_SSL_CTX_use_certificate_file
@@ -157,7 +171,9 @@
 #define SSL_get_rbio                 x_SSL_get_rbio
 #define SSL_get_servername           x_SSL_get_servername
 #define SSL_get_wbio                 x_SSL_get_wbio
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 #define SSL_library_init             x_SSL_library_init
+#endif
 #define SSL_new                      x_SSL_new
 #define SSL_read                     x_SSL_read
 #define SSL_set_SSL_CTX              x_SSL_set_SSL_CTX
@@ -166,10 +182,16 @@
 #define SSL_set_ex_data              x_SSL_set_ex_data
 #define SSL_shutdown                 x_SSL_shutdown
 #define SSL_write                    x_SSL_write
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 #define SSLv23_server_method         x_SSLv23_server_method
+#else
+#define TLS_server_method            x_TLS_server_method
+#endif
 #define d2i_X509                     x_d2i_X509
 #define X509_free                    x_X509_free
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 #define sk_zero                      x_sk_zero
+#endif
 #define SSL_COMP_get_compression_methods    x_SSL_COMP_get_compression_methods
 
 #undef  BIO_set_buffer_read_data
diff --recursive --unified --new-file --no-dereference upstream/libhttp/url.c src/libhttp/url.c
--- upstream/libhttp/url.c	2016-11-09 19:40:33.000000000 +0000
+++ src/libhttp/url.c	2024-09-13 09:02:09.000000000 +0000
@@ -313,6 +313,19 @@
             }
           }
         }
+        /* elf-2018.09.09: Detection of broken multipart/form-data
+           fixes DoS vulnerability.
+           On 9/9/18 10:43 AM, Imre Rad wrote:
+           Hi Markus, Marc!
+           I identified a vulnerability today in Shellinabox, it is
+           remote a denial of service, shellinaboxd eating up 100% cpu
+           and not processing subsequent requests after the attack was
+           mounted.
+        */
+        else {
+          warn("[http] Ignorning broken multipart/form-data");
+          break;
+        }
       }
       if (lastPart) {
         warn("[http] Missing final \"boundary\" for \"multipart/form-data\"!");
diff --recursive --unified --new-file --no-dereference upstream/m4/.gitignore src/m4/.gitignore
--- upstream/m4/.gitignore	2016-11-09 19:40:33.000000000 +0000
+++ src/m4/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-# This directory is used by autotools, so we ignore all files except this one.
-*
-!.gitignore
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/cgi_root.html src/shellinabox/cgi_root.html
--- upstream/shellinabox/cgi_root.html	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/cgi_root.html	2024-09-13 09:02:09.000000000 +0000
@@ -49,7 +49,7 @@
     http://shellinabox.com
     -->
     <title>Shell In A Box</title>
-    <script type="text/javascript"><!--
+    <script nonce="%s" type="text/javascript"><!--
     (function() {
       var url   = document.location.protocol + '//' +
                   document.location.hostname + ':%d/';
@@ -67,10 +67,25 @@
         }
       }
       document.write('<frameset cols="*">\n' +
-                       '<frame src="' + url + '#' +
+                       '<frame id="cli_frame" src="' + url + '#' +
                           encodeURIComponent(document.location.href) +
                           ',%s' + '">\n' +
                      '</frameset>');
+
+      function bindEvent(element, eventName, eventHandler) {
+            if (element.addEventListener) {
+                  element.addEventListener(eventName, eventHandler, false);
+            } else if (element.attachEvent) {
+                  element.attachEvent('on' + eventName, eventHandler);
+            }
+      }
+
+      bindEvent(window, 'message', function (e) {
+            if (window.location.href.indexOf(e.origin.substring(0, e.origin.lastIndexOf(':'))) !== -1 &&
+                  e.data === 'reconnect') {
+                  window.location.reload(true);
+            }
+      });
     })();
     --></script>
   </head>
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/launcher.c src/shellinabox/launcher.c
--- upstream/shellinabox/launcher.c	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/launcher.c	2024-09-13 09:02:09.000000000 +0000
@@ -86,10 +86,6 @@
 #include <util.h>
 #endif
 
-#ifdef HAVE_UTMP_H
-#include <utmp.h>
-#endif
-
 #ifdef HAVE_UTMPX_H
 #include <utmpx.h>
 #endif
@@ -639,7 +635,7 @@
   return utmp;
 }
 
-#if defined(HAVE_UPDWTMP) && !defined(HAVE_UPDWTMPX)
+#if defined(HAVE_UTMPX) && defined(HAVE_UPDWTMP) && !defined(HAVE_UPDWTMPX)
 #define min(a,b) ({ typeof(a) _a=(a); typeof(b) _b=(b); _a < _b ? _a : _b; })
 #define updwtmpx x_updwtmpx
 
@@ -1678,14 +1674,27 @@
     // At login service launch, we try to pass real IP in '-h' parameter. Real
     // IP is provided in HTTP header field 'X-Real-IP', if ShellInABox is used
     // behind properly configured HTTP proxy.
+
+    if (service->bannerContent) {
+      fputs(service->bannerContent, stdout);
+      fputs("\n", stdout);
+    }
+
     char remoteHost[256];
     snprintf(remoteHost, 256,
              (*realIP) ? "%s, %s" : "%s%s", peerName,
              (*realIP) ? realIP : "");
-    execle("/bin/login", "login", "-p", "-h", remoteHost,
-           (void *)0, environment);
-    execle("/usr/bin/login", "login", "-p", "-h", remoteHost,
-           (void *)0, environment);
+	if (service->portRange) {
+		execle("/bin/login", "login", "-p", "-h", remoteHost, "-P", service->portRange,
+			(void *)0, environment);
+		execle("/usr/bin/login", "login", "-p", "-h", remoteHost, "-P", service->portRange,
+			(void *)0, environment);
+	} else {
+		execle("/bin/login", "login", "-p", "-h", remoteHost,
+			(void *)0, environment);
+		execle("/usr/bin/login", "login", "-p", "-h", remoteHost,
+			(void *)0, environment);
+	}
   } else {
     // Launch user provied service
     execService(width, height, service, peerName, realIP, environment, url);
@@ -1786,7 +1795,7 @@
       if (!((*s >= '0' && *s <= '9') ||
             (*s >= 'A' && *s <= 'Z') ||
             (*s >= 'a' && *s <= 'z') ||
-             *s == '.' || *s == '-')) {
+             *s == '.' || *s == '-' || *s == ':')) {
         *s                    = '-';
       }
     }
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/root_page.html src/shellinabox/root_page.html
--- upstream/shellinabox/root_page.html	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/root_page.html	2024-09-13 09:02:09.000000000 +0000
@@ -110,6 +110,22 @@
       }
 
     --></script>
+    <script>
+      function bindEvent2(element, eventName, eventHandler) {
+            if (element.addEventListener) {
+                  element.addEventListener(eventName, eventHandler, false);
+            } else if (element.attachEvent) {
+                  element.attachEvent('on' + eventName, eventHandler);
+            }
+      }
+
+      bindEvent2(window, 'message', function (e) {
+            if (window.location.href.indexOf(e.origin.substring(0, e.origin.lastIndexOf(':'))) !== -1 &&
+                  e.data === 'reconnect') {
+                  window.location.reload(true);
+            }
+      });
+    </script>
     <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
     <script type="text/javascript" src="ShellInABox.js"></script>
   </head>
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/service.c src/shellinabox/service.c
--- upstream/shellinabox/service.c	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/service.c	2024-09-13 09:02:09.000000000 +0000
@@ -253,9 +253,11 @@
   free(desc);
 }
 
-struct Service *newService(const char *arg) {
+struct Service *newService(const char *arg, const char *portRange, const char *bannerContent) {
   struct Service *service;
   check(service = malloc(sizeof(struct Service)));
+  service->portRange = portRange;
+  service->bannerContent = bannerContent;
   initService(service, arg);
   return service;
 }
@@ -267,6 +269,8 @@
     free((char *)service->group);
     free((char *)service->cwd);
     free((char *)service->cmdline);
+	free((char *)service->portRange);
+  free((char *)service->bannerContent);
   }
 }
 
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/service.h src/shellinabox/service.h
--- upstream/shellinabox/service.h	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/service.h	2024-09-13 09:02:09.000000000 +0000
@@ -61,13 +61,15 @@
   const char *group;
   const char *cwd;
   const char *cmdline;
+  const char *portRange;
+  const char *bannerContent;
 };
 
 extern struct Service **services;
 extern int            numServices;
 
 void initService(struct Service *service, const char *arg);
-struct Service *newService(const char *arg);
+struct Service *newService(const char *arg, const char *portRange, const char *bannerContent);
 void destroyService(struct Service *service);
 void deleteService(struct Service *service);
 void destroyServiceHashEntry(void *arg, char *key, char *value);
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/shell_in_a_box.jspp src/shellinabox/shell_in_a_box.jspp
--- upstream/shellinabox/shell_in_a_box.jspp	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/shell_in_a_box.jspp	2024-09-13 09:02:09.000000000 +0000
@@ -92,7 +92,7 @@
 function ShellInABox(url, container) {
   if (url == undefined) {
     this.rooturl    = document.location.href;
-    this.url        = document.location.href.replace(/[?#].*/, '');
+    this.url        = document.location.href;
   } else {
     this.rooturl    = url;
     this.url        = url;
@@ -146,12 +146,15 @@
 ShellInABox.prototype.reconnect = function() {
   this.showReconnect(false);
   if (!this.session) {
-    if (document.location.hash != '') {
+    var is_rms = document.location.hostname.match(/.*\.teltonika\.lt$/)
+    if (is_rms !== null) {
+      window.postMessage('reconnect', '*');
+    } else if (document.location.hash != '') {
       // A shellinaboxd daemon launched from a CGI only allows a single
       // session. In order to reconnect, we must reload the frame definition
       // and obtain a new port number. As this is a different origin, we
       // need to get enclosing page to help us.
-      parent.location        = this.nextUrl;
+      window.parent.postMessage('reconnect', '*');
     } else {
       if (this.url != this.nextUrl) {
         document.location.replace(this.nextUrl);
@@ -170,7 +173,7 @@
   if (request == undefined) {
     request                  = new XMLHttpRequest();
   }
-  request.open('POST', this.url + '?', true);
+  request.open('POST', this.url, true);
   request.timeout = 30000; // Don't leave POST pending forever: force 30s timeout to prevent HTTP Proxy thread hijack
   request.setRequestHeader('Cache-Control', 'no-cache');
   request.setRequestHeader('Content-Type',
@@ -239,7 +242,7 @@
     keys                       = this.pendingKeys + keys;
     this.pendingKeys           = '';
     var request                = new XMLHttpRequest();
-    request.open('POST', this.url + '?', true);
+    request.open('POST', this.url, true);
     request.setRequestHeader('Cache-Control', 'no-cache');
     request.setRequestHeader('Content-Type',
                            'application/x-www-form-urlencoded; charset=utf-8');
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/shellinaboxd.c src/shellinabox/shellinaboxd.c
--- upstream/shellinabox/shellinaboxd.c	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/shellinaboxd.c	2024-09-13 09:02:09.000000000 +0000
@@ -65,6 +65,7 @@
 #include <sys/un.h>
 #include <time.h>
 #include <unistd.h>
+#include <libubus.h>
 
 #ifdef HAVE_SYS_PRCTL_H
 #include <sys/prctl.h>
@@ -103,10 +104,12 @@
 
 #define PORTNUM           4200
 #define MAX_RESPONSE      2048
+#define NONCE_SIZE        128
 
 static int            port;
 static int            portMin;
 static int            portMax;
+static char           *portRange;
 static int            localhostOnly     = 0;
 static int            noBeep            = 0;
 static int            numericHosts      = 0;
@@ -124,6 +127,7 @@
 static char           *cgiSessionKey;
 static int            cgiSessions;
 static char           *cssStyleSheet;
+static char           *bannerContent;
 static struct UserCSS *userCSSList;
 static const char     *pidfile;
 static sigjmp_buf     jmpenv;
@@ -410,8 +414,8 @@
 
   // Adjust window dimensions if provided by client
   if (width && height) {
-    session->width        = atoi(width);
-    session->height       = atoi(height);
+    session->width        = strtol(width, NULL, 0);
+    session->height       = strtol(height, NULL, 0);
   }
 
   // Create a new session, if the client did not provide an existing one
@@ -756,7 +760,7 @@
   } else if (pathInfoLength > 8 && !memcmp(pathInfo, "usercss-", 8)) {
     // Server user style sheets (if any)
     struct UserCSS *css   = userCSSList;
-    for (int idx          = atoi(pathInfo + 8);
+    for (int idx          = strtol(pathInfo + 8, NULL, 0);
          idx-- > 0 && css; css = css->next ) {
     }
     if (css) {
@@ -802,6 +806,7 @@
           "\n"
           "List of command line options:\n"
           "  -b, --background[=PIDFILE]  run in background\n"
+          "      --banner=FILE           show banner before login\n"
           "%s"
           "      --css=FILE              attach contents to CSS style sheet\n"
           "      --cgi[=PORTMIN-PORTMAX] run as CGI\n"
@@ -912,6 +917,7 @@
     static struct option options[] = {
       { "help",                 0, 0, 'h' },
       { "background",           2, 0, 'b' },
+      { "banner",               1, 0,  0  },
       { "cert",                 1, 0, 'c' },
       { "cert-fd",              1, 0,  0  },
       { "css",                  1, 0,  0  },
@@ -971,6 +977,22 @@
         check(pidfile     = strdup(optarg));
       }
     } else if (!idx--) {
+      // Banner
+      struct stat st;
+      if (!optarg || !*optarg || stat(optarg, &st) || !S_ISREG(st.st_mode)) {
+        fatal("[config] Option --banner expects a file name!");
+      }
+      FILE *banner            = fopen(optarg, "r");
+      if (!banner) {
+        fatal("[config] Cannot read banner \"%s\"!", optarg);
+      } else {
+        check(bannerContent = calloc(st.st_size, sizeof(char)));
+        if (fread(bannerContent, st.st_size, 1, banner) != 1) {
+          fatal("[config] Failed to read banner \"%s\"!", optarg);
+        }
+        fclose(banner);
+      }
+    } else if (!idx--) {
       // Certificate
       if (!hasSSL) {
         warn("[config] Ignoring certificate directory, as SSL support is unavailable.");
@@ -1043,6 +1065,7 @@
         if (!ptr) {
           fatal("[config] Syntax error in port range specification!");
         }
+		check(portRange = strdup(optarg));
         *ptr               = '\000';
         portMin            = strtoint(optarg, 1, 65535);
         *ptr               = '-';
@@ -1145,7 +1168,7 @@
         fatal("[config] Option \"--service\" expects an argument.");
       }
       struct Service *service;
-      service              = newService(optarg);
+      service              = newService(optarg, NULL, bannerContent);
       if (getRefFromHashMap(serviceTable, service->path)) {
         fatal("[config] Duplicate service description for \"%s\".", service->path);
       }
@@ -1278,7 +1301,7 @@
 #else
                                     ":SSH"
 #endif
-                                    ));
+                                    , portRange, bannerContent));
   }
   enumerateServices(serviceTable);
   deleteHashMap(serviceTable);
@@ -1359,6 +1382,38 @@
   }
 }
 
+static void receive_uhttpd_nonce_cb(struct ubus_request *req, int type, struct blob_attr *msg) {
+  char *buf = req->priv;
+  struct blob_attr *cur;
+  int rem;
+  blobmsg_for_each_attr (cur, msg, rem) {
+    if (!strcmp(blobmsg_name(cur), "nonce")) {
+      strncpy(buf, blobmsg_get_string(cur), NONCE_SIZE - 1);
+    }
+  }
+}
+
+static int receive_uhttpd_nonce(char *buffer) {
+  struct ubus_context *ubus;
+  uint32_t obj;
+
+  ubus = ubus_connect(NULL);
+  if (!ubus) {
+    fprintf(stderr, "failed to connect to ubus\n");
+    return 1;
+  }
+
+  if (ubus_lookup_id(ubus, "uhttpd", &obj) ||
+    ubus_invoke(ubus, obj, "nonce", NULL, receive_uhttpd_nonce_cb, buffer, 1000)) {
+      fprintf(stderr, "ubus request failed\n");
+      ubus_free(ubus);
+      return 1;
+  }
+
+  ubus_free(ubus);
+  return 0;
+}
+
 int main(int argc, char * const argv[]) {
 #ifdef HAVE_SYS_PRCTL_H
   // Disable core files
@@ -1389,6 +1444,7 @@
     // background.
     pid_t pid;
     int   fds[2];
+    char nonce_hash[NONCE_SIZE];
     dropPrivileges();
     check(!pipe(fds));
     check((pid    = fork()) >= 0);
@@ -1414,7 +1470,8 @@
            "Content-type: text/html; charset=utf-8\r\n\r\n",
            port, getpid(), cgiSessionKey);
     UNUSED(cgiRootSize);
-    printfUnchecked(cgiRootStart, port, cgiSessionKey);
+    receive_uhttpd_nonce(nonce_hash);
+    printfUnchecked(cgiRootStart, nonce_hash, port, cgiSessionKey);
     fflush(stdout);
     check(!NOINTR(close(fds[1])));
     closeAllFds((int []){ launcherFd, serverGetFd(server) }, 2);
@@ -1478,7 +1535,7 @@
       NOINTR(close(fd));
       if (sz > 0) {
         buf[sz]   = '\000';
-        if (atoi(buf) == getpid()) {
+        if (strtol(buf, NULL, 0) == getpid()) {
           unlink(pidfile);
         }
       }
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/styles.css src/shellinabox/styles.css
--- upstream/shellinabox/styles.css	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/styles.css	2024-09-13 09:02:09.000000000 +0000
@@ -13,9 +13,21 @@
 }
 
 #vt100 #reconnect input {
-  padding:              1ex;
-  font-weight:          bold;
-  font-size:            x-large;
+  padding:              0.625rem 1rem;
+  font-weight:          600;
+  font-size:            0.875rem !important;
+  transition:           0.15s;
+  cursor:               pointer;
+  line-height:          1.25rem;
+  background-color:     rgb(0, 84, 166);
+  border-radius:        4px; 
+  color:                white;
+  border:               0;
+  font-family:          'Open Sans', sans-serif;
+}
+
+#vt100 #reconnect input:hover {
+  background-color:    rgb(0, 63, 125) !important;
 }
 
 #vt100 #cursize {
@@ -39,7 +51,9 @@
 
 #vt100 #scrollable {
   overflow-x:           hidden;
-  overflow-y:           scroll;
+  overflow-y:           auto;
+  scrollbar-width:      thin;
+  scrollbar-color:      rgb(201, 201, 201) rgb(247, 247, 247);
   position:             relative;
   padding:              1px;
 }
diff --recursive --unified --new-file --no-dereference upstream/shellinabox/vt100.jspp src/shellinabox/vt100.jspp
--- upstream/shellinabox/vt100.jspp	2016-11-09 19:40:33.000000000 +0000
+++ src/shellinabox/vt100.jspp	2024-09-13 09:02:09.000000000 +0000
@@ -98,6 +98,9 @@
 #define MOUSE_UP       1
 #define MOUSE_CLICK    2
 
+//  check if browser is firefox
+const isFirefox = navigator.userAgent.includes('Firefox')
+
 function VT100(container) {
   if (typeof linkifyURLs == 'undefined' || linkifyURLs <= 0) {
     this.urlRE            = null;
@@ -916,8 +919,8 @@
                        '<div class="hidden">' +
                          '<div id="usercss"></div>' +
                          '<pre><div><span id="space"></span></div></pre>' +
-                         '<input type="text" id="input" autocorrect="off" autocapitalize="off" />' +
-                         '<input type="text" id="cliphelper" />' +
+                         '<input type="text" id="input" autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false" />' +
+                         '<input type="text" id="cliphelper" tabindex="-1" />' +
                          (typeof suppressAllAudio != 'undefined' &&
                           suppressAllAudio ? "" :
                          embed + '<bgsound id="beep_bgsound" loop=1 />') +
@@ -2685,6 +2688,11 @@
 };
 
 VT100.prototype.handleKey = function(event) {
+  // for some reason mobile firefox has bug with 'Backspace' button where 'Backspace' button
+  // is registered as 'Process' (keycode = 229) for n number of times where n is equal times of symbols typed
+  // for example typing '12345' (5 characters) and pressing 'Backspace' registers as `Process` for 5 times and only then registers as "Backspace"
+  // for example typing 'a b c d e' (9 characters (5 letters 4 spaces)) and pressing 'Backspace' registers as `Process` for 9 times and only then registers as "Backspace"
+  if (event.keyCode === 229 && isFirefox) event.keyCode = 8
   // this.vt100('H: c=' + event.charCode + ', k=' + event.keyCode +
   //            (event.shiftKey || event.ctrlKey || event.altKey ||
   //             event.metaKey ? ', ' +
@@ -2714,7 +2722,7 @@
   // By this point, "ch" is either defined and contains the character code, or
   // it is undefined and "key" defines the code of a function key
   if (ch != undefined) {
-    this.scrollable.scrollTop         = this.numScrollbackLines *
+        this.scrollable.scrollTop         = this.numScrollbackLines *
                                         this.cursorHeight + 1;
   } else {
     if ((event.altKey || event.metaKey) && !event.shiftKey && !event.ctrlKey) {
@@ -2819,7 +2827,7 @@
       }
       this.scrollable.scrollTop       = this.numScrollbackLines *
                                         this.cursorHeight + 1;
-    }
+        }
   }
 
   // "ch" now contains the sequence of keycodes to send. But we might still
@@ -2978,7 +2986,7 @@
 };
 
 VT100.prototype.keyDown = function(event) {
-  // this.vt100('D: c=' + event.charCode + ', k=' + event.keyCode +
+    // this.vt100('D: c=' + event.charCode + ', k=' + event.keyCode +
   //            (event.shiftKey || event.ctrlKey || event.altKey ||
   //             event.metaKey ? ', ' +
   //             (event.shiftKey ? 'S' : '') + (event.ctrlKey ? 'C' : '') +
@@ -4299,7 +4307,7 @@
 };
 
 VT100.prototype.renderString = function(s, showCursor) {
-  if (this.printing) {
+    if (this.printing) {
     this.sendToPrinter(s);
     if (showCursor) {
       this.showCursor();
@@ -4326,7 +4334,7 @@
 };
 
 VT100.prototype.vt100 = function(s) {
-  this.cursorNeedsShowing = this.hideCursor();
+    this.cursorNeedsShowing = this.hideCursor();
   this.respondString      = '';
   var lineBuf             = '';
   for (var i = 0; i < s.length; i++) {
@@ -4370,7 +4378,7 @@
         this.utfCount     = 0;
       }
     }
-    var isNormalCharacter =
+        var isNormalCharacter =
       (ch >= 32 && ch <= 127 || ch >= 160 ||
        this.utfEnabled && ch >= 128 ||
        !(this.dispCtrl ? this.ctrlAlways : this.ctrlAction)[ch & 0x1F]) &&
@@ -4424,7 +4432,7 @@
   } else if (this.cursorNeedsShowing) {
     this.showCursor();
   }
-  return this.respondString;
+    return this.respondString;
 };
 
 VT100.prototype.Latin1Map = [
diff --recursive --unified --new-file --no-dereference upstream/shellinabox.init src/shellinabox.init
--- upstream/shellinabox.init	1970-01-01 00:00:00.000000000 +0000
+++ src/shellinabox.init	2024-09-13 09:02:09.000000000 +0000
@@ -0,0 +1,46 @@
+#!/bin/sh /etc/rc.common
+# Copyright (C) 2018 Teltonika
+#. /lib/teltonika-functions.sh
+#. /lib/functions.sh
+START=99
+
+USE_PROCD=1
+enable=$(uci get cli.status.enable)
+uhttpd_cert=$(uci get uhttpd.main.cert)
+uhttpd_key=$(uci get uhttpd.main.key)
+key_type=$(uci get uhttpd.defaults.key_type)
+shell_cert="/tmp/certificate.pem"
+
+start_service()
+{
+	if [ "$enable" == "1" ]; then
+		if [ ! -s "$shell_cert" ]; then
+			openssl x509 -inform DER -in "$uhttpd_cert" -outform PEM | cat "$uhttpd_key" - > /tmp/shellinabox.tmp
+			mv /tmp/shellinabox.tmp "$shell_cert"
+
+			[ "$key_type" = "ec" ] && sed -i 's/PRIVATE/EC PRIVATE/g' "$shell_cert"
+		fi
+	fi
+}
+
+stop_service()
+{
+	rm -f "$shell_cert"
+	killall shellinaboxd
+}
+
+restart_service()
+{
+	rm -f "$shell_cert"
+	killall shellinaboxd
+	if [ "$enable" == "1" ]; then
+		openssl x509 -inform DER -in "$uhttpd_cert" -outform PEM | cat "$uhttpd_key" - > /tmp/shellinabox.tmp
+		mv /tmp/shellinabox.tmp "$shell_cert"
+		[ "$key_type" = "ec" ] && sed -i 's/PRIVATE/EC PRIVATE/g' "$shell_cert"
+	fi
+}
+
+reload_service()
+{
+	restart_service
+}
diff --recursive --unified --new-file --no-dereference upstream/shellinabox.sh src/shellinabox.sh
--- upstream/shellinabox.sh	1970-01-01 00:00:00.000000000 +0000
+++ src/shellinabox.sh	2024-09-13 09:02:09.000000000 +0000
@@ -0,0 +1,55 @@
+#!/bin/sh
+title=""
+paragraph=""
+shell_cert="/tmp/certificate.pem"
+uhttpd_cert=$(uci -q get uhttpd.main.cert)
+uhttpd_key=$(uci -q get uhttpd.main.key)
+enable=$(uci -q get cli.status.enable)
+if [ "$enable" -eq "1" ]; then
+	port=$(uci -q get cli.status.port)
+	if [ -z "$port" ]; then
+		port="4200-4220"
+		uci -q set cli.status.port="$port"
+		uci -q commit cli
+	fi
+	shell_limit=$(uci -q get cli.status.shell_limit)
+	if [ -z "$shell_limit" ]; then
+		shell_limit="5"
+		uci -q set cli.status.shell_limit="$shell_limit"
+		uci -q commit cli
+	fi
+	shells=$(ps | grep -v grep | grep -c shellinaboxd)
+	if [ "$shells" -lt "$shell_limit" ]; then
+		if [ ! -s "$shell_cert" ]; then
+			openssl x509 -inform DER -in "$uhttpd_cert" -outform PEM | cat "$uhttpd_key" - > /tmp/shellinabox.tmp
+			mv /tmp/shellinabox.tmp "$shell_cert"
+		fi
+		if [ -n "$HTTPS" ]; then
+			/usr/sbin/shellinaboxd --disable-ssl-menu --cgi="${port}" -u 0 -g 0 -c /tmp
+		else
+			/usr/sbin/shellinaboxd -t --cgi="${port}" -u 0 -g 0
+		fi
+	else
+		title="Too many active shell instances!"
+		paragraph="Too many active shell instances! Close some shell instances and try again."
+	fi
+else
+	title="CLI not enabled!"
+	paragraph="CLI not enabled! Enable CLI and try again."
+fi
+
+if [ -n "$title" ] && [ -n "$paragraph" ]; then
+echo "Content-type: text/html"
+echo ""
+cat <<EOT
+<!DOCTYPE html>
+<html>
+<head>
+        <title>${title}</title>
+</head>
+<body>
+        <p>${paragraph}</p>
+</body>
+</html>
+EOT
+fi
