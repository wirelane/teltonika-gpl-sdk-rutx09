diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2016-12-15 17:28:43.000000000 +0000
+++ src/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,132 +0,0 @@
-# Object files
-*.o
-*.ko
-*.lo
-
-# Libraries
-*.lib
-*.a
-*.la
-
-# Shared objects (inc. Windows DLLs)
-*.dll
-*.so
-*.so.*
-*.dylib
-
-# Executables
-*.exe
-*.out
-*.app
-
-**/.deps
-**/.libs
-
-Makefile
-Makefile.in
-bstring/Makefile
-bstring/Makefile.in
-conf/Makefile
-conf/Makefile.in
-debian/Makefile
-debian/Makefile.in
-distro/Makefile
-distro/Makefile.in
-doc/Makefile
-doc/Makefile.in
-json/Makefile
-json/Makefile.in
-json/json_config.h
-json/json_config.h.in
-json/stamp-h2
-miniportal/Makefile
-miniportal/Makefile.in
-src/Makefile
-src/Makefile.in
-src/mssl/Makefile
-src/mssl/Makefile.in
-www/Makefile
-www/Makefile.in
-
-aclocal.m4
-compile
-conf/CoovaChilliLib.py
-conf/chilli
-conf/chilli.conf
-conf/defaults
-conf/down.sh
-conf/functions
-conf/newmulti.sh
-conf/up.sh
-conf/wpad.dat
-config.guess
-config.h
-config.h.in
-config.log
-config.status
-config.sub
-configure
-configure.status
-coova-doxygen
-depcomp
-distro/nethserver/coova-chilli.spec
-distro/redhat/coova-chilli.spec
-distro/suse/coova-chilli.spec
-doc/chilli-radius.5
-doc/chilli.8
-doc/chilli.conf.5
-doc/chilli_opt.1
-doc/chilli_proxy.1
-doc/chilli_query.1
-doc/chilli_radconfig.1
-doc/chilli_radsec.1
-doc/chilli_redir.1
-doc/chilli_response.1
-doc/chilli_rtmon.1
-doc/chilli_script.1
-install-sh
-libtool
-ltmain.sh
-m4/
-missing
-stamp-h1
-
-src/chilli
-src/chilli_opt
-src/chilli_query
-src/chilli_radconfig
-src/chilli_response
-src/chilli_proxy
-src/chilli_radsec
-src/chilli_redir
-src/chilli_rtmon
-src/chilli_script
-
-www/config.sh
-miniportal/config-local.sh
-miniportal/contact.chi
-miniportal/error.chi
-miniportal/functions.sh
-miniportal/login.chi
-miniportal/map.chi
-miniportal/payment.chi
-miniportal/payment.sh
-miniportal/register.chi
-miniportal/service.chi
-miniportal/status.chi
-miniportal/terms.chi
-miniportal/tos.chi
-miniportal/uam.sh
-miniportal/wispr.sh
-
-src/cmdline.[ch]
-src/cmdline.c.orig
-autom4te.cache
-
-debian/coova-chilli.debhelper.log
-debian/coova-chilli.postinst.debhelper
-debian/coova-chilli.postrm.debhelper
-debian/coova-chilli.prerm.debhelper
-debian/coova-chilli.substvars
-debian/coova-chilli/
-debian/files
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitlab-ci.yml src/.gitlab-ci.yml
--- upstream/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/Makefile.am src/Makefile.am
--- upstream/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -9,3 +9,6 @@
 if WITH_MINIPORTAL
 SUBDIRS += miniportal
 endif
+#if WITH_UBUS
+#SUBDIRS += lchilli
+#endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/README.md src/README.md
--- upstream/README.md	2016-12-15 17:28:43.000000000 +0000
+++ src/README.md	2025-11-06 13:20:13.000000000 +0000
@@ -27,3 +27,14 @@
   `make`
 
 More details about the build process and dependencies are covered in the [INSTALL file](/INSTALL)
+
+## UBUS Methods
+
+The following methods are exposed over `ubus`:
+
+**Object: chilli**
+
+Path | Procedure | Signature | Description
+--- | --- | --- | ---
+chilli | list | `{"ip":"String","mac":"String","sessionid":"String"}` | List sessions. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional).
+chilli | logout | `{"ip":"String","mac":"String","sessionid":"String"}` | Logoff active user. Params: `ip` - ip address (optional), mac - mac address (optional), sessionid - session ID (optional). At least one parameter required.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/changelog src/changelog
--- upstream/changelog	1970-01-01 00:00:00.000000000 +0000
+++ src/changelog	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,9 @@
+# 2019-12-19
+	*New
+		* SMS authentication added
+		* MAC based authentication added
+		* Signup method added
+		* Additional user scripts added
+		* New session param added "expirationtime"
+		* TOS requirement added
+		* Configurable url params added
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/Makefile.am src/conf/Makefile.am
--- upstream/conf/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -20,8 +20,8 @@
 	-e 's,@ETCDIR\@,$(sysconfdir),g' \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(initrddir),g' \
-	-e 's,@VARTMP\@,$(localstatedir)/tmp,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARTMP\@,$(localstatedir),g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/down.sh.in src/conf/down.sh.in
--- upstream/conf/down.sh.in	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/down.sh.in	2025-11-06 13:20:13.000000000 +0000
@@ -4,23 +4,95 @@
 # down.sh /dev/tun0 192.168.0.10 255.255.255.0
 
 TUNTAP=$(basename $DEV)
+RT_TABLES_FILE="/etc/iproute2/rt_tables"
+
 UNDO_FILE=@VARRUN@/chilli.$TUNTAP.sh
+RT_TABLES_LOCK_FILE=@VARRUN@/rt_tables.lock
+LOCK_FILE=@VARRUN@/down.lock
 
 . @SYSCONFDIR@/chilli/functions
+. /lib/functions.sh
+
+remove_routing_table() {
+    local table_num="$1"
+    local interface="$2"
+    local entry="${table_num} ${interface}"
+
+    lock -w "$RT_TABLES_LOCK_FILE"
+
+    grep -q "^${entry}$" "$RT_TABLES_FILE" && {
+        sed -i "/^${entry}$/d" "$RT_TABLES_FILE"
+        ip route flush table "$table_num"
+        ip rule flush table "$table_num"
+    }
+
+    lock -u "$RT_TABLES_LOCK_FILE"
+}
+
+restore_lan() {
+    local device ipaddr
+    config_get device $1 device
+    config_get ipaddr $1 ipaddr
+    config_get netmask $1 netmask
+
+    [ "$device" == "$2" ] && [ -n "$ipaddr" ] && {
+        ip addr replace $ipaddr/$netmask broadcast + dev $2
+        ip link set $2 up
+    }
+}
 
 run_down() {
     [ -e "$UNDO_FILE" ] && sh $UNDO_FILE 2>/dev/null
     rm -f $UNDO_FILE 2>/dev/null
+
+    [ -n "$TUNTAP" ] && [ "$KNAME" != "" ] && {
+        local virtual="ifb0"
+        local interfaces=$DHCPIF
+        [ -n "$MOREIF" ] && {
+            for iface in $MOREIF; do
+                interfaces="$interfaces $iface"
+            done
+        }
+
+        local index=100
+        for iface in $interfaces; do
+            tc qdisc show dev $iface 2>/dev/null | grep -q '^qdisc htb 1:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del root dev $iface >/dev/null 2>&1 && break
+                    sleep 2
+                done
+            }
+            tc qdisc show dev $virtual 2>/dev/null | grep -q '^qdisc htb 2:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del root dev $virtual >/dev/null 2>&1 && break
+                    sleep 2
+                done
+                ip link set dev $virtual down
+                ip link delete name $virtual
+            }
+            tc qdisc show dev $iface 2>/dev/null | grep -q '^qdisc ingress ffff:' && {
+                for i in $(seq 1 5); do
+                    tc qdisc del dev $iface handle ffff: ingress >/dev/null 2>&1 && break
+                    sleep 2
+                done
+            }
+            ip addr flush dev $iface
+            ip link set $iface up
+            config_load network
+            config_foreach restore_lan interface "$iface"
+            [ -n "$MOREIF" ] && remove_routing_table "$index" "$iface"
+            index=$((index + 1))
+        done
+    }
     
     # site specific stuff optional
     [ -e @SYSCONFDIR@/chilli/ipdown.sh ] && . @SYSCONFDIR@/chilli/ipdown.sh
 }
 
-FLOCK=$(which flock)
-if [ -n "$FLOCK" ] && [ -z "$LOCKED_FILE" ]
-then
-    export LOCKED_FILE=/tmp/.chilli-flock
-    flock -x $LOCKED_FILE -c "$0 $@"
-else
-    run_down
-fi
+lock -w "$LOCK_FILE"
+
+trap 'lock -u '"$LOCK_FILE"'' EXIT
+
+run_down
+
+exit 0
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/cloud4wi src/conf/profiles/configs/cloud4wi
--- upstream/conf/profiles/configs/cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/cloud4wi	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,33 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamserver 'https://splashportal.cloud4wi.com?vendor=teltonika'
+	option radiusserver1 '54.247.117.188'
+	option radiusserver2 '79.125.111.180'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_cloud4wi'
+	option paramuamip 'nas_ip'
+	option paramuamport 'nas_port'
+	option paramcalled 'ap_mac'
+	option parammac 'client_mac'
+	option paramip 'client_ip'
+	option paramnasid 'identifer'
+	option paramuserurl 'redirect_url'
+	option param1 'version'
+	option param1value ''
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/default src/conf/profiles/configs/default
--- upstream/conf/profiles/configs/default	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/default	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,19 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _mode 'local'
+	option _landingpage 'int'
+	option _success 'uam'
+	option _protocol 'http'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/hotspotsystems src/conf/profiles/configs/hotspotsystems
--- upstream/conf/profiles/configs/hotspotsystems	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/hotspotsystems	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,26 @@
+config group
+	option name 'default'
+	
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_hs
+	option uamserver 'https://customer.hotspotsystem.com/customer/hotspotlogin.php'
+	option uamsecret 'hotsys123'
+	option radiusserver1 'radius.hotspotsystem.com'
+	option radiusserver2 'radius2.hotspotsystem.com'
+	option radiussecret 'hotsys123'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/configs/purple src/conf/profiles/configs/purple
--- upstream/conf/profiles/configs/purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/configs/purple	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,31 @@
+config group
+	option name 'default'
+
+config chilli
+	option enabled '0'
+	option net '192.168.2.0/24'
+	option uamlisten '192.168.2.254'
+	option dns1 '8.8.8.8'
+	option dns2 '8.8.4.4'
+	option uamlogoutip '1.0.0.0'
+	option radiusauthport '1812'
+	option radiusacctport '1813'
+	option uamport '3990'
+	option ipup '/etc/chilli/up.sh'
+	option ipdown '/etc/chilli/down.sh'
+	option dbpath '/var/hotspot.db'
+	option usersdbpath '/etc/chilli/users.db'
+	option _success 'uam'
+	option _mode 'radius'
+	option _landingpage 'ext'
+	option _https '0'
+	option tos '0'
+	option trialusers '0'
+	option uamdomainfile '/etc/chilli/uamdomains/uamdomainfile_purple'
+	option uamserver 'https://purpleportal.net/access/'
+	option uamsecret ''
+	option radiusserver1 ''
+	option radiusserver2 ''
+	option radiussecret ''
+	option radiusnasid 'guest'
+	option swapoctets '1'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_cloud4wi src/conf/profiles/uamdomains/uamdomainfile_cloud4wi
--- upstream/conf/profiles/uamdomains/uamdomainfile_cloud4wi	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_cloud4wi	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,5 @@
+cloud4wi.com
+facebook.com
+facebook.net
+flinkedin.com
+licdn.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_hs src/conf/profiles/uamdomains/uamdomainfile_hs
--- upstream/conf/profiles/uamdomains/uamdomainfile_hs	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_hs	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,2 @@
+hotspotsystem.com
+facebook.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/profiles/uamdomains/uamdomainfile_purple src/conf/profiles/uamdomains/uamdomainfile_purple
--- upstream/conf/profiles/uamdomains/uamdomainfile_purple	1970-01-01 00:00:00.000000000 +0000
+++ src/conf/profiles/uamdomains/uamdomainfile_purple	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,5 @@
+purpleportal.net
+venuewifi.com
+cloudfront.net
+openweathermap.org
+stripe.com
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/conf/up.sh.in src/conf/up.sh.in
--- upstream/conf/up.sh.in	2016-12-15 17:28:43.000000000 +0000
+++ src/conf/up.sh.in	2025-11-06 13:20:13.000000000 +0000
@@ -1,7 +1,10 @@
 #!/bin/sh
 
 TUNTAP=$(basename $DEV)
+RT_TABLES_FILE="/etc/iproute2/rt_tables"
+
 UNDO_FILE=@VARRUN@/chilli.$TUNTAP.sh
+RT_TABLES_LOCK_FILE=@VARRUN@/rt_tables.lock
 
 . @SYSCONFDIR@/chilli/functions
 
@@ -9,98 +12,125 @@
 rm -f $UNDO_FILE 2>/dev/null
 
 ipt() {
-    opt=$1; shift
-    echo "iptables -D $*" >> $UNDO_FILE
-    iptables $opt $*
+	opt=$1; shift
+	echo "iptables --wait -D $*" >> $UNDO_FILE
+	iptables --wait $opt $*
+}
+
+add_routing_table() {
+	local table_num="$1"
+	local interface="$2"
+	local entry="${table_num} ${interface}"
+
+	lock -w "$RT_TABLES_LOCK_FILE"
+
+	grep -q " ${interface}$" "$RT_TABLES_FILE" && {
+		sed -i "s/^.* ${interface}$/${entry}/" "$RT_TABLES_FILE"
+	} || {
+		echo "$entry" >>"$RT_TABLES_FILE"
+	}
+
+	lock -u "$RT_TABLES_LOCK_FILE"
+}
+
+add_nat_rule() {
+	local has_dhcp="$(jsonfilter -i /etc/board.json -e '@.network.dhcp.proto')"
+	[ "$has_dhcp" = "dhcp" ] || return
+
+	ipt -I POSTROUTING -t nat -s $ADDR/$MASK -j MASQUERADE
+	ipt -I POSTROUTING -t nat -s $DHCPLISTEN/$MASK -j MASQUERADE
 }
 
-ipt_in() {
-    ipt -I INPUT -i $TUNTAP $*
+chain_exists() {
+	local timeout=5
+	local elapsed=0
+	local sleep_interval=1
+	local chain_name="$1"
+
+	while [ $elapsed -lt $timeout ]; do
+		if iptables -w $timeout -L $chain_name -n &>/dev/null; then
+			return 0
+		fi
+		sleep $sleep_interval
+		elapsed=$((elapsed + sleep_interval))
+	done
+
+	return 1
 }
 
-run_up() {
-    if [ -n "$TUNTAP" ]
-    then
-        # ifconfig $TUNTAP mtu $MTU
+if [ -n "$TUNTAP" ]
+then
 	if [ "$KNAME" != "" ]
 	then
-	    ipt -I FORWARD -i $DHCPIF -m coova --name $KNAME -j ACCEPT 
-	    ipt -I FORWARD -o $DHCPIF -m coova --name $KNAME --dest -j ACCEPT
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    [ -n "$DHCPLISTEN" ] && ifconfig $DHCPIF $DHCPLISTEN
-	else
-	    if [ "$LAYER3" != "1" ]
-	    then
-		ipt_in --dst $ADDR -j DROP
-		
-		[ -n "$UAMPORT" -a "$UAMPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$UAMUIPORT" -a "$UAMUIPORT" != "0" ] && \
-		    ipt_in -p tcp -m tcp --dport $UAMUIPORT --dst $ADDR -j ACCEPT
-		
-		[ -n "$HS_TCP_PORTS" ] && {
-		    for port in $HS_TCP_PORTS; do
-			ipt_in -p tcp -m tcp --dport $port --dst $ADDR -j ACCEPT
-		    done
+		interfaces=$DHCPIF
+		[ -n "$MOREIF" ] && {
+			for iface in $MOREIF; do
+				interfaces="$interfaces $iface"
+			done
+		}
+
+		chain_exists zone_hotspot_input && {
+			ipt -I input_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j zone_hotspot_input
+			ipt -I input_rule -d $DHCPLISTEN/$MASK -m coova --name $KNAME --dest -j ACCEPT
+		} || {
+			[ -n "$UAMPORT" ] && ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport $UAMPORT -m coova --name $KNAME -j ACCEPT
+			[ -n "$UAMUIPORT" ] && ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport $UAMUIPORT -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport 81 -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p tcp -m tcp --dport 444 -m coova --name $KNAME -j ACCEPT
+			ipt -I input_rule -d $ADDR/$MASK -p udp -m udp --dport 53 -m coova --name $KNAME -j ACCEPT
 		}
 
-		[ -n "$HS_UDP_PORTS" ] && {
-		    for port in $HS_UDP_PORTS; do
-			ipt_in -p udp -m udp --dport $port --dst $ADDR -j ACCEPT
-		    done
+		chain_exists zone_hotspot_forward && \
+			ipt -I forwarding_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j zone_hotspot_forward || \
+			ipt -I forwarding_rule -s $DHCPLISTEN/$MASK -m coova --name $KNAME -j ACCEPT
+		ipt -I forwarding_rule -d $DHCPLISTEN/$MASK -m coova --name $KNAME --dest -j ACCEPT
+
+		ipt -I forwarding_rule -s $ADDR/$MASK -j ACCEPT
+		ipt -I forwarding_rule -d $ADDR/$MASK -j ACCEPT
+
+		add_nat_rule
+
+		index=100
+		for iface in $interfaces; do
+			ipt -A PREROUTING -t nat -i $iface -p udp --dport 53 -j DNAT --to-destination $ADDR
+			ipt -A input_rule -i $iface -j DROP
+			ipt -A input_rule -o $iface -j DROP
+
+			ipt -A forwarding_rule -i $iface -j DROP
+			ipt -A forwarding_rule -o $iface -j DROP
+
+			ip addr flush dev $iface
+			ip addr replace $DHCPLISTEN/$MASK broadcast + dev $iface
+			ip link set $iface up
+
+			[ -n "$MOREIF" ] && add_routing_table "$index" "$iface"
+			index=$((index + 1))
+		done
+	else
+		IFS=' '
+		IFS=$' \t\n'
+
+		[ "$HS_LOCAL_DNS" = "on" ] && {
+			ipt -A PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 		}
 
-		ipt_in -p udp -d 255.255.255.255 --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp -d $ADDR --destination-port 67:68 -j ACCEPT
-		ipt_in -p udp --dst $ADDR --dport 53 -j ACCEPT
-		ipt_in -p icmp --dst $ADDR -j ACCEPT
-		
+		ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+		ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
+
 		if [ "$ONLY8021Q" != "1" ]
 		then
-		    ipt -I INPUT -i $DHCPIF -j DROP
+			ipt -I FORWARD -o $DHCPIF -j DROP
+			ipt -A forwarding_rule -i $DHCPIF -j DROP
+		fi
+		if [ "$LAYER3" != "1" ]
+		then
+			if [ "$ONLY8021Q" != "1" ]
+			then
+				ipt -I INPUT -i $DHCPIF -j DROP
+			fi
 		fi
-	    fi
-	    
-	    if [ "$ONLY8021Q" != "1" ]
-	    then
-		ipt -I FORWARD -i $DHCPIF -j DROP
-		ipt -I FORWARD -o $DHCPIF -j DROP
-	    fi
-	    
-	    ipt -I FORWARD -i $TUNTAP -j ACCEPT
-	    ipt -I FORWARD -o $TUNTAP -j ACCEPT
-	    
-            # Help out conntrack to not get confused
-            # (stops masquerading from working)
-            #ipt -I PREROUTING -t raw -j NOTRACK -i $DHCPIF
-            #ipt -I OUTPUT -t raw -j NOTRACK -o $DHCPIF
-	    
-            # Help out MTU issues with PPPoE or Mesh
-	    ipt -I FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    ipt -I FORWARD -t mangle -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
-	    
-	    [ "$HS_LAN_ACCESS" != "on" -a "$HS_LAN_ACCESS" != "allow" ] && \
-		ipt -I FORWARD -i $TUNTAP \! -o $HS_WANIF -j DROP
-	    
-	    ipt -I FORWARD -i $TUNTAP -o $HS_WANIF -j ACCEPT
-	    
-	    [ "$HS_LOCAL_DNS" = "on" ] && \
-		ipt -I PREROUTING -t nat -i $TUNTAP -p udp --dport 53 -j DNAT --to-destination $ADDR
 	fi
-    fi
-
-    # site specific stuff optional
-    [ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
-}
-
-
-FLOCK=$(which flock)
-if [ -n "$FLOCK" ] && [ -z "$LOCKED_FILE" ]
-then
-    export LOCKED_FILE=/tmp/.chilli-flock
-    flock -x $LOCKED_FILE -c "$0 $@"
-else
-    run_up
 fi
+
+# site specific stuff optional
+[ -e @ETCCHILLI@/ipup.sh ] && . @ETCCHILLI@/ipup.sh
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/configure.ac src/configure.ac
--- upstream/configure.ac	2016-12-15 17:28:43.000000000 +0000
+++ src/configure.ac	2025-11-06 13:20:13.000000000 +0000
@@ -154,8 +154,17 @@
    AC_DEFINE(ENABLE_CHILLIQUERY,1,[Define to enable chilli_query])
 fi
 
+AC_ARG_ENABLE(ubus, [AS_HELP_STRING([--disable-ubus],[Disable ubus])],
+  enable_ubus=$enableval, enable_ubus=yes)
+
+if test x"$enable_ubus" = xyes; then
+   AC_DEFINE(ENABLE_UBUS,1,[Define to enable ubus])
+fi
+
 AM_CONDITIONAL(WITH_CHILLIQUERY, [test x"$enable_chilliquery" != xno])
 
+AM_CONDITIONAL(WITH_UBUS, [test x"$enable_ubus" != xno])
+
 AC_ARG_ENABLE(leakybucket, [AS_HELP_STRING([--disable-leakybucket],[disable use of leaky bucket shaping])], 
   enable_leakybucket=$enableval, enable_leakybucket=yes)
 
@@ -206,7 +215,7 @@
 fi
 
 AC_ARG_ENABLE(json, [AS_HELP_STRING([--enable-json],[Enable support for JSON])], 
-  enable_json=$enableval, enable_json=no)
+  enable_json=$enableval, enable_json=yes)
 
 if test x"$enable_json" = xyes; then
    AC_DEFINE(ENABLE_JSON,1,[Define to enable Chilli JSON])
@@ -396,6 +405,9 @@
 AC_ARG_WITH([cyassl],
  [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
 
+AC_ARG_WITH([cyassl],
+ [AS_HELP_STRING([--with-cyassl], [enable support for cyassl])],[],[with_cyassl=no])
+
 AS_IF([test x"$with_cyassl" != xno],
   [AC_CHECK_LIB([cyassl], [CyaSSL_Init],
               [AC_SUBST([LIBSSL], ["-lcyassl"])
@@ -511,13 +523,13 @@
 
 AS_IF([test x"$with_curl" != xno],
   [AC_CHECK_LIB([curl], [curl_global_init],
-              [AC_SUBST([LIBCURL], ["-lcurl -lz -lssl -lcrypto -lcares"])
+              [AC_SUBST([LIBCURL], ["-lcurl -lz -lssl -lcrypto"])
                AC_DEFINE([USING_CURL], [1],
                          [Define if you have curl enabled])
               ],
               [AC_MSG_FAILURE(
                  [--with-curl was given, but test for curl failed])],
-              [-lz -lssl -lcrypto -lcares])])
+              [-lz -lssl -lcrypto])])
 
 AM_CONDITIONAL(WITH_CURL, [test x"$with_curl" != xno])
 
@@ -598,6 +610,24 @@
 
 AM_CONDITIONAL(WITH_CHILLIREDIR, [test x"$enable_chilliredir" = xyes])
 
+AC_ARG_ENABLE(database, [AS_HELP_STRING([--enable-database],[Enable support sqlite database])],
+  enable_database=$enableval, enable_database=no)
+
+if test x"$enable_database" = xyes; then
+   AC_DEFINE(ENABLE_DATABASE,1,[Define to enable sqlite database])
+fi
+
+AM_CONDITIONAL(WITH_DATABASE, [test x"$enable_database" = xyes])
+
+AC_ARG_ENABLE(gsm, [AS_HELP_STRING([--enable-gsm],[Enable gsm support])],
+  enable_gsm=$enableval, enable_gsm=no)
+
+if test x"$enable_gsm" = xyes; then
+   AC_DEFINE(ENABLE_GSM,1,[Define to enable gsm support])
+fi
+
+AM_CONDITIONAL(WITH_GSM, [test x"$enable_gsm" = xyes])
+
 AC_ARG_ENABLE(chilliscript, [AS_HELP_STRING([--enable-chilliscript],[Enable support for chilli_script helper])], 
   enable_chilliscript=$enableval, enable_chilliscript=no)
 
@@ -830,7 +860,7 @@
 AM_CONDITIONAL(WITH_CONFIG, [test x"$enable_config" = xyes])
 
 AC_SUBST(sysconfdir)
-AC_CONFIG_FILES([Makefile 
+AC_CONFIG_FILES([Makefile
 		 bstring/Makefile 
 		 conf/Makefile
 		 debian/Makefile
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/Makefile.am src/doc/Makefile.am
--- upstream/doc/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -10,7 +10,7 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(sysconfdir)/init.d,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/attributes src/doc/attributes
--- upstream/doc/attributes	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/attributes	2025-11-06 13:20:13.000000000 +0000
@@ -8,7 +8,7 @@
 Service-Type      :     6 : Integer : X : - : X : - : - : Set to Login (1) for normal authentication requests.  The Access-Accept message from the radius server for configuration management messages must also be set to Administrative-User.
 Framed-IP-Address : 	8 : IPaddr  : X : X : X : - : - : IP address of the user, which is configurable during MAC authentication in the Access-Accept.
 Framed-IP-Netmask : 	9 : IPaddr  : - : X : - : - : - : IP netmask of the user, which is configurable during MAC authentication in the Access-Accept.
-Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly. 
+Filter-ID         :    11 : String  : - : X : - : X : X : Filter ID pass on to scripts possibly.
 Reply-Message     :    18 : String  : - : X : - : - : - : Reason of reject if present.
 State             :    24 : String  : X : X : - : - : - : Sent to chilli in Access-Accept or Access-Challenge. Used transparently in subsequent Access-Request.
 Class             :    25 : String  : - : X : X : - : - : Copied transparently by chilli from Access-Accept to Accounting-Request.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/chilli.conf.5.in src/doc/chilli.conf.5.in
--- upstream/doc/chilli.conf.5.in	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/chilli.conf.5.in	2025-11-06 13:20:13.000000000 +0000
@@ -889,11 +889,6 @@
 .RE
 
 .TP
-.BI localusers " file"
-A colon seperated file containing usernames and passwords of locally
-authenticated users. 
-
-.TP
 .BI postauthproxy " ipaddress"
 Used with
 .B postauthproxyport
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/chilli_query.1.in src/doc/chilli_query.1.in
--- upstream/doc/chilli_query.1.in	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/chilli_query.1.in	2025-11-06 13:20:13.000000000 +0000
@@ -115,6 +115,10 @@
 Sets the max output data limit of the session.
 
 .TP
+.BI warningoctets " <number-of-bytes>"
+Sets the data threshold for the session over which an SMS warning is sent.
+
+.TP
 .BI maxbwup " <bandwidth>"
 Sets the max up bandwidth of the session.
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/dictionary.coovachilli src/doc/dictionary.coovachilli
--- upstream/doc/dictionary.coovachilli	2016-12-15 17:28:43.000000000 +0000
+++ src/doc/dictionary.coovachilli	2025-11-06 13:20:13.000000000 +0000
@@ -54,6 +54,7 @@
 ATTRIBUTE	CoovaChilli-Location		       25	string
 ATTRIBUTE	CoovaChilli-Old-Location		       26	string
 ATTRIBUTE	CoovaChilli-Location-Change-Count       27	integer
+ATTRIBUTE	CoovaChilli-SSID       28	string
 
 ATTRIBUTE	CoovaChilli-Sys-Uptime		       40	integer
 ATTRIBUTE	CoovaChilli-Sys-LoadAvg		       41	string
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/json/debug.c src/json/debug.c
--- upstream/json/debug.c	2016-12-15 17:28:43.000000000 +0000
+++ src/json/debug.c	2025-11-06 13:20:13.000000000 +0000
@@ -16,10 +16,6 @@
 #include <string.h>
 #include <stdarg.h>
 
-#if HAVE_SYSLOG_H
-# include <syslog.h>
-#endif /* HAVE_SYSLOG_H */
-
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif /* HAVE_UNISTD_H */
@@ -30,15 +26,15 @@
 
 #include "debug.h"
 
-static int _syslog = 0;
+static int _chilli_log = 0;
 static int _debug = 0;
 
 void mc_set_debug(int debug) { _debug = debug; }
 int mc_get_debug(void) { return _debug; }
 
-extern void mc_set_syslog(int syslog)
+extern void mc_set_chilli_log(int chilli_log)
 {
-  _syslog = syslog;
+  _chilli_log = chilli_log;
 }
 
 void mc_debug(const char *msg, ...)
@@ -47,8 +43,8 @@
   if(_debug) {
     va_start(ap, msg);
 #if HAVE_VSYSLOG
-    if(_syslog) {
-		vsyslog(LOG_DEBUG, msg, ap);
+    if(_chilli_log) {
+		_log_v(LOG_DEBUG, msg, ap);
 	} else
 #endif
 		vprintf(msg, ap);
@@ -61,8 +57,8 @@
   va_list ap;
   va_start(ap, msg);
 #if HAVE_VSYSLOG
-    if(_syslog) {
-		vsyslog(LOG_ERR, msg, ap);
+    if(_chilli_log) {
+		_log(LOG_ERR, msg, ap);
 	} else
 #endif
 		vfprintf(stderr, msg, ap);
@@ -74,8 +70,8 @@
   va_list ap;
   va_start(ap, msg);
 #if HAVE_VSYSLOG
-    if(_syslog) {
-		vsyslog(LOG_INFO, msg, ap);
+    if(_chilli_log) {
+		_log(LOG_INFO, msg, ap);
 	} else
 #endif
 		vfprintf(stderr, msg, ap);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/json/linkhash.c src/json/linkhash.c
--- upstream/json/linkhash.c	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.c	2025-11-06 13:20:13.000000000 +0000
@@ -52,15 +52,6 @@
 	return 0;
 }
 
-void lh_abort(const char *msg, ...)
-{
-	va_list ap;
-	va_start(ap, msg);
-	vprintf(msg, ap);
-	va_end(ap);
-	exit(1);
-}
-
 static unsigned long lh_ptr_hash(const void *k)
 {
 	/* CAW: refactored to be 64bit nice */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/json/linkhash.h src/json/linkhash.h
--- upstream/json/linkhash.h	2016-12-15 17:28:43.000000000 +0000
+++ src/json/linkhash.h	2025-11-06 13:20:13.000000000 +0000
@@ -294,21 +294,6 @@
 extern int lh_table_length(struct lh_table *t);
 
 /**
- * Prints a message to <code>stdout</code>,
- * then exits the program with an exit code of <code>1</code>.
- *
- * @param msg Message format string, like for <code>printf</code>.
- * @param ... Format args.
- *
- * @deprecated Since it is not a good idea to exit the entire program
- * 	because of an internal library failure, json-c will no longer
- * 	use this function internally.
- * 	However, because its interface is public, it will remain part of
- * 	the API on the off chance of legacy software using it externally.
- */
-void lh_abort(const char *msg, ...);
-
-/**
  * Resizes the specified table.
  *
  * @param t Pointer to table to resize.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/miniportal/Makefile.am src/miniportal/Makefile.am
--- upstream/miniportal/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/miniportal/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -27,8 +27,8 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(initrddir),g' \
-	-e 's,@VARTMP\@,$(localstatedir)/tmp,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARTMP\@,$(localstatedir),g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/Makefile.am src/src/Makefile.am
--- upstream/src/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/src/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -12,34 +12,35 @@
 tun.h ippool.h md5.h redir.h dhcp.h iphash.h \
 radius_wispr.h radius_coovachilli.h ssl.h dns.h net.h \
 pkt.h conn.h lookup.h chilli_limits.h cmdline.h debug.h \
-radius_pkt.h ../bstring/bstrlib.h ../config.h system.h 
+radius_pkt.h ../bstring/bstrlib.h ../config.h system.h \
+ sqlite.h users.h
 
 lib_LTLIBRARIES = libchilli.la
 sbin_PROGRAMS = \
-chilli chilli_response chilli_radconfig chilli_opt 
+chilli chilli_response chilli_radconfig chilli_opt
 
 suid_programs =
 
 libchilli_la_SOURCES = \
 chilli.c tun.c ippool.c radius.c md5.c redir.c dhcp.c \
 iphash.c lookup.c system.h util.c options.c statusfile.c conn.c sig.c \
-garden.c dns.c session.c pkt.c chksum.c net.c safe.c
+garden.c dns.c session.c pkt.c chksum.c net.c safe.c sqlite.c users.c
 
 AM_CFLAGS = -D_GNU_SOURCE -Wall -Werror -fno-builtin -fno-strict-aliasing \
   -fomit-frame-pointer -funroll-loops -pipe -I$(top_builddir)/bstring \
  -DDEFCHILLICONF='"$(sysconfdir)/chilli.conf"'\
- -DDEFPIDFILE='"$(localstatedir)/run/chilli.pid"'\
- -DDEFSTATEDIR='"$(localstatedir)/run"'\
- -DSBINDIR='"$(sbindir)"' 
+ -DDEFPIDFILE='"$(localstatedir)/chilli.pid"'\
+ -DDEFSTATEDIR='"$(localstatedir)"'\
+ -DSBINDIR='"$(sbindir)"'
 
 chilli_SOURCES= main.c
-chilli_radconfig_SOURCES = main-radconfig.c 
-chilli_response_SOURCES = main-response.c 
-chilli_query_SOURCES = main-query.c 
-chilli_opt_SOURCES = main-opt.c 
+chilli_radconfig_SOURCES = main-radconfig.c
+chilli_response_SOURCES = main-response.c
+chilli_query_SOURCES = main-query.c
+chilli_opt_SOURCES = main-opt.c
 
-libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la 
-LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON}
+libchilli_la_LIBADD = $(top_builddir)/bstring/libbstring.la -lsqlite3 -luci -ltlt_uci -lcap -ltlt_logger
+LDADD = libchilli.la ${LIBRT} $(top_builddir)/bstring/libbstring.la ${LIBJSON} -lsqlite3 -lcap -ltlt_logger
 
 if WITH_MINICONFIG
 chilli_opt_SOURCES += cmdline.mini.c
@@ -54,7 +55,7 @@
 if WITH_JSONLIB
 AM_CFLAGS += -I$(top_builddir)/json
 libchilli_la_LIBADD += $(top_builddir)/json/libjson.la 
-LDADD += $(top_builddir)/json/libjson.la 
+LDADD += $(top_builddir)/json/libjson.la
 endif
 
 if WITH_EWTAPI
@@ -75,6 +76,8 @@
 endif
 
 if WITH_OPENSSL
+libchilli_la_SOURCES += passwd_md5crypt.c passwd_shacrypt.c
+chilliinclude_HEADERS += passwd_md5crypt.h passwd_shacrypt.h
 libchilli_la_LIBADD += ${LIBSSL}
 LDADD += ${LIBSSL}
 endif
@@ -93,6 +96,31 @@
 endif
 endif
 
+if WITH_GSM
+libchilli_la_SOURCES += gsm.c
+chilliinclude_HEADERS += gsm.h
+libchilli_la_LIBADD += -lgsm -lgsm_utils
+LDADD += -lgsm
+endif
+
+if WITH_DATABASE
+libchilli_la_SOURCES += database.c
+chilliinclude_HEADERS += database.h
+endif
+
+if WITH_CURL
+libchilli_la_SOURCES += oauth2.c
+chilliinclude_HEADERS += oauth2.h
+LDADD += ${LIBCURL} 
+endif
+
+if WITH_UBUS
+chilliinclude_HEADERS += ubus.h
+libchilli_la_SOURCES += ubus.c
+libchilli_la_LIBADD += -lubox -lubus
+LDADD += -lubox -lubus
+endif
+
 if WITH_AVL
 libchilli_la_SOURCES += avl/avl.c avl/avl.h avl/list.h \
 avl/common_types.h avl/container_of.h
@@ -131,9 +159,6 @@
 sbin_PROGRAMS += chilli_proxy
 chilli_proxy_SOURCES = main-proxy.c 
 chilli_proxy_LDADD = ${LDADD}
-if WITH_CURL
-chilli_proxy_LDADD += ${LIBCURL} 
-endif
 endif
 
 if WITH_CHILLIRADSEC
@@ -153,9 +178,6 @@
 sbin_PROGRAMS += chilli_redir
 chilli_redir_SOURCES = main-redir.c 
 chilli_redir_LDADD = ${LDADD}
-if WITH_CURL
-chilli_redir_LDADD += ${LIBCURL} 
-endif
 endif
 
 if WITH_NETFILTER_COOVA
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli.c src/src/chilli.c
--- upstream/src/chilli.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.c	2025-11-06 13:20:13.000000000 +0000
@@ -20,10 +20,13 @@
 
 #include "chilli.h"
 #include "bstrlib.h"
+#include "ubus.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
 #endif
 
+
+
 struct tun_t *tun;                /* TUN instance            */
 struct ippool_t *ippool;          /* Pool of IP addresses */
 struct radius_t *radius;          /* Radius client instance */
@@ -42,6 +45,9 @@
 struct app_conn_t *lastusedconn=0;  /* Last used in linked list */
 struct app_conn_t admin_session;
 
+struct ubus_context *g_ubus_event_ctx; /* Ubus for sending events
+                                          about connected/disconnected clients */
+
 struct timespec mainclock;
 time_t checktime;
 time_t rereadtime;
@@ -80,6 +86,8 @@
 static pid_t redir_pid = 0;
 #endif
 
+
+
 typedef struct child {
   pid_t pid;
   uint8_t type;
@@ -135,7 +143,7 @@
       list->next = node->next;
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Freed child process %d [%s]", __FUNCTION__, __LINE__, node->pid, node->name);
+        chilli_log(LOG_DEBUG, "%s(%d): Freed child process %d [%s]", __FUNCTION__, __LINE__, node->pid, node->name);
 #endif
       free(node);
       return 0;
@@ -151,7 +159,7 @@
 
   if (p < 0) {
 
-    syslog(LOG_ERR, "%s: fork failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fork failed", strerror(errno));
 
   } else if (p == 0) {
 
@@ -167,7 +175,7 @@
     newargs[i++] = NULL;
 
     if (execv(path, newargs) != 0) {
-      syslog(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
       exit(0);
     }
 
@@ -214,7 +222,7 @@
   while ((read = getline(&line, &len, fp)) != -1) {
     if (!memcmp(line, name, strlen(name))) {
       int i;
-      if (sscanf(line+strlen(name)+1, "%d %s", &i, buffer) == 2) {
+      if (sscanf(line+strlen(name)+1, "%d %128s", &i, buffer) == 2) {
 	ret = i;
 	if (buffer[0] == 'm') ret *= 1000;
 	else if (buffer[0] == 'g') ret *= 1000000;
@@ -283,7 +291,7 @@
   while (node) {
     kill(node->pid, sig);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): pid %d killed %d", __FUNCTION__, __LINE__, getpid(), node->pid);
+      chilli_log(LOG_DEBUG, "%s(%d): pid %d killed %d", __FUNCTION__, __LINE__, getpid(), node->pid);
     node = node->next;
   }
 }
@@ -313,23 +321,23 @@
   while ((pid = waitpid(-1, &stat, WNOHANG)) > 0) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): child %d terminated", __FUNCTION__, __LINE__, pid);
+      chilli_log(LOG_DEBUG, "%s(%d): child %d terminated", __FUNCTION__, __LINE__, pid);
 #endif
 #ifdef ENABLE_CHILLIRADSEC
     if (!_options.debug && radsec_pid > 0 && radsec_pid == pid) {
-      syslog(LOG_ERR, "Having to re-launch chilli_radsec... PID %d exited", pid);
+      chilli_log(LOG_ERR, "Having to re-launch chilli_radsec... PID %d exited", pid);
       launch_chilliradsec();
     }
 #endif
 #ifdef ENABLE_CHILLIPROXY
     if (!_options.debug && proxy_pid > 0 && proxy_pid == pid) {
-      syslog(LOG_ERR, "Having to re-launch chilli_proxy... PID %d exited", pid);
+      chilli_log(LOG_ERR, "Having to re-launch chilli_proxy... PID %d exited", pid);
       launch_chilliproxy();
     }
 #endif
 #ifdef ENABLE_CHILLIREDIR
     if (!_options.debug && redir_pid > 0 && redir_pid == pid) {
-      syslog(LOG_ERR, "Having to re-launch chilli_redir... PID %d exited", pid);
+      chilli_log(LOG_ERR, "Having to re-launch chilli_redir... PID %d exited", pid);
       launch_chilliredir();
     }
 #endif
@@ -339,19 +347,19 @@
 }
 
 static void _sigterm(int signum) {
-  syslog(LOG_DEBUG, "%s(%d): SIGTERM: shutdown", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): SIGTERM: shutdown", __FUNCTION__, __LINE__);
   if (p_keep_going)
     *p_keep_going = 0;
 }
 
 static void _sigvoid(int signum) {
 #if(_debug_)
-  syslog(LOG_DEBUG, "%s(%d): received %d signal", __FUNCTION__, __LINE__, signum);
+  chilli_log(LOG_DEBUG, "%s(%d): received %d signal", __FUNCTION__, __LINE__, signum);
 #endif
 }
 
 static void _sigusr1(int signum) {
-  syslog(LOG_DEBUG, "%s(%d): SIGUSR1: reloading configuration", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): SIGUSR1: reloading configuration", __FUNCTION__, __LINE__);
 
   if (p_reload_config)
     *p_reload_config = 1;
@@ -374,7 +382,7 @@
 }
 
 static void _sighup(int signum) {
-  syslog(LOG_DEBUG, "%s(%d): SIGHUP: rereading configuration", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): SIGHUP: rereading configuration", __FUNCTION__, __LINE__);
 
   do_interval = 1;
 }
@@ -383,7 +391,7 @@
   int signo = selfpipe_read();
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): caught %d via selfpipe", __FUNCTION__, __LINE__,  signo);
+    chilli_log(LOG_DEBUG, "%s(%d): caught %d via selfpipe", __FUNCTION__, __LINE__,  signo);
 #endif
   switch (signo) {
     case SIGCHLD: _sigchld(signo); break;
@@ -463,7 +471,7 @@
 #ifdef HAVE_LIBRT
   struct timespec ts;
 #if defined(CLOCK_MONOTONIC)
-  clockid_t cid = CLOCK_MONOTONIC;
+  clockid_t cid = _options.testtime ? CLOCK_REALTIME : CLOCK_MONOTONIC;
 #else
   clockid_t cid = CLOCK_REALTIME;
 #endif
@@ -473,7 +481,7 @@
     res = clock_gettime(cid, &ts);
   }
   if (res == -1) {
-    syslog(LOG_ERR, "%s: clock_gettime()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: clock_gettime()", strerror(errno));
     /* drop through to old time() */
   } else {
     mainclock.tv_sec = ts.tv_sec;
@@ -482,7 +490,7 @@
   }
 #endif
   if (time(&mainclock.tv_sec) == (time_t)-1) {
-    syslog(LOG_ERR, "%s: time()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: time()", strerror(errno));
   }
   return mainclock.tv_sec;
 }
@@ -497,7 +505,7 @@
   struct timespec ts;
   clockid_t cid = CLOCK_REALTIME;
   if (clock_gettime(cid, &ts) < 0) {
-    syslog(LOG_ERR, "%s: clock_gettime()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: clock_gettime()", strerror(errno));
     /* drop through to old time() */
   } else {
     rt = ts.tv_sec;
@@ -505,7 +513,7 @@
   }
 #endif
   if (time(&rt) == (time_t)-1) {
-    syslog(LOG_ERR, "%s: time()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: time()", strerror(errno));
   }
   return rt;
 }
@@ -547,13 +555,31 @@
   return d;
 }
 
+const char *get_mac_format() {
+  if (_options.maclower) {
+    switch (_options.macdelimiter) {
+      case MAC_DELIM_DASH: return MAC_FMT_LOWER_DASH;
+      case MAC_DELIM_COLON: return MAC_FMT_LOWER_COLON;
+      case MAC_DELIM_NONE: return MAC_FMT_LOWER_NONE;
+    }
+    return MAC_FMT_LOWER_DASH;
+  }
+
+  switch (_options.macdelimiter) {
+    case MAC_DELIM_DASH: return MAC_FMT_UPPER_DASH;
+    case MAC_DELIM_COLON: return MAC_FMT_UPPER_COLON;
+    case MAC_DELIM_NONE: return MAC_FMT_UPPER_NONE;
+  }
+  return MAC_FMT_UPPER_DASH;
+}
+
 uint8_t* chilli_called_station(struct session_state *state) {
 #ifdef ENABLE_LOCATION
   if (_options.location_copy_called && state->redir.calledlen) {
     return state->redir.called;
   }
 #endif
-  return dhcp_nexthop(dhcp);
+  return dhcp_nexthop(dhcp, 0);
 }
 
 static void set_sessionid(struct app_conn_t *appconn, char full) {
@@ -569,7 +595,7 @@
 #ifdef ENABLE_SESSIONID
   if (full) {
     uint8_t * his = appconn->hismac;
-    uint8_t * called = dhcp_nexthop(dhcp);
+    uint8_t * called = dhcp_nexthop(dhcp, 0);
     snprintf(appconn->s_state.chilli_sessionid,
 		  sizeof(appconn->s_state.chilli_sessionid),
 		  "SES-"
@@ -663,7 +689,7 @@
     if ((conn->s_state.bucketup + octetsup) >
 	conn->s_state.bucketupsize) {
       if (_options.debug)
-	syslog(LOG_DEBUG, "%s(%d): Leaky bucket dropping upload overflow from "MAC_FMT, __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): Leaky bucket dropping upload overflow from "MAC_FMT, __FUNCTION__, __LINE__,
                MAC_ARG(conn->hismac));
       result = -1;
     }
@@ -689,7 +715,7 @@
     if ((conn->s_state.bucketdown + octetsdown) >
 	conn->s_state.bucketdownsize) {
       if (_options.debug)
-	syslog(LOG_DEBUG, "%s(%d): Leaky bucket dropping download overflow to "MAC_FMT, __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): Leaky bucket dropping download overflow to "MAC_FMT, __FUNCTION__, __LINE__,
                MAC_ARG(conn->hismac));
       result = -1;
     }
@@ -702,7 +728,7 @@
   if (_options.debug &&
       (conn->s_params.bandwidthmaxup || conn->s_params.bandwidthmaxdown))
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Leaky bucket: bucketup: %lld/%lld, " __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Leaky bucket: bucketup: %lld/%lld, " __FUNCTION__, __LINE__,
              "bucketdown: %lld/%lld, up: %lld/(%lld), down: %lld/(%lld)",
              conn->s_state.bucketup, conn->s_state.bucketupsize,
              conn->s_state.bucketdown, conn->s_state.bucketdownsize,
@@ -738,17 +764,17 @@
       break;
 
     case VAL_ULONG:
-      snprintf(s, sizeof(s), "%ld", (long int)*(uint32_t *)value);
+      snprintf(s, sizeof(s), "%" PRIu32, *(uint32_t *)value);
       v = s;
       break;
 
     case VAL_ULONG64:
-      snprintf(s, sizeof(s), "%ld", (long int)*(uint64_t *)value);
+      snprintf(s, sizeof(s), "%" PRIu64, *(uint64_t *)value);
       v = s;
       break;
 
     case VAL_USHORT:
-      snprintf(s, sizeof(s), "%d", (int)(*(uint16_t *)value));
+      snprintf(s, sizeof(s), "%" PRIu16, *(uint16_t *)value);
       v = s;
       break;
 
@@ -767,18 +793,55 @@
 
   if (name != NULL && v != NULL) {
     if (setenv(name, v, 1) != 0) {
-      syslog(LOG_ERR, "%s: setenv(%s, %s, 1) did not return 0!", strerror(errno), name, v);
+      chilli_log(LOG_ERR, "%s: setenv(%s, %s, 1) did not return 0!", strerror(errno), name, v);
     }
   }
 }
 
+#ifdef ENABLE_MULTILAN
+void set_moreif_env() {
+  size_t moreif_len = 256;
+  char *moreif = calloc(moreif_len, sizeof(char));
+  if (!moreif)
+    return;
+
+  moreif[0] = '\0';
+  size_t current_len = 0;
+
+  for (int i = 0; i < MAX_MOREIF; i++) {
+    if(!_options.moreif[i].dhcpif)
+      continue;
+
+    size_t needed_len = strlen(moreif) + strlen(_options.moreif[i].dhcpif) + 2;
+    if (needed_len > moreif_len) {
+      moreif_len = needed_len + 256;
+      char *new_moreif = realloc(moreif, moreif_len * sizeof(char));
+      if (!new_moreif) {
+        free(moreif);
+        return;
+      }
+      moreif = new_moreif;
+    }
+
+    if (current_len > 0) {
+      current_len += snprintf(moreif + current_len, moreif_len - current_len, " ");
+    }
+
+    current_len += snprintf(moreif + current_len, moreif_len - current_len, "%s", _options.moreif[i].dhcpif);
+  }
+  set_env("MOREIF", VAL_STRING, moreif, 0);
+  free(moreif);
+}
+#endif
+
 int runscript(struct app_conn_t *appconn, char* script,
-	      char *loc, char *oloc) {
+	      char *loc, char *oloc, char *dhcp_assign) {
   int status;
   uint32_t sessiontime;
+  struct dhcp_conn_t* dhcpconn;
 
   if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
-    syslog(LOG_ERR, "%s: forking %s", strerror(errno), script);
+    chilli_log(LOG_ERR, "%s: forking %s", strerror(errno), script);
     return 0;
   }
 
@@ -790,6 +853,11 @@
   if (_options.layer3)
     set_env("LAYER3", VAL_STRING, "1", 0);
 #endif
+  set_env("DHCPIF", VAL_STRING, _options.dhcpif ? _options.dhcpif : "", 0);
+
+  if ((dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
+    set_env("IF", VAL_STRING, dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname, 0);
+  }
   set_env("DEV", VAL_STRING, tun(tun, 0).devname, 0);
   set_env("NET", VAL_IN_ADDR, &appconn->net, 0);
   set_env("MASK", VAL_IN_ADDR, &appconn->mask, 0);
@@ -812,12 +880,13 @@
   set_env("ACCT_INTERIM_INTERVAL", VAL_USHORT, &appconn->s_params.interim_interval, 0);
   set_env("WISPR_LOCATION_ID", VAL_STRING, _options.radiuslocationid, 0);
   set_env("WISPR_LOCATION_NAME", VAL_STRING, _options.radiuslocationname, 0);
-  set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG, &appconn->s_params.bandwidthmaxup, 0);
-  set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG, &appconn->s_params.bandwidthmaxdown, 0);
+  set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG64, &appconn->s_params.bandwidthmaxup, 0);
+  set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG64, &appconn->s_params.bandwidthmaxdown, 0);
   /*set_env("WISPR-SESSION_TERMINATE_TIME", VAL_USHORT, &appconn->sessionterminatetime, 0);*/
   set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxinputoctets, 0);
   set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_params.maxoutputoctets, 0);
   set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &appconn->s_params.maxtotaloctets, 0);
+  set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &appconn->s_params.warningoctets, 0);
   set_env("INPUT_OCTETS", VAL_ULONG64, &appconn->s_state.input_octets, 0);
   set_env("OUTPUT_OCTETS", VAL_ULONG64, &appconn->s_state.output_octets, 0);
   set_env("INPUT_PACKETS", VAL_ULONG64, &appconn->s_state.input_packets, 0);
@@ -826,6 +895,18 @@
   set_env("SESSION_TIME", VAL_ULONG, &sessiontime, 0);
   sessiontime = mainclock_diffu(appconn->s_state.last_up_time);
   set_env("IDLE_TIME", VAL_ULONG, &sessiontime, 0);
+  if (dhcp_assign != NULL) {
+    // indication of first dhcp request when IP is set for the client
+    set_env("DHCP_ASSIGN", VAL_STRING, dhcp_assign, 0);
+  }
+
+#ifdef HAVE_NETFILTER_COOVA
+  set_env("KNAME", VAL_STRING, _options.kname ? _options.kname : "", 0);
+#endif
+
+#ifdef ENABLE_MULTILAN
+  set_moreif_env();
+#endif
 
   if (loc) {
     set_env("LOCATION", VAL_STRING, loc, 0);
@@ -845,7 +926,7 @@
           script,
 #endif
           script, (char *) 0) != 0) {
-    syslog(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
+    chilli_log(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
   }
 
   exit(0);
@@ -873,11 +954,11 @@
 #endif
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): newip %s", __FUNCTION__, __LINE__,  inet_ntoa(*hisip));
+    chilli_log(LOG_DEBUG, "%s(%d): newip %s", __FUNCTION__, __LINE__,  inet_ntoa(*hisip));
 
   if (ippool_newip(ippool, ipm, hisip, 1)) {
     if (ippool_newip(ippool, ipm, hisip, 0)) {
-      syslog(LOG_ERR, "Failed to allocate either static or dynamic IP address");
+      chilli_log(LOG_ERR, "Failed to allocate either static or dynamic IP address");
       return -1;
     }
   }
@@ -901,14 +982,14 @@
   if (!firstfreeconn) {
 
     if (connections == _options.max_clients) {
-      syslog(LOG_ERR, "reached max connections %d!", _options.max_clients);
+      chilli_log(LOG_ERR, "reached max connections %d!", _options.max_clients);
       return -1;
     }
 
     n = ++connections;
 
     if (!(*conn = calloc(1, sizeof(struct app_conn_t)))) {
-      syslog(LOG_ERR, "Out of memory!");
+      chilli_log(LOG_ERR, "Out of memory!");
       connections--;
       return -1;
     }
@@ -1015,7 +1096,7 @@
   while (appconn) {
 
     if (!appconn->inuse) {
-      syslog(LOG_ERR, "Connection with inuse == 0!");
+      chilli_log(LOG_ERR, "Connection with inuse == 0!");
     }
 
     if (ip && appconn->hisip.s_addr == ip) {
@@ -1037,6 +1118,7 @@
 
 static int dnprot_terminate(struct app_conn_t *appconn) {
   appconn->s_state.authenticated = 0;
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
 #ifdef ENABLE_SESSIONSTATE
   appconn->s_state.session_state = 0;
 #endif
@@ -1079,13 +1161,31 @@
         break;
 #endif
       default:
-        syslog(LOG_ERR, "Unknown downlink protocol");
+        chilli_log(LOG_ERR, "Unknown downlink protocol");
         break;
     }
   return 0;
 }
 
+#ifdef ENABLE_GSM
+int send_warning_sms(uint64_t used, uint64_t warning, uint64_t limit, char *direction, char *phone)
+{
+	if (!limit || used < warning) {
+		// Only return 0 on successful SMS send.
+		return -1;
+	}
+
+	char sms_text[256] = { 0 };
+	float left	   = (used > limit) ? 0 : (float)(limit - used) / 1000000.f;
+
+	sprintf(sms_text, WARNING_FMT, direction, left, "MB");
+	chilli_log(LOG_INFO, "%s(%d): Sending SMS: %s\n", __FUNCTION__, __LINE__, sms_text);
 
+	chilli_send_sms_async(phone, sms_text, _options.modemid);
+
+	return 0;
+}
+#endif
 
 /* Check for:
  * - Session-Timeout
@@ -1104,12 +1204,50 @@
   interimtime = mainclock_diffu(conn->s_state.interim_time);
 
   if (conn->s_state.authenticated == 1) {
+#ifdef ENABLE_GSM
+#if(_debug_ > 1)
+	  if (conn->s_params.maxinputoctets > conn->s_state.input_octets)
+		  chilli_log(LOG_INFO, "warning_sent_download %d | download used %.1f left %.1f",
+			 conn->s_state.warning_sent_download, (float)conn->s_state.input_octets / 1000000.f,
+			 (float)(conn->s_params.maxinputoctets - conn->s_state.input_octets) / 1000000.f);
+	  if (conn->s_params.maxoutputoctets > conn->s_state.output_octets)
+		  chilli_log(LOG_INFO, "  warning_sent_upload %d |   upload used %.1f left %.1f",
+			 conn->s_state.warning_sent_upload, (float)conn->s_state.output_octets / 1000000.f,
+			 (float)(conn->s_params.maxoutputoctets - conn->s_state.output_octets) / 1000000.f);
+#endif
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_download &&
+	      !send_warning_sms(conn->s_state.input_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxinputoctets, "download", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_download = 1;
+	  }
+
+	  if (conn->s_params.warningoctets > 0 && !conn->s_state.warning_sent_upload &&
+	      !send_warning_sms(conn->s_state.output_octets, conn->s_params.warningoctets,
+				 conn->s_params.maxoutputoctets, "upload", conn->s_state.redir.phone)) {
+		  conn->s_state.warning_sent_upload = 1;
+	  }
+#endif
+
     if ((conn->s_params.sessiontimeout) &&
 	(sessiontime > conn->s_params.sessiontimeout)) {
 #ifdef ENABLE_SESSIONSTATE
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+      terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+    }
+    else if (conn->s_params.expiration &&
+			 (conn->s_state.redir.auth_mode == AUTH_DYN_USER ||
+			  conn->s_state.redir.auth_mode == AUTH_SMS_USER) &&
+			 (sessiontime + conn->s_state.redir.user_time > conn->s_params.expiration))
+    {
+#ifdef ENABLE_SESSIONSTATE
+      conn->s_state.session_state =
+          RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+      conn->s_state.terminate_cause_ui = RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.sessionterminatetime) &&
@@ -1118,6 +1256,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_LOGOUT_TIME_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.idletimeout) &&
@@ -1126,6 +1266,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IDLE_TIMEOUT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_IDLE_TIMEOUT);
     }
     else if ((conn->s_params.maxinputoctets) &&
@@ -1134,6 +1276,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxoutputoctets) &&
@@ -1142,6 +1286,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.maxtotaloctets) &&
@@ -1151,6 +1297,8 @@
       conn->s_state.session_state =
           RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
 #endif
+      conn->s_state.terminate_cause_ui =
+              RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED;
       terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
     }
     else if ((conn->s_params.interim_interval) &&
@@ -1172,7 +1320,57 @@
 
       acct_req(ACCT_USER, conn, RADIUS_STATUS_TYPE_INTERIM_UPDATE);
     }
+#ifdef ENABLE_DATABASE
+      if (conn->s_params.sessiontimeout) {
+          uint32_t sessiontime_total = conn->s_history.sessiontime + sessiontime;
+
+          if (sessiontime_total > conn->s_params.sessiontimeout){
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+            RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+#endif
+               conn->s_state.terminate_cause_ui =
+            	RADIUS_VALUE_COOVACHILLI_SESSION_TIMEOUT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+
+      }
+      if (conn->s_params.maxinputoctets) {
+          uint64_t maxinputoctets_total = conn->s_state.input_octets + conn->s_history.input_octets;
+
+          if (maxinputoctets_total > conn->s_params.maxinputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_IN_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+      if (conn->s_params.maxoutputoctets){
+          uint64_t maxoutputoctets_total = conn->s_state.output_octets + conn->s_history.output_octets;
+
+          if (maxoutputoctets_total > conn->s_params.maxoutputoctets) {
+#ifdef ENABLE_SESSIONSTATE
+              conn->s_state.session_state =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+#endif
+              conn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED;
+              terminate_appconn(conn, RADIUS_TERMINATE_CAUSE_SESSION_TIMEOUT);
+              return;
+          }
+      }
+#endif //ENABLE_DATABASE
   }
+#if(_debug_ > 1)
+  else {
+  	chilli_log(LOG_INFO, "Not authenticated");
+  }
+#endif
 #ifdef ENABLE_GARDENACCOUNTING
   interimtime = mainclock_diffu(conn->s_state.garden_interim_time);
   if (_options.uamgardendata &&
@@ -1206,6 +1404,11 @@
     session_interval(&admin_session);
   }
 
+#ifdef ENABLE_DATABASE
+  sqlite3 *db;
+  db = dbopen();
+#endif
+
   for (conn = firstusedconn; conn; conn=conn->next) {
     if (conn->inuse != 0) {
       if (
@@ -1213,9 +1416,13 @@
               !_options.layer3 &&
 #endif
               !(dhcpconn = (struct dhcp_conn_t *)conn->dnlink)) {
-	syslog(LOG_WARNING, "No downlink protocol");
+	chilli_log(LOG_WARNING, "No downlink protocol");
 	continue;
       }
+#ifdef ENABLE_DATABASE
+      if (db && conn->s_state.authenticated)
+        dbupdate(db, conn);
+#endif
       session_interval(conn);
     }
   }
@@ -1229,6 +1436,10 @@
     }
   }
 
+#ifdef ENABLE_DATABASE
+    dbclose(db);
+#endif
+
   return 0;
 }
 
@@ -1296,6 +1507,9 @@
 		     struct session_state *state) {
   char *sessionid = state->sessionid;
   char mac[MACSTRLEN+1];
+  struct ippoolm_t *ipm = NULL;
+  struct app_conn_t *appconn = NULL;
+  struct dhcp_conn_t *dhcpconn = NULL;
 
   switch(pack->code) {
     case RADIUS_CODE_ACCESS_REQUEST:
@@ -1392,7 +1606,7 @@
     case ACCT_USER:
       if (state->redir.classlen) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): RADIUS Request + Class(%zu)", __FUNCTION__, __LINE__,  state->redir.classlen);
+          chilli_log(LOG_DEBUG, "%s(%d): RADIUS Request + Class(%zu)", __FUNCTION__, __LINE__,  state->redir.classlen);
         radius_addattr(radius, pack,
                        RADIUS_ATTR_CLASS, 0, 0, 0,
                        state->redir.classbuf,
@@ -1401,7 +1615,7 @@
 
       if (state->redir.cuilen > 1) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): RADIUS Request + CUI(%zu)", __FUNCTION__, __LINE__, state->redir.cuilen);
+          chilli_log(LOG_DEBUG, "%s(%d): RADIUS Request + CUI(%zu)", __FUNCTION__, __LINE__, state->redir.cuilen);
         radius_addattr(radius, pack,
                        RADIUS_ATTR_CHARGEABLE_USER_IDENTITY, 0, 0, 0,
                        state->redir.cuibuf,
@@ -1410,7 +1624,7 @@
 
       if (state->redir.statelen) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): RADIUS Request + State(%d)", __FUNCTION__, __LINE__, state->redir.statelen);
+          chilli_log(LOG_DEBUG, "%s(%d): RADIUS Request + State(%d)", __FUNCTION__, __LINE__, state->redir.statelen);
         radius_addattr(radius, pack,
                        RADIUS_ATTR_STATE, 0, 0, 0,
                        state->redir.statebuf,
@@ -1422,6 +1636,11 @@
   if (hisip && hisip->s_addr) {
     radius_addattr(radius, pack, RADIUS_ATTR_FRAMED_IP_ADDRESS, 0, 0,
 		   ntohl(hisip->s_addr), NULL, 0);
+    /* Find user based on IP address */
+    if (!ippool_getip(ippool, &ipm, hisip)) {
+      appconn = (struct app_conn_t *)ipm->peer;
+      dhcpconn = appconn != NULL ? (struct dhcp_conn_t *)appconn->dnlink : NULL;
+    }
   }
 
   radius_addattr(radius, pack, RADIUS_ATTR_NAS_PORT_TYPE, 0, 0,
@@ -1470,6 +1689,19 @@
   }
 #endif
 
+  if (dhcpconn != NULL && dhcp->rawif[dhcp_conn_idx(dhcpconn)].fd > 0) {
+    const char* ssid = NULL;
+#ifdef ENABLE_UBUS
+    ssid = find_ssid_by_ifname(dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname);
+#endif
+    ssid = ssid == NULL ? dhcp->rawif[dhcp_conn_idx(dhcpconn)].devname : ssid;
+    radius_addattr(radius, pack, RADIUS_ATTR_VENDOR_SPECIFIC,
+        RADIUS_VENDOR_COOVACHILLI,
+        RADIUS_ATTR_COOVACHILLI_SSID,
+        0, (uint8_t*) ssid,
+        strlen(ssid));
+  }
+
   /* Include NAS-Identifier if given in configuration options */
   if (_options.radiusnasid) {
     radius_addattr(radius, pack, RADIUS_ATTR_NAS_IDENTIFIER, 0, 0, 0,
@@ -1519,7 +1751,7 @@
   int ret = -1;
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REQUEST)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return ret;
   }
 
@@ -1554,15 +1786,15 @@
   if (!radius) return -1;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Starting radius authentication", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Starting radius authentication", __FUNCTION__, __LINE__);
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REQUEST)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
   /* Include his MAC address */
-  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(dhcpconn->hismac));
+  snprintf(mac, sizeof(mac), get_mac_format(), MAC_ARG(dhcpconn->hismac));
 
   if (!username) {
 
@@ -1652,7 +1884,7 @@
   conn->radiuswait = 0;
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REJECT)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -1668,12 +1900,12 @@
   size_t eaplen = 0;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Sending RADIUS AccessChallenge to client", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Sending RADIUS AccessChallenge to client", __FUNCTION__, __LINE__);
 
   conn->radiuswait = 0;
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_CHALLENGE)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -1688,7 +1920,7 @@
 
     if (radius_addattr(radius, &radius_pack, RADIUS_ATTR_EAP_MESSAGE, 0, 0, 0,
 		       conn->chal + offset, eaplen)) {
-      syslog(LOG_ERR, "radius_default_pack() failed");
+      chilli_log(LOG_ERR, "radius_default_pack() failed");
       return -1;
     }
     offset += eaplen;
@@ -1721,7 +1953,7 @@
   conn->radiuswait = 0;
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_ACCEPT)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -1796,6 +2028,7 @@
       switch(type) {
 #ifdef ENABLE_GARDENACCOUNTING
         case ACCT_GARDEN:
+             chilli_log(LOG_INFO, "ACCT_GARDEN set to zeros");
           snprintf(conn->s_state.garden_sessionid,
                         sizeof(conn->s_state.garden_sessionid),
                         "UAM-%s-%.8x%.8x", inet_ntoa(conn->hisip),
@@ -1813,6 +2046,9 @@
           conn->s_state.output_packets = 0;
           conn->s_state.input_octets = 0;
           conn->s_state.output_octets = 0;
+#ifdef ENABLE_DATABASE
+          dbsession_state(conn);
+#endif
           break;
       }
       break;
@@ -1838,7 +2074,7 @@
   /*
    *  Return if there is no RADIUS accounting for this session.
    */
-  if (conn->s_params.flags & NO_ACCOUNTING)
+  if ((conn->s_params.flags & NO_ACCOUNTING) || _options.localusers || _options.smsusers || _options.macusers)
     return 0;
 
   /*
@@ -1846,7 +2082,7 @@
    */
   if (radius_default_pack(radius, &radius_pack,
 			  RADIUS_CODE_ACCOUNTING_REQUEST)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -1878,7 +2114,7 @@
 
 	if (sysinfo(&the_info)) {
 
-	  syslog(LOG_ERR, "%s: sysinfo()", strerror(errno));
+	  chilli_log(LOG_ERR, "%s: sysinfo()", strerror(errno));
 
 	} else {
 	  float shiftfloat;
@@ -1927,7 +2163,7 @@
         incl_garden = 1;
         if (!conn->s_state.garden_start_time) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): session hasn't started yet", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): session hasn't started yet", __FUNCTION__, __LINE__);
           return 0;
         }
         timediff = mainclock_diffu(conn->s_state.garden_start_time);
@@ -2064,7 +2300,7 @@
       (appconn->hisip.s_addr & _options.uamnatanyipex_mask.s_addr) ==
       _options.uamnatanyipex_addr.s_addr) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Excluding ip %s from SNAT becuase it is in uamnatanyipex", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Excluding ip %s from SNAT becuase it is in uamnatanyipex", __FUNCTION__, __LINE__,
              inet_ntoa(appconn->hisip));
     return 0;
   }
@@ -2073,14 +2309,14 @@
     return 0;
 
   if (_options.debug) {
-    syslog(LOG_DEBUG, "%s(%d): Request SNAT ip for client ip: %s", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Request SNAT ip for client ip: %s", __FUNCTION__, __LINE__,
            inet_ntoa(appconn->hisip));
-    syslog(LOG_DEBUG, "%s(%d): SNAT mask: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->mask));
-    syslog(LOG_DEBUG, "%s(%d): SNAT ourip: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->ourip));
+    chilli_log(LOG_DEBUG, "%s(%d): SNAT mask: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->mask));
+    chilli_log(LOG_DEBUG, "%s(%d): SNAT ourip: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->ourip));
   }
 
   if (ippool_newip(ippool, &newipm, &appconn->natip, 0)) {
-    syslog(LOG_ERR, "Failed to allocate SNAT IP address");
+    chilli_log(LOG_ERR, "Failed to allocate SNAT IP address");
     /*
      *  Clean up the static pool listing too, it's misconfigured now.
      */
@@ -2094,7 +2330,7 @@
   newipm->peer = appconn;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): SNAT IP %s assigned", __FUNCTION__, __LINE__, inet_ntoa(appconn->natip));
+    chilli_log(LOG_DEBUG, "%s(%d): SNAT IP %s assigned", __FUNCTION__, __LINE__, inet_ntoa(appconn->natip));
 
   return 0;
 }
@@ -2119,7 +2355,7 @@
 #ifdef ENABLE_EAPOL
     case DNPROT_EAPOL:
       if (!(dhcpconn = (struct dhcp_conn_t*) appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2129,7 +2365,7 @@
 
     case DNPROT_UAM:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Rejecting UAM", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Rejecting UAM", __FUNCTION__, __LINE__);
       return 0;
 
 #ifdef ENABLE_RADPROXY
@@ -2143,7 +2379,7 @@
         strlcpy(appconn->s_state.redir.username, "-", USERNAMESIZE);
 
       if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2165,7 +2401,7 @@
       return 0;
 
     default:
-      syslog(LOG_ERR, "Unknown downlink protocol");
+      chilli_log(LOG_ERR, "Unknown downlink protocol");
       return 0;
   }
 }
@@ -2180,7 +2416,7 @@
       {
         struct dhcp_conn_t* dhcpconn = NULL;
         if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-          syslog(LOG_ERR, "No downlink protocol");
+          chilli_log(LOG_ERR, "No downlink protocol");
           return 0;
         }
 
@@ -2204,7 +2440,7 @@
 #endif
 
     default:
-      syslog(LOG_ERR, "Unknown downlink protocol");
+      chilli_log(LOG_ERR, "Unknown downlink protocol");
   }
 
   return 0;
@@ -2217,7 +2453,7 @@
   if (appconn->is_adminsession) return 0;
 
   if (!appconn->hisip.s_addr) {
-    syslog(LOG_ERR, "IP address not allocated");
+    chilli_log(LOG_ERR, "IP address not allocated");
     return 0;
   }
 
@@ -2226,7 +2462,7 @@
 #ifdef ENABLE_EAPOL
     case DNPROT_EAPOL:
       if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2242,13 +2478,13 @@
       /* Tell client it was successful */
       dhcp_sendEAP(dhcpconn, appconn->chal, appconn->challen);
 
-      syslog(LOG_WARNING, "Do not know how to set encryption keys on this platform!");
+      chilli_log(LOG_WARNING, "Do not know how to set encryption keys on this platform!");
       break;
 #endif
 
     case DNPROT_UAM:
       if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2265,7 +2501,7 @@
 #ifdef ENABLE_RADPROXY
     case DNPROT_WPA:
       if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2291,7 +2527,7 @@
 
     case DNPROT_MAC:
       if (!(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink)) {
-        syslog(LOG_ERR, "No downlink protocol");
+        chilli_log(LOG_ERR, "No downlink protocol");
         return 0;
       }
 
@@ -2313,7 +2549,7 @@
 #endif
 
     default:
-      syslog(LOG_ERR, "Unknown downlink protocol");
+      chilli_log(LOG_ERR, "Unknown downlink protocol");
       return 0;
   }
 
@@ -2324,6 +2560,10 @@
   if (!(appconn->s_params.flags & REQUIRE_UAM_AUTH)) {
     /* This is the one and only place state is switched to authenticated */
     appconn->s_state.authenticated = 1;
+    appconn->s_state.terminate_cause_ui = 0;
+    memset(appconn->s_params.tcp_reset_addr, 0, sizeof(appconn->s_params.tcp_reset_addr));
+    appconn->s_params.num_tcp_reset_addr = 0;
+    send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_CONNECT, appconn, dhcpconn);
 
 #ifdef ENABLE_SESSIONSTATE
     appconn->s_state.session_state =
@@ -2352,12 +2592,15 @@
 
     /* if (!(appconn->s_params.flags & IS_UAM_REAUTH))*/
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
-
+#ifdef ENABLE_DATABASE
+      dbconup(appconn);
+#endif
     /* Run connection up script */
     if (_options.conup && !(appconn->s_params.flags & NO_SCRIPT)) {
- if (_options.debug)
-     syslog(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n", __FUNCTION__, __LINE__, _options.conup);
-      runscript(appconn, _options.conup, 0, 0);
+        if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): Calling connection up script: %s\n",
+                   __FUNCTION__, __LINE__, _options.conup);
+        runscript(appconn, _options.conup, 0, 0, NULL);
     }
   }
 
@@ -2382,7 +2625,7 @@
   if (udph && dst->s_addr == ssdp.s_addr) {
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): src="MAC_FMT" "
+      chilli_log(LOG_DEBUG, "%s(%d): src="MAC_FMT" "
              "dst="MAC_FMT" prot=%.4x", __FUNCTION__, __LINE__,
              MAC_ARG(ethh->src),
              MAC_ARG(ethh->dst),
@@ -2397,7 +2640,7 @@
 
       src.s_addr = iph->saddr;
 
-      syslog(LOG_DEBUG, "%s(%d): ssdp multicast from %s\n%.*s", __FUNCTION__, __LINE__, inet_ntoa(src),
+      chilli_log(LOG_DEBUG, "%s(%d): ssdp multicast from %s\n%.*s", __FUNCTION__, __LINE__, inet_ntoa(src),
              ntohs(udph->len), bufr);
     }
 
@@ -2408,7 +2651,7 @@
       if (conn->inuse && conn->authstate == DHCP_AUTH_PASS) {
 	/*
 	if (_options.debug)
-  syslog(LOG_DEBUG, "sending to %s.", inet_ntoa(conn->hisip ));
+  chilli_log(LOG_DEBUG, "sending to %s.", inet_ntoa(conn->hisip ));
 	*/
 	dhcp_data_req(conn, pb, ethhdr);
       }
@@ -2441,12 +2684,12 @@
       if (!appconn) {
 	struct in_addr src;
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Detecting layer3 IP assignment", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Detecting layer3 IP assignment", __FUNCTION__, __LINE__);
 
 	src.s_addr = pdhcp->yiaddr;
 	appconn = chilli_connect_layer3(&src, 0);
 	if (!appconn) {
-	  syslog(LOG_ERR, "could not allocate for %s", inet_ntoa(src));
+	  chilli_log(LOG_ERR, "could not allocate for %s", inet_ntoa(src));
 	  return 1;
 	}
       }
@@ -2456,7 +2699,7 @@
 	struct pkt_ethhdr_t *ethh = pkt_ethhdr(pkt_buffer_head(pb));
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): forwarding layer3 dhcp-broadcast: %s",__FUNCTION__, __LINE__, inet_ntoa(*dst));
+          chilli_log(LOG_DEBUG, "%s(%d): forwarding layer3 dhcp-broadcast: %s",__FUNCTION__, __LINE__, inet_ntoa(*dst));
 
 	dhcp_send(dhcp, -1, ethh->dst,
 		  pkt_buffer_head(pb),
@@ -2481,7 +2724,7 @@
 	length += hdrlen;
 
 	copy_mac6(ethh->dst, dstmac);
-	copy_mac6(ethh->src, dhcp_nexthop(dhcp));
+	copy_mac6(ethh->src, dhcp_nexthop(dhcp, 0));
 	ethh->prot = htons(PKT_ETH_PROTO_IP);
 
 	dhcp_send(dhcp, -1, dstmac, packet, length);
@@ -2560,7 +2803,7 @@
           memcpy(&reqaddr.s_addr, p_arp->tpa, PKT_IP_ALEN);
 
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): arp: ifidx=%d src="MAC_FMT" "
+            chilli_log(LOG_DEBUG, "%s(%d): arp: ifidx=%d src="MAC_FMT" "
                    "dst="MAC_FMT" "
                    "prot=%.4x (asking for %s)", __FUNCTION__, __LINE__,
                    tun(tun,idx).ifindex,
@@ -2574,13 +2817,13 @@
            */
           if (ippool_getip(ippool, &ipm, &reqaddr)) {
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): ARP for unknown IP %s", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
+              chilli_log(LOG_DEBUG, "%s(%d): ARP for unknown IP %s", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
             return 0;
           }
 
           if ((appconn  = (struct app_conn_t *)ipm->peer) == NULL ||
               (appconn->dnlink) == NULL) {
-            syslog(LOG_ERR, "No peer protocol defined for ARP request");
+            chilli_log(LOG_ERR, "No peer protocol defined for ARP request");
             return 0;
           }
 
@@ -2610,7 +2853,7 @@
               char snatip[56];
               strlcpy(ip, inet_ntoa(appconn->hisip), sizeof(ip));
               strlcpy(snatip, inet_ntoa(appconn->natip), sizeof(snatip));
-              syslog(LOG_DEBUG, "%s(%d): SNAT anyip in ARP response from %s to %s", __FUNCTION__, __LINE__,
+              chilli_log(LOG_DEBUG, "%s(%d): SNAT anyip in ARP response from %s to %s", __FUNCTION__, __LINE__,
                      ip, snatip);
             }
           } else
@@ -2629,18 +2872,18 @@
           packet_ethh->prot = htons(PKT_ETH_PROTO_ARP);
 
           if (_options.debug) {
-            syslog(LOG_DEBUG, "%s(%d): arp-reply: src="MAC_FMT" "
+            chilli_log(LOG_DEBUG, "%s(%d): arp-reply: src="MAC_FMT" "
                    "dst="MAC_FMT, __FUNCTION__, __LINE__,
                    MAC_ARG(packet_ethh->src),
                    MAC_ARG(packet_ethh->dst));
 
             memcpy(&reqaddr.s_addr, packet_arp->spa, PKT_IP_ALEN);
-            syslog(LOG_DEBUG, "%s(%d): arp-reply: source sha="MAC_FMT" spa=%s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): arp-reply: source sha="MAC_FMT" spa=%s", __FUNCTION__, __LINE__,
                    MAC_ARG(packet_arp->sha),
                    inet_ntoa(reqaddr));
 
             memcpy(&reqaddr.s_addr, packet_arp->tpa, PKT_IP_ALEN);
-            syslog(LOG_DEBUG, "%s(%d): arp-reply: target tha="MAC_FMT" tpa=%s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): arp-reply: target tha="MAC_FMT" tpa=%s", __FUNCTION__, __LINE__,
                    MAC_ARG(packet_arp->tha),
                    inet_ntoa(reqaddr));
           }
@@ -2649,7 +2892,7 @@
         }
       default:
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): unhandled protocol %x", __FUNCTION__, __LINE__, prot);
+          chilli_log(LOG_DEBUG, "%s(%d): unhandled protocol %x", __FUNCTION__, __LINE__, prot);
         return 0;
     }
 
@@ -2662,7 +2905,7 @@
   size_t hlen = (ipph->version_ihl & 0x0f) << 2;
   if (ntohs(ipph->tot_len) > ip_len || hlen > ip_len) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): invalid IP packet %d / %zu", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): invalid IP packet %d / %zu", __FUNCTION__, __LINE__,
              ntohs(ipph->tot_len),
              len);
     return 0;
@@ -2689,7 +2932,7 @@
         }
         if (udph && !iphdr_more_frag((struct pkt_iphdr_t*)ipph) && (ntohs(udph->len) > ip_len)) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): invalid UDP packet %d / %d / %zu", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): invalid UDP packet %d / %d / %zu", __FUNCTION__, __LINE__,
                    ntohs(ipph->tot_len),
                    udph ? ntohs(udph->len) : -1, ip_len);
           return 0;
@@ -2698,7 +2941,7 @@
       break;
     default:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping unhandled packet: %x", __FUNCTION__, __LINE__, ipph->protocol);
+        chilli_log(LOG_DEBUG, "%s(%d): dropping unhandled packet: %x", __FUNCTION__, __LINE__, ipph->protocol);
       return 0;
   }
 
@@ -2706,7 +2949,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): sending to : %s", __FUNCTION__, __LINE__, inet_ntoa(dst));
+    chilli_log(LOG_DEBUG, "%s(%d): sending to : %s", __FUNCTION__, __LINE__, inet_ntoa(dst));
 #endif
 
   if (ippool_getip(ippool, &ipm, &dst)) {
@@ -2726,7 +2969,7 @@
 #endif
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dropping packet with unknown destination: %s", __FUNCTION__, __LINE__, inet_ntoa(dst));
+      chilli_log(LOG_DEBUG, "%s(%d): dropping packet with unknown destination: %s", __FUNCTION__, __LINE__, inet_ntoa(dst));
 
     return 0;
   }
@@ -2749,7 +2992,7 @@
 #endif
 
   if (appconn == NULL || appconn->dnlink == NULL) {
-    syslog(LOG_ERR, "No %s protocol defined for %s",
+    chilli_log(LOG_ERR, "No %s protocol defined for %s",
            appconn ? "dnlink" : "peer", inet_ntoa(dst));
     return 0;
   }
@@ -2767,7 +3010,7 @@
       char snatip[56];
       strlcpy(ip, inet_ntoa(appconn->hisip), sizeof(ip));
       strlcpy(snatip, inet_ntoa(appconn->natip), sizeof(snatip));
-      syslog(LOG_DEBUG, "%s(%d): SNAT anyip replace %s back to %s; snat was: %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): SNAT anyip replace %s back to %s; snat was: %s", __FUNCTION__, __LINE__,
              inet_ntoa(dst), ip, snatip);
     }
 #endif
@@ -2793,7 +3036,7 @@
     case DNPROT_NULL:
     case DNPROT_DHCP_NONE:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Dropping...", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Dropping...", __FUNCTION__, __LINE__);
       break;
 
     case DNPROT_UAM:
@@ -2809,7 +3052,7 @@
       break;
 
     default:
-      syslog(LOG_ERR, "Unknown downlink protocol: %d", appconn->dnprot);
+      chilli_log(LOG_ERR, "Unknown downlink protocol: %d", appconn->dnprot);
       break;
   }
 
@@ -2841,13 +3084,13 @@
 
   if (ippool_getip(ippool, &ipm, addr)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): did not find %s", __FUNCTION__, __LINE__, inet_ntoa(*addr));
+      chilli_log(LOG_DEBUG, "%s(%d): did not find %s", __FUNCTION__, __LINE__, inet_ntoa(*addr));
     return -1;
   }
 
   if ( (appconn  = (struct app_conn_t *)ipm->peer)        == NULL ||
        (dhcpconn = (struct dhcp_conn_t *)appconn->dnlink) == NULL ) {
-    syslog(LOG_WARNING, "No peer protocol defined app-null=%d", appconn == 0);
+    chilli_log(LOG_WARNING, "No peer protocol defined app-null=%d", appconn == 0);
     return -1;
   }
 
@@ -2867,7 +3110,7 @@
       /*
        *  First, search the dnat list to see if we are tracking the port.
        */
-      /*syslog("%d(%d) == %d",ntohs(dhcpconn->dnat[n].src_port),ntohs(dhcpconn->dnat[n].dst_port),ntohs(address->sin_port));*/
+      /*chilli_log("%d(%d) == %d",ntohs(dhcpconn->dnat[n].src_port),ntohs(dhcpconn->dnat[n].dst_port),ntohs(address->sin_port));*/
       if (dhcpconn->dnat[n].src_port == address->sin_port) {
 	if (dhcpconn->dnat[n].dst_port == htons(DHCP_HTTPS)
 #ifdef ENABLE_UAMUIPORT
@@ -2876,7 +3119,7 @@
 	    ) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
 #endif
 	  flags |= USING_SSL;
 	}
@@ -2892,7 +3135,7 @@
 	ntohs(baddress->sin_port) == _options.uamuiport) {
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
 #endif
       flags |= USING_SSL;
     }
@@ -2923,7 +3166,7 @@
   char restart_accounting = 0;
 
   if (loclen >= MAX_LOCATION_LENGTH) {
-    syslog(LOG_ERR, "Location too long %d", loclen);
+    chilli_log(LOG_ERR, "Location too long %d", loclen);
     return 0;
   }
 
@@ -2934,7 +3177,7 @@
   prev_loc_len = strlen(prev_loc_buff);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Learned location : [%.*s]", __FUNCTION__, __LINE__, loclen, loc);
+    chilli_log(LOG_DEBUG, "%s(%d): Learned location : [%.*s]", __FUNCTION__, __LINE__, loclen, loc);
 
   if (prev_loc_len == 0 ||
       prev_loc_len != loclen ||
@@ -2948,7 +3191,7 @@
       appconn->s_state.pending_location[0]=0;
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Learned new-location : %d [%.*s] old %d [%s]", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Learned new-location : %d [%.*s] old %d [%s]", __FUNCTION__, __LINE__,
                loclen, loclen, loc,
                prev_loc_len, prev_loc_buff);
 
@@ -2958,7 +3201,7 @@
 
       if (_options.locationupdate) {
 	runscript(appconn, _options.locationupdate,
-		  loc_buff, prev_loc_buff);
+		  loc_buff, prev_loc_buff, NULL);
       }
 
       if (_options.location_stop_start) {
@@ -3050,6 +3293,7 @@
     appconn->s_state.input_octets = 0;
     appconn->s_state.output_packets = 0;
     appconn->s_state.output_octets = 0;
+     chilli_log(LOG_INFO, "location set to zeros");
 
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_START);
   }
@@ -3111,7 +3355,7 @@
 
       if ((appconn->s_state.redir.vsalen + (size_t) attr->l) >
 	  RADIUS_PROXYVSA) {
-	syslog(LOG_WARNING, "VSAs too long");
+	chilli_log(LOG_WARNING, "VSAs too long");
 	return -1;
       }
 
@@ -3121,7 +3365,7 @@
 
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Remembering VSA", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Remembering VSA", __FUNCTION__, __LINE__);
 #endif
     }
   } while (attr);
@@ -3146,13 +3390,13 @@
 
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): looking for attr %d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr);
+          chilli_log(LOG_DEBUG, "%s(%d): looking for attr %d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr);
 #endif
 
 	if (radius_getattr(pack, &attr, _options.proxy_loc[i].attr,
 			   0, 0, 0)) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): didn't find attr %d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr);
+            chilli_log(LOG_DEBUG, "%s(%d): didn't find attr %d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr);
 	  attr = 0;
 	}
       } else {
@@ -3162,7 +3406,7 @@
 
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): looking for attr %d/%d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr_vsa,
+          chilli_log(LOG_DEBUG, "%s(%d): looking for attr %d/%d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr_vsa,
                  _options.proxy_loc[i].attr);
 #endif
 
@@ -3172,7 +3416,7 @@
 			   _options.proxy_loc[i].attr, 0)) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): didn't find attr %d/%d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr_vsa,
+            chilli_log(LOG_DEBUG, "%s(%d): didn't find attr %d/%d", __FUNCTION__, __LINE__, _options.proxy_loc[i].attr_vsa,
                    _options.proxy_loc[i].attr);
 #endif
 	  attr = 0;
@@ -3211,7 +3455,7 @@
 
   if (radius_default_pack(radius, &radius_pack,
 			  RADIUS_CODE_ACCOUNTING_RESPONSE)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -3220,7 +3464,7 @@
 
   /* Status type */
   if (radius_getattr(pack, &attr, RADIUS_ATTR_ACCT_STATUS_TYPE, 0, 0, 0)) {
-    syslog(LOG_ERR, "Status type is missing from radius request");
+    chilli_log(LOG_ERR, "Status type is missing from radius request");
     radius_resp(radius, &radius_pack, peer, pack->authenticator);
     return 0;
   }
@@ -3234,7 +3478,7 @@
     if (!radius_getattr(pack, &nasipattr,
 			RADIUS_ATTR_NAS_IP_ADDRESS, 0, 0, 0)) {
       if ((nasipattr->l-2) != sizeof(appconn->nasip)) {
-	syslog(LOG_ERR, "Wrong length of NAS IP address");
+	chilli_log(LOG_ERR, "Wrong length of NAS IP address");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
       nasip = nasipattr->v.i;
@@ -3244,7 +3488,7 @@
     if (!radius_getattr(pack, &nasportattr,
 			RADIUS_ATTR_NAS_PORT, 0, 0, 0)) {
       if ((nasportattr->l-2) != sizeof(appconn->nasport)) {
-	syslog(LOG_ERR, "Wrong length of NAS port");
+	chilli_log(LOG_ERR, "Wrong length of NAS port");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
       nasport = nasportattr->v.i;
@@ -3254,11 +3498,11 @@
     if (!radius_getattr(pack, &hismacattr,
 			RADIUS_ATTR_CALLING_STATION_ID, 0, 0, 0)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Calling Station ID is: %.*s", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Calling Station ID is: %.*s", __FUNCTION__, __LINE__,
                hismacattr->l-2, hismacattr->v.t);
 
       if ((macstrlen = (size_t)hismacattr->l-2) >= (RADIUS_ATTR_VLEN-1)) {
-	syslog(LOG_ERR, "Wrong length of called station ID");
+	chilli_log(LOG_ERR, "Wrong length of called station ID");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
 
@@ -3273,7 +3517,7 @@
       if (sscanf (macstr, "%2x %2x %2x %2x %2x %2x",
 		  &temp[0], &temp[1], &temp[2],
 		  &temp[3], &temp[4], &temp[5]) != 6) {
-	syslog(LOG_ERR, "Failed to convert Calling Station ID to MAC Address");
+	chilli_log(LOG_ERR, "Failed to convert Calling Station ID to MAC Address");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
 
@@ -3288,18 +3532,18 @@
        */
 #ifdef ENABLE_LAYER3
       if (_options.layer3) {
-	syslog(LOG_ERR, "Not supported in layer3 mode");
+	chilli_log(LOG_ERR, "Not supported in layer3 mode");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       } else {
 #endif
 	if (dhcp_hashget(dhcp, &dhcpconn, hismac)) {
 	  if (dhcp_newconn(dhcp, &dhcpconn, hismac)) {
-	    syslog(LOG_ERR, "Out of connections");
+	    chilli_log(LOG_ERR, "Out of connections");
 	    return radius_resp(radius, &radius_pack, peer, pack->authenticator);
 	  }
 	}
 	if (!(dhcpconn->peer)) {
-	  syslog(LOG_ERR, "No peer protocol defined");
+	  chilli_log(LOG_ERR, "No peer protocol defined");
 	  return radius_resp(radius, &radius_pack, peer, pack->authenticator);
 	}
 	appconn = (struct app_conn_t *)dhcpconn->peer;
@@ -3309,20 +3553,20 @@
     }
     else if (nasipattr && nasportattr) { /* Look for NAS IP / Port */
       if (chilli_getconn(&appconn, 0, nasip, nasport)) {
-	syslog(LOG_ERR, "Unknown connection");
+	chilli_log(LOG_ERR, "Unknown connection");
 	radius_resp(radius, &radius_pack, peer, pack->authenticator);
 	return 0;
       }
     }
     else {
-      syslog(LOG_ERR, "Calling Station ID or NAS IP/Port is missing from radius request");
+      chilli_log(LOG_ERR, "Calling Station ID or NAS IP/Port is missing from radius request");
       radius_resp(radius, &radius_pack, peer, pack->authenticator);
       return 0;
     }
 
     if (!appconn) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): No application context for RADIUS proxy", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): No application context for RADIUS proxy", __FUNCTION__, __LINE__);
       return 0;
     }
 
@@ -3330,18 +3574,18 @@
     if (appconn->radiuswait) {
       if (appconn->radiuswait == 2) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Giving up on previous packet.. not dropping this one", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Giving up on previous packet.. not dropping this one", __FUNCTION__, __LINE__);
 	appconn->radiuswait = 0;
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Dropping RADIUS while waiting", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Dropping RADIUS while waiting", __FUNCTION__, __LINE__);
 	appconn->radiuswait++;
 	return 0;
       }
     }
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Handing RADIUS accounting proxy packet", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Handing RADIUS accounting proxy packet", __FUNCTION__, __LINE__);
 
     dhcpconn = (struct dhcp_conn_t*) appconn->dnlink;
 
@@ -3354,7 +3598,7 @@
       memcpy(appconn->s_state.ap_sessionid, attr->v.t, len);
       appconn->s_state.ap_sessionid[len]=0;
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): AP Acct-Session-ID is: %s", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): AP Acct-Session-ID is: %s", __FUNCTION__, __LINE__,
                appconn->s_state.ap_sessionid);
     }
 #endif
@@ -3376,7 +3620,7 @@
     /* -- This needs to be optional --
        case RADIUS_STATUS_TYPE_STOP:
        if (!dhcpconn) {
-       syslog(LOG_ERR,"No downlink protocol defined for RADIUS proxy client");
+       chilli_log(LOG_ERR,"No downlink protocol defined for RADIUS proxy client");
        return 0;
        }
        dhcp_freeconn(dhcpconn, RADIUS_TERMINATE_CAUSE_LOST_CARRIER);
@@ -3438,10 +3682,10 @@
   uint8_t qid;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): RADIUS Access-Request received", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): RADIUS Access-Request received", __FUNCTION__, __LINE__);
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REJECT)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -3459,22 +3703,22 @@
   if (!radius_getattr(pack, &hisipattr,
 		      RADIUS_ATTR_FRAMED_IP_ADDRESS, 0, 0, 0)) {
     if ((hisipattr->l-2) != sizeof(hisip.s_addr)) {
-      syslog(LOG_ERR, "Wrong length of framed IP address");
+      chilli_log(LOG_ERR, "Wrong length of framed IP address");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
     hisip.s_addr = hisipattr->v.i;
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Framed IP address is: %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
+      chilli_log(LOG_DEBUG, "%s(%d): Framed IP address is: %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
   }
 
   /* Calling Station ID: MAC Address (Conditional) */
   if (!radius_getattr(pack, &hismacattr,
 		      RADIUS_ATTR_CALLING_STATION_ID, 0, 0, 0)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Calling Station ID is: %.*s", __FUNCTION__, __LINE__, hismacattr->l-2, hismacattr->v.t);
+      chilli_log(LOG_DEBUG, "%s(%d): Calling Station ID is: %.*s", __FUNCTION__, __LINE__, hismacattr->l-2, hismacattr->v.t);
 
     if ((macstrlen = (size_t)hismacattr->l-2) >= (RADIUS_ATTR_VLEN-1)) {
-      syslog(LOG_ERR, "Wrong length of calling station ID");
+      chilli_log(LOG_ERR, "Wrong length of calling station ID");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
 
@@ -3489,7 +3733,7 @@
     if (sscanf (macstr, "%2x %2x %2x %2x %2x %2x",
 		&temp[0], &temp[1], &temp[2],
 		&temp[3], &temp[4], &temp[5]) != 6) {
-      syslog(LOG_ERR, "Failed to convert Calling Station ID to MAC Address");
+      chilli_log(LOG_ERR, "Failed to convert Calling Station ID to MAC Address");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
 
@@ -3499,25 +3743,25 @@
 
   /* Framed IP address or MAC Address must be given in request */
   if ((!hisipattr) && (!hismacattr)) {
-    syslog(LOG_ERR, "Framed IP address or Calling Station ID is missing from radius request");
+    chilli_log(LOG_ERR, "Framed IP address or Calling Station ID is missing from radius request");
     return radius_resp(radius, &radius_pack, peer, pack->authenticator);
   }
 
   /* Username (Mandatory) */
   if (radius_getattr(pack, &uidattr, RADIUS_ATTR_USER_NAME, 0, 0, 0)) {
-    syslog(LOG_ERR, "User-Name is missing from radius request");
+    chilli_log(LOG_ERR, "User-Name is missing from radius request");
     return radius_resp(radius, &radius_pack, peer, pack->authenticator);
   }
 
   if (hisipattr) { /* Find user based on IP address */
     if (ippool_getip(ippool, &ipm, &hisip)) {
-      syslog(LOG_ERR, "RADIUS-Request: IP Address not found");
+      chilli_log(LOG_ERR, "RADIUS-Request: IP Address not found");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
 
     if ((appconn  = (struct app_conn_t *)ipm->peer)        == NULL ||
 	(dhcpconn = (struct dhcp_conn_t *)appconn->dnlink) == NULL) {
-      syslog(LOG_ERR, "RADIUS-Request: No peer protocol defined");
+      chilli_log(LOG_ERR, "RADIUS-Request: No peer protocol defined");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
   }
@@ -3528,18 +3772,18 @@
      */
 #ifdef ENABLE_LAYER3
     if (_options.layer3) {
-      syslog(LOG_ERR, "Not supported in layer3 mode");
+      chilli_log(LOG_ERR, "Not supported in layer3 mode");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     } else {
 #endif
       if (dhcp_hashget(dhcp, &dhcpconn, hismac)) {
 	if (dhcp_newconn(dhcp, &dhcpconn, hismac)) {
-	  syslog(LOG_ERR, "Out of connections");
+	  chilli_log(LOG_ERR, "Out of connections");
 	  return radius_resp(radius, &radius_pack, peer, pack->authenticator);
 	}
       }
       if (!(dhcpconn->peer)) {
-	syslog(LOG_ERR, "No peer protocol defined");
+	chilli_log(LOG_ERR, "No peer protocol defined");
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
       appconn = (struct app_conn_t *)dhcpconn->peer;
@@ -3548,7 +3792,7 @@
 #endif
   }
   else {
-    syslog(LOG_ERR, "Framed-IP-Address or Calling-Station-ID required in RADIUS request");
+    chilli_log(LOG_ERR, "Framed-IP-Address or Calling-Station-ID required in RADIUS request");
     return radius_resp(radius, &radius_pack, peer, pack->authenticator);
   }
 
@@ -3556,11 +3800,11 @@
   if (appconn->radiuswait) {
     if (appconn->radiuswait == 2) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Giving up on previous packet.. not dropping this one", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Giving up on previous packet.. not dropping this one", __FUNCTION__, __LINE__);
       appconn->radiuswait = 0;
     } else {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Dropping RADIUS while waiting", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Dropping RADIUS while waiting", __FUNCTION__, __LINE__);
       appconn->radiuswait++;
       return 0;
     }
@@ -3574,12 +3818,12 @@
 			pwdattr->v.t, pwdattr->l-2, pack->authenticator,
 			radius->proxysecret,
 			radius->proxysecretlen)) {
-      syslog(LOG_ERR, "radius_pwdecode() failed");
+      chilli_log(LOG_ERR, "radius_pwdecode() failed");
       return -1;
     }
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Password is: %s", __FUNCTION__, __LINE__, pwd);
+      chilli_log(LOG_DEBUG, "%s(%d): Password is: %s", __FUNCTION__, __LINE__, pwd);
 #endif
   }
 
@@ -3590,7 +3834,7 @@
     if (!radius_getattr(pack, &eapattr, RADIUS_ATTR_EAP_MESSAGE, 0, 0,
 			instance++)) {
       if ((resplen + (size_t)eapattr->l-2) > MAX_EAP_LEN) {
-	syslog(LOG_INFO, "EAP message too long %zu %d", resplen, (int)eapattr->l-2);
+	chilli_log(LOG_INFO, "EAP message too long %zu %d", resplen, (int)eapattr->l-2);
 	return radius_resp(radius, &radius_pack, peer, pack->authenticator);
       }
       memcpy(resp + resplen, eapattr->v.t, (size_t)eapattr->l-2);
@@ -3609,13 +3853,13 @@
 
   /* Passwd or EAP must be given in request */
   if ((!pwdattr) && (!resplen)) {
-    syslog(LOG_ERR, "Password or EAP message is missing from radius request");
+    chilli_log(LOG_ERR, "Password or EAP message is missing from radius request");
     return radius_resp(radius, &radius_pack, peer, pack->authenticator);
   }
 
 #ifdef ENABLE_RADPROXY
   if (_options.proxymacaccept && !resplen) {
-    syslog(LOG_INFO, "Accepting MAC login");
+    chilli_log(LOG_INFO, "Accepting MAC login");
     radius_pack.code = RADIUS_CODE_ACCESS_ACCEPT;
     return radius_resp(radius, &radius_pack, peer, pack->authenticator);
   }
@@ -3641,7 +3885,7 @@
        (memcmp(appconn->s_state.redir.username, uidattr->v.t, uidattr->l-2)))) {
     terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
     if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REJECT)) {
-      syslog(LOG_ERR, "radius_default_pack() failed");
+      chilli_log(LOG_ERR, "radius_default_pack() failed");
       return -1;
     }
   }
@@ -3649,7 +3893,7 @@
   /* NAS IP */
   if (!radius_getattr(pack, &nasipattr, RADIUS_ATTR_NAS_IP_ADDRESS, 0, 0, 0)) {
     if ((nasipattr->l-2) != sizeof(appconn->nasip)) {
-      syslog(LOG_ERR, "Wrong length of NAS IP address");
+      chilli_log(LOG_ERR, "Wrong length of NAS IP address");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
     appconn->nasip = nasipattr->v.i;
@@ -3658,7 +3902,7 @@
   /* NAS PORT */
   if (!radius_getattr(pack, &nasportattr, RADIUS_ATTR_NAS_PORT, 0, 0, 0)) {
     if ((nasportattr->l-2) != sizeof(appconn->nasport)) {
-      syslog(LOG_ERR, "Wrong length of NAS port");
+      chilli_log(LOG_ERR, "Wrong length of NAS port");
       return radius_resp(radius, &radius_pack, peer, pack->authenticator);
     }
     appconn->nasport = nasportattr->v.i;
@@ -3749,7 +3993,7 @@
 		  struct sockaddr_in *peer) {
 
   if (rp != radius) {
-    syslog(LOG_ERR, "Radius callback from unknown instance");
+    chilli_log(LOG_ERR, "Radius callback from unknown instance");
     return 0;
   }
 
@@ -3759,7 +4003,7 @@
     case RADIUS_CODE_ACCESS_REQUEST:
       return access_request(pack, peer);
     default:
-      syslog(LOG_ERR, "Unsupported radius request received: %d", pack->code);
+      chilli_log(LOG_ERR, "Unsupported radius request received: %d", pack->code);
       return 0;
   }
 }
@@ -3802,13 +4046,13 @@
 	  mask.s_addr = 0xffffffff;
 	  res = net_del_route(&member->addr, &appconn->ourip, &mask);
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Removing route: %s %d", __FUNCTION__, __LINE__, inet_ntoa(member->addr), res);
+            chilli_log(LOG_DEBUG, "%s(%d): Removing route: %s %d", __FUNCTION__, __LINE__, inet_ntoa(member->addr), res);
 	}
       } else {
 	struct ippoolm_t *natipm;
 	if (ippool_getip(ippool, &natipm, &appconn->natip) == 0) {
 	  if (ippool_freeip(ippool, natipm)) {
-	    syslog(LOG_ERR, "ippool_freeip(%s) failed for nat ip!",
+	    chilli_log(LOG_ERR, "ippool_freeip(%s) failed for nat ip!",
                    inet_ntoa(appconn->natip));
 	  }
 	}
@@ -3818,7 +4062,7 @@
 
     if (member->in_use && (!dhcpconn || !dhcpconn->is_reserved)) {
       if (ippool_freeip(ippool, member)) {
-	syslog(LOG_ERR, "ippool_freeip(%s) failed!",
+	chilli_log(LOG_ERR, "ippool_freeip(%s) failed!",
                inet_ntoa(member->addr));
       }
     }
@@ -3852,8 +4096,8 @@
   }
 
   if (_options.macdown) {
-    syslog(LOG_DEBUG, "%s(%d): Calling MAC down script: %s", __FUNCTION__, __LINE__, _options.macdown);
-    runscript(appconn, _options.macdown, 0, 0);
+    chilli_log(LOG_DEBUG, "%s(%d): Calling MAC down script: %s", __FUNCTION__, __LINE__, _options.macdown);
+    runscript(appconn, _options.macdown, 0, 0, NULL);
   }
 
   if (!dhcpconn || !dhcpconn->is_reserved) {
@@ -3878,10 +4122,8 @@
 
   struct dhcp_conn_t *dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
 
-#if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): UPPROT - GETIP", __FUNCTION__, __LINE__);
-#endif
+    chilli_log(LOG_DEBUG, "%s(%d): UPPROT - GETIP", __FUNCTION__, __LINE__);
 
   /* If IP address is already allocated: Fill it in */
   /* This should only happen for UAM */
@@ -3926,7 +4168,6 @@
 }
 
 void session_param_defaults(struct session_params *params) {
-
   if (_options.defsessiontimeout && !params->sessiontimeout)
     params->sessiontimeout = _options.defsessiontimeout;
 
@@ -3941,6 +4182,52 @@
 
   if (_options.definteriminterval && !params->interim_interval)
     params->interim_interval = _options.definteriminterval;
+
+  if (_options.defmaxdownload && !params->maxinputoctets)
+    params->maxinputoctets = _options.defmaxdownload;
+
+  if (_options.defmaxupload && !params->maxoutputoctets)
+    params->maxoutputoctets = _options.defmaxupload;
+
+  if (_options.defwarning && !params->warningoctets)
+    params->warningoctets = _options.defwarning;
+
+  if (_options.deflimitperiod && !params->period)
+    params->period = _options.deflimitperiod;
+
+  if (_options.deflimitstart && !params->start)
+    params->start = _options.deflimitstart;
+
+  if (_options.defexpirationtime && !params->expiration)
+    params->expiration = _options.defexpirationtime;
+}
+
+void session_params_dyn(struct session_params *params) {
+    params->sessiontimeout = _options.dynsessiontimeout;
+    params->idletimeout = _options.dynidletimeout;
+    params->bandwidthmaxdown = _options.dynbandwidthmaxdown;
+    params->bandwidthmaxup = _options.dynbandwidthmaxup;
+    params->interim_interval = _options.dyninteriminterval;
+    params->maxinputoctets = _options.dynmaxdownload;
+    params->maxoutputoctets = _options.dynmaxupload;
+    params->warningoctets = _options.dynwarning;
+    params->period = _options.dynlimitperiod;
+    params->start = _options.dynlimitstart;
+    params->expiration = _options.dynexpirationtime;
+}
+
+void session_params_trial(struct session_params *params) {
+  params->sessiontimeout = _options.trialsessiontimeout;
+  params->idletimeout = _options.trialidletimeout;
+  params->bandwidthmaxdown = _options.trialbandwidthmaxdown;
+  params->bandwidthmaxup = _options.trialbandwidthmaxup;
+  params->interim_interval = _options.trialinteriminterval;
+  params->maxinputoctets = _options.trialmaxdownload;
+  params->maxoutputoctets = _options.trialmaxupload;
+  params->warningoctets = _options.trialwarning;
+  params->period = _options.triallimitperiod;
+  params->start = _options.triallimitstart;
+  params->expiration = _options.trialexpirationtime;
 }
 
 void
@@ -3980,7 +4267,7 @@
   if (!radius_getattr(pack, &attr, RADIUS_ATTR_ACCT_INTERIM_INTERVAL, 0, 0, 0)) {
     params->interim_interval = ntohl(attr->v.i);
     if (params->interim_interval < 60) {
-      syslog(LOG_ERR, "Received too small radius Acct-Interim-Interval: %d; resettings to default.",
+      chilli_log(LOG_ERR, "Received too small radius Acct-Interim-Interval: %d; resettings to default.",
              params->interim_interval);
       params->interim_interval = 0;
     }
@@ -4044,6 +4331,14 @@
   else if (!reconfig)
     params->maxtotaloctets = 0;
 
+  /* Warning octets */
+  if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
+		      RADIUS_VENDOR_COOVACHILLI,
+		      RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS, 0))
+    params->warningoctets = ntohl(attr->v.i);
+  else if (!reconfig)
+    params->warningoctets = 0;
+
 
   /* Max input gigawords */
   if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
@@ -4127,12 +4422,12 @@
 
       if (len == strlen(uamauth) && !memcmp(val, uamauth, len)) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): received require-uam-auth", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): received require-uam-auth", __FUNCTION__, __LINE__);
 	params->flags |= REQUIRE_UAM_AUTH;
       }
       else if (len == strlen(splash) && !memcmp(val, splash, len)) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): received splash response", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): received splash response", __FUNCTION__, __LINE__);
 	params->flags |= REQUIRE_UAM_SPLASH;
 	/*is_splash = 1;*/
       }
@@ -4259,7 +4554,7 @@
     }
     else {
       params->sessionterminatetime = 0;
-      syslog(LOG_WARNING, "Invalid WISPr-Session-Terminate-Time received: %s", attrs);
+      chilli_log(LOG_WARNING, "Invalid WISPr-Session-Terminate-Time received: %s", attrs);
     }
   }
   else if (!reconfig)
@@ -4277,27 +4572,27 @@
   size_t offset = 0;
 
   if (!pack) {
-    syslog(LOG_ERR, "Radius request timed out");
+    chilli_log(LOG_ERR, "Radius request timed out");
     return 0;
   }
 
   if ((pack->code != RADIUS_CODE_ACCESS_REJECT) &&
       (pack->code != RADIUS_CODE_ACCESS_CHALLENGE) &&
       (pack->code != RADIUS_CODE_ACCESS_ACCEPT)) {
-    syslog(LOG_ERR, "Unknown radius access reply code %d", pack->code);
+    chilli_log(LOG_ERR, "Unknown radius access reply code %d", pack->code);
     return 0;
   }
 
   /* ACCESS-ACCEPT */
   if (pack->code != RADIUS_CODE_ACCESS_ACCEPT) {
-    syslog(LOG_ERR, "Administrative-User Login Failed");
+    chilli_log(LOG_ERR, "Administrative-User Login Failed");
     return 0;
   }
 
   if (_options.adminupdatefile) {
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): looking to replace: %s", __FUNCTION__, __LINE__, _options.adminupdatefile);
+      chilli_log(LOG_DEBUG, "%s(%d): looking to replace: %s", __FUNCTION__, __LINE__, _options.adminupdatefile);
 
     if (!radius_getnextattr(pack, &attr,
 			    RADIUS_ATTR_VENDOR_SPECIFIC,
@@ -4314,13 +4609,13 @@
        */
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): using template temp file: %s", __FUNCTION__, __LINE__, template);
+        chilli_log(LOG_DEBUG, "%s(%d): using template temp file: %s", __FUNCTION__, __LINE__, template);
 
       int fd = mkstemp(template);
       if (fd > 0) {
         do {
           if (safe_write(fd, attr->v.t, attr->l - 2) < 0 || safe_write(fd, "\n", 1) < 0) {
-            syslog(LOG_ERR, "%s: adminupdatefile", strerror(errno));
+            chilli_log(LOG_ERR, "%s: adminupdatefile", strerror(errno));
             break;
            }
          }
@@ -4360,7 +4655,7 @@
 
 	  if (differ) {
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Writing out new hs.conf file with administraive-user settings", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): Writing out new hs.conf file with administraive-user settings", __FUNCTION__, __LINE__);
 
 	    oldfd = open(hs_conf, O_RDWR | O_TRUNC | O_CREAT, 0644);
 
@@ -4405,7 +4700,7 @@
   struct app_conn_t *appconn = (struct app_conn_t*) cbp;
 
   if (!appconn) {
-    syslog(LOG_ERR,"No peer protocol defined");
+    chilli_log(LOG_ERR,"No peer protocol defined");
     return 0;
   }
 
@@ -4449,7 +4744,7 @@
   struct dhcp_conn_t *dhcpconn = NULL;
 
   if (!appconn) {
-    syslog(LOG_ERR,"No peer protocol defined");
+    chilli_log(LOG_ERR,"No peer protocol defined");
     return 0;
   }
 
@@ -4467,7 +4762,7 @@
 #endif
 
   if (!pack) { /* Timeout */
-    syslog(LOG_ERR, "RADIUS request id=%d timed out for session %s",
+    chilli_log(LOG_ERR, "RADIUS request id=%d timed out for session %s",
            pack_req ? pack_req->id : -1,
            appconn->s_state.sessionid);
     if (_options.noradallow) {
@@ -4479,7 +4774,7 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Received RADIUS response id=%d", __FUNCTION__, __LINE__, pack->id);
+    chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS response id=%d", __FUNCTION__, __LINE__, pack->id);
 #endif
 
 
@@ -4493,14 +4788,14 @@
 #endif
       ) {
     if ((hisipattr->l-2) != sizeof(struct in_addr)) {
-      syslog(LOG_ERR, "Wrong length of framed IP address");
+      chilli_log(LOG_ERR, "Wrong length of framed IP address");
       return dnprot_reject(appconn);
     }
     force_ip = 1;
     hisip.s_addr = hisipattr->v.i;
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Framed IP address set to: %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
+      chilli_log(LOG_DEBUG, "%s(%d): Framed IP address set to: %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
 
     if (!radius_getattr(pack, &hisipattr, RADIUS_ATTR_FRAMED_IP_NETMASK, 0, 0, 0)
 #ifdef ENABLE_DHCPRADIUS
@@ -4511,13 +4806,13 @@
 #endif
 	) {
       if ((hisipattr->l-2) != sizeof(struct in_addr)) {
-	syslog(LOG_ERR, "Wrong length of framed IP netmask");
+	chilli_log(LOG_ERR, "Wrong length of framed IP netmask");
 	return dnprot_reject(appconn);
       }
       hismask.s_addr = hisipattr->v.i;
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Framed IP netmask set to: %s", __FUNCTION__, __LINE__, inet_ntoa(hismask));
+        chilli_log(LOG_DEBUG, "%s(%d): Framed IP netmask set to: %s", __FUNCTION__, __LINE__, inet_ntoa(hismask));
     }
   }
   else {
@@ -4537,8 +4832,8 @@
 	  memcpy(hwaddr, dhcpconn->hismac, sizeof(hwaddr));
 
           if (_options.debug) {
-            syslog(LOG_DEBUG, "%s(%d): Old ip address freed %s", __FUNCTION__, __LINE__, inet_ntoa(ipm->addr));
-            syslog(LOG_DEBUG, "%s(%d): Resetting ip address to %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
+            chilli_log(LOG_DEBUG, "%s(%d): Old ip address freed %s", __FUNCTION__, __LINE__, inet_ntoa(ipm->addr));
+            chilli_log(LOG_DEBUG, "%s(%d): Resetting ip address to %s", __FUNCTION__, __LINE__, inet_ntoa(hisip));
           }
 
 	  dhcp_freeconn(dhcpconn, 0);
@@ -4626,7 +4921,7 @@
   /* ACCESS-REJECT */
   if (pack->code == RADIUS_CODE_ACCESS_REJECT) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received RADIUS Access-Reject", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS Access-Reject", __FUNCTION__, __LINE__);
     config_radius_session(&appconn->s_params, pack, appconn, 0); /*XXX*/
     return dnprot_reject(appconn);
   }
@@ -4641,7 +4936,7 @@
   /* ACCESS-CHALLENGE */
   if (pack->code == RADIUS_CODE_ACCESS_CHALLENGE) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received RADIUS Access-Challenge", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS Access-Challenge", __FUNCTION__, __LINE__);
 
     /* Get EAP message */
     appconn->challen = 0;
@@ -4649,7 +4944,7 @@
       eapattr=NULL;
       if (!radius_getattr(pack, &eapattr, RADIUS_ATTR_EAP_MESSAGE, 0, 0, instance++)) {
 	if ((appconn->challen + eapattr->l-2) > MAX_EAP_LEN) {
-	  syslog(LOG_INFO, "EAP message too long %zu %d",
+	  chilli_log(LOG_INFO, "EAP message too long %zu %d",
                  appconn->challen, (int) eapattr->l-2);
 	  return dnprot_reject(appconn);
 	}
@@ -4659,7 +4954,7 @@
     } while (eapattr);
 
     if (!appconn->challen) {
-      syslog(LOG_INFO, "No EAP message found");
+      chilli_log(LOG_INFO, "No EAP message found");
       return dnprot_reject(appconn);
     }
 
@@ -4669,13 +4964,13 @@
 
   /* ACCESS-ACCEPT */
   if (pack->code != RADIUS_CODE_ACCESS_ACCEPT) {
-    syslog(LOG_ERR, "Unknown RADIUS code");
+    chilli_log(LOG_ERR, "Unknown RADIUS code");
     return dnprot_reject(appconn);
   }
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Received RADIUS Access-Accept", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS Access-Accept", __FUNCTION__, __LINE__);
 #endif
 
   if (!radius_getattr(pack, &uidattr, RADIUS_ATTR_USER_NAME, 0, 0, 0)) {
@@ -4686,7 +4981,7 @@
     }
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received User-Name override from RADIUS Access-Accept: %s", __FUNCTION__, __LINE__, appconn->s_state.redir.username);
+      chilli_log(LOG_DEBUG, "%s(%d): Received User-Name override from RADIUS Access-Accept: %s", __FUNCTION__, __LINE__, appconn->s_state.redir.username);
 #endif
   }
 
@@ -4694,10 +4989,10 @@
   if (!radius_getattr(pack, &classattr, RADIUS_ATTR_CLASS, 0, 0, 0)) {
     appconn->s_state.redir.classlen = classattr->l-2;
     memcpy(appconn->s_state.redir.classbuf, classattr->v.t, classattr->l-2);
-    /*syslog("!!!! CLASSLEN = %d !!!!", appconn->s_state.redir.classlen);*/
+    /*chilli_log("!!!! CLASSLEN = %d !!!!", appconn->s_state.redir.classlen);*/
   }
   else {
-    /*syslog("!!!! RESET CLASSLEN !!!!");*/
+    /*chilli_log("!!!! RESET CLASSLEN !!!!");*/
     appconn->s_state.redir.classlen = 0;
   }
 
@@ -4710,7 +5005,7 @@
 
   if (appconn->s_params.sessionterminatetime) {
     if (mainclock_rtdiff(appconn->s_params.sessionterminatetime) > 0) {
-      syslog(LOG_WARNING, "WISPr-Session-Terminate-Time in the past received, rejecting");
+      chilli_log(LOG_WARNING, "WISPr-Session-Terminate-Time in the past received, rejecting");
       return dnprot_reject(appconn);
     }
   }
@@ -4723,7 +5018,7 @@
     if (!radius_getattr(pack, &eapattr, RADIUS_ATTR_EAP_MESSAGE, 0, 0,
 			instance++)) {
       if ((appconn->challen + eapattr->l-2) > MAX_EAP_LEN) {
-	syslog(LOG_INFO, "EAP message too long %zu %d",
+	chilli_log(LOG_INFO, "EAP message too long %zu %d",
                appconn->challen, (int) eapattr->l-2);
 	return dnprot_reject(appconn);
       }
@@ -4742,7 +5037,7 @@
 			 (uint8_t *)&sendattr->v.t, sendattr->l-2,
 			 pack_req->authenticator,
 			 radius->secret, radius->secretlen)) {
-      syslog(LOG_ERR, "radius_keydecode() failed!");
+      chilli_log(LOG_ERR, "radius_keydecode() failed!");
       return dnprot_reject(appconn);
     }
   }
@@ -4755,7 +5050,7 @@
 			 (uint8_t *)&recvattr->v.t, recvattr->l-2,
 			 pack_req->authenticator,
 			 radius->secret, radius->secretlen) ) {
-      syslog(LOG_ERR, "radius_keydecode() failed!");
+      chilli_log(LOG_ERR, "radius_keydecode() failed!");
       return dnprot_reject(appconn);
     }
   }
@@ -4770,7 +5065,7 @@
 			&appconn->lmntlen, (uint8_t *)&lmntattr->v.t,
 			lmntattr->l-2, pack_req->authenticator,
 			radius->secret, radius->secretlen)) {
-      syslog(LOG_ERR, "radius_pwdecode() failed");
+      chilli_log(LOG_ERR, "radius_pwdecode() failed");
       return dnprot_reject(appconn);
     }
   }
@@ -4794,7 +5089,7 @@
 		      RADIUS_VENDOR_MS,
 		      RADIUS_ATTR_MS_CHAP2_SUCCESS, 0)) {
     if ((succattr->l-5) != MS2SUCCSIZE) {
-      syslog(LOG_ERR, "Wrong length of MS-CHAP2 success: %d", succattr->l-5);
+      chilli_log(LOG_ERR, "Wrong length of MS-CHAP2 success: %d", succattr->l-5);
       return dnprot_reject(appconn);
     }
     memcpy(appconn->ms2succ, ((void*)&succattr->v.t)+3, MS2SUCCSIZE);
@@ -4809,7 +5104,7 @@
 #ifdef ENABLE_RADPROXY
     case EAP_MESSAGE:
       if (!appconn->challen) {
-        syslog(LOG_INFO, "No EAP message found");
+        chilli_log(LOG_INFO, "No EAP message found");
         return dnprot_reject(appconn);
       }
       break;
@@ -4820,30 +5115,30 @@
 
     case CHAP_MICROSOFT:
       if (!lmntattr) {
-        syslog(LOG_INFO, "No MPPE keys found");
+        chilli_log(LOG_INFO, "No MPPE keys found");
         return dnprot_reject(appconn);
       }
       if (!succattr) {
-        syslog(LOG_ERR, "No MS-CHAP2 success found");
+        chilli_log(LOG_ERR, "No MS-CHAP2 success found");
         return dnprot_reject(appconn);
       }
       break;
 
     case CHAP_MICROSOFT_V2:
       if (!sendattr) {
-        syslog(LOG_INFO, "No MPPE sendkey found");
+        chilli_log(LOG_INFO, "No MPPE sendkey found");
         return dnprot_reject(appconn);
       }
 
       if (!recvattr) {
-        syslog(LOG_INFO, "No MPPE recvkey found");
+        chilli_log(LOG_INFO, "No MPPE recvkey found");
         return dnprot_reject(appconn);
       }
 
       break;
 
     default:
-      syslog(LOG_ERR, "Unknown authtype");
+      chilli_log(LOG_ERR, "Unknown authtype");
       return dnprot_reject(appconn);
   }
 
@@ -4864,12 +5159,12 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Received coa or disconnect request\n", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Received coa or disconnect request\n", __FUNCTION__, __LINE__);
 #endif
 
   if (pack->code != RADIUS_CODE_DISCONNECT_REQUEST &&
       pack->code != RADIUS_CODE_COA_REQUEST) {
-    syslog(LOG_ERR, "Radius packet not supported: %d,\n", pack->code);
+    chilli_log(LOG_ERR, "Radius packet not supported: %d,\n", pack->code);
     return -1;
   }
 
@@ -4877,22 +5172,22 @@
 
   /* Get username */
   if (radius_getattr(pack, &uattr, RADIUS_ATTR_USER_NAME, 0, 0, 0)) {
-    syslog(LOG_WARNING, "Username must be included in disconnect request");
+    chilli_log(LOG_WARNING, "Username must be included in disconnect request");
     return -1;
   }
 
   if (!radius_getattr(pack, &sattr, RADIUS_ATTR_ACCT_SESSION_ID, 0, 0, 0))
     if (_options.debug) {
-      syslog(LOG_DEBUG, "%s(%d): Session-id present in disconnect. Only disconnecting that session\n", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Session-id present in disconnect. Only disconnecting that session\n", __FUNCTION__, __LINE__);
 
-      syslog(LOG_DEBUG, "%s(%d): Looking for session [username=%.*s,sessionid=%.*s]", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Looking for session [username=%.*s,sessionid=%.*s]", __FUNCTION__, __LINE__,
              uattr->l-2, uattr->v.t, sattr ? sattr->l-2 : 3,
              sattr ? (char*)sattr->v.t : "all");
     }
 
   for (appconn = firstusedconn; appconn; appconn = appconn->next) {
 
-    if (!appconn->inuse) { syslog(LOG_ERR, "Connection with inuse == 0!"); }
+    if (!appconn->inuse) { chilli_log(LOG_ERR, "Connection with inuse == 0!"); }
 
     if (
             (strlen(appconn->s_state.redir.username) == uattr->l-2 &&
@@ -4903,7 +5198,7 @@
 
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Found session %s", __FUNCTION__, __LINE__, appconn->s_state.sessionid);
+        chilli_log(LOG_DEBUG, "%s(%d): Found session %s", __FUNCTION__, __LINE__, appconn->s_state.sessionid);
 #endif
 
       if (iscoa) {
@@ -4942,14 +5237,14 @@
   if (found) {
     if (radius_default_pack(radius, &radius_pack,
 			    iscoa ? RADIUS_CODE_COA_ACK : RADIUS_CODE_DISCONNECT_ACK)) {
-      syslog(LOG_ERR, "radius_default_pack() failed");
+      chilli_log(LOG_ERR, "radius_default_pack() failed");
       return -1;
     }
   }
   else {
     if (radius_default_pack(radius, &radius_pack,
 			    iscoa ? RADIUS_CODE_COA_NAK : RADIUS_CODE_DISCONNECT_NAK)) {
-      syslog(LOG_ERR, "radius_default_pack() failed");
+      chilli_log(LOG_ERR, "radius_default_pack() failed");
       return -1;
     }
   }
@@ -4961,6 +5256,70 @@
 }
 #endif
 
+static struct ippoolm_t* sms_auth_mac_authentication(struct app_conn_t *appconn) {
+  sqlite3 *db;
+
+  struct str_sms_user user = {0};
+  struct dhcp_conn_t *dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
+
+  if (!dhcpconn || !dhcpconn->hismac || !_options.usersdbpath)
+    return NULL;
+
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    chilli_log(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return NULL;
+  }
+
+  if (usr_sms_user_exists(db, NULL, dhcpconn->hismac) != USER_RET_ALREADY) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (usr_get_sms_user_phone(db, &user, NULL, dhcpconn->hismac)) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (user.username == NULL || user.username[0] == '\0' || user.used == 0) {
+    sqlclose(db);
+    return NULL;
+  }
+
+  if (_options.duplicateusers && find_active_user(user.username)) {
+    chilli_log(LOG_INFO, "%s(%d): Found duplication on username: %s", __FUNCTION__, __LINE__, user.username);
+    sqlclose(db);
+    return NULL;
+  }
+
+  appconn->s_state.redir.user_time = user.user_time;
+  appconn->s_state.redir.auth_mode = AUTH_SMS_USER;
+  strncpy(appconn->s_state.redir.username, user.username, USER_RAND_USERNAME_LEN);
+  strlcpy(appconn->s_state.redir.phone, user.phone, sizeof(appconn->s_state.redir.phone));
+  session_params_dyn(&appconn->s_params);
+
+  uint32_t timestamp = (uint32_t)mainclock_now();
+  usr_update_sms_user(db, &user, user.phone, dhcpconn->hismac, timestamp, NULL);
+  session_param_defaults(&appconn->s_params);
+
+#ifdef ENABLE_DATABASE
+  if ((appconn->s_params.maxinputoctets || appconn->s_params.maxoutputoctets ||
+      appconn->s_params.sessiontimeout) && dbcheck_session(appconn) != ACCESS_ACCEPTED) {
+    sqlclose(db);
+    return NULL;
+  }
+#endif
+
+  chilli_log(LOG_INFO, "Granted PHONE=%s MAC="MAC_FMT" with IP=%s access by MAC authentication",
+                 user.phone, MAC_ARG(dhcpconn->hismac), inet_ntoa(appconn->hisip));
+
+  memcpy(appconn->hismac, dhcpconn->hismac, PKT_ETH_ALEN);
+
+  upprot_getip(appconn, &appconn->reqip, 0);
+
+  sqlclose(db);
+  return (struct ippoolm_t*) appconn->uplink;
+}
+
 /***********************************************************
  *
  * dhcp callback functions
@@ -4978,12 +5337,12 @@
   char allocate = 1;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "%s(%d): DHCP request for IP address %s", __FUNCTION__, __LINE__,
+  chilli_log(LOG_DEBUG, "%s(%d): DHCP request for IP address %s", __FUNCTION__, __LINE__,
          addr ? inet_ntoa(*addr) : "n/a");
 #endif
 
   if (!appconn) {
-    syslog(LOG_ERR, "Peer protocol not defined");
+    chilli_log(LOG_ERR, "Peer protocol not defined");
     return -1;
   }
 
@@ -5005,7 +5364,7 @@
       /* clients with an IPv4LL ip normally have no default gw assigned, rendering uamanyip useless
 	 They must rather get a proper dynamic ip via dhcp */
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): IPv4LL/APIPA address requested, ignoring %s", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): IPv4LL/APIPA address requested, ignoring %s", __FUNCTION__, __LINE__,
                inet_ntoa(*addr));
       return -1;
     }
@@ -5038,7 +5397,7 @@
 	if (_options.macallowlocal) {
 	  char mac[MACSTRLEN+1];
 
-	  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+	  snprintf(mac, sizeof(mac), get_mac_format(), MAC_ARG(conn->hismac));
 
 	  strlcpy(appconn->s_state.redir.username, mac, USERNAMESIZE);
 
@@ -5053,7 +5412,7 @@
 	   */
 	  upprot_getip(appconn, &appconn->reqip, 0);
 
-	  syslog(LOG_INFO, "Granted MAC=%s with IP=%s access without radius auth",
+	  chilli_log(LOG_INFO, "Granted MAC=%s with IP=%s access without radius auth",
                  mac, inet_ntoa(appconn->hisip));
 
 	  ipm = (struct ippoolm_t*) appconn->uplink;
@@ -5063,7 +5422,11 @@
 	  /*
 	   *  Otherwise, authenticate with RADIUS.
 	   */
-	  auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	  if (_options.smsusers) {
+	    ipm = sms_auth_mac_authentication(appconn);
+	  } else {
+	    auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	  }
 
 	  allocate = !_options.strictmacauth;
 	  domacauth = 0;
@@ -5077,7 +5440,11 @@
 	 */
 	appconn->dnprot = DNPROT_MAC;
 
-	auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	if (_options.smsusers) {
+		ipm = sms_auth_mac_authentication(appconn);
+	} else {
+		auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+	}
 
 	allocate = !_options.strictmacauth;
 	domacauth = 0;
@@ -5085,13 +5452,16 @@
     }
   }
 
+  int ip_assigned = 1;
   if (!ipm) {
 
+    ip_assigned = 0;
+
     if (!allocate)
       return -1;
 
     if (appconn->dnprot != DNPROT_DHCP_NONE && appconn->hisip.s_addr) {
-      syslog(LOG_WARNING, "Requested IP address when already allocated (hisip %s)",
+      chilli_log(LOG_WARNING, "Requested IP address when already allocated (hisip %s)",
              inet_ntoa(appconn->hisip));
       appconn->reqip.s_addr = appconn->hisip.s_addr;
     }
@@ -5099,7 +5469,7 @@
     /* Allocate dynamic IP address */
     /* XXX  if (ippool_newip(ippool, &ipm, &appconn->reqip, 0)) {*/
     if (newip(&ipm, &appconn->reqip, conn->hismac)) {
-      syslog(LOG_ERR, "Failed allocate dynamic IP address");
+      chilli_log(LOG_ERR, "Failed allocate dynamic IP address");
       return -1;
     }
 
@@ -5107,7 +5477,7 @@
     appconn->hismask.s_addr = _options.mask.s_addr;
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Client MAC="MAC_FMT" assigned IP %s" , __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Client MAC="MAC_FMT" assigned IP %s" , __FUNCTION__, __LINE__,
              MAC_ARG(conn->hismac), inet_ntoa(appconn->hisip));
 
 #ifdef ENABLE_MODULES
@@ -5151,17 +5521,27 @@
 		   &_options.dns1, &_options.dns2);
   }
 
-  if (!appconn->s_state.authenticated) {
+  if (_options.macup && (mainclock.tv_sec - appconn->s_state.dhcp_last_time > 1 || !ip_assigned)) {
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Calling MAC up script: %s", __FUNCTION__, __LINE__, _options.macup);
+    runscript(appconn, _options.macup, 0, 0, !ip_assigned ? "1" : "0");
+  }
 
-    if (domacauth) {
-      auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+  if (!appconn->s_state.authenticated) {
+    if (domacauth && mainclock.tv_sec - appconn->s_state.dhcp_last_time > 1) {
+      if (_options.smsusers) {
+        sms_auth_mac_authentication(appconn);
+      } else {
+        auth_radius(appconn, 0, 0, dhcp_pkt, dhcp_len);
+      }
     }
 
     /* if not already authenticated, ensure DNAT authstate */
 #ifdef ENABLE_LAYER3
     if (!_options.layer3)
 #endif
-      conn->authstate = DHCP_AUTH_DNAT;
+      if (!appconn->s_state.authenticated)
+        conn->authstate = DHCP_AUTH_DNAT;
   }
 
   /* If IP was requested before authentication it was UAM */
@@ -5171,6 +5551,8 @@
   if (_options.dhcpnotidle)
     appconn->s_state.last_up_time = mainclock.tv_sec;
 
+  appconn->s_state.dhcp_last_time = mainclock.tv_sec;
+
   return 0;
 }
 
@@ -5180,12 +5562,12 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): New Chilli Connection", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): New Chilli Connection", __FUNCTION__, __LINE__);
 #endif
 
   /* Allocate new application connection */
   if (chilli_new_conn(appconn)) {
-    syslog(LOG_ERR, "Failed to allocate connection");
+    chilli_log(LOG_ERR, "Failed to allocate connection");
     return -1;
   }
 
@@ -5219,7 +5601,7 @@
   struct app_conn_t *appconn;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): New DHCP request from MAC="MAC_FMT, __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): New DHCP request from MAC="MAC_FMT, __FUNCTION__, __LINE__,
            MAC_ARG(conn->hismac));
 
   if (chilli_connect(&appconn, conn))
@@ -5229,12 +5611,6 @@
 
   conn->authstate = DHCP_AUTH_NONE; /* TODO: Not yet authenticated */
 
-  if (_options.macup) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Calling MAC up script: %s", __FUNCTION__, __LINE__, _options.macup);
-    runscript(appconn, _options.macup, 0, 0);
-  }
-
   return 0;
 }
 
@@ -5245,10 +5621,10 @@
 
   if (ippool_getip(ippool, &ipm, src)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): New Layer3 %s", __FUNCTION__, __LINE__, inet_ntoa(*src));
+      chilli_log(LOG_DEBUG, "%s(%d): New Layer3 %s", __FUNCTION__, __LINE__, inet_ntoa(*src));
     if (ippool_newip(ippool, &ipm, src, 1)) {
       if (ippool_newip(ippool, &ipm, src, 0)) {
-	syslog(LOG_ERR, "Failed to allocate either static or dynamic IP address");
+	chilli_log(LOG_ERR, "Failed to allocate either static or dynamic IP address");
 	return 0;
       }
     }
@@ -5256,14 +5632,14 @@
 
   if (!ipm) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): unknown ip", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): unknown ip", __FUNCTION__, __LINE__);
     return 0;
   }
 
   if ((appconn = (struct app_conn_t *)ipm->peer) == NULL) {
     if (chilli_getconn(&appconn, src->s_addr, 0, 0)) {
       if (chilli_connect(&appconn, conn)) {
-	syslog(LOG_ERR, "chilli_connect()");
+	chilli_log(LOG_ERR, "chilli_connect()");
 	return 0;
       }
     }
@@ -5279,20 +5655,23 @@
 }
 #endif
 
-#ifdef ENABLE_CHILLIQUERY
-static char *state2name(int authstate) {
-  switch(authstate) {
-    case DHCP_AUTH_NONE:   return "none";
-    case DHCP_AUTH_DROP:   return "drop";
-    case DHCP_AUTH_PASS:   return "pass";
-    case DHCP_AUTH_DNAT:   return "dnat";
-    case DHCP_AUTH_SPLASH: return "splash";
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_UBUS)
+char *state2name(int authstate) {
+	switch(authstate) {
+	case DHCP_AUTH_NONE:   return "none";
+	case DHCP_AUTH_DROP:   return "drop";
+	case DHCP_AUTH_PASS:   return "pass";
+	case DHCP_AUTH_DNAT:   return "dnat";
+	case DHCP_AUTH_SPLASH: return "splash";
 #ifdef ENABLE_LAYER3
-    case DHCP_AUTH_ROUTER: return "layer2";
+	case DHCP_AUTH_ROUTER: return "layer2";
 #endif
-    default:               return "unknown";
-  }
+	default:               return "unknown";
+	}
 }
+#endif
+
+#ifdef ENABLE_CHILLIQUERY
 
 int chilli_getinfo(struct app_conn_t *appconn, bstring b, int fmt) {
   uint32_t sessiontime = 0;
@@ -5374,6 +5753,11 @@
                       appconn->s_params.maxtotaloctets, _options.swapoctets);
         bconcat(b, tmp);
 
+        /* adding: warning-octets */
+        bassignformat(tmp, " %lld",
+                      appconn->s_params.warningoctets);
+        bconcat(b, tmp);
+
 #ifdef ENABLE_LEAKYBUCKET
         /* adding: max-bandwidth-up max-bandwidth-down */
         if (appconn->s_state.bucketupsize) {
@@ -5458,13 +5842,13 @@
           (!appconn || !appconn->inuse)) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Can not print info about unused chilli connection", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Can not print info about unused chilli connection", __FUNCTION__, __LINE__);
 #endif
     return;
   } else if (conn && !conn->inuse) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Can not print info about unused dhcp connection", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Can not print info about unused dhcp connection", __FUNCTION__, __LINE__);
 #endif
     return;
   } else {
@@ -5553,10 +5937,12 @@
       appconn->s_params.maxinputoctets =
       appconn->s_params.maxoutputoctets =
       appconn->s_params.maxtotaloctets =
+      appconn->s_params.warningoctets =
       appconn->s_params.sessiontimeout = 0;
   appconn->s_params.idletimeout = 0;
   appconn->s_params.interim_interval = 0;
   appconn->s_params.sessionterminatetime = 0;
+  appconn->s_params.expiration = 0;
 }
 
 int terminate_appconn(struct app_conn_t *appconn, int terminate_cause) {
@@ -5580,11 +5966,15 @@
       }
     }
 #endif
+#ifdef  ENABLE_DATABASE
+      dbconupdate(appconn);
+#endif
 
     if (_options.condown && !(appconn->s_params.flags & NO_SCRIPT)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Calling connection down script: %s\n", __FUNCTION__, __LINE__, _options.condown);
-      runscript(appconn, _options.condown, 0, 0);
+        chilli_log(LOG_DEBUG, "%s(%d): Calling connection down script: %s\n", __FUNCTION__, __LINE__, _options.condown);
+
+      runscript(appconn, _options.condown, 0, 0, NULL);
     }
 
     acct_req(ACCT_USER, appconn, RADIUS_STATUS_TYPE_STOP);
@@ -5605,11 +5995,11 @@
 int cb_dhcp_disconnect(struct dhcp_conn_t *conn, int term_cause) {
   struct app_conn_t *appconn;
 
-  syslog(LOG_INFO, "DHCP Released MAC="MAC_FMT" IP=%s",
+  chilli_log(LOG_INFO, "DHCP Released MAC="MAC_FMT" IP=%s",
          MAC_ARG(conn->hismac), inet_ntoa(conn->hisip));
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): DHCP connection removed", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): DHCP connection removed", __FUNCTION__, __LINE__);
 
   if (!conn->peer) {
     /* No appconn allocated. Stop here */
@@ -5622,6 +6012,8 @@
 
   appconn = (struct app_conn_t*) conn->peer;
 
+  send_ubus_event(g_ubus_event_ctx, CHILLI_EVENT_DISCONNECT, appconn, NULL);
+
   return session_disconnect(appconn, conn, term_cause);
 }
 
@@ -5631,7 +6023,7 @@
   struct pkt_ipphdr_t *ipph = pkt_ipphdr(pack);
 
   /*if (_options.debug)
-    syslog(LOG_DEBUG, "cb_dhcp_data_ind. Packet received. DHCP authstate: %d\n",
+    chilli_log(LOG_DEBUG, "cb_dhcp_data_ind. Packet received. DHCP authstate: %d\n",
     conn->authstate);*/
 
 #ifdef ENABLE_LEAKYBUCKET
@@ -5657,7 +6049,7 @@
 
       if (ippool_getip(ippool, &ipm, &addr)) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): unknown IP address: %s", __FUNCTION__, __LINE__, inet_ntoa(addr));
+          chilli_log(LOG_DEBUG, "%s(%d): unknown IP address: %s", __FUNCTION__, __LINE__, inet_ntoa(addr));
 	return -1;
       }
 
@@ -5666,7 +6058,7 @@
     if (!appconn)
 #endif
     {
-      syslog(LOG_ERR, "No peer protocol defined");
+      chilli_log(LOG_ERR, "No peer protocol defined");
       return -1;
     }
   }
@@ -5675,7 +6067,7 @@
     case DNPROT_NULL:
     case DNPROT_DHCP_NONE:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): NULL: %d", __FUNCTION__, __LINE__, appconn->dnprot);
+        chilli_log(LOG_DEBUG, "%s(%d): NULL: %d", __FUNCTION__, __LINE__, appconn->dnprot);
       return -1;
 
     case DNPROT_UAM:
@@ -5690,7 +6082,7 @@
       break;
 
     default:
-      syslog(LOG_ERR, "Unknown downlink protocol: %d", appconn->dnprot);
+      chilli_log(LOG_ERR, "Unknown downlink protocol: %d", appconn->dnprot);
       break;
   }
 
@@ -5702,7 +6094,7 @@
   if (_options.uamanyip && appconn->natip.s_addr) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): SNAT to: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->natip));
+      chilli_log(LOG_DEBUG, "%s(%d): SNAT to: %s", __FUNCTION__, __LINE__, inet_ntoa(appconn->natip));
 #endif
     ipph->saddr = appconn->natip.s_addr;
     if (chksum((struct pkt_iphdr_t *) ipph) < 0)
@@ -5761,7 +6153,7 @@
 #ifdef ENABLE_LEAKYBUCKET
       do_bw = 0;
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): !!!! Skipping leaky bucket because of authedallowed", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): !!!! Skipping leaky bucket because of authedallowed", __FUNCTION__, __LINE__);
 #endif
     }
 #endif
@@ -5782,7 +6174,7 @@
 #ifdef ENABLE_LEAKYBUCKET
 	do_bw = 0;
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): !!!! Skipping leaky bucket because of uamauthedallowed", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): !!!! Skipping leaky bucket because of uamauthedallowed", __FUNCTION__, __LINE__);
 #endif
       }
     }
@@ -5988,7 +6380,7 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): EAP Packet received", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): EAP Packet received", __FUNCTION__, __LINE__);
 #endif
 
   /* If this is the first EAPOL authentication request */
@@ -6004,20 +6396,20 @@
       appconn->authtype = EAP_MESSAGE;
     }
     else if (appconn->dnprot == DNPROT_DHCP_NONE) {
-      syslog(LOG_ERR, "Initial EAP response was not a valid identity response!");
+      chilli_log(LOG_ERR, "Initial EAP response was not a valid identity response!");
       return 0;
     }
   }
 
   /* Return if not EAPOL */
   if (appconn->dnprot != DNPROT_EAPOL) {
-    syslog(LOG_WARNING, "Received EAP message, processing for authentication");
+    chilli_log(LOG_WARNING, "Received EAP message, processing for authentication");
     appconn->dnprot = DNPROT_EAPOL;
     return 0;
   }
 
   if (radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REQUEST)) {
-    syslog(LOG_ERR, "radius_default_pack() failed");
+    chilli_log(LOG_ERR, "radius_default_pack() failed");
     return -1;
   }
 
@@ -6076,13 +6468,13 @@
 
   if (ippool_getip(ippool, &ipm, &msg->mdata.address.sin_addr)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): UAM login with unknown IP address: %s", __FUNCTION__, __LINE__, inet_ntoa(msg->mdata.address.sin_addr));
+      chilli_log(LOG_DEBUG, "%s(%d): UAM login with unknown IP address: %s", __FUNCTION__, __LINE__, inet_ntoa(msg->mdata.address.sin_addr));
     return 0;
   }
 
   if ((appconn  = (struct app_conn_t *)ipm->peer)        == NULL ||
       (dhcpconn = (struct dhcp_conn_t *)appconn->dnlink) == NULL) {
-    syslog(LOG_ERR, "No peer protocol defined");
+    chilli_log(LOG_ERR, "No peer protocol defined");
     return 0;
   }
 
@@ -6102,13 +6494,13 @@
 
     case REDIR_LOGIN:
       if (appconn->uamabort) {
-        syslog(LOG_INFO, "UAM login from username=%s IP=%s was aborted!",
+        chilli_log(LOG_INFO, "UAM login from username=%s IP=%s was aborted!",
 	       msg->mdata.redir.username, inet_ntoa(appconn->hisip));
         appconn->uamabort = 0;
         return 0;
       }
 
-      syslog(LOG_INFO, "Successful UAM login from username=%s IP=%s",
+      chilli_log(LOG_INFO, "Successful UAM login from username=%s IP=%s",
 	     msg->mdata.redir.username, inet_ntoa(appconn->hisip));
 
       /* Initialise */
@@ -6132,20 +6524,23 @@
 
     case REDIR_LOGOUT:
 
-      syslog(LOG_INFO, "Received UAM logoff from username=%s IP=%s",
+      chilli_log(LOG_INFO, "Received UAM logoff from username=%s IP=%s",
 	     appconn->s_state.redir.username, inet_ntoa(appconn->hisip));
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Received logoff from UAM", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Received logoff from UAM", __FUNCTION__, __LINE__);
 
       if (appconn->s_state.authenticated == 1) {
 #ifdef ENABLE_SESSIONSTATE
         appconn->s_state.session_state =
             RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
 #endif
+        appconn->s_state.terminate_cause_ui =
+                RADIUS_VALUE_COOVACHILLI_SESSION_USER_LOGOUT_URL;
         terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
         appconn->s_params.sessiontimeout = 0;
         appconn->s_params.idletimeout = 0;
+        appconn->s_params.expiration = 0;
       }
 
       appconn->uamabort = 0;
@@ -6160,7 +6555,7 @@
 
     case REDIR_ABORT:
 
-      syslog(LOG_INFO, "Received UAM abort from IP=%s", inet_ntoa(appconn->hisip));
+      chilli_log(LOG_INFO, "Received UAM abort from IP=%s", inet_ntoa(appconn->hisip));
 
       appconn->uamabort = 1; /* Next login will be aborted */
       appconn->s_state.uamtime = 0;  /* Force generation of new challenge */
@@ -6191,57 +6586,75 @@
   return 0;
 }
 
-#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
-static struct app_conn_t * find_app_conn(struct cmdsock_request *req,
-                                         int *has_criteria) {
-  struct app_conn_t *appconn = 0;
-  struct dhcp_conn_t *dhcpconn = 0;
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER) || defined(ENABLE_UBUS)
+struct app_conn_t * find_app_conn(struct cmdsock_request *req,
+								  int *has_criteria) {
+	struct app_conn_t *appconn = 0;
+	struct dhcp_conn_t *dhcpconn = 0;
+
+	if (req->ip.s_addr) {
+		appconn = dhcp_get_appconn_ip(0, &req->ip);
+		if (has_criteria)
+			*has_criteria = 1;
+	} 
 
-  if (req->ip.s_addr) {
-    appconn = dhcp_get_appconn_ip(0, &req->ip);
-    if (has_criteria)
-      *has_criteria = 1;
-  } else {
+	if (!appconn) {
 #ifdef ENABLE_LAYER3
-    if (!_options.layer3)
+		if (!_options.layer3)
 #endif
-      if (req->mac[0]||req->mac[1]||req->mac[2]||
-	  req->mac[3]||req->mac[4]||req->mac[5]) {
-	dhcp_hashget(dhcp, &dhcpconn, req->mac);
-	if (has_criteria)
-	  *has_criteria = 1;
-      }
-  }
+		if (req->mac[0]||req->mac[1]||req->mac[2]||
+			req->mac[3]||req->mac[4]||req->mac[5]) {
+			dhcp_hashget(dhcp, &dhcpconn, req->mac);
+			if (has_criteria)
+				*has_criteria = 1;
+		}
+	}
 
-  if (!appconn && dhcpconn
+	if (!appconn && dhcpconn
 #ifdef ENABLE_LAYER3
-      && !_options.layer3
+		&& !_options.layer3
 #endif
-      )
-    appconn = (struct app_conn_t *) dhcpconn->peer;
+			)
+		appconn = (struct app_conn_t *) dhcpconn->peer;
 
-  if (!appconn && req->d.sess.sessionid[0] != 0) {
-    struct app_conn_t *aconn = firstusedconn;
-    if (has_criteria)
-      *has_criteria = 1;
-    while (aconn) {
-      if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
-	appconn = aconn;
-	break;
-      }
-      aconn = aconn->next;
-    }
-  }
+	if (!appconn && req->d.sess.sessionid[0] != 0) {
+		struct app_conn_t *aconn = firstusedconn;
+		if (has_criteria)
+			*has_criteria = 1;
+		while (aconn) {
+			if (!strcmp(aconn->s_state.sessionid, req->d.sess.sessionid)) {
+				appconn = aconn;
+				break;
+			}
+			aconn = aconn->next;
+		}
+	}
 
-  if (appconn && !appconn->inuse) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
-    return 0;
-  }
+	if (appconn && !appconn->inuse) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): appconn not in use!", __FUNCTION__, __LINE__);
+		return 0;
+	}
 
-  return appconn;
+	return appconn;
 }
+#endif
+
+int find_active_user(char *username)
+{
+  struct app_conn_t *appconn = firstusedconn;
+  int match = 0;
+  while (appconn) { 
+    if (strcmp(appconn->s_state.redir.username, username) == 0 && appconn->s_state.authenticated == 1) {
+      match = 1;
+      break;
+    }
+    appconn = appconn->next;
+  }
+  return match;
+} 
 
+#if defined(ENABLE_CHILLIQUERY) || defined(ENABLE_CLUSTER)
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock) {
 
 #ifdef HAVE_NETFILTER_COOVA
@@ -6261,7 +6674,7 @@
         memset(z, 0, PKT_ETH_ALEN);
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): looking to inspect ip=%s/mac="MAC_FMT, __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): looking to inspect ip=%s/mac="MAC_FMT, __FUNCTION__, __LINE__,
                  inet_ntoa(req->ip), MAC_ARG(req->mac));
 
         if (req->ip.s_addr)
@@ -6275,7 +6688,7 @@
         if (!appconn && !dhcpconn) {
 
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): not found", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): not found", __FUNCTION__, __LINE__);
 
         } else {
 
@@ -6482,6 +6895,14 @@
             bconcat(s, tmp);
           }
 
+          if (appconn->s_params.warningoctets) {
+            bassignformat(tmp,
+                          "%20s: %lld\n",
+                          "warning octets in",
+                          appconn->s_params.warningoctets);
+            bconcat(s, tmp);
+          }
+
 #ifdef ENABLE_GARDENACCOUNTING
           if (_options.uamgardendata) {
             bassignformat(tmp,
@@ -6669,7 +7090,7 @@
         memset(z, 0, PKT_ETH_ALEN);
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): looking to %s to garden ip=%s/sessionid=%s", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): looking to %s to garden ip=%s/sessionid=%s", __FUNCTION__, __LINE__,
                  remove ? "remove" : "add", inet_ntoa(req->ip), req->d.sess.sessionid);
 
         if (req->ip.s_addr || memcmp(req->mac, z, PKT_ETH_ALEN)) {
@@ -6682,7 +7103,7 @@
                   ) ) {
 
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): remote %s garden for session %s", __FUNCTION__, __LINE__,
+                chilli_log(LOG_DEBUG, "%s(%d): remote %s garden for session %s", __FUNCTION__, __LINE__,
                        remove ? "rem" : "add", appconn->s_state.sessionid);
 
 #ifdef HAVE_PATRICIA
@@ -6723,12 +7144,12 @@
         struct app_conn_t *appconn = find_app_conn(req, 0);
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
                  inet_ntoa(req->ip));
 
         if (appconn) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
                    inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
 
           terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_ADMIN_RESET);
@@ -6844,18 +7265,18 @@
       {
         if (req->type == CMDSOCK_ROUTE_GW) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): setting route for idx %d", __FUNCTION__, __LINE__, req->d.sess.params.routeidx);
+            chilli_log(LOG_DEBUG, "%s(%d): setting route for idx %d", __FUNCTION__, __LINE__, req->d.sess.params.routeidx);
           copy_mac6(tun(tun, req->d.sess.params.routeidx).gwaddr, req->mac);
         } else {
           struct dhcp_conn_t *conn = dhcp->firstusedconn;
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): looking to alter session %s", __FUNCTION__, __LINE__, inet_ntoa(req->ip));
+            chilli_log(LOG_DEBUG, "%s(%d): looking to alter session %s", __FUNCTION__, __LINE__, inet_ntoa(req->ip));
           while (conn && conn->inuse) {
             if (conn->peer) {
               struct app_conn_t * appconn = (struct app_conn_t*)conn->peer;
               if (!memcmp(appconn->hismac, req->mac, 6)) {
                 if (_options.debug)
-                  syslog(LOG_DEBUG, "%s(%d): routeidx %s %d", __FUNCTION__, __LINE__,
+                  chilli_log(LOG_DEBUG, "%s(%d): routeidx %s %d", __FUNCTION__, __LINE__,
                          appconn->s_state.sessionid,
                          req->d.sess.params.routeidx);
                 appconn->s_params.routeidx = req->d.sess.params.routeidx;
@@ -6924,9 +7345,10 @@
         struct app_conn_t *appconn = find_app_conn(req, 0);
         if (appconn) {
           char *uname = req->d.sess.username;
+          char *uurl = req->d.sess.userurl;
 
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): remotely authorized session %s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): remotely authorized session %s", __FUNCTION__, __LINE__,
                    appconn->s_state.sessionid);
 
           memcpy(&appconn->s_params, &req->d.sess.params,
@@ -6936,6 +7358,10 @@
             strlcpy(appconn->s_state.redir.username,
                     uname, USERNAMESIZE);
 
+          if (uurl[0])
+            strlcpy(appconn->s_state.redir.userurl,
+                    uurl, REDIR_USERURLSIZE);
+
           session_param_defaults(&appconn->s_params);
 
 #ifdef ENABLE_LEAKYBUCKET
@@ -6944,12 +7370,35 @@
 
           switch(req->type) {
             case CMDSOCK_LOGIN:
-              auth_radius(appconn, uname, req->d.sess.password, 0, 0);
+              if (_options.localusers) {
+                if (authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                  session_param_defaults(&appconn->s_params);
+                  dnprot_accept(appconn);
+                } else if (_options.registerusers) {
+                  if (dynamic_user_authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                    dnprot_accept(appconn);
+                  }
+                }
+              } else if (_options.smsusers) {
+                if (sms_user_authenticator_chilli(appconn, (uint8_t *) req->d.sess.password) == ACCESS_ACCEPTED) {
+                  session_param_defaults(&appconn->s_params);
+                  dnprot_accept(appconn);
+                }
+              } else if (_options.macusers) {
+                if (mac_user_authenticator_chilli(appconn, (uint8_t *)req->d.sess.password) == ACCESS_ACCEPTED) {
+                  dnprot_accept(appconn);
+                }
+              } else {
+                auth_radius(appconn, uname, req->d.sess.password, 0, 0);
+              }
               break;
             case CMDSOCK_AUTHORIZE:
               dnprot_accept(appconn);
               break;
             case CMDSOCK_UPDATE:
+              if (_options.conrestart) {
+                runscript(appconn, _options.conrestart, 0, 0, NULL);
+              }
               break;
           }
         }
@@ -7012,7 +7461,7 @@
         }
 #endif
         if (unknown) {
-          syslog(LOG_ERR, "unknown cmdsock command");
+          chilli_log(LOG_ERR, "unknown cmdsock command");
           safe_close(sock);
           return -1;
         }
@@ -7035,24 +7484,24 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Processing cmdsock request...", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Processing cmdsock request...", __FUNCTION__, __LINE__);
 #endif
 
   len = sizeof(remote);
   if ((csock = safe_accept(sock, (struct sockaddr *)&remote, &len)) == -1) {
-    syslog(LOG_ERR, "%s: cmdsock_accept()/accept()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: cmdsock_accept()/accept()", strerror(errno));
     return -1;
   }
 
   if (safe_read(csock, &req, sizeof(req)) != sizeof(req)) {
-    syslog(LOG_ERR, "%s: cmdsock_accept()/read()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: cmdsock_accept()/read()", strerror(errno));
     safe_close(csock);
     return -1;
   }
 
   s = bfromcstr("");
   if (s == NULL) {
-    syslog(LOG_ERR, "bfromstr(): memory allocation error");
+    chilli_log(LOG_ERR, "bfromstr(): memory allocation error");
     safe_close(csock);
     return -1;
   }
@@ -7060,7 +7509,7 @@
   rval = chilli_cmd(&req, s, csock);
 
   if (net_write(csock, s->data, s->slen) < 0)
-    syslog(LOG_ERR, "%s: write()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
   bdestroy(s);
   shutdown(csock, 2);
@@ -7070,6 +7519,17 @@
 }
 #endif
 
+#ifdef ENABLE_UBUS
+static int ubus_sock_accept(void *ctx, int sock)
+{
+  struct ubus_context *uctx = (struct ubus_context *)ctx;
+
+  ubus_handle_event(uctx);
+
+  return 0;
+}
+#endif
+
 #if XXX_IO_DAEMON
 int chilli_io(int fd_ctrl_r, int fd_ctrl_w, int fd_pkt_r, int fd_pkt_w) {
   int maxfd = 0;
@@ -7086,7 +7546,7 @@
 
     if  ((status = select(maxfd + 1, &fds, NULL, NULL, NULL)) == -1) {
       if (EINTR != errno) {
-	syslog(LOG_ERR, "select() returned -1!");
+	chilli_log(LOG_ERR, "select() returned -1!");
       }
     }
 
@@ -7100,7 +7560,7 @@
       if (fd_isset(fd_pkt_w, &fds)) {
       }
     } else {
-      syslog(LOG_ERR, "%s: problem in select", strerror(errno));
+      chilli_log(LOG_ERR, "%s: problem in select", strerror(errno));
       break;
     }
   }
@@ -7126,16 +7586,16 @@
 			      &msg.mdata.baddress,
 			      &conn) != -1) {
 	  if (safe_write(socket, &conn, sizeof(conn)) < 0) {
-	    syslog(LOG_ERR, "%s: redir_msg writing", strerror(errno));
+	    chilli_log(LOG_ERR, "%s: redir_msg writing", strerror(errno));
 	  }
 	}
       } else {
 	uam_msg(&msg);
       }
     } else if (msgresult == -1) {
-      syslog(LOG_ERR, "%s: redir_msg read", strerror(errno));
+      chilli_log(LOG_ERR, "%s: redir_msg read", strerror(errno));
     } else {
-      syslog(LOG_ERR, "invalid size %d", msgresult);
+      chilli_log(LOG_ERR, "invalid size %d", msgresult);
     }
     safe_close(socket);
   }
@@ -7177,7 +7637,7 @@
 
 static int rtmon_accept(struct rtmon_t *rtmon, int idx) {
   if (rtmon_read_event(rtmon))
-    syslog(LOG_ERR, "%s: error reading netlink message", strerror(errno));
+    chilli_log(LOG_ERR, "%s: error reading netlink message", strerror(errno));
   return 0;
 }
 #endif
@@ -7190,7 +7650,11 @@
     if (conn->is_reserved && conn->peer) {
       appconn = (struct app_conn_t *)conn->peer;
       if (!appconn->s_state.authenticated) {
-	auth_radius((struct app_conn_t *)conn->peer, 0, 0, 0, 0);
+        if (_options.smsusers) {
+          sms_auth_mac_authentication((struct app_conn_t *)conn->peer);
+        } else {
+          auth_radius((struct app_conn_t *)conn->peer, 0, 0, 0, 0);
+        }
       }
     }
     conn = conn->next;
@@ -7207,7 +7671,7 @@
     if (mainclock_diff(check_conn->s_state.last_up_time) >
 	_options.lease + _options.leaseplus) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Session timeout: Removing connection", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Session timeout: Removing connection", __FUNCTION__, __LINE__);
       session_disconnect(check_conn, 0, RADIUS_TERMINATE_CAUSE_LOST_CARRIER);
     }
   }
@@ -7216,6 +7680,12 @@
 }
 #endif
 
+static void signal_handler(int signum)
+{
+	(void)signum;
+	tun_runscript(tun, _options.ipup, 0);
+}
+
 int chilli_main(int argc, char **argv) {
   select_ctx sctx;
   int status;
@@ -7249,18 +7719,18 @@
   int keep_going = 1;
   int reload_config = 0;
 
-  int syslog_options = LOG_PID;
-  int syslog_debug_options = 0;
-  char *syslog_ident = NULL;
+  int chilli_log_options = LOG_PID;
+  int chilli_log_debug_options = 0;
+  char *chilli_log_ident = NULL;
 
 #ifdef LOG_PERROR
-  syslog_debug_options = LOG_PERROR;
+  chilli_log_debug_options = LOG_PERROR;
 #endif
 
-  syslog_ident = basename(argv[0]);
+  chilli_log_ident = basename(argv[0]);
 
   /* Start out also logging to stderr until we load options. */
-  openlog(syslog_ident, syslog_options|syslog_debug_options, LOG_DAEMON);
+  openlog(chilli_log_ident, chilli_log_options|chilli_log_debug_options, LOG_DAEMON);
 
   options_init();
 
@@ -7273,19 +7743,19 @@
   if (!_options.foreground) {
     FILE *fp = NULL;
     if (!(fp = freopen("/dev/null", "w", stdout))) {
-      syslog(LOG_ERR, "freopen()");
+      chilli_log(LOG_ERR, "freopen()");
     } else {
       fclose(fp);
       fp = NULL;
     }
     if (!(fp = freopen("/dev/null", "w", stderr))) {
-      syslog(LOG_ERR, "freopen()");
+      chilli_log(LOG_ERR, "freopen()");
     } else {
       fclose(fp);
       fp = NULL;
     }
     if (!(fp = freopen("/dev/null", "r", stdin))) {
-      syslog(LOG_ERR, "freopen()");
+      chilli_log(LOG_ERR, "freopen()");
     } else {
       fclose(fp);
       fp = NULL;
@@ -7295,7 +7765,7 @@
       exit(0);
 #else
       if (daemon(1, 1)) {
-        syslog(LOG_ERR, "daemon() failed!");
+        chilli_log(LOG_ERR, "daemon() failed!");
 #endif
       }
       else {
@@ -7333,7 +7803,7 @@
         ok = options_save(file2, bt);
 
         if (!ok) {
-          syslog(LOG_ERR, "%s: could not save configuration options! [%s]", strerror(errno), file2);
+          chilli_log(LOG_ERR, "%s: could not save configuration options! [%s]", strerror(errno), file2);
           exit(1);
         }
 
@@ -7346,7 +7816,7 @@
         bdestroy(bt);
 
         if (!options_binload(file2)) {
-          syslog(LOG_ERR, "%s: could not reload configuration! [%s]", strerror(errno), file2);
+          chilli_log(LOG_ERR, "%s: could not reload configuration! [%s]", strerror(errno), file2);
           exit(1);
         }
       }
@@ -7358,10 +7828,12 @@
 #endif
 
     closelog();
+    chilli_log_options |= chilli_log_debug_options;
+	if (logger_init(L_SYSTEM, L_TYPE_SYSLOG | L_SYSLOG_LEVELS, "coova-chilli") < 0) {
+		fprintf(stderr, "Failed to initialize logger\n");
+		return 1;
+	}
 
-    if (_options.debug)
-      syslog_options |= syslog_debug_options;
-    openlog(syslog_ident, syslog_options, (_options.logfacility<<3));
     if (!_options.debug)
       setlogmask(LOG_UPTO(_options.loglevel));
 
@@ -7389,6 +7861,16 @@
     /* This has to be done after we have our final pid */
     log_pid((_options.pidfile && *_options.pidfile) ? _options.pidfile : DEFPIDFILE);
 
+    cap_t caps = cap_get_proc();
+    cap_value_t newcaps[2] = { CAP_NET_ADMIN, CAP_NET_RAW };
+    if (cap_set_flag(caps, CAP_INHERITABLE, 2, newcaps, CAP_SET) == -1) {
+      chilli_log(LOG_ERR, "Failed to set inheritable capabilities: %s", strerror(errno));
+    }
+    if (cap_set_proc(caps) == -1) {
+      chilli_log(LOG_ERR, "Failed to process inheritable capabilities: %s", strerror(errno));
+    }
+    cap_free(caps);
+
 #ifdef ENABLE_UAMANYIP
     /* setup IPv4LL/APIPA network ip and mask for uamanyip exception */
     inet_aton("169.254.0.0", &ipv4ll_ip);
@@ -7398,7 +7880,8 @@
     ssdp.s_addr = inet_addr(SSDP_MCAST_ADDR);
 #endif
 
-    syslog(LOG_INFO, "CoovaChilli %s. "
+    alter_tables();
+    chilli_log(LOG_INFO, "CoovaChilli %s. "
            "Copyright 2002-2005 Mondru AB. Licensed under GPL. "
            "Copyright 2006-2012 David Bird (Coova Technologies). "
            "Licensed under GPL. "
@@ -7410,16 +7893,16 @@
     memset(&startup_real, 0, sizeof(startup_real));
     memset(&startup_mono, 0, sizeof(startup_mono));
     if (clock_gettime(CLOCK_REALTIME, &startup_real) < 0) {
-      syslog(LOG_ERR, "%s: getting startup (realtime) time", strerror(errno));
+      chilli_log(LOG_ERR, "%s: getting startup (realtime) time", strerror(errno));
     }
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): clock realtime sec %ld nsec %ld", __FUNCTION__, __LINE__, startup_real.tv_sec, startup_real.tv_nsec);
+      chilli_log(LOG_DEBUG, "%s(%d): clock realtime sec %ld nsec %ld", __FUNCTION__, __LINE__, startup_real.tv_sec, startup_real.tv_nsec);
 #ifdef CLOCK_MONOTONIC
     if (clock_gettime(CLOCK_MONOTONIC, &startup_mono) < 0) {
-      syslog(LOG_ERR, "%s: getting startup (monotonic) time", strerror(errno));
+      chilli_log(LOG_ERR, "%s: getting startup (monotonic) time", strerror(errno));
     }
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): clock monotonic sec %ld nsec %ld", __FUNCTION__, __LINE__, startup_mono.tv_sec, startup_mono.tv_nsec);
+      chilli_log(LOG_DEBUG, "%s(%d): clock monotonic sec %ld nsec %ld", __FUNCTION__, __LINE__, startup_mono.tv_sec, startup_mono.tv_nsec);
 #endif
 #endif
 
@@ -7427,7 +7910,7 @@
 
     /* Create a tunnel interface */
     if (tun_new(&tun)) {
-      syslog(LOG_ERR, "Failed to create tun");
+      chilli_log(LOG_ERR, "Failed to create tun");
       exit(1);
     }
 
@@ -7438,8 +7921,13 @@
 
     tun_set_cb_ind(tun, cb_tun_ind);
 
-    if (_options.ipup)
+    if (_options.ipup) {
       tun_runscript(tun, _options.ipup, 0);
+      // Firewall rule reinitialization signal handler
+      struct sigaction action = { 0 };
+      action.sa_handler	= signal_handler;
+      sigaction(SIGUSR1, &action, NULL);
+    }
 
     /* Allocate ippool for dynamic IP address allocation */
     if (ippool_new(&ippool,
@@ -7449,7 +7937,7 @@
                    _options.statip,
                    _options.allowdyn,
                    _options.allowstat)) {
-      syslog(LOG_ERR, "Failed to allocate IP pool!");
+      chilli_log(LOG_ERR, "Failed to allocate IP pool!");
       exit(1);
     }
 
@@ -7463,10 +7951,15 @@
                  &_options.dhcplisten, _options.lease, 1,
                  &_options.uamlisten, _options.uamport,
                  _options.noc2c)) {
-      syslog(LOG_ERR, "Failed to create dhcp listener on %s", _options.dhcpif);
+      chilli_log(LOG_ERR, "Failed to create dhcp listener on %s", _options.dhcpif);
       exit(1);
     }
 
+    g_ubus_event_ctx = ubus_connect(NULL);
+    if (!g_ubus_event_ctx) {
+      chilli_log(LOG_ERR, "Failed to set up ubus for event sending");
+    }
+
     dhcp_set_cb_request(dhcp, cb_dhcp_request);
     dhcp_set_cb_connect(dhcp, cb_dhcp_connect);
     dhcp_set_cb_disconnect(dhcp, cb_dhcp_disconnect);
@@ -7478,7 +7971,7 @@
     if (dhcp_set(dhcp,
                  _options.ethers,
                  (_options.debug & DEBUG_DHCP))) {
-      syslog(LOG_ERR, "Failed to set DHCP parameters");
+      chilli_log(LOG_ERR, "Failed to set DHCP parameters");
       exit(1);
     }
 
@@ -7488,7 +7981,7 @@
                    _options.coaport,
                    _options.coanoipcheck, 1) ||
         radius_init_q(radius, _options.radiusqsize)) {
-      syslog(LOG_ERR, "Failed to create radius");
+      chilli_log(LOG_ERR, "Failed to create radius");
       return -1;
     }
 
@@ -7517,17 +8010,17 @@
                   0
 #endif
                   )) {
-      syslog(LOG_ERR, "Failed to create redir");
+      chilli_log(LOG_ERR, "Failed to create redir");
       return -1;
     }
 
     if (!_options.redir && redir_listen(redir)) {
-      syslog(LOG_ERR, "Failed to create redir listen");
+      chilli_log(LOG_ERR, "Failed to create redir listen");
       return -1;
     }
 
     if (redir_ipc(redir)) {
-      syslog(LOG_ERR, "Failed to create redir IPC");
+      chilli_log(LOG_ERR, "Failed to create redir IPC");
       return -1;
     }
 
@@ -7543,23 +8036,31 @@
       cmdsock = cmdsock_port_init();
     }
     if (cmdsock < 0) {
-      syslog(LOG_ERR, "%s: Failed to initialize chilli query socket", strerror(errno));
+      chilli_log(LOG_ERR, "%s: Failed to initialize chilli query socket", strerror(errno));
       return -1;
     }
 #endif
+#ifdef ENABLE_UBUS
+    ubus_ctx = ubus_connect(NULL);
+	if (!ubus_ctx) {
+		chilli_log(LOG_ERR, "Failed to connect to ubus, exiting...");
+	}
+#endif
+
+
 
     if (_options.radsec) {
 #ifdef ENABLE_CHILLIRADSEC
       launch_chilliradsec();
 #else
-      syslog(LOG_ERR, "Feature is not supported; use --enable-chilliradsec");
+      chilli_log(LOG_ERR, "Feature is not supported; use --enable-chilliradsec");
       _options.radsec = 0;
 #endif
     } else if (_options.uamaaaurl) {
 #ifdef ENABLE_CHILLIPROXY
       launch_chilliproxy();
 #else
-      syslog(LOG_ERR, "Feature is not supported; use --enable-chilliproxy");
+      chilli_log(LOG_ERR, "Feature is not supported; use --enable-chilliproxy");
 #endif
     }
 
@@ -7567,14 +8068,14 @@
 #ifdef ENABLE_CHILLIREDIR
       launch_chilliredir();
 #else
-      syslog(LOG_ERR, "Feature is not supported; use --enable-chilliredir");
+      chilli_log(LOG_ERR, "Feature is not supported; use --enable-chilliredir");
       _options.redir = 0;
 #endif
     }
 
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Waiting for client request...", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Waiting for client request...", __FUNCTION__, __LINE__);
 #endif
 
     /*
@@ -7625,17 +8126,17 @@
     /******************************************************************/
 
     if (_options.gid && setgid(_options.gid)) {
-      syslog(LOG_ERR, "%d setgid(%d) failed while running with gid = %d",
+      chilli_log(LOG_ERR, "%d setgid(%d) failed while running with gid = %d",
              errno, _options.gid, getgid());
     }
 
     if (_options.uid && setuid(_options.uid)) {
-      syslog(LOG_ERR, "%d setuid(%d) failed while running with uid = %d",
+      chilli_log(LOG_ERR, "%d setuid(%d) failed while running with uid = %d",
              errno, _options.uid, getuid());
     }
 
     if (net_select_init(&sctx))
-      syslog(LOG_ERR, "%s: select init", strerror(errno));
+      chilli_log(LOG_ERR, "%s: select init", strerror(errno));
 
 #ifdef ENABLE_MULTIROUTE
     tun->sctx = &sctx;
@@ -7714,10 +8215,25 @@
 #ifdef ENABLE_CHILLIQUERY
     net_select_reg(&sctx, cmdsock, SELECT_READ,
                    (select_callback)cmdsock_accept, 0, cmdsock);
+
+#endif
+#ifdef ENABLE_UBUS
+    net_select_reg(&sctx, ubus_ctx->sock.fd, SELECT_READ,
+                   (select_callback)ubus_sock_accept, ubus_ctx, ubus_ctx->sock.fd);
+    chilli_ubus_add_obj(ubus_ctx);
+    
+    /* subscribe to hostapd to listen for dissasoc calls. */
+    chilli_ubus_subscribe_hostapd(ubus_ctx, _options);
+
 #endif
 
     mainclock_tick();
-    while (keep_going) {
+#ifdef ENABLE_DATABASE
+    chilli_log(LOG_INFO, "[%s] Checking data base %s", __FUNCTION__, sqlite3_libversion());
+    dbcheck_table();
+#endif
+
+  while (keep_going) {
 
       if (reload_config) {
 
@@ -7780,7 +8296,7 @@
       }
 
       if (net_select_prepare(&sctx))
-        syslog(LOG_ERR, "%s: select prepare", strerror(errno));
+        chilli_log(LOG_ERR, "%s: select prepare", strerror(errno));
 
       status = net_select(&sctx);
 
@@ -7790,7 +8306,7 @@
       if ((msgresult =
            TEMP_FAILURE_RETRY(msgrcv(redir->msgid, (void *)&msg, sizeof(msg.mdata), 0, IPC_NOWAIT)))  == -1) {
         if ((errno != EAGAIN) && (errno != ENOMSG))
-          syslog(LOG_ERR, "%s: msgrcv() failed!", strerror(errno));
+          chilli_log(LOG_ERR, "%s: msgrcv() failed!", strerror(errno));
       }
 
       if (msgresult > 0)
@@ -7819,20 +8335,20 @@
 
     } /* while(keep_going) */
 
-    syslog(LOG_INFO, "CoovaChilli shutting down");
+    chilli_log(LOG_INFO, "CoovaChilli shutting down");
 
     if (_options.seskeepalive) {
 #ifdef ENABLE_BINSTATFILE
       if (printstatus() != 0)
-        syslog(LOG_ERR, "%s: could not save status file", strerror(errno));
+        chilli_log(LOG_ERR, "%s: could not save status file", strerror(errno));
 #else
-      syslog(LOG_WARNING, "Not stopping sessions! seskeepalive should be used with compile option --enable-binstatusfile");
+      chilli_log(LOG_WARNING, "Not stopping sessions! seskeepalive should be used with compile option --enable-binstatusfile");
 #endif
     } else {
       killconn();
 #ifdef ENABLE_STATFILE
       if (printstatus() != 0)
-        syslog(LOG_ERR, "%s: could not save status file", strerror(errno));
+        chilli_log(LOG_ERR, "%s: could not save status file", strerror(errno));
 #endif
     }
 
@@ -7856,6 +8372,9 @@
     if (ippool)
       ippool_free(ippool);
 
+    if (g_ubus_event_ctx)
+      ubus_free(g_ubus_event_ctx);
+
     /*
      *  Terminate not-so-nicely
      */
@@ -7863,6 +8382,10 @@
 #ifdef ENABLE_CHILLIQUERY
     cmdsock_shutdown();
 #endif
+#ifdef ENABLE_UBUS
+	chilli_ubus_remove_obj(ubus_ctx);	//Workaround (?) Protection from Huawei
+    ubus_free(ubus_ctx);
+#endif
 
 #ifdef ENABLE_CHILLIREDIR
     if (redir_pid > 0) {
@@ -7892,3 +8415,14 @@
 
     return 0;
   }
+
+void chilli_log(int priority, const char* format, ...) {
+    va_list args;
+    char printbuf[1024];
+
+    va_start(args, format);
+    vsnprintf(printbuf, sizeof(printbuf), format, args);
+    va_end(args);
+
+    _log(priority, "%s", printbuf);
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli.h src/src/chilli.h
--- upstream/src/chilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli.h	2025-11-06 13:20:13.000000000 +0000
@@ -21,6 +21,8 @@
 #ifndef _CHILLI_H
 #define _CHILLI_H
 
+#include <sys/capability.h>
+#include <tlt_logger.h>
 #include "system.h"
 #include "debug.h"
 #include "chilli_limits.h"
@@ -35,11 +37,33 @@
 #include "net.h"
 #include "md5.h"
 #include "dns.h"
+#include "sqlite.h"
+#include "ubus.h"
+#ifdef  ENABLE_DATABASE
+#include "database.h"
+#endif
+#ifdef  USING_CURL
+#include "oauth2.h"
+#endif
+#include "users.h"
+#ifdef ENABLE_GSM
+#include "gsm.h"
+#endif
+#ifdef HAVE_OPENSSL
+#include "passwd_md5crypt.h"
+#include "passwd_shacrypt.h"
+#endif
 
 #ifndef HAVE_STRLCPY
 extern size_t strlcpy(char *dst, const char *src, size_t dsize);
 #endif
 
+#ifdef ENABLE_UBUS
+  struct ubus_context *ubus_ctx;
+#endif
+
+void chilli_log(int priority, const char* format, ...);
+
 /*#define XXX_IO_DAEMON 1*/
 
 /* Authtype defs */
@@ -70,6 +94,8 @@
 #define DEBUG_REDIR       8
 #define DEBUG_CONF       16
 
+#define WARNING_FMT "You're about to reach your %s data limit, %.1f %s left.\n"
+
 /* Struct information for each connection */
 struct app_conn_t {
 
@@ -102,6 +128,11 @@
 
   struct session_params s_params;         /* Session parameters */
   struct session_state  s_state;          /* Session state */
+#ifdef ENABLE_DATABASE
+  struct session_history s_history;		/*Session history*/
+#endif
+
+
 
 #ifdef HAVE_PATRICIA
   patricia_tree_t *ptree;
@@ -177,6 +208,7 @@
 } acct_type;
 
 void set_env(char *name, char type, void *value, int len);
+void set_moreif_env();
 
 extern struct app_conn_t *firstfreeconn; /* First free in linked list */
 extern struct app_conn_t *lastfreeconn;  /* Last free in linked list */
@@ -212,6 +244,8 @@
 struct app_conn_t * chilli_connect_layer3(struct in_addr *src, struct dhcp_conn_t *conn);
 #endif
 
+int find_active_user(char *username);
+
 int chilli_getconn(struct app_conn_t **conn, uint32_t ip,
 		   uint32_t nasip, uint32_t nasport);
 
@@ -256,12 +290,24 @@
 
 void session_param_defaults(struct session_params *params);
 
+void session_params_dyn(struct session_params *params);
+
+void session_params_trial(struct session_params *params);
+
 int dnprot_accept(struct app_conn_t *appconn);
 
 int dnprot_reject(struct app_conn_t *appconn);
 
 int get_urlparts(char *src, char *host, int hostsize, int *port, int *uripos);
 
+int bstrtocstr(bstring src, char *dst, unsigned int len);
+
+int bescape_str(bstring src, bstring dst);
+
+int escape_cstr(char *src, char *dst);
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len);
+
 int cmdsock_init();
 
 int cmdsock_port_init();
@@ -320,6 +366,12 @@
 int chilli_getconn_byroute(struct app_conn_t **conn, int idx);
 #endif
 
+
+struct app_conn_t * find_app_conn(struct cmdsock_request *req, int *has_criteria);
+char *state2name(int authstate);
+int has_dhcp(void);
+
+
 uint8_t* chilli_called_station(struct session_state *state);
 
 int chilli_cmd(struct cmdsock_request *req, bstring s, int sock);
@@ -328,7 +380,7 @@
 void chilli_freeconn();
 
 int runscript(struct app_conn_t *appconn, char* script,
-	      char *loc, char *oloc);
+	      char *loc, char *oloc, char *dhcp_assign);
 
 /* utils.c */
 int statedir_file(char *dst, int dlen, char *file, char *deffile);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli_limits.h src/src/chilli_limits.h
--- upstream/src/chilli_limits.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli_limits.h	2025-11-06 13:20:13.000000000 +0000
@@ -112,20 +112,18 @@
 #endif
 
 #define MAX_EAP_LEN                     3000 /* Size of buffer to hold EAP message */
+#define PKT_MAX_LEN                    65535 /* Maximum packet size we receive */
+#define MAX_PASS_THROUGHS               1024 /* Max number of allowed UAM pass-throughs */
 
 #ifdef ENABLE_LARGELIMITS
-#define PKT_MAX_LEN                    65535 /* Maximum packet size we receive */
 #define SESSION_PASS_THROUGH_MAX          16
-#define MAX_PASS_THROUGHS               1024 /* Max number of allowed UAM pass-throughs */
 #define MAX_REGEX_PASS_THROUGHS          512 /* Max number of allowed UAM pass-throughs */
 #define MAX_UAM_DOMAINS                  128 /* Max number of allowed UAM domains */
 #define MACOK_MAX                         56
 #define MAX_SELECT                        56
 #define RADIUS_PACKSIZE                 4096
 #else
-#define PKT_MAX_LEN                     9000 /* Maximum packet size we receive */
 #define SESSION_PASS_THROUGH_MAX           8
-#define MAX_PASS_THROUGHS                128 /* Max number of allowed UAM pass-throughs */
 #define MAX_REGEX_PASS_THROUGHS            8 /* Max number of allowed UAM pass-throughs */
 #define MAX_UAM_DOMAINS                   32 /* Max number of allowed UAM domains */
 #define MACOK_MAX                         16
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/chilli_module.c src/src/chilli_module.c
--- upstream/src/chilli_module.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/chilli_module.c	2025-11-06 13:20:13.000000000 +0000
@@ -35,7 +35,7 @@
   lib_handle = dlopen(path, RTLD_NOW | RTLD_LOCAL);
 
   if (!lib_handle) {
-    syslog(LOG_ERR, "%s: chilli_module_load() %s", strerror(errno), dlerror());
+    chilli_log(LOG_ERR, "%s: chilli_module_load() %s", strerror(errno), dlerror());
     return -1;
   }
 
@@ -49,14 +49,14 @@
   sym = dlsym(lib_handle, path);
   if ((sym == NULL) || ((error = dlerror()) != NULL)) {
     dlclose(lib_handle);
-    syslog(LOG_ERR, "%s: %s", strerror(errno), error);
+    chilli_log(LOG_ERR, "%s: %s", strerror(errno), error);
     return -1;
   }
 
   m = (struct chilli_module *) sym;
   m->lib = lib_handle;
 
-  syslog(LOG_DEBUG, "Loaded module %s", name);
+  chilli_log(LOG_DEBUG, "Loaded module %s", name);
 
   *ctx = m;
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdline.ggo src/src/cmdline.ggo
--- upstream/src/cmdline.ggo	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdline.ggo	2025-11-06 13:20:13.000000000 +0000
@@ -30,7 +30,7 @@
 option  "gid"         - "GID to run as, after being started as root" int default="0" no
 
 # NET/TUN parameters
-option "net"         n "Network"           string default="192.168.182.0/24" no
+option "net"         n "Network"           string no
 option "dhcpstart"   - "Network DHCP Starting IP"      int default="0" no
 option "dhcpend"     - "Network DHCP Ending IP"        int default="0" no
 option "dhcpbroadcast" - "Always broadcast DHCP responses" flag off
@@ -46,6 +46,7 @@
 option "ipdown"      - "Script to run after link-down" string no
 option "conup"       - "Script to run after user logon"  string no
 option "condown"     - "Script to run after user logoff" string no
+option "conrestart"  - "Script to run when changed session info" string no
 option "macup"       - "Script to run after initial DHCP"  string no
 option "macdown"     - "Script to run after DHCP release" string no
 option "vlanupdate"  - "Script to run after 802.1Q/VLAN id assignment" string no
@@ -99,6 +100,7 @@
 option "coaport"            - "Radius disconnect port to listen to" int default="0" no
 option "coanoipcheck"       - "Allow radius disconnect from any IP" flag   off
 option "noradallow"         - "Allow all sessions when RADIUS is not available" flag   off
+option "radiusrequiremessageauth" - "Radius packets must have valid Message-Authenticator" flag   off
 
 
 # Radius proxy parameters
@@ -166,6 +168,36 @@
 option "defbandwidthmaxdown" - "Default WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
 option "defbandwidthmaxup" - "Default WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
 option "definteriminterval" - "Default interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "defmaxdownload" - "Default CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "defmaxupload" - "Default CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "defwarning" - "Default CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "deflimitperiod" - "Default period for data limit calculations" int default="0" no
+option "deflimitstart" - "Default start point for data limit calculations" int default="0" no
+option "defexpirationtime" - "Default expiration time for dynamically allocated ussers" long default="0" no
+
+option "dynsessiontimeout" - "Dynamically created user session-timeout if not returned by RADIUS" long default="0" no
+option "dynidletimeout" - "Dynamically created user idle-timeout if not returned by RADIUS" int default="0" no
+option "dynbandwidthmaxdown" - "Dynamically created user WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "dynbandwidthmaxup" - "Dynamically created user WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "dyninteriminterval" - "Dynamically created user interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "dynmaxdownload" - "Dynamically created user CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "dynmaxupload" - "Dynamically created user CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "dynwarning" - "Dynamically created user CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "dynlimitperiod" - "Dynamically created user period for data limit calculations" int default="0" no
+option "dynlimitstart" - "Dynamically created user start point for data limit calculations" int default="0" no
+option "dynexpirationtime" - "Expiration time for dynamically allocated ussers" long default="0" no
+
+option "trialsessiontimeout" - "Trial session session-timeout if not returned by RADIUS" long default="0" no
+option "trialidletimeout" - "Trial session idle-timeout if not returned by RADIUS" int default="0" no
+option "trialbandwidthmaxdown" - "Trial session WISPr-Bandwidth-Max-Down if not returned by RADIUS" long default="0" no
+option "trialbandwidthmaxup" - "Trial session WISPr-Bandwidth-Max-Up if not returned by RADIUS" long default="0" no
+option "trialinteriminterval" - "Trial session interim-interval for accounting if not returned by RADIUS" int default="300" no
+option "trialmaxdownload" - "Trial session CoovaChilli-Max-Input-Octets if not returned by RADIUS" long default="0" no
+option "trialmaxupload" - "Trial session CoovaChilli-Max-Output-Octets if not returned by RADIUS" long default="0" no
+option "trialwarning" - "Trial session CoovaChilli-Warning-Octets if not returned by RADIUS" long default="0" no
+option "triallimitperiod" - "Trial session period for data limit calculations" int default="0" no
+option "triallimitstart" - "Trial session start point for data limit calculations" int default="0" no
+option "trialexpirationtime" - "Trial session expiration time" long default="0" no
 
 option "bwbucketupsize" - "Define the up-bound 'leaky bucket' size" int default="0" no
 option "bwbucketdnsize" - "Define the down-bound 'leaky bucket' size" int default="0" no
@@ -178,6 +210,8 @@
 option "macallowed"  - "List of allowed MAC addresses" string no multiple
 option "macsuffix"   - "Suffix to add to the MAC address" string no
 option "macpasswd"   - "Password used when performing MAC authentication" string no
+option "maclower"     - "MAC address in lower case" flag   off
+option "macdelimiter"  - "MAC address delimiter" int default="0" no
 option "macallowlocal" - "Do not use RADIUS for authenticating the macallowed" flag off
 option "strictmacauth" - "Be strict about MAC Auth (no DHCP reply until we get RADIUS reply)" flag off
 option "strictdhcp"    - "Be strict about only allocating dyn-pool from DHCP" flag off
@@ -211,7 +245,12 @@
 option "swapoctets"    - "Swap the meaning of input/output octets/packets" flag   off
 option "usestatusfile" - "Use the status file to keep track of sessions" string no
 option "statusfilesave" - "Aggressively save the status of sessions to status file" flag off
-option "localusers"    - "File keep 'Local' usernames and passwords" string no
+option "localusers"    - "Enable local users in database" flag   off
+option "oidc"    - "Enable OIDC SSO login" flag   off
+option "oidcforcehttps"    - "Force redirect_uri HTTPS through external redirect" flag   off
+option "oidcdiscoveryurl" - "OIDC Discovery Document URL" string no
+option "oidcclientid" - "OIDC Client ID" string no
+option "oidcclientsecret" - "OIDC Client Secret" string no
 option "postauthproxy" - "IP of an upstream transparent proxy" string no
 option "postauthproxyport" - "Port of an upstream transparent proxy" int default="0" no
 option "postauthproxyssl" - "Send SSL to upstream transparent proxy" flag off
@@ -267,6 +306,7 @@
 
 option "ipwhitelist" - "Binary IP White List file" string no
 option "uamdomainfile" - "Load uamdomains (regex) from file" string no
+option "uamblocklist" - "Allow all traffic, use uamdomainfile as a blocklist" flag off
 
 option "layer3" - "Layer3 only" flag off
 option "ipsrcallowed"  - "List of allowed source IP addresses, for Layer3" string no multiple
@@ -295,3 +335,34 @@
 option "ipv6mode" - "IPv6 mode is either 6and4 (default), 4to6, or 6to4" string no
 option "ipv6only" - "Enable IPv6-Only" flag off
 
+#Custom options
+option "successuserurl" - "Do not return to the UAM server on success, original url instead" flag  off
+option "successurlcustom" - "Return to the custom URL on success. Overwrites 'successuserurl' option" string no
+option "dbpath" - "Path to the statistics database" string no
+option "usersdbpath" - "Path to the users database" string no
+option "smsusers"    - "Enable SMS OTP for authentication" flag   off
+option "duplicateusers"    - "Enable same SMS OTP for more than one user" flag	off
+option "macusers"    - "Enable mac users for authentication" flag   off
+option "trialusers"    - "Enable trial logins" flag   off
+option "macpass"    - "Protects MAC users with password" string no
+option "registerusers"    - "Enable signup to create new users" flag   off
+option "modemid" - "GSM modem id" string no
+option "usersignup"     - "Script to run after user has been created" string no
+option "tos"    - "Enable Terms Of Service requirement" flag   off
+
+option "paramuamip"     - "Overwrites uamip parameter name" string no
+option "paramuamport"     - "Overwrites uamport parameter name" string no
+option "paramcalled"     - "Overwrites called parameter name" string no
+option "parammac"     - "Overwrites mac parameter name" string no
+option "paramip"     - "Overwrites ip parameter name" string no
+option "paramnasid"     - "Overwrites nasid parameter name" string no
+option "paramsessionid"     - "Overwrites sessionid parameter name" string no
+option "paramuserurl"     - "Overwrites userurl parameter name" string no
+option "paramchallenge"     - "Overwrites challenge parameter name" string no
+option "param1"     - "Adds custom parameter to redirect url" string no
+option "param1value"     - "The value of custom parameter" string no
+option "param2"     - "Adds custom parameter to redirect url" string no
+option "param2value"     - "The value of custom parameter" string no
+
+option "testtime"    - "Disables CLOCK_MONOTONIC and use CLOCK_REALTIME instead" flag   off
+
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdline.mini.c src/src/cmdline.mini.c
--- upstream/src/cmdline.mini.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdline.mini.c	2025-11-06 13:20:13.000000000 +0000
@@ -57,7 +57,7 @@
 		       void *d, char is_cmdline) {
   struct opt_def_t * opt = &opts[o];
 
-#if(_debug_)
+#if(_debug_ > 1)
   printf("%s opts[%d] %s [%s] offset %d\n", __FUNCTION__, o,
 	 opt->opt_name, d ? (char *)d : "(null)",
 	 opt->offset_arg);
@@ -72,7 +72,7 @@
       *p = d;
     } else {
       if (*p && !opt->multi_opt) {
-#if(_debug_)
+#if(_debug_ > 1)
 	fprintf(stderr, "Skipping option %s defined on command line\n",
 		opt->opt_name);
 #endif
@@ -85,17 +85,22 @@
 
     case OPT_integer:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
 #endif
-        *((int *)(((char *)args_info) + opt->offset_arg)) = atoi((char *)d);
+        long value = strtol((char *)d, NULL, 10);
+        if (value < INT_MIN || value > INT_MAX) {
+            fprintf(stderr, "Value out of range for int: '%s'\n", d);
+        } else {
+            *((int *)(((char *)args_info) + opt->offset_arg)) = (int)value;
+        }
       }
       *given = 1;
       break;
 
     case OPT_flag:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
 #endif
         *((int *)(((char *)args_info) + opt->offset_arg)) = 1;
@@ -135,11 +140,11 @@
 
     case OPT_long:
       if (opt->offset_arg > 0) {
-#if(_debug_)
+#if(_debug_ > 1)
         if (opt->multi_opt) fprintf(stderr, "NOT SUPPORTED %s %s %d\n", __FUNCTION__, __FILE__, __LINE__);
         printf("long offset %d\n", opt->offset_arg);
 #endif
-        *((long *)(((char *)args_info) + opt->offset_arg)) = (long) atol((char *)d);
+        *((int64_t *)(((char *)args_info) + opt->offset_arg)) = (int64_t) strtoll((char *)d, NULL, 10);
         break;
       }
   }
@@ -163,7 +168,7 @@
   int i;
 
   if (!file) {
-    syslog(LOG_ERR, "%s: Could not open file %s", strerror(errno), filename);
+    chilli_log(LOG_ERR, "%s: Could not open file %s", strerror(errno), filename);
     return -1;
   }
 
@@ -232,7 +237,7 @@
       continue;
     }
 
-#if(_debug_)
+#if(_debug_ > 1)
     fprintf(stderr,"%s = %s\n", fopt, farg);
 #endif
 
@@ -250,6 +255,10 @@
     }
   }
 
+  if (line_num == 0) {
+    result = -1;
+  }
+
   return result;
 }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdsock.c src/src/cmdsock.c
--- upstream/src/cmdsock.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdsock.c	2025-11-06 13:20:13.000000000 +0000
@@ -25,33 +25,29 @@
   int cmdsock;
 
   if ((cmdsock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-
-    syslog(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
-
+    chilli_log(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
   } else {
-
     local.sun_family = AF_UNIX;
-
     strlcpy(local.sun_path, _options.cmdsocket, sizeof(local.sun_path));
     unlink(local.sun_path);
 
-    if (bind(cmdsock, (struct sockaddr *)&local,
-	     sizeof(struct sockaddr_un)) == -1) {
-      syslog(LOG_ERR, "%s: could bind UNIX Socket!", strerror(errno));
+    if (bind(cmdsock, (struct sockaddr *)&local, sizeof(struct sockaddr_un)) == -1) {
+      chilli_log(LOG_ERR, "%s: could bind UNIX Socket!", strerror(errno));
       close(cmdsock);
       cmdsock = -1;
     } else {
       if (listen(cmdsock, 5) == -1) {
-	syslog(LOG_ERR, "%s: could listen to UNIX Socket!", strerror(errno));
-	close(cmdsock);
-	cmdsock = -1;
+        chilli_log(LOG_ERR, "%s: could listen to UNIX Socket!", strerror(errno));
+        close(cmdsock);
+        cmdsock = -1;
       } else {
-	if (_options.uid) {
-	  if (chown(_options.cmdsocket, _options.uid, _options.gid)) {
-	    syslog(LOG_ERR, "%d could not chown() %s",
-                   errno, _options.cmdsocket);
-	  }
-	}
+        chmod(_options.cmdsocket, 0770);
+        if (_options.uid) {
+          if (fchown(cmdsock, _options.uid, _options.gid)) {
+            chilli_log(LOG_ERR, "%d could not chown() %s",
+                  errno, _options.cmdsocket);
+          }
+        }
       }
     }
   }
@@ -68,7 +64,7 @@
 
   if ((cmdsock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
 
-    syslog(LOG_ERR, "%s: could not allocate commands socket!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not allocate commands socket!", strerror(errno));
 
   } else {
 
@@ -86,12 +82,12 @@
 
     if (bind(cmdsock, (struct sockaddr *)&local,
 	     sizeof(struct sockaddr_in)) == -1) {
-      syslog(LOG_ERR, "%s: could not bind commands socket!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: could not bind commands socket!", strerror(errno));
       close(cmdsock);
       cmdsock = -1;
     } else {
       if (listen(cmdsock, 5) == -1) {
-	syslog(LOG_ERR, "%s: could not listen from commands socket!", strerror(errno));
+	chilli_log(LOG_ERR, "%s: could not listen from commands socket!", strerror(errno));
 	close(cmdsock);
 	cmdsock = -1;
       }
@@ -106,7 +102,7 @@
   if (s < 0) {
     return;
   }
-  syslog(LOG_DEBUG, "%s(%d): Shutting down cmdsocket", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): Shutting down cmdsocket", __FUNCTION__, __LINE__);
   shutdown(s, 2);
   close(s);
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/cmdsock.h src/src/cmdsock.h
--- upstream/src/cmdsock.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/cmdsock.h	2025-11-06 13:20:13.000000000 +0000
@@ -71,6 +71,7 @@
       char username[256];
       char password[256];
       char sessionid[17];
+      char userurl[REDIR_USERURLSIZE];
 #ifdef ENABLE_LOCATION
       char location[MAX_LOCATION_LENGTH];
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/conn.c src/src/conn.c
--- upstream/src/conn.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/conn.c	2025-11-06 13:20:13.000000000 +0000
@@ -37,14 +37,14 @@
 #endif
 
     if (ndelay_on(sock) < 0) {
-      syslog(LOG_ERR, "%s: could not set non-blocking", strerror(errno));
+      chilli_log(LOG_ERR, "%s: could not set non-blocking", strerror(errno));
     }
 
     if (safe_connect(sock,
 		     (struct sockaddr *) &server,
 		     sizeof(server)) < 0) {
       if (errno != EINPROGRESS) {
-	syslog(LOG_ERR, "%d could not connect to %s:%d",
+	chilli_log(LOG_ERR, "%d could not connect to %s:%d",
                errno, inet_ntoa(server.sin_addr), port);
 	close(sock);
 	return -1;
@@ -67,7 +67,7 @@
   conn->read_buf = bread;
 
   if (!(host = gethostbyname(hostname)) || !host->h_addr_list[0]) {
-    syslog(LOG_ERR, "Could not resolve IP address of uamserver: %s! [%s]",
+    chilli_log(LOG_ERR, "Could not resolve IP address of uamserver: %s! [%s]",
            hostname, strerror(errno));
     return -1;
   }
@@ -110,7 +110,7 @@
 
 int conn_update_write(struct conn_t *conn) {
 #if(_debug_)
-  syslog(LOG_DEBUG, "%s(%d): socket writeable!", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): socket writeable!", __FUNCTION__, __LINE__);
 #endif
 
   if (conn->write_pos == 0) {
@@ -118,7 +118,7 @@
     socklen_t errlen = sizeof(err);
     if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,
 		   &err, &errlen) || (err != 0)) {
-      syslog(LOG_ERR, "%s: not connected", strerror(errno));
+      chilli_log(LOG_ERR, "%s: not connected", strerror(errno));
       conn_finish(conn);
       return -1;
     } else {
@@ -126,7 +126,7 @@
       /*log_dbg("RESETTING non-blocking");*/
 #endif
       /*if (ndelay_off(conn->sock) < 0) {
-	syslog(LOG_ERR, "%s: could not un-set non-blocking", strerror(errno));
+	chilli_log(LOG_ERR, "%s: could not un-set non-blocking", strerror(errno));
 	}*/
     }
   }
@@ -140,7 +140,7 @@
       conn->write_pos += ret;
     } else if (ret < 0 || errno != EWOULDBLOCK) {
 #if(_debug_)
-      syslog(LOG_DEBUG, "%s(%d): socket closed!", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): socket closed!", __FUNCTION__, __LINE__);
 #endif
       conn_finish(conn);
       return -1;
@@ -154,7 +154,7 @@
   if (conn->sock) {
     switch (net_select_read_fd(sctx, conn->sock)) {
       case -1:
-        syslog(LOG_DEBUG, "%s(%d): exception", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): exception", __FUNCTION__, __LINE__);
         conn_finish(conn);
         return -1;
 
@@ -186,7 +186,7 @@
 
     if (FD_ISSET(conn->sock, e)) {
 #if(_debug_)
-      syslog(LOG_DEBUG, "%s(%d): socket exception!", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): socket exception!", __FUNCTION__, __LINE__);
 #endif
       conn_finish(conn);
     }
@@ -207,13 +207,13 @@
 
   if (ret > 0) {
 #if(_debug_)
-    syslog(LOG_DEBUG, "%s(%d): bstring_read: %d bytes", __FUNCTION__, __LINE__, ret);
+    chilli_log(LOG_DEBUG, "%s(%d): bstring_read: %d bytes", __FUNCTION__, __LINE__, ret);
 #endif
     data->slen += ret;
   } else {
 #if(_debug_)
-    syslog(LOG_DEBUG, "%s(%d): socket closed!", __FUNCTION__, __LINE__);
-    syslog(LOG_DEBUG, "%s(%d): <== [%s]", __FUNCTION__, __LINE__, data->data);
+    chilli_log(LOG_DEBUG, "%s(%d): socket closed!", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): <== [%s]", __FUNCTION__, __LINE__, data->data);
 #endif
     conn_finish(conn);
   }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/database.c src/src/database.c
--- upstream/src/database.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,326 @@
+#include <inttypes.h>
+#include "chilli.h"
+
+static int _seletc_callback(void *str_session, int argc, char **argv, char **azColName) {
+    struct db_session_state *p_str_session = (struct db_session_state *)str_session;
+
+    if (argc > 0) {
+        p_str_session->input_packets = argv[0] ? strtol(argv[0], NULL, 0) : 0;
+        p_str_session->output_packets = argv[1] ? strtol(argv[1], NULL, 0) : 0;
+        p_str_session->input_octets = argv[2] ? strtol(argv[2], NULL, 0) : 0;
+        p_str_session->output_octets = argv[3] ? strtol(argv[3], NULL, 0) : 0;
+        p_str_session->sessiontime = argv[4] ? strtol(argv[4], NULL, 0) : 0;
+
+    }
+
+    return DB_SUCCESS;
+}
+
+static int dbsession_data(struct session_params *s_params, char *username, uint8_t *hismac,
+        struct db_session_state * db_state){
+    int ret;
+    char *sql;
+    char *err = 0;
+    sqlite3 *db;
+    time_t timestamp_now = mainclock_wall();
+    struct tm *time_now;
+    int start_wday, wday;
+
+    if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] Trying to get sesions state %ld", __FUNCTION__, (long) timestamp_now);
+
+    time_now = localtime(&timestamp_now);
+    time_now->tm_min = 0;
+    time_now->tm_sec = 0;
+
+    switch (s_params->period)
+    {
+        case PERIOD_MONTH:
+            if (s_params->start > time_now->tm_mday)
+                time_now->tm_mon--;
+
+            time_now->tm_mday = s_params->start;
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_WEEK:
+            start_wday = s_params->start == 0 ? 7 : s_params->start;
+            wday = time_now->tm_wday == 0 ? 7 : time_now->tm_wday;
+
+            if (time_now->tm_wday != s_params->start){
+                if (start_wday > wday)
+                    time_now->tm_mday -= (7 - start_wday - wday);
+                else
+                    time_now->tm_mday -= wday -start_wday;
+            }
+
+            time_now->tm_hour = 0;
+
+            break;
+        case PERIOD_DAY:
+            if (s_params->start > time_now->tm_hour)
+                time_now->tm_mday--;
+
+            time_now->tm_hour = s_params->start;
+
+            break;
+    }
+
+    db = dbopen();
+    asprintf(&sql, "SELECT SUM(input_packets) AS input_packets, SUM(output_packets) AS output_packets," \
+                   "SUM(input_octets) AS input_octets, SUM(output_octets) AS output_octets," \
+                   " SUM(sessiontime) AS sessiontime FROM "TABLE_NAME \
+                   " WHERE start_time >= %"PRId64" AND username = '%s';", (uint64_t) mktime(time_now), username);
+    if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = sqlite3_exec(db, sql, _seletc_callback, db_state, &err);
+    if (ret){
+        chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    dbclose(db);
+    free(sql);
+
+    return ret;
+}
+
+sqlite3 *dbopen(void) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(_options.dbpath, &db);
+    if (ret)
+        chilli_log(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int dbclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int dbprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        chilli_log(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        chilli_log(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int dbcreate_table(sqlite3 *db){
+    int ret;
+    char *sql;
+
+    sql = "CREATE TABLE "TABLE_NAME"("
+      "id               INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE," \
+      "start_time       TIMESTAMP NOT NULL," \
+      "last_update      TIMESTAMP," \
+      "mac              VARCHAR(32)," \
+      "ip               VARCHAR(16)," \
+      "username         VARCHAR(64)," \
+      "sessiontime      BIGINT NOT NULL DEFAULT 0," \
+      "idletime         BIGINT NOT NULL DEFAULT 0," \
+      "input_octets     BIGINT NOT NULL DEFAULT 0," \
+      "output_octets    BIGINT NOT NULL DEFAULT 0," \
+      "input_packets    BIGINT NOT NULL DEFAULT 0," \
+      "output_packets   BIGINT NOT NULL DEFAULT 0," \
+      "session          BOOLEAN NOT NULL DEFAULT 0," \
+      "ifname           VARCHAR(16)," \
+      "sessionid        VARCHAR(33)," \
+      "terminate_cause  BIGINT NOT NULL DEFAULT 0," \
+      "custom           VARCHAR(64)," \
+      "url              VARCHAR(64)," \
+      "authmode         VARCHAR(64));";
+    ret = dbexec(db, sql, NULL);
+
+    return ret;
+}
+
+int dbwrite(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    time_t time_now;
+    struct session_state s_state;
+
+    time_now = mainclock_wall();
+    s_state = conn->s_state;
+
+    asprintf(&sql, INSERT_FMT, (uint64_t)time_now, MAC_ARG(conn->hismac),
+             inet_ntoa(conn->hisip), s_state.redir.username, s_state.authenticated,
+#ifdef ENABLE_MULTILAN
+			 app_conn_idx(conn) ? _options.moreif[app_conn_idx(conn)-1].dhcpif : _options.dhcpif,
+#else
+			 _options.dhcpif,
+#endif
+             s_state.sessionid, conn->s_state.redir.auth_mode, conn->s_state.redir.userurl);
+    if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+
+    ret = dbexec(db, sql, NULL);
+
+    free(sql);
+    return ret;
+}
+
+int dbupdate(sqlite3 *db, struct app_conn_t *conn){
+    int ret;
+    char *sql = NULL;
+    uint64_t time_now, idletime, sessiontime;
+    struct session_state s_state;
+
+    s_state = conn->s_state;
+    time_now = mainclock_wall();
+    idletime = mainclock_diffu(s_state.last_up_time);
+    sessiontime = mainclock_diffu(s_state.start_time);
+    asprintf(&sql, UPDATE_FMT, time_now, idletime, sessiontime,
+             s_state.input_octets, s_state.output_octets, s_state.input_packets,
+             s_state.output_packets, s_state.authenticated, s_state.terminate_cause_ui,
+			 MAC_ARG(conn->hismac), 1, s_state.sessionid);
+
+    if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__ , sql);
+    ret = dbexec(db, sql, NULL);
+    free(sql);
+
+    return ret;
+}
+
+int dbtable_exists(sqlite3 *db){
+    int ret;
+    int count = 0;
+    char *sql;
+    sqlite3_stmt *stmt;
+
+    sql = "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='"TABLE_NAME"';";
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        chilli_log(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return DB_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? DB_FAIL : DB_SUCCESS;
+}
+
+int dbcheck_table(void){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (dbtable_exists(db) == DB_FAIL)
+        ret = dbcreate_table(db);
+
+    dbclose(db);
+
+    return ret;
+}
+
+int dbconup(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db != NULL) {
+        ret = dbwrite(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbconupdate(struct app_conn_t *conn){
+    sqlite3 *db;
+    int ret = -1;
+
+    db = dbopen();
+    if (db) {
+        ret = dbupdate(db, conn);
+        dbclose(db);
+    }
+
+    return ret;
+}
+
+int dbcheck_session(struct redir_conn_t *conn){
+    int ret = ACCESS_ACCEPTED;
+    uint64_t sessiontime, start_time;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] input_octets %" PRIi64 ", output_octets %" PRIi64 ",  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+
+    if (conn->s_params.maxinputoctets &&
+        conn->s_params.maxinputoctets < db_state.input_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.maxoutputoctets &&
+             conn->s_params.maxoutputoctets < db_state.output_octets)
+        ret = ACCESS_DENIED_DATA;
+    else if (conn->s_params.sessiontimeout) {
+        start_time = mainclock_now() - db_state.sessiontime;
+        sessiontime = mainclock_diffu(start_time);
+        if (conn->s_params.sessiontimeout < sessiontime)
+            ret = ACCESS_DENIED_TIME;
+    }
+
+    return ret;
+}
+
+int dbsession_state(struct app_conn_t *conn){
+    int ret;
+    struct db_session_state db_state;
+
+    if (strlen(conn->s_state.redir.username) == 0)
+        return 0;
+
+    ret = dbsession_data(&conn->s_params, conn->s_state.redir.username, conn->hismac, &db_state);
+
+    if (!ret){
+        if (_options.debug)
+        chilli_log(LOG_INFO, "[%s] input_octets %" PRIi64 ", output_octets %" PRIi64 ",  sessiontime %d", __FUNCTION__,
+               db_state.input_octets, db_state.output_octets, db_state.sessiontime);
+        conn->s_history.input_packets = db_state.input_packets;
+        conn->s_history.output_packets = db_state.output_packets;
+        conn->s_history.input_octets = db_state.input_octets;
+        conn->s_history.output_octets = db_state.output_octets;
+        conn->s_history.sessiontime = db_state.sessiontime;
+    }
+
+    return ret;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/database.h src/src/database.h
--- upstream/src/database.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/database.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,43 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_DATABASE_H
+#define RUTX_DATABASE_H
+
+#include <inttypes.h>
+
+#define DB_SUCCESS 0
+#define DB_FAIL 1
+
+
+#define TABLE_NAME "statistics"
+#define INSERT_FMT "INSERT INTO "TABLE_NAME" (start_time, mac, ip, username, session, ifname, sessionid," \
+        "authmode, url) VALUES (%"PRId64", '"MAC_FMT"', '%s', '%s', %d, '%s', '%s', '%d', '%s');"
+#define UPDATE_FMT "UPDATE "TABLE_NAME \
+                 " SET last_update = %"PRId64", idletime = %"PRId64", sessiontime = %"PRId64", input_octets = %" PRIi64 "," \
+                 " output_octets = %" PRIi64 ", input_packets = %" PRIi64 ", output_packets = %" PRIi64 ", session = %d," \
+                 " terminate_cause = %d" \
+                 " WHERE mac = '"MAC_FMT"' AND session = %d AND sessionid = '%s';"
+
+struct db_session_state {
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint32_t sessiontime;
+};
+
+sqlite3 *dbopen(void);
+int dbclose(sqlite3 *db);
+int dbexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int dbcreate_table(sqlite3 *db);
+int dbwrite(sqlite3 *db, struct app_conn_t *appconn);
+int dbupdate(sqlite3 *db, struct app_conn_t *appconn);
+int dbcheck_table(void);
+int dbconup(struct app_conn_t *conn);
+int dbconupdate(struct app_conn_t *conn);
+int dbsession_state(struct app_conn_t *conn);
+int dbcheck_session(struct redir_conn_t *conn);
+
+#endif //RUTX_DATABASE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dhcp.c src/src/dhcp.c
--- upstream/src/dhcp.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dhcp.c	2025-11-06 13:20:13.000000000 +0000
@@ -42,7 +42,7 @@
 struct chilli_peer * get_chilli_peer(int id) {
   if (id < 0) id = _options.peerid;
   if (_options.peerid >= 8) {
-    syslog(LOG_ERR, "Valid PEERID is 0-7!");
+    chilli_log(LOG_ERR, "Valid PEERID is 0-7!");
     exit(-1);
   }
   if (!chilli_peers) {
@@ -50,7 +50,7 @@
     struct chilli_peer *p;
     chilli_peers = (struct chilli_peer *)calloc(8, sizeof(struct chilli_peer));
     p = chilli_peers + _options.peerid;
-    memcpy(p->mac, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+    memcpy(p->mac, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
     memcpy(&p->addr, &_options.uamlisten, sizeof(_options.uamlisten));
     if (_options.peerid == 0)
       p->state = PEER_STATE_ACTIVE;
@@ -135,7 +135,7 @@
 
   packet_ethh->prot = htons(PKT_ETH_PROTO_CHILLI);
   memcpy(packet_ethh->dst, bmac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
   chilli_hdr.from = _options.peerid;
   chilli_hdr.type = type;
@@ -157,17 +157,17 @@
   if (EVP_EncryptUpdate (&ctx, outbuf, &olen,
 			 (const unsigned char *) &chilli_hdr,
 			 sizeof(chilli_hdr)) != 1) {
-    syslog(LOG_ERR, "CHILLI: peer %d error in encrypt update",
+    chilli_log(LOG_ERR, "CHILLI: peer %d error in encrypt update",
            _options.peerid);
   } else {
     datalen += olen;
     if (EVP_EncryptFinal (&ctx, outbuf + olen, &tlen) != 1) {
-      syslog(LOG_ERR, "CHILLI: peer %d error in encrypt final",
+      chilli_log(LOG_ERR, "CHILLI: peer %d error in encrypt final",
              _options.peerid);
     } else {
       datalen += tlen;
 
-      syslog(LOG_DEBUG, "%s(%d): CHILLI: peer %d sending %d bytes", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): CHILLI: peer %d sending %d bytes", __FUNCTION__, __LINE__,
              _options.peerid, datalen);
 
       ret = dhcp_send(dhcp, -1, bmac, packet,
@@ -235,25 +235,25 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Looking up appconn for %s", __FUNCTION__, __LINE__, inet_ntoa(*dst));
+    chilli_log(LOG_DEBUG, "%s(%d): Looking up appconn for %s", __FUNCTION__, __LINE__, inet_ntoa(*dst));
 #endif
 
   if (ippool_getip(ippool, &ipm, dst)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): No ip assigned for %s", __FUNCTION__, __LINE__, inet_ntoa(*dst));
+      chilli_log(LOG_DEBUG, "%s(%d): No ip assigned for %s", __FUNCTION__, __LINE__, inet_ntoa(*dst));
     return 0;
   }
 
   if (!ipm) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): unknown ip", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): unknown ip", __FUNCTION__, __LINE__);
     return 0;
   }
 
   if ((appconn = (struct app_conn_t *)ipm->peer) == NULL) {
     if (chilli_getconn(&appconn, dst->s_addr, 0, 0)) {
       if (conn && chilli_connect(&appconn, conn)) {
-	syslog(LOG_ERR, "chilli_connect()");
+	chilli_log(LOG_ERR, "chilli_connect()");
 	return 0;
       }
     }
@@ -327,7 +327,7 @@
   packet_arp->op  = htons(DHCP_ARP_REPLY);
 
   /* Source address */
-  memcpy(packet_arp->sha, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_arp->sha, dhcp_nexthop(this, idx), PKT_ETH_ALEN);
   memcpy(packet_arp->spa, &_options.dhcplisten.s_addr, PKT_IP_ALEN);
 
   /* Target address */
@@ -335,11 +335,11 @@
   memcpy(packet_arp->tpa, &_options.dhcplisten.s_addr, PKT_IP_ALEN);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): GARP: Replying to broadcast", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): GARP: Replying to broadcast", __FUNCTION__, __LINE__);
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, bmac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, idx), PKT_ETH_ALEN);
   packet_ethh->prot = htons(PKT_ETH_PROTO_ARP);
 
   return dhcp_send(this, idx, bmac, packet, sizeofarp(packet));
@@ -378,13 +378,13 @@
       if (conn->dnat[n].dst_ip) {
 	uint8_t *ip = (uint8_t*)&conn->dnat[n].dst_ip;
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Resetting dst %d.%d.%d.%d:%d", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): Resetting dst %d.%d.%d.%d:%d", __FUNCTION__, __LINE__,
                  ip[0], ip[1], ip[2], ip[3], conn->dnat[n].dst_port);
       }
       if (conn->dnat[n].src_ip) {
 	uint8_t *ip = (uint8_t*)&conn->dnat[n].src_ip;
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Resetting src %d.%d.%d.%d:%d", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): Resetting src %d.%d.%d.%d:%d", __FUNCTION__, __LINE__,
                  ip[0], ip[1], ip[2], ip[3], conn->dnat[n].src_port);
       }
     }
@@ -416,14 +416,14 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "dhcp_send() len=%zd", length);
+    chilli_log(LOG_DEBUG, "dhcp_send() len=%zd", length);
 #endif
 
   return net_write_eth(netif, packet, length, &netif->dest);
 
 #elif defined (__FreeBSD__) || defined (__APPLE__) || defined (__OpenBSD__) || defined (__NetBSD__)
   if (safe_write(netif->fd, packet, length) < 0) {
-    syslog(LOG_ERR, "%s: write() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: write() failed", strerror(errno));
     return -1;
   }
 #endif
@@ -487,7 +487,7 @@
   }
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): hash table size %d (%d)", __FUNCTION__, __LINE__, this->hashsize, listsize);
+    chilli_log(LOG_DEBUG, "%s(%d): hash table size %d (%d)", __FUNCTION__, __LINE__, this->hashsize, listsize);
   return 0;
 }
 
@@ -524,7 +524,7 @@
   struct dhcp_conn_t *p_prev = NULL;
   
   if (conn == (struct dhcp_conn_t *)0) {
-    syslog(LOG_ERR, "%s: Bad input param conn(%p)", __FUNCTION__, conn);
+    chilli_log(LOG_ERR, "%s: Bad input param conn(%p)", __FUNCTION__, conn);
     return -1;
   }
 
@@ -538,7 +538,7 @@
   }
 
   if (p != conn) {
-    syslog(LOG_ERR, "trying to remove connection not in hash table");
+    chilli_log(LOG_ERR, "trying to remove connection not in hash table");
     return -1;
   }
 
@@ -558,7 +558,7 @@
   uint16_t tag;
 
   if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
-    syslog(LOG_ERR, "%s: forking %s", strerror(errno), script);
+    chilli_log(LOG_ERR, "%s: forking %s", strerror(errno), script);
     return 0;
   }
 
@@ -573,7 +573,7 @@
   set_env("ADDR", VAL_IN_ADDR, &conn->ourip, 0);
   set_env("FRAMED_IP_ADDRESS", VAL_IN_ADDR, &conn->hisip, 0);
   set_env("CALLING_STATION_ID", VAL_MAC_ADDR, conn->hismac, 0);
-  set_env("CALLED_STATION_ID", VAL_MAC_ADDR, dhcp_nexthop(dhcp), 0);
+  set_env("CALLED_STATION_ID", VAL_MAC_ADDR, dhcp_nexthop(dhcp, 0), 0);
   set_env("NAS_ID", VAL_STRING, _options.radiusnasid, 0);
   set_env("8021Q_TAG", VAL_USHORT, &tag, 0);
   set_env("OLD_8021Q_TAG", VAL_USHORT, &oldtag, 0);
@@ -585,7 +585,7 @@
           script,
 #endif
           script, (char *) 0) != 0) {
-    syslog(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
+    chilli_log(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
   }
 
   exit(0);
@@ -602,7 +602,7 @@
       conn->tag8021q = tag;
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): IEEE 802.1Q: "MAC_FMT" on VLAN %d", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): IEEE 802.1Q: "MAC_FMT" on VLAN %d", __FUNCTION__, __LINE__,
                MAC_ARG(conn->hismac),
                (int) ntohs(tag & PKT_8021Q_MASK_VID));
 
@@ -659,7 +659,7 @@
   if (!this->firstfreeconn) {
 
     if (connections == _options.max_clients) {
-      syslog(LOG_ERR, "reached max connections %d!",
+      chilli_log(LOG_ERR, "reached max connections %d!",
              _options.max_clients);
       return -1;
     }
@@ -667,7 +667,7 @@
     ++connections;
 
     if (!(*conn = calloc(1, sizeof(struct dhcp_conn_t)))) {
-      syslog(LOG_ERR, "Out of memory!");
+      chilli_log(LOG_ERR, "Out of memory!");
       return -1;
     }
 
@@ -723,7 +723,7 @@
     if (pkt) {
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
 #endif
       dhcp_checktag(*conn, pkt);
     }
@@ -742,7 +742,7 @@
 		 uint8_t *hwaddr)
 {
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): DHCP newconn: "MAC_FMT, __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): DHCP newconn: "MAC_FMT, __FUNCTION__, __LINE__,
            MAC_ARG(hwaddr));
 
   if (dhcp_lnkconn(dhcp, conn) != 0)
@@ -776,11 +776,16 @@
   return 0; /* Success */
 }
 
-uint8_t * dhcp_nexthop(struct dhcp_t *this) {
+uint8_t * dhcp_nexthop(struct dhcp_t *this, int idx) {
 #ifdef ENABLE_TAP
   if (_options.usetap && _options.has_nexthop)
     return _options.nexthop;
 #endif
+#ifdef HAVE_NETFILTER_COOVA
+  if (_options.kname) {
+    return this->rawif[idx].hwaddr;
+  }
+#endif
   return this->rawif[0].hwaddr;
 }
 
@@ -803,7 +808,7 @@
     return 0;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): DHCP freeconn: "MAC_FMT, __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): DHCP freeconn: "MAC_FMT, __FUNCTION__, __LINE__,
            MAC_ARG(conn->hismac));
 
 #ifdef HAVE_NETFILTER_COOVA
@@ -862,14 +867,14 @@
   while (conn) {
     /*
       if (_options.debug)
-      syslog(LOG_DEBUG, "dhcp_checkconn: %d %d", mainclock_diff(conn->lasttime), (int) this->lease);
+      chilli_log(LOG_DEBUG, "dhcp_checkconn: %d %d", mainclock_diff(conn->lasttime), (int) this->lease);
     */
     struct dhcp_conn_t *check_conn = conn;
     conn = conn->next;
     if (!check_conn->is_reserved &&
 	mainclock_diff(check_conn->lasttime) > (int)this->lease + _options.leaseplus) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): DHCP timeout: Removing connection", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): DHCP timeout: Removing connection", __FUNCTION__, __LINE__);
       dhcp_freeconn(check_conn, RADIUS_TERMINATE_CAUSE_LOST_CARRIER);
     }
   }
@@ -923,13 +928,13 @@
 
     if (_options.debug) {
       addr.s_addr = pack_iph->saddr;
-      syslog(LOG_DEBUG, "%s(%d): NFQUEUE: From "MAC_FMT" %s %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): NFQUEUE: From "MAC_FMT" %s %s", __FUNCTION__, __LINE__,
              MAC_ARG(hw->hw_addr),
              inet_ntoa(addr),
              result == NF_ACCEPT ? "Accept" : "Drop");
 
       addr.s_addr = pack_iph->daddr;
-      syslog(LOG_DEBUG, "%s(%d): NFQUEUE: To %s %s %d %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): NFQUEUE: To %s %s %d %s", __FUNCTION__, __LINE__,
              inet_ntoa(addr),
              pack_iph->protocol == PKT_IP_PROTO_UDP ? "UDP" :
              pack_iph->protocol == PKT_IP_PROTO_TCP ? "TCP" : "Other",
@@ -976,14 +981,14 @@
     if (ippool_getip(ippool, &ipm, &addr)) {
 
       if (_options.debug)
-	syslog(LOG_DEBUG, "%s(%d): dropping packet with unknown destination: %s", __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): dropping packet with unknown destination: %s", __FUNCTION__, __LINE__,
                inet_ntoa(addr));
     }
     else {
 
       if ((appconn = (struct app_conn_t *)ipm->peer) == NULL ||
 	  (appconn->dnlink) == NULL) {
-	syslog(LOG_ERR, "No %s protocol defined for %s",
+	chilli_log(LOG_ERR, "No %s protocol defined for %s",
                appconn ? "dnlink" : "peer", inet_ntoa(addr));
       }
       else {
@@ -999,12 +1004,12 @@
 
     if (_options.debug) {
       addr.s_addr = pack_iph->saddr;
-      syslog(LOG_DEBUG, "%s(%d): NFQUEUE OUT: From %s %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): NFQUEUE OUT: From %s %s", __FUNCTION__, __LINE__,
              inet_ntoa(addr),
              result == NF_ACCEPT ? "Accept" : "Drop");
 
       addr.s_addr = pack_iph->daddr;
-      syslog(LOG_DEBUG, "%s(%d): NFQUEUE OUT: To %s %s %d %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): NFQUEUE OUT: To %s %s %d %s", __FUNCTION__, __LINE__,
              inet_ntoa(addr),
              pack_iph->protocol == PKT_IP_PROTO_UDP ? "UDP" :
              pack_iph->protocol == PKT_IP_PROTO_TCP ? "TCP" : "Other",
@@ -1030,7 +1035,7 @@
   struct dhcp_t *dhcp;
 
   if (!(dhcp = *pdhcp = calloc(sizeof(struct dhcp_t), 1))) {
-    syslog(LOG_ERR, "calloc() failed");
+    chilli_log(LOG_ERR, "calloc() failed");
     return -1;
   }
 
@@ -1057,10 +1062,10 @@
 		   0,
 #endif
 		   promisc, 0) < 0) {
-	syslog(LOG_ERR, "could not setup interface %s",
+	chilli_log(LOG_ERR, "could not setup interface %s",
                _options.moreif[i].dhcpif);
       } else {
-	syslog(LOG_DEBUG, "%s(%d): Configured interface %s/%s fd=%d", __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): Configured interface %s/%s fd=%d", __FUNCTION__, __LINE__,
                _options.moreif[i].dhcpif,
                _options.moreif[i].vlan,
                dhcp->rawif[idx].fd);
@@ -1073,8 +1078,8 @@
   if (getenv("NFQUEUE_IN") && getenv("NFQUEUE_OUT")) {
     int q1 = 0, q2 = 1;
     char *e;
-    if ((e = getenv("NFQUEUE_IN"))) q1 = atoi(e);
-    if ((e = getenv("NFQUEUE_OUT"))) q2 = atoi(e);
+    if ((e = getenv("NFQUEUE_IN"))) q1 = strtol(e, NULL, 0);
+    if ((e = getenv("NFQUEUE_OUT"))) q2 = strtol(e, NULL, 0);
     if (net_open_nfqueue(&dhcp->qif_in, q1, nfqueue_cb_in) == -1) {
       return -1;
     }
@@ -1088,13 +1093,13 @@
   {
     int blen=0;
     if (ioctl(dhcp->rawif[0].fd, BIOCGBLEN, &blen) < 0) {
-      syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
     }
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): BIOCGBLEN=%d", __FUNCTION__, __LINE__, blen);
+      chilli_log(LOG_DEBUG, "%s(%d): BIOCGBLEN=%d", __FUNCTION__, __LINE__, blen);
     dhcp->pb.buflen = blen;
     if (!(dhcp->pb.buf = calloc(dhcp->pb.buflen, 1))) {
-      syslog(LOG_ERR, "%s: malloc() failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: malloc() failed", strerror(errno));
     }
   }
 #endif
@@ -1133,11 +1138,11 @@
       addr.sin_port = htons(_options.dhcpgwport);
 
       if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0) {
-	syslog(LOG_ERR, "%s: Can't set reuse option", strerror(errno));
+	chilli_log(LOG_ERR, "%s: Can't set reuse option", strerror(errno));
       }
 
       if (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-	syslog(LOG_ERR, "%s: socket or bind failed for dhcp relay!", strerror(errno));
+	chilli_log(LOG_ERR, "%s: socket or bind failed for dhcp relay!", strerror(errno));
 	close(fd);
 	fd = -1;
       }
@@ -1188,7 +1193,7 @@
 	      fmt, sizeof(fmt));
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dhcpif (%s) IPv6 address %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): dhcpif (%s) IPv6 address %s", __FUNCTION__, __LINE__,
              dhcp->rawif[0].devname, fmt);
 
     /*
@@ -1234,16 +1239,12 @@
   return 0;
 }
 
-int dhcp_reopen() {
-  return 0;
-}
-
 int dhcp_reserve_ip(uint8_t *mac, struct in_addr *ip) {
   struct dhcp_conn_t *conn = 0;
 
   if (dhcp_hashget(dhcp, &conn, mac)) {
     if (dhcp_newconn(dhcp, &conn, mac)) {
-      syslog(LOG_ERR, "could not allocate connection");
+      chilli_log(LOG_ERR, "could not allocate connection");
       return -1;
     }
   }
@@ -1300,7 +1301,7 @@
                 if (sscanf (bp, "%2x %2x %2x %2x %2x %2x",
                             &tmp[0], &tmp[1], &tmp[2],
                             &tmp[3], &tmp[4], &tmp[5]) != 6) {
-                  syslog(LOG_ERR, "Parse error in ethers file at line %d", lineno);
+                  chilli_log(LOG_ERR, "Parse error in ethers file at line %d", lineno);
                   state = -1;
                 } else {
                   mac[0] = (uint8_t) tmp[0];
@@ -1316,7 +1317,7 @@
             case 1:
               {
                 if (!inet_aton(bp, &ip)) {
-                  syslog(LOG_ERR, "Bad IP address!");
+                  chilli_log(LOG_ERR, "Bad IP address!");
                   state = -1;
                 } else {
                   state = 2;
@@ -1326,7 +1327,7 @@
           }
 
           if (newline || state == 2) {
-            syslog(LOG_NOTICE, "Reserving IP MAC="MAC_FMT" IP %s" ,
+            chilli_log(LOG_NOTICE, "Reserving IP MAC="MAC_FMT" IP %s" ,
                    MAC_ARG(mac), inet_ntoa(ip));
             dhcp_reserve_ip(mac, &ip);
             state = 0;
@@ -1376,7 +1377,7 @@
 	  if (r == blen) {
 	    dhcp_reserve_str(b, blen);
 	  } else {
-	    syslog(LOG_ERR, "bad ethers file %s", ethers);
+	    chilli_log(LOG_ERR, "bad ethers file %s", ethers);
 	  }
 	  free(b);
 	}
@@ -1384,7 +1385,7 @@
 
       close(fd);
     } else {
-      syslog(LOG_ERR, "could not open ethers file %s", ethers);
+      chilli_log(LOG_ERR, "could not open ethers file %s", ethers);
     }
   }
 
@@ -1464,7 +1465,7 @@
   FILE *fp;
 
   if ((fp = fopen(_options.ipwhitelist, "r")) == NULL) {
-    syslog(LOG_ERR, "%s: error openning %s", strerror(errno), _options.ipwhitelist);
+    chilli_log(LOG_ERR, "%s: error openning %s", strerror(errno), _options.ipwhitelist);
     return 0;
   }
 
@@ -1473,7 +1474,7 @@
       if (iph->protocol == PKT_IP_PROTO_TCP ||
 	  iph->protocol == PKT_IP_PROTO_UDP) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): DYNAMIC WHITELIST: %s\n", __FUNCTION__, __LINE__, inet_ntoa(inp));
+          chilli_log(LOG_DEBUG, "%s(%d): DYNAMIC WHITELIST: %s\n", __FUNCTION__, __LINE__, inet_ntoa(inp));
 	fclose(fp);
 	return 1;
       }
@@ -1482,7 +1483,7 @@
 
   fclose(fp);
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): NO WHITELIST: %s", __FUNCTION__, __LINE__, inet_ntoa(inp));
+    chilli_log(LOG_DEBUG, "%s(%d): NO WHITELIST: %s", __FUNCTION__, __LINE__, inet_ntoa(inp));
   return 0;
 }
 #endif
@@ -1669,7 +1670,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ---------  checking dns for %s in %s", __FUNCTION__, __LINE__, name, r);
+    chilli_log(LOG_DEBUG, "%s(%d): ---------  checking dns for %s in %s", __FUNCTION__, __LINE__, name, r);
 #endif
 
   if (r_len == name_len && !memcmp(r, name, name_len)) {
@@ -1698,7 +1699,7 @@
   if (*plen < DHCP_DNS_HLEN + sizeofudp(pack)) {
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): bad DNS packet of length %zu", __FUNCTION__, __LINE__, *plen);
+      chilli_log(LOG_DEBUG, "%s(%d): bad DNS packet of length %zu", __FUNCTION__, __LINE__, *plen);
     return 0;
 
   } else {
@@ -1737,9 +1738,9 @@
 #if(_debug_ > 1)
     uint16_t id = ntohs(dnsp->id);
     if (_options.debug) {
-      syslog(LOG_DEBUG, "%s(%d): dhcp_dns plen=%zd dlen=%zd olen=%zd", __FUNCTION__, __LINE__, *plen, dlen, olen);
-      syslog(LOG_DEBUG, "%s(%d): DNS ID:    %d", __FUNCTION__, __LINE__, id);
-      syslog(LOG_DEBUG, "%s(%d): DNS Flags: %d", __FUNCTION__, __LINE__, flags);
+      chilli_log(LOG_DEBUG, "%s(%d): dhcp_dns plen=%zd dlen=%zd olen=%zd", __FUNCTION__, __LINE__, *plen, dlen, olen);
+      chilli_log(LOG_DEBUG, "%s(%d): DNS ID:    %d", __FUNCTION__, __LINE__, id);
+      chilli_log(LOG_DEBUG, "%s(%d): DNS Flags: %d", __FUNCTION__, __LINE__, flags);
     }
 #endif
 
@@ -1782,7 +1783,7 @@
         if (((flags & 0x8000) >> 15) == 0) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Dropping unexpected DNS query", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): Dropping unexpected DNS query", __FUNCTION__, __LINE__);
 #endif
           return 0;
         }
@@ -1791,7 +1792,7 @@
         if (((flags & 0x8000) >> 15) == 1) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Dropping unexpected DNS response", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): Dropping unexpected DNS response", __FUNCTION__, __LINE__);
 #endif
           return 0;
         }
@@ -1810,7 +1811,7 @@
 		       (uint8_t *)dnsp, olen,                   \
 		       q, sizeof(q), isReq,                     \
 		       &qmatch, &mod, mode)) {                  \
-        syslog(LOG_WARNING, "dropping malformed DNS");		\
+        chilli_log(LOG_WARNING, "dropping malformed DNS");		\
 	return isReq ? dhcp_nakDNS(conn,pack,*plen) : 0;        \
       }                                                         \
     }
@@ -1825,13 +1826,13 @@
 
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): left (should be zero): %zd q=%s", __FUNCTION__, __LINE__, dlen, q);
+      chilli_log(LOG_DEBUG, "%s(%d): left (should be zero): %zd q=%s", __FUNCTION__, __LINE__, dlen, q);
 #endif
 
     if (dlen) {
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Remaining length not zero dlen=%zu!", __FUNCTION__, __LINE__, dlen);
+        chilli_log(LOG_DEBUG, "%s(%d): Remaining length not zero dlen=%zu!", __FUNCTION__, __LINE__, dlen);
 #endif
       return 0;
     }
@@ -1844,13 +1845,13 @@
 	  nscount == 0x0000 &&
 	  arcount == 0x0000) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): MDNS Query %s", __FUNCTION__, __LINE__, q);
+          chilli_log(LOG_DEBUG, "%s(%d): MDNS Query %s", __FUNCTION__, __LINE__, q);
       }
       else if (flags == 0x8400 &&
 	       qdcount == 0x0000 &&
 	       ancount > 0) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): MDNS Response %s", __FUNCTION__, __LINE__, q);
+          chilli_log(LOG_DEBUG, "%s(%d): MDNS Response %s", __FUNCTION__, __LINE__, q);
       }
     }
 #endif
@@ -1886,6 +1887,8 @@
       if (!match && hostname) {
 	match = dhcp_matchDNS(q, hostname);
 	if (match) {
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Hostname DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
 	  memcpy(reply, &_options.uamlisten.s_addr, 4);
 	}
       }
@@ -1893,7 +1896,9 @@
       if (!match && aliasname) {
 	match = dhcp_matchDNS(q, aliasname);
 	if (match) {
-	  memcpy(reply, &_options.uamalias.s_addr, 4);
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Alias DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
+	  memcpy(reply, &_options.uamlisten.s_addr, 4);
 	}
       }
 
@@ -1905,7 +1910,7 @@
 	    !strcasecmp((char *)q + 5, _options.domain)))) {
 	match = 1;
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): WPAD DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamalias));
+          chilli_log(LOG_DEBUG, "%s(%d): WPAD DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamalias));
 	memcpy(reply, &_options.uamalias.s_addr, 4);
       }
 #endif
@@ -1924,8 +1929,9 @@
 	     * count (recent) dns requests vs responses to get an
 	     * overall picture of on-line status.
 	     */
-
-	    memcpy(reply, &_options.uamalias.s_addr, 4);
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): Domain DNS (returning %s)\n", __FUNCTION__, __LINE__, inet_ntoa(_options.uamlisten));
+	    memcpy(reply, &_options.uamlisten.s_addr, 4);
 	    match = 1;
 	  }
 	}
@@ -1953,7 +1959,7 @@
 	p = dnsp->records;
 
 #if(_debug_)
-	syslog(LOG_DEBUG, "%s(%d): It was a matching query!\n", __FUNCTION__, __LINE__);
+	chilli_log(LOG_DEBUG, "%s(%d): It was a matching query!\n", __FUNCTION__, __LINE__);
 #endif
 
 	do {
@@ -2062,14 +2068,14 @@
 	uint16_t us;
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): namelen %zd", __FUNCTION__, __LINE__, namelen);
+          chilli_log(LOG_DEBUG, "%s(%d): namelen %zd", __FUNCTION__, __LINE__, namelen);
 
 	if (namelen <= 0 || namelen > 1500)
 	  break;
 
 	if (len < 10) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): len too short %d", __FUNCTION__, __LINE__, len);
+            chilli_log(LOG_DEBUG, "%s(%d): len too short %d", __FUNCTION__, __LINE__, len);
 	  break;
 	}
 
@@ -2099,7 +2105,7 @@
 	len -= 2;
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): DNS t=%d c=%d ttl=%d dlen=%d", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): DNS t=%d c=%d ttl=%d dlen=%d", __FUNCTION__, __LINE__,
                  type, class, ttl, rdlen);
 
 	switch(type) {
@@ -2123,7 +2129,7 @@
             {
               int l = rdlen + namelen + 10;
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): copy %d", __FUNCTION__, __LINE__, l);
+                chilli_log(LOG_DEBUG, "%s(%d): copy %d", __FUNCTION__, __LINE__, l);
               memcpy(bp, pkt_head, l);
               bp += l;
             }
@@ -2138,7 +2144,7 @@
 
       if (new_ancount != ancount) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Could not pack all answers %d/%d", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): Could not pack all answers %d/%d", __FUNCTION__, __LINE__,
                  ancount, new_ancount);
       }
 
@@ -2146,14 +2152,14 @@
 	uint16_t bdiff = (uint16_t)(bp - bt);
 	int newlen = (int)(an_mark - pack) + (int)bdiff;
 	if (newlen < 0 || newlen > 1500) {
-	  syslog(LOG_ERR, "Problem growing DNS packet from %zu to %d (%d %d)",
+	  chilli_log(LOG_ERR, "Problem growing DNS packet from %zu to %d (%d %d)",
                  *plen, newlen, (int)(an_mark - pack), bdiff);
 	} else {
 	  uint16_t data_len = bdiff + (uint16_t) (an_mark - ((uint8_t *)dnsp));
 	  struct pkt_iphdr_t  *iph  = pkt_iphdr(pack);
 	  struct pkt_udphdr_t *udph = pkt_udphdr(pack);
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Growing DNS packet from %zu to %d (%d %d) dt=%d", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): Growing DNS packet from %zu to %d (%d %d) dt=%d", __FUNCTION__, __LINE__,
                    *plen, newlen, (int)(an_mark - pack), bdiff, data_len);
 	  data_len += PKT_UDP_HLEN;
 	  udph->len = htons(data_len);
@@ -2187,7 +2193,7 @@
 
 #if(_debug > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): uam_nat %s:%d", __FUNCTION__, __LINE__, inet_ntoa(*addr), port);
+    chilli_log(LOG_DEBUG, "%s(%d): uam_nat %s:%d", __FUNCTION__, __LINE__, inet_ntoa(*addr), port);
 #endif
 
   for (n=0; n < DHCP_DNAT_MAX; n++) {
@@ -2196,7 +2202,7 @@
       pos = n;
 #if(_debug > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): uam_nat pos %d", __FUNCTION__, __LINE__,pos);
+        chilli_log(LOG_DEBUG, "%s(%d): uam_nat pos %d", __FUNCTION__, __LINE__,pos);
 #endif
       break;
     }
@@ -2274,11 +2280,11 @@
       udph->src == htons(DHCP_MDNS) &&
       udph->dst == htons(DHCP_MDNS)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): mDNS packet", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): mDNS packet", __FUNCTION__, __LINE__);
     if (!dhcp_dns(conn, pack, len, 1)) {
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dhcp_dns()", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dhcp_dns()", __FUNCTION__, __LINE__);
 #endif
     }
     return -1; /* Drop DNS */
@@ -2338,7 +2344,7 @@
     if (!dhcp_dns(conn, pack, len, 1)) {
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dhcp_dns()", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dhcp_dns()", __FUNCTION__, __LINE__);
 #endif
       return -1; /* Drop DNS */
     }
@@ -2397,7 +2403,7 @@
       if (!dhcp_dns(conn, pack, len, 0)) {
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d); dhcp_dns()", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d); dhcp_dns()", __FUNCTION__, __LINE__);
 #endif
 	return -1; /* Is not allowed DNS */
       }
@@ -2597,7 +2603,7 @@
   if (!found && _options.ipsrc_num_pass_throughs) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Checking ipsrcallowed pass throughs (%d)", __FUNCTION__, __LINE__, _options.ipsrc_num_pass_throughs);
+      chilli_log(LOG_DEBUG, "%s(%d): Checking ipsrcallowed pass throughs (%d)", __FUNCTION__, __LINE__, _options.ipsrc_num_pass_throughs);
 #endif
     if (garden_check(_options.ipsrc_pass_throughs,
                      &_options.ipsrc_num_pass_throughs, &pt,
@@ -2609,7 +2615,7 @@
       found = 1;
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Packet matches ipsrcallowed", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Packet matches ipsrcallowed", __FUNCTION__, __LINE__);
 #endif
     }
   }
@@ -2722,7 +2728,7 @@
 
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Resetting connection on port %d->%d", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Resetting connection on port %d->%d", __FUNCTION__, __LINE__,
                ntohs(tcph->src), ntohs(tcph->dst));
 #endif
 
@@ -2777,7 +2783,7 @@
 
 #if(_debug_ > 0)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): rewriting packet for post-auth proxy %s:%d", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): rewriting packet for post-auth proxy %s:%d", __FUNCTION__, __LINE__,
                  inet_ntoa(_options.postauth_proxyip),
                  _options.postauth_proxyport);
 #endif
@@ -2838,11 +2844,9 @@
 
 #ifdef ENABLE_TCPRESET
   if (do_reset && iph->protocol == PKT_IP_PROTO_TCP) {
-#if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Resetting connection on port %d->%d (undo)", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Resetting connection on port %d->%d (undo)", __FUNCTION__, __LINE__,
              ntohs(tcph->src), ntohs(tcph->dst));
-#endif
     dhcp_sendRESET(conn, pack, 0);
     if (conn->peer) {
       tun_sendRESET(tun, pack, (struct app_conn_t *)conn->peer);
@@ -2924,7 +2928,7 @@
 #endif
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dhcp server: %s", __FUNCTION__, __LINE__, pack_dhcp->sname);
+      chilli_log(LOG_DEBUG, "%s(%d): dhcp server: %s", __FUNCTION__, __LINE__, pack_dhcp->sname);
   }
 
   switch(type) {
@@ -2942,7 +2946,7 @@
 
   /* Ethernet Header */
   memcpy(pack_ethh->dst, req_ethh->src, PKT_ETH_ALEN);
-  memcpy(pack_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(pack_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   /* UDP and IP Headers */
   pack_udph->src = htons(DHCP_BOOTPS);
@@ -3048,7 +3052,7 @@
         int i;
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): DHCP Type: %d Length: %d", __FUNCTION__, __LINE__, (int)opt->t, (int)opt->l);
+          chilli_log(LOG_DEBUG, "%s(%d): DHCP Type: %d Length: %d", __FUNCTION__, __LINE__, (int)opt->t, (int)opt->l);
 
         /* for each configured option, iterate the param_list */
         for (i=0; i < param_count; i++) {
@@ -3072,7 +3076,7 @@
       struct dhcp_tag_t *opt = (struct dhcp_tag_t *)lhead;
       while (opt && opt->t && opt->l) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): DHCP Type: %d Length: %d", __FUNCTION__, __LINE__, (int)opt->t, (int)opt->l);
+          chilli_log(LOG_DEBUG, "%s(%d): DHCP Type: %d Length: %d", __FUNCTION__, __LINE__, (int)opt->t, (int)opt->l);
         /* for each configured option, check if it's option 43 */
         if (opt->t == DHCP_OPTION_VENDOR_SPECIFIC_INFORMATION) {
           if (pos + opt->l + 2 < DHCP_OPTIONS_LEN) {
@@ -3102,7 +3106,7 @@
   size_t offset = DHCP_MIN_LEN + DHCP_OPTION_MAGIC_LEN;
 
   /* if (length > DHCP_LEN) {
-     syslog(LOG_WARNING,"Length of dhcp packet larger then %d: %d", DHCP_LEN, length);
+     chilli_log(LOG_WARNING,"Length of dhcp packet larger then %d: %d", DHCP_LEN, length);
      length = DHCP_LEN;
      } */
 
@@ -3202,7 +3206,7 @@
     slen = strlen(str);
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): WPAD DHCP (URL %s)\n", __FUNCTION__, __LINE__, str);
+      chilli_log(LOG_DEBUG, "%s(%d): WPAD DHCP (URL %s)\n", __FUNCTION__, __LINE__, str);
 
     o[pos++] = DHCP_OPTION_WPAD_URL;
     o[pos++] = slen;
@@ -3217,7 +3221,7 @@
     memcpy(&o[pos], _options.rfc7710uri, strlen(_options.rfc7710uri));
     pos += strlen(_options.rfc7710uri);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): DHCP Captive Portal URI %s\n", __FUNCTION__, __LINE__, _options.rfc7710uri);
+      chilli_log(LOG_DEBUG, "%s(%d): DHCP Captive Portal URI %s\n", __FUNCTION__, __LINE__, _options.rfc7710uri);
   }
 
   o[pos++] = DHCP_OPTION_END;
@@ -3256,7 +3260,7 @@
             chilli_learn_location(opt82->v, opt82->l, appconn, 1);
           } else {
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): no appconn for option 82", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): no appconn for option 82", __FUNCTION__, __LINE__);
           }
         }
       } break;
@@ -3267,7 +3271,7 @@
 #ifdef ENABLE_MODULES
   {
     int i;
-    syslog(LOG_DEBUG, "%s(%d); checking modules...", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d); checking modules...", __FUNCTION__, __LINE__);
     for (i=0; i < MAX_MODULES; i++) {
       if (!_options.modules[i].name[0]) break;
       if (_options.modules[i].ctx) {
@@ -3456,14 +3460,14 @@
 		      0, pack, len, 0, 0);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Sending DHCP relay packet to %s", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Sending DHCP relay packet to %s", __FUNCTION__, __LINE__,
            inet_ntoa(addr.sin_addr));
 
   /* if we can't send, lets do dhcp ourselves */
   if (sendto(this->relayfd, pack_dhcp,
 	     ntohs(pack_udph->len) - PKT_UDP_HLEN, 0,
 	     (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-    syslog(LOG_ERR, "%s: could not relay DHCP request!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not relay DHCP request!", strerror(errno));
     return -1;
   }
 
@@ -3487,7 +3491,7 @@
   struct dhcp_packet_t *pack_dhcp = pkt_dhcppkt(pack);
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "%s(%d): function", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): function", __FUNCTION__, __LINE__);
 #endif
 
   if (pack_udph->dst != htons(DHCP_BOOTPS))
@@ -3510,7 +3514,7 @@
 
     case DHCPDECLINE:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): DHCP-Decline", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): DHCP-Decline", __FUNCTION__, __LINE__);
       /* drop through */
 
     case DHCPRELEASE:
@@ -3554,7 +3558,7 @@
   if (_options.strictdhcp && addr.s_addr &&
       (addr.s_addr & _options.mask.s_addr) != _options.net.s_addr) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): NAK: strictdhcp and address not in net", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): NAK: strictdhcp and address not in net", __FUNCTION__, __LINE__);
     return dhcp_sendNAK(conn, pack, len);
   }
 
@@ -3564,7 +3568,7 @@
     if (this->cb_request &&
 	this->cb_request(conn, &addr, pack, len)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): NAK: auth-none", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): NAK: auth-none", __FUNCTION__, __LINE__);
       return dhcp_sendNAK(conn, pack, len);
     }
   }
@@ -3587,7 +3591,7 @@
         if (!conn->hisip.s_addr) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): hisip not set!", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): hisip not set!", __FUNCTION__, __LINE__);
 #endif
           return dhcp_sendNAK(conn, pack, len);
         }
@@ -3605,7 +3609,7 @@
 
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Sending NAK to client", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Sending NAK to client", __FUNCTION__, __LINE__);
 #endif
         return dhcp_sendNAK(conn, pack, len);
       }
@@ -3615,7 +3619,7 @@
    *  Unsupported DHCP message: Ignore
    */
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Unsupported DHCP message ignored", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Unsupported DHCP message ignored", __FUNCTION__, __LINE__);
   return 0;
 }
 
@@ -3664,7 +3668,7 @@
       memcpy(req.arp_ha.sa_data, conn->hismac, PKT_ETH_ALEN);
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): ARP Entry: %s -> "MAC_FMT, __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): ARP Entry: %s -> "MAC_FMT, __FUNCTION__, __LINE__,
                inet_ntoa(conn->hisip),
                MAC_ARG(conn->hismac));
 
@@ -3696,7 +3700,7 @@
 	mask.s_addr = 0xffffffff;
 	res = net_add_route(hisip, ourip, &mask);
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Adding route for %s %d", __FUNCTION__, __LINE__, inet_ntoa(*hisip), res);
+          chilli_log(LOG_DEBUG, "%s(%d): Adding route for %s %d", __FUNCTION__, __LINE__, inet_ntoa(*hisip), res);
       }
     }
   }
@@ -3708,6 +3712,57 @@
 int dhcp_receive_eapol(struct dhcp_ctx *ctx, uint8_t *pack);
 int dhcp_receive_arp(struct dhcp_ctx *ctx, uint8_t *pack, size_t len);
 
+#ifdef ENABLE_TCPRESET
+static void dhcp_garden_process_tcpreset(struct dhcp_conn_t *conn, struct app_conn_t *appconn, 
+                             uint8_t *pack, struct pkt_iphdr_t *iph, struct pkt_tcphdr_t *tcph,
+                             pass_through *pass_throughs, int num_pass_throughs) {
+  for (int i = 0; i < num_pass_throughs; i++) {
+    if ((iph->saddr == pass_throughs[i].host.s_addr &&
+        (pass_throughs[i].port == 0 || tcph->src == htons(pass_throughs[i].port))) ||
+        (iph->daddr == pass_throughs[i].host.s_addr &&
+        (pass_throughs[i].port == 0 || tcph->dst == htons(pass_throughs[i].port))))
+    {
+      int found = 0;
+      for (int j = 0; j < appconn->s_params.num_tcp_reset_addr; j++) {
+        if (appconn->s_params.tcp_reset_addr[j].s_addr == pass_throughs[i].host.s_addr) {
+          found = 1;
+          break;
+        }
+      }
+      if (found)
+        continue;
+
+      uint8_t tcp_pack[1500];
+      dhcp_send(conn->parent, dhcp_conn_idx(conn), conn->hismac, tcp_pack, tcprst(tcp_pack, pack, 1));
+      dhcp_send(conn->parent, dhcp_conn_idx(conn), conn->hismac, tcp_pack, tcprst(tcp_pack, pack, 0));
+
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): Pass through TCP RESET %s:%d", __FUNCTION__, __LINE__,
+                inet_ntoa(pass_throughs[i].host),
+                pass_throughs[i].port);
+
+      appconn->s_params.tcp_reset_addr[appconn->s_params.num_tcp_reset_addr++] = pass_throughs[i].host;
+    }
+  }
+}
+
+static void dhcp_garden_tcpreset(struct dhcp_conn_t *conn, struct app_conn_t *appconn, uint8_t *pack) {
+  if (!appconn->s_state.authenticated)
+    return;
+
+  struct pkt_iphdr_t  *iph  = pkt_iphdr(pack);
+  struct pkt_tcphdr_t *tcph = pkt_tcphdr(pack);
+  if (iph->protocol != PKT_IP_PROTO_TCP)
+    return;
+
+  if (appconn->s_params.num_tcp_reset_addr >= _options.num_pass_throughs + dhcp->num_pass_throughs)
+    return;
+
+  dhcp_garden_process_tcpreset(conn, appconn, pack, iph, tcph, _options.pass_throughs, _options.num_pass_throughs);
+  dhcp_garden_process_tcpreset(conn, appconn, pack, iph, tcph, dhcp->pass_throughs, dhcp->num_pass_throughs);
+}
+#endif
+
 /**
  *  dhcp_receive_ip()
  *  Received a packet from the dhcpif
@@ -3736,13 +3791,13 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): function ", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): function ", __FUNCTION__, __LINE__);
 #endif
 
   if (len < PKT_IP_HLEN + PKT_ETH_HLEN + 4) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): too short", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): too short", __FUNCTION__, __LINE__);
 #endif
     return 0;
   }
@@ -3750,7 +3805,7 @@
   if ((pack_iph->version_ihl & 0xf0) != 0x40) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dropping non-IPv4", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): dropping non-IPv4", __FUNCTION__, __LINE__);
 #endif
     return 0;
   }
@@ -3760,8 +3815,8 @@
    */
   if (!dhcp_hashget(this, &conn, pack_ethh->src)) {
 
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
+    if (_options.debug > 2)
+      chilli_log(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
 
     ourip.s_addr = conn->ourip.s_addr;
 
@@ -3772,7 +3827,7 @@
     memcpy(&reqaddr.s_addr, &pack_iph->saddr, PKT_IP_ALEN);
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Address not found (%s)", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
+      chilli_log(LOG_DEBUG, "%s(%d): Address not found (%s)", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
 
     /* Do we allow dynamic allocation of IP addresses? */
     if (!this->allowdyn
@@ -3784,14 +3839,14 @@
 #endif
 	) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping packet; no dynamic ip and no anyip", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dropping packet; no dynamic ip and no anyip", __FUNCTION__, __LINE__);
       return 0;
     }
 
     /* Allocate new connection */
     if (dhcp_newconn(this, &conn, pack_ethh->src)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping packet; out of connections", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dropping packet; out of connections", __FUNCTION__, __LINE__);
       return 0; /* Out of connections */
     }
   }
@@ -3799,7 +3854,7 @@
   /* Return if we do not know peer */
   if (!conn) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dropping packet; no peer", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): dropping packet; no peer", __FUNCTION__, __LINE__);
     return 0;
   }
 
@@ -3809,7 +3864,7 @@
   if (_options.ieee8021q) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
 #endif
     dhcp_checktag(conn, pack);
   }
@@ -3823,7 +3878,7 @@
 
   if (eth_tot_len > (uint16_t) len) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dropping ip packet; ip-len=%d + eth-hdr=%d > read-len=%d", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): dropping ip packet; ip-len=%d + eth-hdr=%d > read-len=%d", __FUNCTION__, __LINE__,
              iph_tot_len,
              sizeofeth(pack), (int)len);
 
@@ -3831,7 +3886,7 @@
       uint8_t icmp_pack[1500];
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Sending fragmentation ICMP", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Sending fragmentation ICMP", __FUNCTION__, __LINE__);
       dhcp_send(this, ctx->idx, pack_ethh->src, icmp_pack,
 		icmpfrag(conn, icmp_pack, sizeof(icmp_pack), pack));
 
@@ -3847,7 +3902,7 @@
       (pack_iph->version_ihl & 0xf) * 4 > iph_tot_len) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dropping invalid-IPv4", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): dropping invalid-IPv4", __FUNCTION__, __LINE__);
 #endif
     return 0;
   }
@@ -3860,7 +3915,7 @@
   if (iph_tot_len > _options.mtu && (pack_iph->opt_off_high & 64)) {
     uint8_t icmp_pack[1500];
     if (_options.debug)
-      syslog(LOG_DEBUG,
+      chilli_log(LOG_DEBUG,
              "%s(%d): ICMP frag forbidden for IP packet with length %d > %d", __FUNCTION__, __LINE__,
              iph_tot_len, _options.mtu);
     dhcp_send(this, ctx->idx, pack_ethh->src, icmp_pack,
@@ -3891,7 +3946,7 @@
          iphdr_more_frag(pack_iph) == 0 &&
          iphdr_offset(pack_iph) == 0)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping udp packet; ip-len=%d != udp-len=%d + ip-hdr=20", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): dropping udp packet; ip-len=%d != udp-len=%d + ip-hdr=20", __FUNCTION__, __LINE__,
                (int) iph_tot_len,
                (int) udph_len);
       OTHER_RECEIVED(conn, pack_iph);
@@ -3903,7 +3958,7 @@
     pack_tcph = pkt_tcphdr(pack);
     if (iph_tot_len < PKT_IP_HLEN + PKT_TCP_HLEN) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping tcp packet; ip-len=%d", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): dropping tcp packet; ip-len=%d", __FUNCTION__, __LINE__,
                (int) iph_tot_len);
       OTHER_RECEIVED(conn, pack_iph);
       return 0;
@@ -3913,7 +3968,7 @@
   /*
    *  Check that the destination MAC address is our MAC or Broadcast
    */
-  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this), PKT_ETH_ALEN)) &&
+  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN)) &&
       (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
 #ifdef ENABLE_MDNS
     /* http://en.wikipedia.org/wiki/IP_multicast */
@@ -3922,14 +3977,16 @@
 	pack_ethh->dst[1] == 0x00 &&
 	pack_ethh->dst[2] == 0x5e) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Multicast: "MAC_FMT, __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Multicast: "MAC_FMT, __FUNCTION__, __LINE__,
                MAC_ARG(pack_ethh->dst));
     } else {
 #endif
-#if(_debug_)
+#if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Not for our MAC or broadcast: "MAC_FMT, __FUNCTION__, __LINE__,
-               MAC_ARG(pack_ethh->dst));
+        chilli_log(LOG_DEBUG, "%s(%d): Not for our MAC ("MAC_FMT") or broadcast ("MAC_FMT"): "MAC_FMT, __FUNCTION__, __LINE__,
+                MAC_ARG(bmac),
+                MAC_ARG(dhcp_nexthop(this, dhcp_conn_idx(conn))),
+                MAC_ARG(pack_ethh->dst));
 #endif
       OTHER_RECEIVED(conn, pack_iph);
       return 0;
@@ -3954,7 +4011,7 @@
 #endif
       ) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): dhcp/bootps request being processed", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): dhcp/bootps request being processed", __FUNCTION__, __LINE__);
     (void) dhcp_getreq(ctx, pack, len);
     OTHER_RECEIVED(conn, pack_iph);
     return 0;
@@ -3964,7 +4021,7 @@
 #ifdef ENABLE_LAYER3
   if (is_dhcp && _options.layer3) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): forwarding layer2 dhcp/bootps request", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): forwarding layer2 dhcp/bootps request", __FUNCTION__, __LINE__);
 
     if (this->relayfd > 0) {
       /** Relay the DHCP request **/
@@ -4041,7 +4098,7 @@
   if (_options.ieee8021q) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
 #endif
     dhcp_checktag(conn, pack);
   }
@@ -4061,7 +4118,7 @@
     if (this->cb_request)
       if (this->cb_request(conn, &addr, 0, 0)) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): dropping packet; ip not known: %s", __FUNCTION__, __LINE__, inet_ntoa(addr));
+          chilli_log(LOG_DEBUG, "%s(%d): dropping packet; ip not known: %s", __FUNCTION__, __LINE__, inet_ntoa(addr));
 	OTHER_RECEIVED(conn, pack_iph);
 	return 0; /* Ignore request if IP address was not allocated */
       }
@@ -4075,7 +4132,7 @@
 #endif
           pack_iph->saddr != conn->hisip.s_addr) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received packet with spoofed source!", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Received packet with spoofed source!", __FUNCTION__, __LINE__);
     OTHER_RECEIVED(conn, pack_iph);
     /*dhcp_sendRENEW(conn, pack, len);*/
     return 0;
@@ -4090,18 +4147,18 @@
 #ifdef ENABLE_NETBIOS
         if (pack_udph->dst == htons(137)) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): NetBIOS NS to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
+            chilli_log(LOG_DEBUG, "%s(%d): NetBIOS NS to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
           break;
         }
         else if (pack_udph->dst == htons(138)) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): NetBIOS DGM to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
+            chilli_log(LOG_DEBUG, "%s(%d): NetBIOS DGM to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
           break;
         }
 #endif
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Broadcasted UDP to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
+          chilli_log(LOG_DEBUG, "%s(%d): Broadcasted UDP to port %d", __FUNCTION__, __LINE__, ntohs(pack_udph->dst));
 #endif
         OTHER_RECEIVED(conn, pack_iph);
         return 0;
@@ -4119,8 +4176,9 @@
         if (appconn) {
           if (appconn->s_state.authenticated) {
             terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_USER_REQUEST);
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Dropping session due to request for auto-logout ip", __FUNCTION__, __LINE__);
+            char str[INET_ADDRSTRLEN] = {0};
+            inet_ntop(AF_INET, &(appconn->hisip), str, INET_ADDRSTRLEN);
+            chilli_log(LOG_INFO, "Dropping session due to request for auto-logout from username=%s IP=%s", appconn->s_state.redir.username, str);
             appconn->uamexit = 1;
           }
         }
@@ -4170,6 +4228,10 @@
           appconn = (struct app_conn_t *)conn->peer;
           appconn->s_state.last_up_time =
               appconn->s_state.last_time = mainclock_now();
+
+#ifdef ENABLE_TCPRESET
+          dhcp_garden_tcpreset(conn, appconn, pack);
+#endif
         }
         return 1;
       }
@@ -4200,7 +4262,7 @@
       if (dhcp_doDNAT(conn, pack, len, 1, &do_checksum) && !allowed) {
 #if(_debug_ > 1)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): dropping packet; not nat'ed", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): dropping packet; not nat'ed", __FUNCTION__, __LINE__);
 #endif
         OTHER_RECEIVED(conn, pack_iph);
         return 0;
@@ -4209,13 +4271,13 @@
 
     case DHCP_AUTH_DROP:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping packet; auth-drop", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dropping packet; auth-drop", __FUNCTION__, __LINE__);
       OTHER_RECEIVED(conn, pack_iph);
       return 0;
 
     default:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): dropping packet; unhandled auth state %d", __FUNCTION__, __LINE__, authstate);
+        chilli_log(LOG_DEBUG, "%s(%d): dropping packet; unhandled auth state %d", __FUNCTION__, __LINE__, authstate);
       OTHER_RECEIVED(conn, pack_iph);
       return 0;
   }
@@ -4238,7 +4300,7 @@
   } else {
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): no hisip; packet-drop", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): no hisip; packet-drop", __FUNCTION__, __LINE__);
 
   }
 
@@ -4263,14 +4325,14 @@
           break;
         default:
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): could not parse ICMP option", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): could not parse ICMP option", __FUNCTION__, __LINE__);
           datalen = 0;
           break;
       }
       if (dlen > 0) {
         if (dlen <= datalen) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): ICMPv6 Option %d %d %d", __FUNCTION__, __LINE__, (int)t,(int)l,dlen);
+            chilli_log(LOG_DEBUG, "%s(%d): ICMPv6 Option %d %d %d", __FUNCTION__, __LINE__, (int)t,(int)l,dlen);
           memcpy(b, data + i, dlen);
           switch(t) {
             case 1: /* source link-layer address */
@@ -4279,20 +4341,20 @@
               break;
             default:
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): could not parse ICMP option", __FUNCTION__, __LINE__);
+                chilli_log(LOG_DEBUG, "%s(%d): could not parse ICMP option", __FUNCTION__, __LINE__);
               datalen = 0;
               break;
           }
           if (dlen > 0) {
             if (dlen <= datalen) {
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): ICMPv6 Option %d %d %d", __FUNCTION__, __LINE__, (int)t,(int)l,dlen);
+                chilli_log(LOG_DEBUG, "%s(%d): ICMPv6 Option %d %d %d", __FUNCTION__, __LINE__, (int)t,(int)l,dlen);
               memcpy(b, data + i, dlen);
               switch(t) {
                 case 1: /* source link-layer address */
                 case 2: /* target link-layer address */
                   if (_options.debug)
-                    syslog(LOG_DEBUG, "%s(%d): ICMPv6 Source Link-Layer Address Option "MAC_FMT, __FUNCTION__, __LINE__, 
+                    chilli_log(LOG_DEBUG, "%s(%d): ICMPv6 Source Link-Layer Address Option "MAC_FMT, __FUNCTION__, __LINE__, 
                            MAC_ARG(b));
                   break;
                 default:
@@ -4317,12 +4379,12 @@
   int ip_datalen = (int) ntohs(iphdr->data_len);
   
   if (_options.debug) {
-    syslog(LOG_DEBUG, "%s(%d): Processing IPv6 ver=%d class=%d len=%d datalen=%d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Processing IPv6 ver=%d class=%d len=%d datalen=%d", __FUNCTION__, __LINE__,
            (int) ipv6_version(iphdr),
            (int) ipv6_class(iphdr),
            (int) len, ip_datalen);
 
-    syslog(LOG_DEBUG, "%s(%d): src "IPv6_ADDR_FMT" dst "IPv6_ADDR_FMT, __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): src "IPv6_ADDR_FMT" dst "IPv6_ADDR_FMT, __FUNCTION__, __LINE__,
            ipv6_exlode_addr(iphdr->src_addr),
            ipv6_exlode_addr(iphdr->dst_addr));
   }
@@ -4343,7 +4405,7 @@
       datalen = ip_datalen - sizeof(struct pkt_icmphdr_t);
       
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): ICMPv6 type=%d", __FUNCTION__, __LINE__, icmphdr->type);
+        chilli_log(LOG_DEBUG, "%s(%d): ICMPv6 type=%d", __FUNCTION__, __LINE__, icmphdr->type);
       
       /* Check checksum */
       
@@ -4440,7 +4502,7 @@
             data_len += 2 + PKT_ETH_ALEN;
             *payload++ = 1;
             *payload++ = 1;
-            memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+            memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
             payload += PKT_ETH_ALEN;
             
             /* MTU option */
@@ -4499,7 +4561,7 @@
             memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
             
             memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-            memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+            memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
             
             chksum6(packet_ip6h);
             
@@ -4555,7 +4617,7 @@
 	  data_len += 2 + PKT_ETH_ALEN;
 	  *payload++ = 2;
 	  *payload++ = 1;
-	  memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	  memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	  packet_ip6h->ver_class_label = iphdr->ver_class_label;
 	  packet_ip6h->next_header = iphdr->next_header;
@@ -4567,7 +4629,7 @@
 	  memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
 
 	  memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-	  memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	  memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	  chksum6(packet_ip6h);
 
@@ -4595,7 +4657,7 @@
             - sizeof(struct pkt_dhcp6hdr_t);
         
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): DHCPv6 message %d 0x%.2X%.2X%.2X", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): DHCPv6 message %d 0x%.2X%.2X%.2X", __FUNCTION__, __LINE__,
                  dhcp6hdr->type,dhcp6hdr->id[0],
                  dhcp6hdr->id[1],dhcp6hdr->id[2]);
         
@@ -4618,7 +4680,7 @@
 	      t = ntohs(t);
 	      l = ntohs(l);
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): DHCPv6 Option %d %d", __FUNCTION__, __LINE__, t, l);
+                chilli_log(LOG_DEBUG, "%s(%d): DHCPv6 Option %d %d", __FUNCTION__, __LINE__, t, l);
 	      switch(t) {
                 case 1: /* Client-Identifier */
                   duid = opts;
@@ -4688,7 +4750,7 @@
 	      u = htons(1); memcpy(payload, &u, 2); payload+=2;
 	      u = htons(1); memcpy(payload, &u, 2); payload+=2;
 	      u2 = htonl(time(0)); memcpy(payload, &u2, 4); payload+=4;
-	      memcpy(payload, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(payload, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 	      payload+=PKT_ETH_ALEN;
 
 	      if (ia_type) {
@@ -4761,7 +4823,7 @@
 	      memcpy(packet_ip6h->dst_addr, iphdr->src_addr, PKT_IPv6_ALEN);
 
 	      memcpy(packet_ethh->dst, ethh->src, PKT_ETH_ALEN);
-	      memcpy(packet_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(packet_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	      chksum6(packet_ip6h);
 
@@ -4804,7 +4866,7 @@
           memcpy(pack + 20, pack, sizeofeth(pack));
           
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): IPv6to4 src "IPv6_ADDR_FMT" dst "IPv6_ADDR_FMT" --> %s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): IPv6to4 src "IPv6_ADDR_FMT" dst "IPv6_ADDR_FMT" --> %s", __FUNCTION__, __LINE__,
                    ipv6_exlode_addr(iphdr->src_addr),
                    ipv6_exlode_addr(iphdr->dst_addr),
                    inet_ntoa(appconn->hisip));
@@ -4847,14 +4909,14 @@
       p += sizeof(struct pkt_pppoe_hdr_t);
       ppp = ntohs(*((uint16_t *)p));
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): PPPoE Session Code 0x%.2x Session 0x%.4x"
+        chilli_log(LOG_DEBUG, "%s(%d): PPPoE Session Code 0x%.2x Session 0x%.4x"
                " Length %d Proto 0x%.4x", __FUNCTION__, __LINE__,
                hdr->code, ntohs(hdr->session_id), len, ppp);
       switch(ppp) {
         case PKT_PPP_PROTO_LCP: {
           struct pkt_ppp_lcp_t *lcp = (struct pkt_ppp_lcp_t *)(p + 2);
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): PPP LCP code %.2x", __FUNCTION__, __LINE__, lcp->code);
+            chilli_log(LOG_DEBUG, "%s(%d): PPP LCP code %.2x", __FUNCTION__, __LINE__, lcp->code);
           switch (lcp->code) {
             case PPP_LCP_ConfigRequest: {
               uint8_t answer[1500];
@@ -4922,7 +4984,7 @@
 	       */
 
 	      memcpy(&answer_ethh->dst, &ethh->src, PKT_ETH_ALEN);
-	      memcpy(&answer_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	      memcpy(&answer_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
 
 	      dhcp_send(dhcp, ctx->idx, conn->hismac, answer, length);
 	    } break;
@@ -4947,7 +5009,7 @@
     uint8_t host_uniq_len=0;
     
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): PPPoE Discovery Code 0x%.2x Session 0x%.4x Length %d", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): PPPoE Discovery Code 0x%.2x Session 0x%.4x Length %d", __FUNCTION__, __LINE__,
              hdr->code, ntohs(hdr->session_id), len);
     
     p += sizeof(struct pkt_pppoe_hdr_t);
@@ -4963,17 +5025,17 @@
       switch(t) {
         case PPPoE_TAG_ServiceName:
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): PPPoE Service-Name: %.*s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): PPPoE Service-Name: %.*s", __FUNCTION__, __LINE__,
                    l, p + sizeof(struct pkt_pppoe_taghdr_t));
           break;
         case PPPoE_TAG_ACName:
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): PPPoE AC-Name: %.*s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): PPPoE AC-Name: %.*s", __FUNCTION__, __LINE__,
                    l, p + sizeof(struct pkt_pppoe_taghdr_t));
           break;
         case PPPoE_TAG_HostUniq:
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): PPPoE Host-Uniq: %.*s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): PPPoE Host-Uniq: %.*s", __FUNCTION__, __LINE__,
                    l * 2, p + sizeof(struct pkt_pppoe_taghdr_t));
           if (l > sizeof(host_uniq)) break;
           host_uniq_len = l;
@@ -4981,7 +5043,7 @@
           break;
         default:
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): PPPoE Tag Type 0x%.4x = (%d)[%.*s]", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): PPPoE Tag Type 0x%.4x = (%d)[%.*s]", __FUNCTION__, __LINE__,
                    t, l, l * 2, p + sizeof(struct pkt_pppoe_taghdr_t));
           break;
       }
@@ -5069,7 +5131,7 @@
 	 */
 
 	memcpy(&answer_ethh->dst, &ethh->src, PKT_ETH_ALEN);
-	memcpy(&answer_ethh->src, dhcp_nexthop(dhcp), PKT_ETH_ALEN);
+	memcpy(&answer_ethh->src, dhcp_nexthop(dhcp, 0), PKT_ETH_ALEN);
         
 	dhcp_send(dhcp, dhcp_conn_idx(conn), conn->hismac, answer, length);
       } break;
@@ -5118,7 +5180,7 @@
     _options.peerkey = "hello!";
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypting %d bytes", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypting %d bytes", __FUNCTION__, __LINE__,
            _options.peerid, n);
 
   EVP_CIPHER_CTX_init(&cctx);
@@ -5126,18 +5188,18 @@
 		  (const unsigned char *)_options.peerkey, iv);
 
   if (EVP_DecryptUpdate(&cctx, out, &olen, in, n) != 1) {
-    syslog(LOG_ERR, "%d CHILLI: peer %d error in decrypt update",
+    chilli_log(LOG_ERR, "%d CHILLI: peer %d error in decrypt update",
            errno, _options.peerid);
   } else {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypted %d bytes", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypted %d bytes", __FUNCTION__, __LINE__,
              _options.peerid, olen);
     if (EVP_DecryptFinal(&cctx, out + olen, &tlen) != 1) {
-      syslog(LOG_ERR, "%d CHILLI: peer %d error in decrypt final",
+      chilli_log(LOG_ERR, "%d CHILLI: peer %d error in decrypt final",
              errno, _options.peerid);
     } else {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypted %d bytes", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): CHILLI: peer %d decrypted %d bytes", __FUNCTION__, __LINE__,
                _options.peerid, tlen);
 
       olen += tlen;
@@ -5165,7 +5227,7 @@
           case CHILLI_PEER_INIT:
             cmd = "Init";
             if (chilli_hdr->from == _options.peerid) {
-              syslog(LOG_ERR, "peer %d possible conflicting peerid, oops",
+              chilli_log(LOG_ERR, "peer %d possible conflicting peerid, oops",
                      _options.peerid);
             } else {
               dhcp_sendCHILLI(CHILLI_PEER_HELLO, 0, 0);
@@ -5176,7 +5238,7 @@
           case CHILLI_PEER_HELLO:
             cmd = "Hello";
             if (chilli_hdr->from == _options.peerid) {
-              syslog(LOG_ERR, "peer %d possible conflicting peerid",
+              chilli_log(LOG_ERR, "peer %d possible conflicting peerid",
                      _options.peerid);
             } else {
               update_peer(chilli_hdr);
@@ -5185,7 +5247,7 @@
 	}
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): CHILLI: peer %d received %s from "
+          chilli_log(LOG_DEBUG, "%s(%d): CHILLI: peer %d received %s from "
                  MAC_FMT" peerid %d len=%d", __FUNCTION__, __LINE__,
                  _options.peerid, cmd,
                  MAC_ARG(ethh->src),
@@ -5210,7 +5272,7 @@
   ignore = get_chilli_peer(-1)->state != PEER_STATE_ACTIVE;
 
   if (ignore && _options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ignore: src="MAC_FMT" "
+    chilli_log(LOG_DEBUG, "%s(%d): ignore: src="MAC_FMT" "
            "dst="MAC_FMT" prot=%.4x %d len=%d", __FUNCTION__, __LINE__,
            MAC_ARG(ethh->src),
            MAC_ARG(ethh->dst),
@@ -5245,7 +5307,7 @@
 
   if (length < min_length) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): bad packet length %zu", __FUNCTION__, __LINE__, length);
+      chilli_log(LOG_DEBUG, "%s(%d): bad packet length %zu", __FUNCTION__, __LINE__, length);
     return 0;
   }
 
@@ -5256,7 +5318,7 @@
       min_length = sizeof(struct pkt_ethhdr8021q_t);
       if (length < min_length) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): bad packet length %zu", __FUNCTION__, __LINE__, length);
+          chilli_log(LOG_DEBUG, "%s(%d): bad packet length %zu", __FUNCTION__, __LINE__, length);
 	return 0;
       }
       ethh = ethhdr8021q(packet);
@@ -5275,7 +5337,7 @@
 #if(_debug_ > 1)
   if (_options.debug) {
     struct pkt_ethhdr_t *ethh = pkt_ethhdr(packet);
-    syslog(LOG_DEBUG, "%s(%d): dhcp_decaps: src="MAC_FMT" "
+    chilli_log(LOG_DEBUG, "%s(%d): dhcp_decaps: src="MAC_FMT" "
            "dst="MAC_FMT" prot=%.4x %d len=%zd", __FUNCTION__, __LINE__,
            MAC_ARG(ethh->src),
            MAC_ARG(ethh->dst),
@@ -5301,12 +5363,12 @@
             (struct pkt_llc_snap_t *)(p + sizeof(struct pkt_llc_t));
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Layer2 PROT: IEEE 802.3 LLC SNAP "
+          chilli_log(LOG_DEBUG, "%s(%d): Layer2 PROT: IEEE 802.3 LLC SNAP "
                  " EtherType 0x%.4x", __FUNCTION__, __LINE__, 
                  ntohs(snap->type));
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Layer2 PROT: Likely IEEE 802.3: "
+          chilli_log(LOG_DEBUG, "%s(%d): Layer2 PROT: Likely IEEE 802.3: "
                  "length %d dsap=0x%.2x ssap=0x%.2x ctrl=0x%.2x", __FUNCTION__, __LINE__,
                  (int) prot, llc->dsap, llc->ssap, llc->cntl);
       }
@@ -5317,7 +5379,7 @@
 #ifdef ENABLE_LAYER3
     if (!_options.layer3)
 #endif
-      syslog(LOG_DEBUG, "%s(%d): Layer2 PROT: 0x%.4x dropped", __FUNCTION__, __LINE__, prot);
+      chilli_log(LOG_DEBUG, "%s(%d): Layer2 PROT: 0x%.4x dropped", __FUNCTION__, __LINE__, prot);
 #endif
 
     return 0;
@@ -5377,7 +5439,7 @@
         if (!_options.layer3)
 #endif
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Layer2 PROT: 0x%.4x dropped", __FUNCTION__, __LINE__, prot);
+            chilli_log(LOG_DEBUG, "%s(%d): Layer2 PROT: 0x%.4x dropped", __FUNCTION__, __LINE__, prot);
       break;
   }
 
@@ -5464,71 +5526,73 @@
 
   if ((length = recvfrom(this->relayfd, &packet, sizeof(packet), 0,
                          (struct sockaddr *) &addr, &fromlen)) <= 0) {
-    syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
     return -1;
   }
 
   if (length < 44) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): DHCP packet too short", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): DHCP packet too short", __FUNCTION__, __LINE__);
     return -1;
   }
 
   if (packet.op != 2) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Ignored non-relay reply DHCP packet", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Ignored non-relay reply DHCP packet", __FUNCTION__, __LINE__);
     return -1;
   }
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): DHCP relay response from %s of length %d received", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): DHCP relay response from %s of length %d received", __FUNCTION__, __LINE__,
            inet_ntoa(addr.sin_addr), (int)length);
 
   if (addr.sin_addr.s_addr != _options.dhcpgwip.s_addr &&
       addr.sin_addr.s_addr != _options.dhcprelayip.s_addr &&
       addr.sin_addr.s_addr != _options.uamlisten.s_addr) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received DHCP response from host (%s) other than our gateway", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Received DHCP response from host (%s) other than our gateway", __FUNCTION__, __LINE__,
              inet_ntoa(addr.sin_addr));
     return -1;
   }
 
   if (addr.sin_port != htons(_options.dhcpgwport)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Received DHCP response from port (%d) other than our gateway", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Received DHCP response from port (%d) other than our gateway", __FUNCTION__, __LINE__,
              ntohs(addr.sin_port));
     return -1;
   }
 
   if (dhcp_gettag(&packet, length, &message_type,
 		  DHCP_OPTION_MESSAGE_TYPE)) {
-    syslog(LOG_ERR, "no message type");
+    chilli_log(LOG_ERR, "no message type");
     return -1;
   }
 
   if (message_type->l != 1) {
-    syslog(LOG_ERR, "wrong message type length");
+    chilli_log(LOG_ERR, "wrong message type length");
     return -1; /* Wrong length of message type */
   }
 
   if (dhcp_hashget(this, &conn, packet.chaddr)) {
     /* Allocate new connection */
     if (dhcp_newconn(this, &conn, packet.chaddr)) {
-      syslog(LOG_ERR, "out of connections");
+      chilli_log(LOG_ERR, "out of connections");
       return 0; /* Out of connections */
     }
   }
 
-  if (conn->authstate == DHCP_AUTH_NONE ||
-      conn->authstate == DHCP_AUTH_DNAT)
+  if (message_type->v[0] != DHCPNAK &&
+      (conn->authstate == DHCP_AUTH_NONE ||
+       conn->authstate == DHCP_AUTH_DNAT)) {
     this->cb_request(conn, (struct in_addr *)&packet.yiaddr, 0, 0);
+  }
 
   packet.giaddr = 0;
 
   memset(&fullpack, 0, sizeof(fullpack));
 
   dhcp_ethhdr(conn, fullpack, conn->hismac,
-	      dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+	      dhcp_nexthop(this, idx), PKT_ETH_PROTO_IP);
 
   {
     struct pkt_iphdr_t *fullpack_iph = pkt_iphdr(fullpack);
@@ -5550,16 +5614,16 @@
 
     if (packet.ciaddr) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): DHCP: CIAddr", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): DHCP: CIAddr", __FUNCTION__, __LINE__);
       fullpack_iph->daddr = packet.ciaddr;
     } else if (packet.flags[0] & 0x80 || message_type->v[0] == DHCPNAK) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): DHCP: Nak or Broadcast", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): DHCP: Nak or Broadcast", __FUNCTION__, __LINE__);
       packet.flags[0] = 0x80;
-      dhcp_ethhdr(conn, fullpack, bmac, dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+      dhcp_ethhdr(conn, fullpack, bmac, dhcp_nexthop(this, idx), PKT_ETH_PROTO_IP);
     } else if (packet.yiaddr) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): DHCP: YIAddr", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): DHCP: YIAddr", __FUNCTION__, __LINE__);
       fullpack_iph->daddr = packet.yiaddr;
     }
 
@@ -5583,13 +5647,13 @@
     chksum(fullpack_iph);
 
     addr.sin_addr.s_addr = fullpack_iph->daddr;
-    syslog(LOG_DEBUG, "%s(%d): Sending DHCP relay response %s:%d %d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Sending DHCP relay response %s:%d %d", __FUNCTION__, __LINE__,
            inet_ntoa(addr.sin_addr),
            ntohs(fullpack_udph->dst),
            (int)(length + sizeofudp(fullpack)));
 
     addr.sin_addr.s_addr = fullpack_iph->saddr;
-    syslog(LOG_DEBUG, "%s(%d): Sending DHCP from %s:%d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Sending DHCP from %s:%d", __FUNCTION__, __LINE__,
            inet_ntoa(addr.sin_addr),
            ntohs(fullpack_udph->src));
 
@@ -5628,7 +5692,7 @@
     size_t hdrplus = sizeofeth2(tag) - sizeofeth(packet);
     if (hdrplus > 0) {
       if (pb->offset < hdrplus) {
-	syslog(LOG_ERR, "bad buffer off=%d hdrplus=%d",
+	chilli_log(LOG_ERR, "bad buffer off=%d hdrplus=%d",
                (int) pb->offset, (int) hdrplus);
 	return 0;
       }
@@ -5639,7 +5703,7 @@
   } else {
     size_t hdrlen = sizeofeth2(tag);
     if (pb->offset < hdrlen) {
-      syslog(LOG_ERR, "bad buffer off=%d hdr=%d",
+      chilli_log(LOG_ERR, "bad buffer off=%d hdr=%d",
              (int) pb->offset, (int) hdrlen);
       return 0;
     }
@@ -5647,12 +5711,12 @@
     packet = pkt_buffer_head(pb);
     length = pkt_buffer_length(pb);
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "%s(%d): adding %zd to IP frame length %zd", __FUNCTION__, __LINE__, hdrlen, length);
+    chilli_log(LOG_DEBUG, "%s(%d): adding %zd to IP frame length %zd", __FUNCTION__, __LINE__, hdrlen, length);
 #endif
   }
 
   if (!this) {
-    syslog(LOG_WARNING, "DHCP connection no longer valid");
+    chilli_log(LOG_WARNING, "DHCP connection no longer valid");
     return 0;
   }
 
@@ -5691,7 +5755,7 @@
   authstate = conn->authstate;
 #endif
 
-  dhcp_ethhdr(conn, packet, conn->hismac, dhcp_nexthop(this), PKT_ETH_PROTO_IP);
+  dhcp_ethhdr(conn, packet, conn->hismac, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_PROTO_IP);
 
   switch (dhcp_dnsunDNAT(conn, packet, &length, &do_checksum)) {
     case 0:  /* Not DNS */break;
@@ -5716,7 +5780,7 @@
       /* undo destination NAT */
       if (dhcp_undoDNAT(conn, packet, &length, 1, &do_checksum) && !allowed) {
 #if(_debug_ > 1)
-        syslog(LOG_DEBUG, "%s(%d): dhcp_undoDNAT() returns true", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): dhcp_undoDNAT() returns true", __FUNCTION__, __LINE__);
 #endif
         return 0;
       }
@@ -5724,12 +5788,12 @@
 
     case DHCP_AUTH_DROP:
 #if(_debug_)
-      syslog(LOG_DEBUG, "%s(%d): drop", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): drop", __FUNCTION__, __LINE__);
 #endif
       return 0;
     default:
 #if(_debug_)
-      syslog(LOG_DEBUG, "%s(%d): unhandled authstate %d", __FUNCTION__, __LINE__, authstate);
+      chilli_log(LOG_DEBUG, "%s(%d): unhandled authstate %d", __FUNCTION__, __LINE__, authstate);
 #endif
       return 0;
   }
@@ -5753,7 +5817,7 @@
     pb->length = length;
 
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "%s(%d): adding 20 to frame length %zd", __FUNCTION__, __LINE__, length);
+    chilli_log(LOG_DEBUG, "%s(%d): adding 20 to frame length %zd", __FUNCTION__, __LINE__, length);
 #endif
 
     pkt_buffer_grow(pb, 20);
@@ -5823,20 +5887,20 @@
 
   /* Source address */
   memcpy(packet_arp->spa, &reqaddr.s_addr, PKT_IP_ALEN);
-  memcpy(packet_arp->sha, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_arp->sha, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   /* Target address */
   memcpy(packet_arp->tha, &conn->hismac, PKT_ETH_ALEN);
   memcpy(packet_arp->tpa, &conn->hisip.s_addr, PKT_IP_ALEN);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ARP: Replying to %s / "MAC_FMT, __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): ARP: Replying to %s / "MAC_FMT, __FUNCTION__, __LINE__,
            inet_ntoa(conn->hisip),
            MAC_ARG(conn->hismac));
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, conn->hismac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   OTHER_SENDING_LEN(conn,sizeof(struct arp_packet_t));
   return dhcp_send(this, dhcp_conn_idx(conn), conn->hismac,
@@ -5854,7 +5918,7 @@
   struct arp_packet_t *pack_arp = pkt_arppkt(pack);
 
   if (len < sizeofeth(pack) + sizeof(struct arp_packet_t)) {
-    syslog(LOG_ERR, "ARP too short %d < %d", (int) len,
+    chilli_log(LOG_ERR, "ARP too short %d < %d", (int) len,
            (int) (sizeofeth(pack) + sizeof(struct arp_packet_t)));
     return 0;
   }
@@ -5862,7 +5926,7 @@
   if (ntohs(pack_arp->hrd) != 1 ||       /* Ethernet Hardware */
       pack_arp->hln != PKT_ETH_ALEN ||   /* MAC Address Size */
       pack_arp->pln != PKT_IP_ALEN) {    /* IP Address Size */
-    syslog(LOG_ERR, "ARP reject hrd=%d hln=%d pln=%d",
+    chilli_log(LOG_ERR, "ARP reject hrd=%d hln=%d pln=%d",
            ntohs(pack_arp->hrd), pack_arp->hln, pack_arp->pln);
     return 0;
   }
@@ -5870,15 +5934,7 @@
   /* Check that this is ARP request */
   if (pack_arp->op != htons(DHCP_ARP_REQUEST)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Received other ARP than request!", __FUNCTION__, __LINE__);
-    return 0;
-  }
-
-  /* Check that MAC address is our MAC or Broadcast */
-  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this), PKT_ETH_ALEN)) &&
-      (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
-    if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Received ARP request for other destination!", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Received other ARP than request!", __FUNCTION__, __LINE__);
     return 0;
   }
 
@@ -5893,9 +5949,9 @@
     if (taraddr.s_addr == _options.dhcplisten.s_addr) {
       if (dhcp_hashget(this, &conn, pack_arp->sha)) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): ARP: Address not found: %s", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
+          chilli_log(LOG_DEBUG, "%s(%d): ARP: Address not found: %s", __FUNCTION__, __LINE__, inet_ntoa(reqaddr));
 	if (dhcp_newconn(this, &conn, pack_arp->sha)) {
-	  syslog(LOG_WARNING, "ARP: out of connections");
+	  chilli_log(LOG_WARNING, "ARP: out of connections");
 	  return 0; /* Out of connections */
 	}
       }
@@ -5905,7 +5961,7 @@
       if (_options.ieee8021q) {
 #if(_debug_ > 1)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
 #endif
 	dhcp_checktag(conn, pack);
       }
@@ -5919,7 +5975,7 @@
   /* Check to see if we know MAC address. */
   if (dhcp_hashget(this, &conn, pack_arp->sha)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Address not found: %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Address not found: %s", __FUNCTION__, __LINE__,
              inet_ntoa(reqaddr));
 
     /* Do we allow dynamic allocation of IP addresses? */
@@ -5929,18 +5985,26 @@
 #endif
 	) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): ARP: Unknown client and no dynip: %s", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): ARP: Unknown client and no dynip: %s", __FUNCTION__, __LINE__,
                inet_ntoa(taraddr));
       return 0;
     }
 
     /* Allocate new connection */
     if (dhcp_newconn(this, &conn, pack_arp->sha)) {
-      syslog(LOG_WARNING, "ARP: out of connections");
+      chilli_log(LOG_WARNING, "ARP: out of connections");
       return 0; /* Out of connections */
     }
   }
 
+  /* Check that MAC address is our MAC or Broadcast */
+  if ((memcmp(pack_ethh->dst, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN)) &&
+      (memcmp(pack_ethh->dst, bmac, PKT_ETH_ALEN))) {
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Received ARP request for other destination!", __FUNCTION__, __LINE__);
+    return 0;
+  }
+
   OTHER_RECEIVED_LEN(conn, len-PKT_ETH_HLEN);
   dhcp_conn_set_idx(conn, ctx);
 
@@ -5948,16 +6012,18 @@
   if (_options.ieee8021q) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): calling dhcp_checktag", __FUNCTION__, __LINE__);
 #endif
     dhcp_checktag(conn, pack);
   }
 #endif
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ARP: "MAC_FMT" asking about %s", __FUNCTION__, __LINE__,
-           MAC_ARG(conn->hismac),
-           inet_ntoa(taraddr));
+    chilli_log(LOG_DEBUG, "%s(%d): ARP: %s ("MAC_FMT") interface "MAC_FMT" asking about %s", __FUNCTION__, __LINE__,
+            this->rawif[dhcp_conn_idx(conn)].devname,
+            MAC_ARG(this->rawif[dhcp_conn_idx(conn)].hwaddr),
+            MAC_ARG(conn->hismac),
+            inet_ntoa(taraddr));
 
   if (conn->authstate == DHCP_AUTH_DROP) {
     return 0;
@@ -5968,7 +6034,7 @@
     /* XXX: lookup in ippool to see if we really do know who has this */
     /* XXX: it should also ack if *we* are that ip */
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Ignoring self-discovery: %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Ignoring self-discovery: %s", __FUNCTION__, __LINE__,
              inet_ntoa(taraddr));
 
     /* If a static ip address... */
@@ -5988,7 +6054,7 @@
 #endif
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Ignoring gratuitous arp %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Ignoring gratuitous arp %s", __FUNCTION__, __LINE__,
              inet_ntoa(taraddr));
     return 0;
   }
@@ -5996,7 +6062,7 @@
   /* Is ARP request for clients own address: Ignore */
   if (!memcmp(&conn->hisip.s_addr, &taraddr.s_addr, 4)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: hisip equals target ip: %s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: hisip equals target ip: %s", __FUNCTION__, __LINE__,
              inet_ntoa(conn->hisip));
     return 0;
   }
@@ -6013,7 +6079,7 @@
     /* Only reply if he was allocated an address,
        unless it was a request for the gateway dhcplisten. */
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: request did not come from known client", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: request did not come from known client", __FUNCTION__, __LINE__);
     return 0;
   }
 
@@ -6024,7 +6090,7 @@
        if (reqaddr.s_addr &&
        (conn->hisip.s_addr & conn->hismask.s_addr) !=
        (reqaddr.s_addr & conn->hismask.s_addr)) {
-       syslog(LOG_DEBUG, "ARP: request not in our subnet");
+       chilli_log(LOG_DEBUG, "ARP: request not in our subnet");
        return 0;
        }
     */
@@ -6033,9 +6099,9 @@
 	memcmp(&_options.dhcplisten.s_addr, &taraddr.s_addr, 4)) {
       /* if ourip differs from target ip */
       if (_options.debug) {
-	syslog(LOG_DEBUG, "%s(%d): ARP: Did not ask for router address: %s", __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): ARP: Did not ask for router address: %s", __FUNCTION__, __LINE__,
                inet_ntoa(conn->ourip));
-	syslog(LOG_DEBUG, "%s(%d): ARP: Asked for target: %s", __FUNCTION__, __LINE__,
+	chilli_log(LOG_DEBUG, "%s(%d): ARP: Asked for target: %s", __FUNCTION__, __LINE__,
                inet_ntoa(taraddr));
       }
       return 0; /* Only reply if he asked for his router address */
@@ -6046,7 +6112,7 @@
 	   (taraddr.s_addr & _options.uamanyipex_mask.s_addr) ==
 	   _options.uamanyipex_addr.s_addr) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): ARP: Request for %s in uamanyipex subnet, ignoring", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): ARP: Request for %s in uamanyipex subnet, ignoring", __FUNCTION__, __LINE__,
              inet_ntoa(taraddr));
     return 0;
   }
@@ -6055,7 +6121,7 @@
     /* when uamanyip is on we should ignore arp requests that ARE within
        our subnet except of course the ones for ourselves */
     if (_options.debug)
-      syslog(LOG_DEBUG, "ARP: Request for %s other than us within "
+      chilli_log(LOG_DEBUG, "ARP: Request for %s other than us within "
              "our subnet(uamanyip on), ignoring",
              inet_ntoa(taraddr));
     return 0;
@@ -6095,7 +6161,7 @@
 
   /* Ethernet header */
   memcpy(packet_ethh->dst, conn->hismac, PKT_ETH_ALEN);
-  memcpy(packet_ethh->src, dhcp_nexthop(this), PKT_ETH_ALEN);
+  memcpy(packet_ethh->src, dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_ALEN);
 
   packet_ethh->prot = htons(PKT_ETH_PROTO_EAPOL);
 
@@ -6145,15 +6211,15 @@
   /* Check to see if we know MAC address. */
   if (!dhcp_hashget(this, &conn, pack_ethh->src)) {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Address found", __FUNCTION__, __LINE__);
   }
   else {
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Address not found", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Address not found", __FUNCTION__, __LINE__);
   }
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): IEEE 802.1x Packet: %.2x, %.2x %d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): IEEE 802.1x Packet: %.2x, %.2x %d", __FUNCTION__, __LINE__,
            pack_dot1x->ver, pack_dot1x->type,
            ntohs(pack_dot1x->len));
 
@@ -6180,7 +6246,7 @@
     if (_options.ieee8021q) {
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s calling dhcp_checktag", __FUNCTION__);
+        chilli_log(LOG_DEBUG, "%s calling dhcp_checktag", __FUNCTION__);
 #endif
       dhcp_checktag(conn, pack);
     }
@@ -6188,7 +6254,7 @@
 
     memset(&p, 0, sizeof(p));
     dhcp_ethhdr(conn, p, pack_ethh->src,
-		dhcp_nexthop(this), PKT_ETH_PROTO_EAPOL);
+		dhcp_nexthop(this, dhcp_conn_idx(conn)), PKT_ETH_PROTO_EAPOL);
 
     p_dot1x = pkt_dot1xhdr(p);
     p_eap = pkt_eappkt(p);
@@ -6249,7 +6315,7 @@
 #if(_debug_ > 1)
   if (_options.debug) {
     struct pkt_ethhdr_t *ethh = pkt_ethhdr(packet);
-    syslog(LOG_DEBUG, "eapol_decaps: src="MAC_FMT" dst="MAC_FMT" prot=%.4x",
+    chilli_log(LOG_DEBUG, "eapol_decaps: src="MAC_FMT" dst="MAC_FMT" prot=%.4x",
            MAC_ARG(ethh->src),
            MAC_ARG(ethh->dst),
            ntohs(ethh->prot));
@@ -6337,18 +6403,18 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "dhcp_received: %zd", length);
+    chilli_log(LOG_DEBUG, "dhcp_received: %zd", length);
 #endif
 
   while (this->pb.offset < this->pb.length) {
 
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "dhcp_packet offset: %zu", this->pb.offset);
+      chilli_log(LOG_DEBUG, "dhcp_packet offset: %zu", this->pb.offset);
 #endif
 
     if (this->pb.length - this->pb.offset < sizeof(struct bpf_hdr)) {
-      syslog(LOG_ERR, "bad packet read");
+      chilli_log(LOG_ERR, "bad packet read");
       break;
     }
 
@@ -6356,18 +6422,18 @@
 
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "bpf_hdr  hdrlen %d caplen %d datalen %d",
+      chilli_log(LOG_DEBUG, "bpf_hdr  hdrlen %d caplen %d datalen %d",
              hdrp->bh_hdrlen, hdrp->bh_caplen, hdrp->bh_datalen);
 #endif
 
     if (this->pb.offset + hdrp->bh_hdrlen +
 	hdrp->bh_caplen > this->pb.length) {
-      syslog(LOG_ERR, "bad packet read");
+      chilli_log(LOG_ERR, "bad packet read");
       break;
     }
 
     if (hdrp->bh_caplen != hdrp->bh_datalen) {
-      syslog(LOG_WARNING, "BPF caplen(%d) != datalen(%d)",
+      chilli_log(LOG_WARNING, "BPF caplen(%d) != datalen(%d)",
              hdrp->bh_caplen, hdrp->bh_datalen);
       this->pb.offset += hdrp->bh_hdrlen + hdrp->bh_caplen;
       continue;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dhcp.h src/src/dhcp.h
--- upstream/src/dhcp.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dhcp.h	2025-11-06 13:20:13.000000000 +0000
@@ -300,7 +300,7 @@
 int dhcp_decaps(struct dhcp_t *this, int idx);
 int dhcp_relay_decaps(struct dhcp_t *this, int idx);
 int dhcp_data_req(struct dhcp_conn_t *conn, struct pkt_buffer *pb, int ethhdr);
-uint8_t * dhcp_nexthop(struct dhcp_t *);
+uint8_t * dhcp_nexthop(struct dhcp_t *, int idx);
 
 #if defined (__FreeBSD__) || defined (__APPLE__) || defined (__OpenBSD__) || defined (__NetBSD__)
 int dhcp_receive(struct dhcp_t *this, int idx);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/dns.c src/src/dns.c
--- upstream/src/dns.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/dns.c	2025-11-06 13:20:13.000000000 +0000
@@ -36,7 +36,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): %s dlen=%zd reslen=%zd olen=%zd lvl=%d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): %s dlen=%zd reslen=%zd olen=%zd lvl=%d", __FUNCTION__, __LINE__,
            __FUNCTION__, dlen, reslen, olen, lvl);
 #endif
 
@@ -54,13 +54,13 @@
 
 	if (offset > olen) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): bad value", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): bad value", __FUNCTION__, __LINE__);
 	  return -1;
 	}
 
 #if(_debug_ > 1)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): skip[%d] olen=%zd", __FUNCTION__, __LINE__, offset, olen);
+          chilli_log(LOG_DEBUG, "%s(%d): skip[%d] olen=%zd", __FUNCTION__, __LINE__, offset, olen);
 #endif
 
 	if (dns_fullname(d, dlen,
@@ -74,13 +74,13 @@
 
     if (l >= dlen || l >= olen) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): bad value %d/%zu/%zu", __FUNCTION__, __LINE__, l, dlen, olen);
+        chilli_log(LOG_DEBUG, "%s(%d): bad value %d/%zu/%zu", __FUNCTION__, __LINE__, l, dlen, olen);
       return -1;
     }
 
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): part[%.*s] reslen=%zd l=%d dlen=%zd", __FUNCTION__, __LINE__, 
+      chilli_log(LOG_DEBUG, "%s(%d): part[%.*s] reslen=%zd l=%d dlen=%zd", __FUNCTION__, __LINE__, 
              l, res, reslen, l, dlen);
 #endif
 
@@ -136,7 +136,11 @@
 	     int isReq, int *qmatch, int *modified, int mode) {
 
 #define return_error {                                                  \
-    if (_options.debug) syslog(LOG_DEBUG, "%s(%d): failed parsing DNS packet", __FUNCTION__, __LINE__); return -1; }
+		if (_options.debug)					\
+			chilli_log(LOG_DEBUG, "%s(%d): failed parsing DNS packet", __FUNCTION__, __LINE__); \
+									\
+		return -1; \
+}
 
   uint8_t *p_pkt = *pktp;
   size_t len = *left;
@@ -162,7 +166,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): left=%zd olen=%zd qsize=%zd",
+    chilli_log(LOG_DEBUG, "%s(%d): left=%zd olen=%zd qsize=%zd",
            __FUNCTION__, __LINE__, *left, olen, qsize);
 #endif
 
@@ -176,7 +180,7 @@
   len -= namelen;
 
   if (antidnstunnel && namelen > 128) {
-    syslog(LOG_WARNING,"dropping dns for anti-dnstunnel (namelen: %zd)", namelen);
+    chilli_log(LOG_WARNING,"dropping dns for anti-dnstunnel (namelen: %zd)", namelen);
     return -1;
   }
 
@@ -198,7 +202,7 @@
 
 #if(_debug_)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): It was a dns record type: %d class: %d", __FUNCTION__, __LINE__, type, class);
+    chilli_log(LOG_DEBUG, "%s(%d): It was a dns record type: %d class: %d", __FUNCTION__, __LINE__, type, class);
 #endif
 
   if (q) {
@@ -206,7 +210,7 @@
       return_error;
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): DNS: %s", __FUNCTION__, __LINE__, question);
+      chilli_log(LOG_DEBUG, "%s(%d): DNS: %s", __FUNCTION__, __LINE__, question);
 
     *pktp = p_pkt;
     *left = len;
@@ -221,7 +225,7 @@
 
 #if(_debug_)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): checking %s [%s]", __FUNCTION__, __LINE__,
+          chilli_log(LOG_DEBUG, "%s(%d): checking %s [%s]", __FUNCTION__, __LINE__,
                  _options.uamdomains[id], question);
 #endif
 
@@ -244,7 +248,7 @@
 	      ) ) {
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): matched %s [%s]", __FUNCTION__, __LINE__, _options.uamdomains[id], question);
+            chilli_log(LOG_DEBUG, "%s(%d): matched %s [%s]", __FUNCTION__, __LINE__, _options.uamdomains[id], question);
 #endif
 	  *qmatch = 1;
 	  break;
@@ -253,7 +257,7 @@
     }
 
 #ifdef ENABLE_UAMDOMAINFILE
-    if (!isReq && *qmatch == -1 && _options.uamdomainfile) {
+    if (!isReq && *qmatch == -1 && (_options.uamdomainfile || _options.uamblocklist)) {
       *qmatch = garden_check_domainfile((char *) question);
     }
 #endif
@@ -262,14 +266,14 @@
     if (_options.ipv6) {
       if (isReq && type == 28) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): changing AAAA to A request", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): changing AAAA to A request", __FUNCTION__, __LINE__);
 	us = 1;
 	us = htons(us);
 	memcpy(pkt_type, &us, sizeof(us));
 	*modified = 1;
       } else if (!isReq && type == 1) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): changing A to AAAA response", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): changing A to AAAA response", __FUNCTION__, __LINE__);
 	us = 28;
 	us = htons(us);
 	memcpy(pkt_type, &us, sizeof(us));
@@ -296,13 +300,13 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): -> w ttl: %d rdlength: %d/%zd", __FUNCTION__, __LINE__, ttl, rdlen, len);
+    chilli_log(LOG_DEBUG, "%s(%d): -> w ttl: %d rdlength: %d/%zd", __FUNCTION__, __LINE__, ttl, rdlen, len);
 #endif
 
   if (*qmatch == 1 && ttl > _options.uamdomain_ttl) {
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Rewriting DNS ttl from %d to %d", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): Rewriting DNS ttl from %d to %d", __FUNCTION__, __LINE__,
              (int) ttl, _options.uamdomain_ttl);
 #endif
     ul = _options.uamdomain_ttl;
@@ -321,14 +325,14 @@
 
     default:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Record type %d", __FUNCTION__, __LINE__, type);
+        chilli_log(LOG_DEBUG, "%s(%d): Record type %d", __FUNCTION__, __LINE__, type);
       return_error;
       break;
 
     case 1:
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): A record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): A record", __FUNCTION__, __LINE__);
 #endif
       required = 1;
 
@@ -340,7 +344,7 @@
           memcpy(&reqaddr.s_addr, p_pkt+offset, 4);
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): mDNS %s = %s", __FUNCTION__, __LINE__, name, inet_ntoa(reqaddr));
+            chilli_log(LOG_DEBUG, "%s(%d): mDNS %s = %s", __FUNCTION__, __LINE__, name, inet_ntoa(reqaddr));
 #endif
         }
         break;
@@ -357,32 +361,32 @@
 
     case 2: 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): NS record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): NS record", __FUNCTION__, __LINE__);
       required = 1;
       break;
     case 5: 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): CNAME record %s", __FUNCTION__, __LINE__, name);
+        chilli_log(LOG_DEBUG, "%s(%d): CNAME record %s", __FUNCTION__, __LINE__, name);
       required = 1;
       break;
     case 6: 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): SOA record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): SOA record", __FUNCTION__, __LINE__);
       break;
 
     case 12:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): PTR record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): PTR record", __FUNCTION__, __LINE__);
       break;
     case 15:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): MX record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): MX record", __FUNCTION__, __LINE__);
       required = 1;
       break;
 
     case 16:/* TXT */
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): TXT record %d", __FUNCTION__, __LINE__, rdlen);
+        chilli_log(LOG_DEBUG, "%s(%d): TXT record %d", __FUNCTION__, __LINE__, rdlen);
       if (_options.debug) {
         char *txt = (char *)p_pkt;
         int txtlen = rdlen;
@@ -390,7 +394,7 @@
           uint8_t l = *txt++;
           if (l == 0) break;
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Text: %.*s", __FUNCTION__, __LINE__, (int) l, txt);
+            chilli_log(LOG_DEBUG, "%s(%d): Text: %.*s", __FUNCTION__, __LINE__, (int) l, txt);
           txt += l;
           txtlen -= l;
         }
@@ -399,29 +403,41 @@
 
     case 28:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): AAAA record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): AAAA record", __FUNCTION__, __LINE__);
       required = 1;
       break;
     case 29:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): LOC record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): LOC record", __FUNCTION__, __LINE__);
       break;
     case 33:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): SRV record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): SRV record", __FUNCTION__, __LINE__);
+      break;
+    case 35:
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): NAPTR record", __FUNCTION__, __LINE__);
       break;
     case 41:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): EDNS OPT pseudorecord", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): EDNS OPT pseudorecord", __FUNCTION__, __LINE__);
       break;
     case 47:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): NSEC record", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): NSEC record", __FUNCTION__, __LINE__);
+      break;
+    case 64:
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): SVCB record", __FUNCTION__, __LINE__);
+      break;
+    case 65:
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): HTTPS record", __FUNCTION__, __LINE__);
       break;
   }
 
   if (antidnstunnel && !required) {
-    syslog(LOG_WARNING, "dropping dns for anti-dnstunnel (type %d: length %d)",
+    chilli_log(LOG_WARNING, "dropping dns for anti-dnstunnel (type %d: length %d)",
            type, rdlen);
     return -1;
   }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ewt.c src/src/ewt.c
--- upstream/src/ewt.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ewt.c	2025-11-06 13:20:13.000000000 +0000
@@ -48,11 +48,11 @@
       /*bunescape(name);*/
 
       if ((eq_pos + 1) == end_pos || (end_pos - eq_pos) <= 1) {
-	syslog(LOG_DEBUG, "%s(%d): %s = nil", __FUNCTION__, __LINE__, name->data);
+	chilli_log(LOG_DEBUG, "%s(%d): %s = nil", __FUNCTION__, __LINE__, name->data);
       } else {
         bassignblk(value, src+eq_pos+1, end_pos-eq_pos-1);
         /*bunescape(value);*/
-	syslog(LOG_DEBUG, "%s(%d): %s = %s", __FUNCTION__, __LINE__, name->data, value->data);
+	chilli_log(LOG_DEBUG, "%s(%d): %s = %s", __FUNCTION__, __LINE__, name->data, value->data);
 	setenv((char *)name->data, (char *)value->data, 1);
       }
       start_pos = end_pos + 1;
@@ -147,12 +147,12 @@
       case json_type_array:
         bassign(tmp, prefix);
         bcatcstr(tmp, key);
-        syslog(LOG_DEBUG, "%s(%d): a %s=%s", __FUNCTION__, __LINE__, tmp->data, json_object_to_json_string(val));
+        chilli_log(LOG_DEBUG, "%s(%d): a %s=%s", __FUNCTION__, __LINE__, tmp->data, json_object_to_json_string(val));
         break;
       default:
         bassign(tmp, prefix);
         bcatcstr(tmp, key);
-        syslog(LOG_DEBUG, "%s(%d): %s=%s", __FUNCTION__, __LINE__, tmp->data, json_object_to_json_string(val));
+        chilli_log(LOG_DEBUG, "%s(%d): %s=%s", __FUNCTION__, __LINE__, tmp->data, json_object_to_json_string(val));
         break;
     }
     bdestroy(tmp);
@@ -170,7 +170,7 @@
   bstring res = bfromcstr("");
   int i;
 
-  syslog(LOG_DEBUG, "%s(%d): EWT API Request", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): EWT API Request", __FUNCTION__, __LINE__);
 
   redir_getparam(redir, httpreq->qs, "s", s);
   redir_getparam(redir, httpreq->qs, "res", res);
@@ -183,7 +183,7 @@
     struct json_object *obj = 0;
     bblk_fromfd(b, 0, httpreq->clen);
     if ((obj = json_tokener_parse((char *)b->data))) {
-      syslog(LOG_DEBUG, "%s(%d): obj.to_string()=%s", __FUNCTION__, __LINE__, json_object_to_json_string(obj));
+      chilli_log(LOG_DEBUG, "%s(%d): obj.to_string()=%s", __FUNCTION__, __LINE__, json_object_to_json_string(obj));
       json_object_object_foreach(obj, key, val) {
 	if (!strcmp(key, (char *)s->data)) {
 	  bstring tmp = bfromcstr("CAP_");
@@ -204,7 +204,7 @@
 		"Content-type: application/json\r\n\r\n");
 
   if (safe_write(1, b->data, b->slen) < 0) {
-    syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
   }
 
   snprintf(path, sizeof(path),
@@ -214,9 +214,9 @@
     bassigncstr(b, "");
     if (!strcmp(ewt_services[i].name, (char *)s->data)) {
       ewt_services[i].func(b);
-      syslog(LOG_DEBUG, "%s(%d): Internal EWT Service %s -> %s", __FUNCTION__, __LINE__, ewt_services[i].name, b->data);
+      chilli_log(LOG_DEBUG, "%s(%d): Internal EWT Service %s -> %s", __FUNCTION__, __LINE__, ewt_services[i].name, b->data);
       if (safe_write(1, b->data, b->slen) < 0) {
-	syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+	chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
       }
       bdestroy(b);
       bdestroy(s);
@@ -226,9 +226,9 @@
   }
 
   setenv("EWTAPI", "1", 1);
-  syslog(LOG_DEBUG, "%s(%d): EWT API Running %s", __FUNCTION__, __LINE__, *binqqargs);
+  chilli_log(LOG_DEBUG, "%s(%d): EWT API Running %s", __FUNCTION__, __LINE__, *binqqargs);
 
   execv(*binqqargs, binqqargs);
-  syslog(LOG_ERR, "%s: count not exec %s", strerror(errno), *binqqargs);
+  chilli_log(LOG_ERR, "%s: count not exec %s", strerror(errno), *binqqargs);
   return -1;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/garden.c src/src/garden.c
--- upstream/src/garden.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/garden.c	2025-11-06 13:20:13.000000000 +0000
@@ -227,7 +227,7 @@
       for (i=0; i < nd->ptcnt; i++) {
 	if (pt_equal(&nd->ptlist[i], pt)) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): (Patricia)Uamallowed already exists #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): (Patricia)Uamallowed already exists #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
                    i, nd->ptcnt, pt->proto, inet_ntoa(pt->host), pt->port);
 	  break;
 	}
@@ -274,9 +274,9 @@
       for (i=0; i < nd->ptcnt; i++) {
 	if (pt_equal(&nd->ptlist[i], pt)) {
           if (_options.debug) {
-            syslog(LOG_DEBUG, "%s(%d): (Patricia)Uamallowed removing #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): (Patricia)Uamallowed removing #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
                    i, nd->ptcnt, pt->proto, inet_ntoa(pt->host), pt->port);
-            syslog(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, nd->ptcnt);
+            chilli_log(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, nd->ptcnt);
           }
 
 	  for (; i < nd->ptcnt-1; i++)
@@ -380,9 +380,9 @@
   for (i=0; i < cnt; i++) {
     if (pt_equal(&ptlist[i], pt)) {
       if (_options.debug) {
-        syslog(LOG_DEBUG, "%s(%d): Uamallowed removing #%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Uamallowed removing #%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
                i, pt->proto, inet_ntoa(pt->host), pt->port);
-        syslog(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, cnt);
+        chilli_log(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, cnt);
       }
       for (; i < cnt-1; i++)
 	memcpy(&ptlist[i], &ptlist[i+1], sizeof(pass_through));
@@ -412,11 +412,11 @@
   for (i=0; i < cnt; i++) {
     if (pt_equal(&ptlist[i], pt)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Uamallowed already exists #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): Uamallowed already exists #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
                i, ptlen, pt->proto, inet_ntoa(pt->host), pt->port);
       if (is_dyn) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, cnt);
+          chilli_log(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, cnt);
 	for (; i<cnt-1; i++)
 	  memcpy(&ptlist[i], &ptlist[i+1], sizeof(pass_through));
 	cnt = *ptcnt = *ptcnt - 1;
@@ -430,12 +430,12 @@
   if (cnt == ptlen) {
     if (!is_dyn) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): No more room for walled garden entries", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): No more room for walled garden entries", __FUNCTION__, __LINE__);
       return -1;
     }
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, ptlen);
+      chilli_log(LOG_DEBUG, "%s(%d): Shifting uamallowed list %d to %d", __FUNCTION__, __LINE__, i, ptlen);
     for (i=0; i<ptlen-1; i++)
       memcpy(&ptlist[i], &ptlist[i+1], sizeof(pass_through));
 
@@ -443,7 +443,7 @@
   }
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Uamallowed IP address #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): Uamallowed IP address #%d:%d: proto=%d host=%s port=%d", __FUNCTION__, __LINE__,
            cnt, ptlen, pt->proto, inet_ntoa(pt->host), pt->port);
 
   memcpy(&ptlist[cnt], pt, sizeof(pass_through));
@@ -478,11 +478,11 @@
   if (p3 == NULL)
      return 0;
 
-  strcpy(p3, s);
+  strncpy(p3, s, strlen(s));
   p1 = p3;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Uamallowed [%s]", __FUNCTION__, __LINE__, s);
+    chilli_log(LOG_DEBUG, "%s(%d): Uamallowed [%s]", __FUNCTION__, __LINE__, s);
 
   for ( ; p1; p1 = p2) {
 
@@ -506,7 +506,7 @@
 	struct protoent *proto = getprotobyname(p1);
 
 	if (!proto && !strchr(p1, '.'))
-	  proto = getprotobynumber(atoi(p1));
+	  proto = getprotobynumber(strtol(p1, NULL, 0));
 
 	if (proto)
 	  pnum = proto->p_proto;
@@ -531,7 +531,7 @@
     {
       char *e = strchr(p1, '#');
       if (e) {
-	int add = atoi(e+1);
+	int add = strtol(e+1, NULL, 0);
 	pt.expiry = mainclock_now() + add;
 	*e = 0;
       }
@@ -540,13 +540,13 @@
 
     /* look for an optional port */
     if ((t = strchr(p1, ':'))) {
-      pt.port = atoi(t+1);
+      pt.port = strtol(t+1, NULL, 0);
       *t = 0;
     }
 
     if (strchr(p1, '/')) {	/* parse a network address */
       if (option_aton(&pt.host, &pt.mask, p1, 0)) {
-	syslog(LOG_ERR, "Invalid uamallowed network address or mask %s!", s);
+	chilli_log(LOG_ERR, "Invalid uamallowed network address or mask %s!", s);
 	continue;
       }
       if (is_rem) {
@@ -555,14 +555,14 @@
 			     , ptree
 #endif
 			     ))
-	  syslog(LOG_ERR, "Too many pass-throughs! skipped %s", s);
+	  chilli_log(LOG_ERR, "Too many pass-throughs! skipped %s", s);
       } else {
 	if (pass_through_add(ptlist, ptlen, ptcnt, &pt, is_dyn
 #ifdef HAVE_PATRICIA
 			     , ptree
 #endif
 			     ))
-	  syslog(LOG_ERR, "Too many pass-throughs! skipped %s", s);
+	  chilli_log(LOG_ERR, "Too many pass-throughs! skipped %s", s);
       }
     }
     else {	/* otherwise, parse a host ip or hostname */
@@ -570,7 +570,7 @@
       pt.mask.s_addr = 0xffffffff;
 
       if (!(host = gethostbyname(p1))) {
-	syslog(LOG_ERR, "%s: Invalid uamallowed domain or address: %s!", strerror(errno), p1);
+	chilli_log(LOG_ERR, "%s: Invalid uamallowed domain or address: %s!", strerror(errno), p1);
 	continue;
       }
 
@@ -582,14 +582,14 @@
 			       , ptree
 #endif
 			       ))
-	    syslog(LOG_ERR, "Too many pass-throughs! skipped %s", s);
+	    chilli_log(LOG_ERR, "Too many pass-throughs! skipped %s", s);
 	} else {
 	  if (pass_through_add(ptlist, ptlen, ptcnt, &pt, is_dyn
 #ifdef HAVE_PATRICIA
 			       , ptree
 #endif
 			       ))
-	    syslog(LOG_ERR, "Too many pass-throughs! skipped %s", s);
+	    chilli_log(LOG_ERR, "Too many pass-throughs! skipped %s", s);
 	}
       }
     }
@@ -671,7 +671,7 @@
 
     fp = fopen(_options.uamdomainfile, "r");
     if (!fp) {
-      syslog(LOG_ERR, "%d could not open file %s",
+      chilli_log(LOG_ERR, "%d could not open file %s",
              errno, _options.uamdomainfile);
       return;
     }
@@ -685,7 +685,7 @@
 	uamdomain_regex * uam_re = (uamdomain_regex *)
             calloc(sizeof(uamdomain_regex), 1);
 	if (uam_re == (uamdomain_regex *)0) {
-	  syslog(LOG_ERR, "memory allocation for a new regex %s failed", line);
+	  chilli_log(LOG_ERR, "memory allocation for a new regex %s failed", line);
       fclose(fp);
 	  continue;
 	}
@@ -701,9 +701,9 @@
 	}
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): compiling %s", __FUNCTION__, __LINE__, pline);
+          chilli_log(LOG_DEBUG, "%s(%d): compiling %s", __FUNCTION__, __LINE__, pline);
 	if (regcomp(&uam_re->re, pline, REG_EXTENDED | REG_NOSUB)) {
-	  syslog(LOG_ERR, "could not compile regex %s", line);
+	  chilli_log(LOG_ERR, "could not compile regex %s", line);
 	  free(uam_re);
 	  continue;
 	}
@@ -733,15 +733,15 @@
 #if(_debug_)
     if (match)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): matched DNS name %s", __FUNCTION__, __LINE__, question);
+        chilli_log(LOG_DEBUG, "%s(%d): matched DNS name %s", __FUNCTION__, __LINE__, question);
 #endif
 
-    if (match) return uam_re->neg ? 0 : 1;
+    if (match) return uam_re->neg ? (_options.uamblocklist ? 1 : 0) : (_options.uamblocklist ? 0 : 1);
 
     uam_re = uam_re->next;
   }
 
-  return -1;
+  return _options.uamblocklist ? 1 : -1;
 }
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/gsm.c src/src/gsm.c
--- upstream/src/gsm.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,57 @@
+
+#include "system.h"
+#include <libgsm.h>
+#include <libgsm_utils.h>
+
+#include "gsm.h"
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	struct ubus_context *ubus;
+	lgsm_structed_info_t data = { 0 };
+	int ret = CHILLI_GSM_ERR;
+	int modem_num;
+
+	ubus = ubus_connect(NULL);
+	if (!ubus) {
+		return CHILLI_GSM_ERR;
+	}
+
+	if ((modem_num = lgsmu_modem_id_to_num(ubus, modem_id)) < 0) {
+		chilli_log(LOG_ERR, "Unable to get modem '%s' number", modem_id);
+
+		goto out;
+	}
+
+	if (lgsm_send_sms(ubus, phone, msg, &data, modem_num) == LGSM_SUCCESS) {
+		ret = CHILLI_GSM_OK;
+	} else {
+		chilli_log(LOG_ERR, "Unable to send SMS message to %s", phone);
+	}
+
+out:
+	ubus_free(ubus);
+	handle_gsm_structed_info_free(&data);
+
+	return ret;
+}
+
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id)
+{
+	int status;
+
+	if ((status = fork()) < 0) {
+		chilli_log(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+		return CHILLI_GSM_ERR;
+	}
+
+	if (status > 0) { /* Parent */
+		return CHILLI_GSM_OK;
+	}
+
+	chilli_send_sms(phone, msg, modem_id);
+
+	exit(0);
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/gsm.h src/src/gsm.h
--- upstream/src/gsm.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/gsm.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,20 @@
+
+#ifndef RUTX_GSM_H
+#define RUTX_GSM_H
+
+#include <libgsm.h>
+
+#define GSM_DEFAULT_USB_ID "3-1"
+
+typedef enum {
+    CHILLI_GSM_OK,
+    CHILLI_GSM_ERR
+} chilli_gsm_t;
+
+chilli_gsm_t chilli_send_sms(const char *phone, const char *msg,
+		const char *modem_id);
+chilli_gsm_t chilli_send_sms_async(const char *phone, const char *msg,
+		const char *modem_id);
+
+#endif //RUTX_GSM_H
+
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/iphash.c src/src/iphash.c
--- upstream/src/iphash.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/iphash.c	2025-11-06 13:20:13.000000000 +0000
@@ -54,7 +54,7 @@
   int i;
 
   if (!(n = calloc(sizeof(struct iphash_t), 1))) {
-    syslog(LOG_ERR, "Failed to allocate memory for iphash");
+    chilli_log(LOG_ERR, "Failed to allocate memory for iphash");
     return -1;
   }
 
@@ -85,7 +85,7 @@
   }
 
   if (!(n->hash = calloc(sizeof(struct iphashm_t *), n->hashsize))){
-    syslog(LOG_ERR, "Failed to allocate memory for iphash");
+    chilli_log(LOG_ERR, "Failed to allocate memory for iphash");
     free(n);
     return -1;
   }
@@ -118,7 +118,7 @@
   struct iphashm_t *p_prev = NULL;
   
   if (member == NULL) {
-    syslog(LOG_ERR, "%s: Bad input param member(%p)", __FUNCTION__, member);
+    chilli_log(LOG_ERR, "%s: Bad input param member(%p)", __FUNCTION__, member);
     return -1;
   }
 
@@ -132,7 +132,7 @@
   }
 
   if (p != member) {
-    syslog(LOG_ERR, "iphash_hashdel: Tried to delete member not in hash table");
+    chilli_log(LOG_ERR, "iphash_hashdel: Tried to delete member not in hash table");
     return -1;
   }
 
@@ -148,7 +148,7 @@
   struct iphashm_t *p = NULL;
   /*uint32_t hash;*/
 
-  syslog(LOG_DEBUG, "IPHASH IP: %s %d", inet_ntoa(*addr), ntohs(port));
+  chilli_log(LOG_DEBUG, "IPHASH IP: %s %d", inet_ntoa(*addr), ntohs(port));
 
   p = this->first;
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ippool.c src/src/ippool.c
--- upstream/src/ippool.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ippool.c	2025-11-06 13:20:13.000000000 +0000
@@ -173,7 +173,7 @@
   }
 
   if (p!= member) {
-    syslog(LOG_ERR, "ippool_hashdel: Tried to delete member not in hash table");
+    chilli_log(LOG_ERR, "ippool_hashdel: Tried to delete member not in hash table");
     return -1;
   }
 
@@ -218,7 +218,7 @@
   }
   else {
     if (option_aton(&addr, &mask, dyn, 0)) {
-      syslog(LOG_ERR, "Failed to parse dynamic pool");
+      chilli_log(LOG_ERR, "Failed to parse dynamic pool");
       return -1;
     }
 
@@ -234,25 +234,25 @@
 
     if ( ((ntohl(addr.s_addr) + start) & m) != (ntohl(addr.s_addr) & m) ) {
       addr.s_addr = htonl(ntohl(addr.s_addr) + start);
-      syslog(LOG_ERR, "Invalid dhcpstart=%d (%s) (outside of subnet)!",
+      chilli_log(LOG_ERR, "Invalid dhcpstart=%d (%s) (outside of subnet)!",
              start, inet_ntoa(addr));
       return -1;
     }
 
     if ( ((ntohl(addr.s_addr) + end) & m) != (ntohl(addr.s_addr) & m) ) {
-      syslog(LOG_ERR, "Invalid dhcpend (outside of subnet)!");
+      chilli_log(LOG_ERR, "Invalid dhcpend (outside of subnet)!");
       return -1;
     }
 
     if (start > 0 && end > 0) {
 
       if (end < start) {
-	syslog(LOG_ERR, "Bad arguments dhcpstart=%d and dhcpend=%d", start, end);
+	chilli_log(LOG_ERR, "Bad arguments dhcpstart=%d and dhcpend=%d", start, end);
 	return -1;
       }
 
       if ((end - start) > dynsize) {
-	syslog(LOG_ERR, "Too many IPs between dhcpstart=%d and dhcpend=%d",
+	chilli_log(LOG_ERR, "Too many IPs between dhcpstart=%d and dhcpend=%d",
                start, end);
 	return -1;
       }
@@ -295,7 +295,7 @@
   }
   else {
     if (option_aton(&stataddr, &statmask, stat, 0)) {
-      syslog(LOG_ERR, "Failed to parse static range");
+      chilli_log(LOG_ERR, "Failed to parse static range");
       return -1;
     }
 
@@ -312,7 +312,7 @@
   listsize = dynsize + statsize; /* Allocate space for static IP addresses */
 
   if (!(*this = calloc(sizeof(struct ippool_t), 1))) {
-    syslog(LOG_ERR, "Failed to allocate memory for ippool");
+    chilli_log(LOG_ERR, "Failed to allocate memory for ippool");
     return -1;
   }
 
@@ -326,7 +326,7 @@
   (*this)->listsize  = listsize;
 
   if (!((*this)->member = calloc(sizeof(struct ippoolm_t), listsize))){
-    syslog(LOG_ERR, "Failed to allocate memory for members in ippool");
+    chilli_log(LOG_ERR, "Failed to allocate memory for members in ippool");
     return -1;
   }
 
@@ -334,7 +334,7 @@
        ((1 << (*this)->hashlog) < listsize);
        (*this)->hashlog++);
 
-  syslog(LOG_DEBUG, "Hashlog %d %d %d", (*this)->hashlog, listsize,
+  chilli_log(LOG_DEBUG, "Hashlog %d %d %d", (*this)->hashlog, listsize,
          (1 << (*this)->hashlog));
 
   /* Determine hashsize */
@@ -344,7 +344,7 @@
   /* Allocate hash table */
   if (!((*this)->hash =
 	calloc(sizeof(struct ippoolm_t *), (*this)->hashsize))){
-    syslog(LOG_ERR, "Failed to allocate memory for hash members in ippool");
+    chilli_log(LOG_ERR, "Failed to allocate memory for hash members in ippool");
     return -1;
   }
 
@@ -452,7 +452,7 @@
   struct ippoolm_t *p2 = NULL;
   uint32_t hash;
 
-  syslog(LOG_DEBUG, "Requesting new %s ip: %s",
+  chilli_log(LOG_DEBUG, "Requesting new %s ip: %s",
          statip ? "static" : "dynamic", inet_ntoa(*addr));
 
   /* If static:
@@ -478,11 +478,11 @@
     if (!_options.uamanyip) {
 #endif
       if (!this->allowstat) {
-	syslog(LOG_DEBUG, "Static IP address not allowed");
+	chilli_log(LOG_DEBUG, "Static IP address not allowed");
 	return -1;
       }
       if ((addr->s_addr & this->statmask.s_addr) != this->stataddr.s_addr) {
-	syslog(LOG_ERR, "Static out of range (%s)", inet_ntoa(*addr));
+	chilli_log(LOG_ERR, "Static out of range (%s)", inet_ntoa(*addr));
 	return -1;
       }
 #ifdef ENABLE_UAMANYIP
@@ -491,7 +491,7 @@
   }
   else {
     if (!this->allowdyn) {
-      syslog(LOG_ERR, "Dynamic IP address not allowed");
+      chilli_log(LOG_ERR, "Dynamic IP address not allowed");
       return -1;
     }
   }
@@ -511,7 +511,7 @@
 #ifdef ENABLE_UAMANYIP
   /* if anyip is set and statip return the same ip */
   if (statip && _options.uamanyip && p2 && p2->is_static) {
-    syslog(LOG_DEBUG, "Found already allocated static ip %s",
+    chilli_log(LOG_DEBUG, "Found already allocated static ip %s",
            inet_ntoa(p2->addr));
     *member = p2;
     return 0;
@@ -526,7 +526,7 @@
   /* If not found yet and dynamic IP then allocate dynamic IP */
   if ((!p2) && (!statip) /*XXX: && (!addr || !addr->s_addr)*/) {
     if (!this->firstdyn) {
-      syslog(LOG_ERR, "No more dynamic addresses available");
+      chilli_log(LOG_ERR, "No more dynamic addresses available");
       return -1;
     }
     else {
@@ -537,14 +537,14 @@
   if (p2) { /* Was allocated from dynamic address pool */
 
     if (p2->in_use) {
-      syslog(LOG_ERR, "IP address already in use");
+      chilli_log(LOG_ERR, "IP address already in use");
       return -1; /* Already in use / Should not happen */
     }
 
     /* Remove from linked list of free dynamic addresses */
 
     if (p2->is_static) {
-      syslog(LOG_ERR, "Should not happen!");
+      chilli_log(LOG_ERR, "Should not happen!");
       return -1;
     }
 
@@ -582,7 +582,7 @@
 				   )) { /* IP address given */
 
     if (!this->firststat) {
-      syslog(LOG_ERR, "No more static addresses available");
+      chilli_log(LOG_ERR, "No more static addresses available");
       return -1; /* No more available */
     }
     else {
@@ -592,12 +592,12 @@
     /* Remove from linked list of free static addresses */
 
     if (p2->in_use) {
-      syslog(LOG_ERR, "IP address already in use");
+      chilli_log(LOG_ERR, "IP address already in use");
       return -1; /* Already in use / Should not happen */
     }
 
     if (!p2->is_static) {
-      syslog(LOG_ERR, "Should not happen!");
+      chilli_log(LOG_ERR, "Should not happen!");
       return -1;
     }
 
@@ -619,7 +619,7 @@
 
     *member = p2;
 
-    syslog(LOG_DEBUG, "Assigned a static ip to: %s", inet_ntoa(*addr));
+    chilli_log(LOG_DEBUG, "Assigned a static ip to: %s", inet_ntoa(*addr));
 
     ippool_hashadd(this, *member);
 
@@ -643,7 +643,7 @@
 #endif
 
   if (!member->in_use) {
-    syslog(LOG_ERR, "Address not in use");
+    chilli_log(LOG_ERR, "Address not in use");
     return -1; /* Not in use: Should not happen */
   }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/kcoova.c src/src/kcoova.c
--- upstream/src/kcoova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/kcoova.c	2025-11-06 13:20:13.000000000 +0000
@@ -37,11 +37,11 @@
       snprintf(line, sizeof(line), "%c\n", cmd);
 
     rd = safe_write(fd, line, strlen(line));
-    syslog(LOG_DEBUG, "kmod wrote %d %s", rd, line);
+    chilli_log(LOG_DEBUG, "kmod wrote %d %s", rd, line);
     close(fd);
     return rd == strlen(line);
   } else {
-    syslog(LOG_ERR, "%s: could not open %s", strerror(errno), file);
+    chilli_log(LOG_ERR, "%s: could not open %s", strerror(errno), file);
   }
   return 0;
 }
@@ -89,7 +89,7 @@
 
   while ((read = getline(&line, &len, fp)) != -1) {
     if (len > 256) {
-      syslog(LOG_ERR, "%s: problem", strerror(errno));
+      chilli_log(LOG_ERR, "%s: problem", strerror(errno));
       continue;
     }
 
@@ -111,7 +111,7 @@
         struct in_addr in_ip;
         struct app_conn_t *appconn = NULL;
         if (!inet_aton(ip, &in_ip)) {
-            syslog(LOG_ERR, "Invalid IP Address: %s\n", ip);
+            chilli_log(LOG_ERR, "Invalid IP Address: %s\n", ip);
             return -1;
         }
         appconn = dhcp_get_appconn_ip(0, &in_ip);
@@ -128,7 +128,7 @@
                 appconn->s_state.input_packets = pout;
           }
         } else {
-            syslog(LOG_DEBUG, "Unknown entry");
+            chilli_log(LOG_DEBUG, "Unknown entry");
         }
       } else {
 #endif
@@ -147,14 +147,14 @@
               appconn->s_state.input_packets = pout;
             }
           } else {
-            syslog(LOG_DEBUG, "Unknown entry");
+            chilli_log(LOG_DEBUG, "Unknown entry");
           }
         }
 #ifdef ENABLE_LAYER3
       }
 #endif
     } else {
-      syslog(LOG_ERR, "%s: Error parsing %s", strerror(errno), line);
+      chilli_log(LOG_ERR, "%s: Error parsing %s", strerror(errno), line);
     }
   }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/linux/libxt_coova.c src/src/linux/libxt_coova.c
--- upstream/src/linux/libxt_coova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/linux/libxt_coova.c	2025-11-06 13:20:13.000000000 +0000
@@ -126,7 +126,7 @@
 	.extra_opts    = coova_opts,
 };
 
-void _init(void)
+void __attribute__ ((constructor)) libxt_coova_init(void)
 {
 	xtables_register_match(&coova_mt_reg);
 	xtables_register_match(&coova_mt6_reg);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/linux/xt_coova.c src/src/linux/xt_coova.c
--- upstream/src/linux/xt_coova.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/linux/xt_coova.c	2025-11-06 13:20:13.000000000 +0000
@@ -45,9 +45,9 @@
 static unsigned int ip_list_tot = 100;
 static unsigned int ip_pkt_list_tot = 20;
 static unsigned int ip_list_hash_size = 0;
-static unsigned int ip_list_perms = 0644;
+static unsigned int ip_list_perms = 0660;
 static unsigned int ip_list_uid = 0;
-static unsigned int ip_list_gid = 0;
+static unsigned int ip_list_gid = 511;
 module_param(ip_list_tot, uint, 0400);
 module_param(ip_pkt_list_tot, uint, 0400);
 module_param(ip_list_hash_size, uint, 0400);
@@ -91,8 +91,12 @@
 
 #ifdef CONFIG_PROC_FS
 static struct proc_dir_entry *coova_proc_dir;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+static const struct proc_ops coova_old_fops, coova_mt_fops;
+#else
 static const struct file_operations coova_old_fops, coova_mt_fops;
 #endif
+#endif
 
 static u_int32_t hash_rnd;
 static bool hash_rnd_initted;
@@ -230,7 +234,7 @@
 		else
 			addr.ip = iph->saddr;
 
-		p_bytes = iph->tot_len;
+		p_bytes = ntohs(iph->tot_len);
 	} else {
 		const struct ipv6hdr *iph = ipv6_hdr(skb);
 
@@ -239,7 +243,7 @@
 		else
 			memcpy(&addr.in6, &iph->saddr, sizeof(addr.in6));
 
-		p_bytes = iph->payload_len;
+		p_bytes = ntohs(iph->payload_len);
 	}
 
 	if (info->side != XT_COOVA_DEST) {
@@ -305,14 +309,18 @@
 	    strnlen(info->name, XT_COOVA_NAME_LEN) == XT_COOVA_NAME_LEN)
 		return -EINVAL;
 
+#ifdef DEBUG
 	printk(KERN_INFO "xt_coova: looking for %s\n", info->name);
+#endif
 
 	mutex_lock(&coova_mutex);
 	t = coova_table_lookup(info->name);
 	if (t != NULL) {
 		t->refcnt++;
+#ifdef DEBUG
 		printk(KERN_INFO "xt_coova: found %s refcnt=%d\n", 
 		       info->name, t->refcnt);
+#endif
 		goto out;
 	}
 
@@ -323,7 +331,7 @@
 		goto out;
 	}
 	t->refcnt = 1;
-	strcpy(t->name, info->name);
+	strncpy(t->name, info->name, strlen(info->name));
 	INIT_LIST_HEAD(&t->lru_list);
 	for (i = 0; i < ip_list_hash_size; i++)
 		INIT_LIST_HEAD(&t->iphash[i]);
@@ -348,11 +356,15 @@
 	spin_lock_bh(&coova_lock);
 	list_add_tail(&t->list, &tables);
 	spin_unlock_bh(&coova_lock);
+#ifdef DEBUG
 	printk(KERN_INFO "xt_coova: created %s refcnt=%d\n", 
 	       t->name, t->refcnt);
+#endif
 out:
 	mutex_unlock(&coova_mutex);
-	printk(KERN_INFO "xt_coova: match ret=%d\n", ret); 
+#ifdef DEBUG
+	printk(KERN_INFO "xt_coova: match ret=%d\n", ret);
+#endif
 	return ret;
 }
 
@@ -406,12 +418,13 @@
 	const struct coova_entry *e = v;
 	const struct list_head *head = e->list.next;
 
+	(*pos)++;
 	while (head == &t->iphash[st->bucket]) {
 		if (++st->bucket >= ip_list_hash_size)
 			return NULL;
 		head = t->iphash[st->bucket].next;
 	}
-	(*pos)++;
+	
 	return list_entry(head, struct coova_entry, list);
 }
 
@@ -577,6 +590,14 @@
 	return size + 1;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+static const struct proc_ops coova_mt_fops = {
+	.proc_open    = coova_seq_open,
+	.proc_read    = seq_read,
+	.proc_write   = coova_mt_proc_write,
+	.proc_release = seq_release_private,
+};
+#else
 static const struct file_operations coova_mt_fops = {
 	.open    = coova_seq_open,
 	.read    = seq_read,
@@ -584,6 +605,7 @@
 	.release = seq_release_private,
 	.owner   = THIS_MODULE,
 };
+#endif
 #endif /* CONFIG_PROC_FS */
 
 static struct xt_match coova_mt_reg[] __read_mostly = {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/location.c src/src/location.c
--- upstream/src/location.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/location.c	2025-11-06 13:20:13.000000000 +0000
@@ -28,7 +28,7 @@
 
 void location_close_conn(struct app_conn_t *conn, int close) {
 
-  syslog(LOG_DEBUG, "%s(%d): removing(%s) one of %d sessions from %s", __FUNCTION__, __LINE__,
+  chilli_log(LOG_DEBUG, "%s(%d): removing(%s) one of %d sessions from %s", __FUNCTION__, __LINE__,
          close ? "closing" : "roaming out",
          (int)conn->loc_search_node->total_sess_count,
          conn->loc_search_node->value);
@@ -89,13 +89,13 @@
 static int
 avl_comp(const void *k1, const void *k2) {
   int result = strncmp(k1, k2, MAX_LOCATION_LENGTH);
-  syslog(LOG_DEBUG, "%s(%d): result %d",__FUNCTION__, __LINE__, result);
+  chilli_log(LOG_DEBUG, "%s(%d): result %d",__FUNCTION__, __LINE__, result);
   /* log_dbg("k1: %s k2: %s",k1,k2); */
   return result;
 }
 
 struct loc_search_t *location_find(char *loc) {
-  syslog(LOG_DEBUG, "%s(%d): looking for location: %s", __FUNCTION__, __LINE__, loc);
+  chilli_log(LOG_DEBUG, "%s(%d): looking for location: %s", __FUNCTION__, __LINE__, loc);
   return (struct loc_search_t *)avl_find(&loc_search_tree, loc);
 }
 
@@ -110,10 +110,10 @@
 
   loc_search = (struct loc_search_t *)avl_find(&loc_search_tree, loc);
 
-  syslog(LOG_DEBUG, "%s(%d): checking location: %s", __FUNCTION__, __LINE__, loc);
+  chilli_log(LOG_DEBUG, "%s(%d): checking location: %s", __FUNCTION__, __LINE__, loc);
   if (loc_search == NULL) {
     location_count++;
-    syslog(LOG_DEBUG, "%s(%d): creating tree entry %d for location: %s", __FUNCTION__, __LINE__, 
+    chilli_log(LOG_DEBUG, "%s(%d): creating tree entry %d for location: %s", __FUNCTION__, __LINE__, 
            location_count, loc);
     loc_search=calloc(1, sizeof(*loc_search));
     memcpy(loc_search->value,loc,sizeof(loc_search->value));
@@ -124,7 +124,7 @@
       loc_search->loc_closed_bytes_down=0;*/
     list_init_head(&loc_search->loc_sess_head);
     if (avl_insert(&loc_search_tree, &loc_search->node)!=0) {
-      syslog(LOG_ERR, "unexpected avl error!");
+      chilli_log(LOG_ERR, "unexpected avl error!");
     }
   }
 
@@ -135,7 +135,7 @@
   else loc_search->new_sess_count++;
 
   appconn->loc_search_node=loc_search;
-  syslog(LOG_DEBUG, "%s(%d): location '%s' now has %d sessions attached", __FUNCTION__, __LINE__, 
+  chilli_log(LOG_DEBUG, "%s(%d): location '%s' now has %d sessions attached", __FUNCTION__, __LINE__, 
          loc,(int)loc_search->total_sess_count);
 }
 
@@ -164,10 +164,10 @@
 
     if (timespan >= 1) {
 
-      syslog(LOG_DEBUG, "%s(%d): roamed_in_session_count %d, out %d", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): roamed_in_session_count %d, out %d", __FUNCTION__, __LINE__,
              (int)loc_search->roamed_in_sess_count,
              (int)loc_search->roamed_out_sess_count);
-      syslog(LOG_DEBUG, "%s(%d): new_session_count %d, closed %d", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): new_session_count %d, closed %d", __FUNCTION__, __LINE__,
              (int)loc_search->new_sess_count,
              (int)loc_search->closed_sess_count);
 
@@ -196,8 +196,8 @@
 #endif
 	int last_sent;
 
-	syslog(LOG_DEBUG, "%s(%d): location has %d sessions attached! ", __FUNCTION__, __LINE__, (int)loc_search->total_sess_count);
-	syslog(LOG_DEBUG, "%s(%d): (last queried %d seconds ago)\n", __FUNCTION__, __LINE__, (int)(act_mainclock-loc_search->last_queried));
+	chilli_log(LOG_DEBUG, "%s(%d): location has %d sessions attached! ", __FUNCTION__, __LINE__, (int)loc_search->total_sess_count);
+	chilli_log(LOG_DEBUG, "%s(%d): (last queried %d seconds ago)\n", __FUNCTION__, __LINE__, (int)(act_mainclock-loc_search->last_queried));
 
 	bassignformat(tmp,json ?
 		      ",\"session_count\":%d,\"seconds_elapsed\":%d" :
@@ -262,7 +262,7 @@
 	  } else last_sent=-1;
 
 	  if (list) {
-	    syslog(LOG_DEBUG, "%s(%d): mac: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X up: %d down: %d\n", __FUNCTION__, __LINE__, 
+	    chilli_log(LOG_DEBUG, "%s(%d): mac: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X up: %d down: %d\n", __FUNCTION__, __LINE__, 
                    appconn->hismac[0], appconn->hismac[1], appconn->hismac[2],
                    appconn->hismac[3], appconn->hismac[4], appconn->hismac[5],
                    bytes_up,bytes_down);
@@ -463,14 +463,14 @@
           = loc_search->roamed_out_sess_count = 0;
 
     } else { /*query too short after the last*/
-      syslog(LOG_DEBUG, "%s(%d): last query less than 1 second ago!!\n", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): last query less than 1 second ago!!\n", __FUNCTION__, __LINE__);
       bassignformat(tmp,json
 		    ? ",\"session_count\":-2"
 		    : "\n\tsession_count = -2");
       bconcat(s,tmp);
     }
   } else {
-    syslog(LOG_DEBUG, "%s(%d): location (%s) not found!", __FUNCTION__, __LINE__, loc);
+    chilli_log(LOG_DEBUG, "%s(%d): location (%s) not found!", __FUNCTION__, __LINE__, loc);
     bassignformat(tmp,json ?
 		  ",\"session_count\":-1"
 		  ",\"location_count\":%d" :
@@ -515,7 +515,7 @@
   memset(&loc_search_tree, 0, sizeof(loc_search_tree));
   avl_init(&loc_search_tree, avl_comp, false);
   while (conn) {
-    syslog(LOG_DEBUG, "%s(%d): restoring location (%s) of conn %X-%X-%X-%X-%X-%X\n", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): restoring location (%s) of conn %X-%X-%X-%X-%X-%X\n", __FUNCTION__, __LINE__,
            conn->s_state.location,
            conn->hismac[0],conn->hismac[1],conn->hismac[2],
            conn->hismac[3],conn->hismac[4],conn->hismac[5]);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-opt.c src/src/main-opt.c
--- upstream/src/main-opt.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-opt.c	2025-11-06 13:20:13.000000000 +0000
@@ -24,6 +24,10 @@
 #include "system.h"
 #include "chilli.h"
 
+#ifdef ENABLE_GSM
+#include <libgsm_utils.h>
+#endif
+
 struct options_t _options;
 
 static const char *description =
@@ -63,6 +67,9 @@
 #ifdef ENABLE_CHILLIQUERY
     "ENABLE_CHILLIQUERY "
 #endif
+#ifdef ENABLE_UBUS
+"ENABLE_UBUS "
+#endif
 #ifdef ENABLE_CHILLIPROXY
     "ENABLE_CHILLIPROXY "
 #endif
@@ -255,6 +262,12 @@
 #ifdef USING_POLL
     "USING_POLL "
 #endif
+#ifdef  ENABLE_DATABASE
+    "ENABLE_DATABASE "
+#endif
+#ifdef  ENABLE_GSM
+    "ENABLE_GSM "
+#endif
 #ifdef EX_OPT_FEATURES
 #include EX_OPT_FEATURES
 #endif
@@ -336,7 +349,7 @@
   memset(&args_info, 0, sizeof(args_info));
 
   if (cmdline_parser2(argc, argv, &args_info, 1, 1, 1) != 0) {
-    syslog(LOG_ERR, "Failed to parse command line options");
+    chilli_log(LOG_ERR, "Failed to parse command line options");
     goto end_processing;
   }
 
@@ -354,7 +367,7 @@
 				args_info.conf_arg :
 				DEFCHILLICONF,
 				&args_info, 0, 0, 0)) {
-    syslog(LOG_ERR, "Failed to parse configuration file: %s!",
+    chilli_log(LOG_ERR, "Failed to parse configuration file: %s!",
            args_info.conf_arg);
     if (!args_info.forgiving_flag)
       goto end_processing;
@@ -363,7 +376,7 @@
   /* Get the system default DNS entries */
   if (!args_info.nosystemdns_flag) {
     if (res_init()) {
-      syslog(LOG_ERR, "Failed to update system DNS settings (res_init()!");
+      chilli_log(LOG_ERR, "Failed to update system DNS settings (res_init()!");
       goto end_processing;
     }
   }
@@ -374,7 +387,7 @@
   if (args_info.debug_flag)
     _options.debug = args_info.debugfacility_arg;
   else
-    _options.debug = 0;
+    _options.debug = 1;
 
   /* pass-throughs */
   memset(_options.pass_throughs, 0, sizeof(_options.pass_throughs));
@@ -384,7 +397,7 @@
   _options.layer3 = args_info.layer3_flag;
 #if(_debug_ && !defined(ENABLE_LAYER3))
   if (_options.layer3)
-    syslog(LOG_WARNING, "layer3 not implemented. build with --enable-layer3");
+    chilli_log(LOG_WARNING, "layer3 not implemented. build with --enable-layer3");
 #endif
   _options.uid = args_info.uid_arg;
   _options.gid = args_info.gid_arg;
@@ -393,11 +406,11 @@
   _options.noarpentries = args_info.noarpentries_flag;
 #if(_debug_ && !defined(ENABLE_TAP))
   if (_options.noarpentries)
-    syslog(LOG_WARNING, "tap not implemented. build with --enable-tap");
+    chilli_log(LOG_WARNING, "tap not implemented. build with --enable-tap");
 #endif
 #if(_debug_ && !defined(ENABLE_TAP))
   if (_options.usetap)
-    syslog(LOG_WARNING, "tap not implemented. build with --enable-tap");
+    chilli_log(LOG_WARNING, "tap not implemented. build with --enable-tap");
 #endif
   _options.foreground = args_info.fg_flag;
   _options.logfacility = args_info.logfacility_arg;
@@ -410,11 +423,13 @@
   _options.eapolenable = args_info.eapolenable_flag;
 #if(_debug_ && !defined(ENABLE_EAPOL))
   if (_options.eapolenable)
-    syslog(LOG_WARNING, "EAPOL not implemented. build with --enable-eapol");
+    chilli_log(LOG_WARNING, "EAPOL not implemented. build with --enable-eapol");
 #endif
   _options.swapoctets = args_info.swapoctets_flag;
   _options.chillixml = args_info.chillixml_flag;
   _options.macauth = args_info.macauth_flag;
+  _options.macdelimiter = args_info.macdelimiter_arg;
+  _options.maclower = args_info.maclower_flag;
   _options.macreauth = args_info.macreauth_flag;
   _options.macauthdeny = args_info.macauthdeny_flag;
   _options.uamport = args_info.uamport_arg;
@@ -435,6 +450,37 @@
   _options.defbandwidthmaxdown = args_info.defbandwidthmaxdown_arg;
   _options.defbandwidthmaxup = args_info.defbandwidthmaxup_arg;
   _options.defidletimeout = args_info.defidletimeout_arg;
+  _options.defmaxdownload = args_info.defmaxdownload_arg;
+  _options.defmaxupload = args_info.defmaxupload_arg;
+  _options.defwarning = args_info.defwarning_arg;
+  _options.deflimitperiod = args_info.deflimitperiod_arg;
+  _options.deflimitstart = args_info.deflimitstart_arg;
+  _options.defexpirationtime = args_info.defexpirationtime_arg;
+
+  _options.dynsessiontimeout = args_info.dynsessiontimeout_arg;
+  _options.dynbandwidthmaxdown = args_info.dynbandwidthmaxdown_arg;
+  _options.dynbandwidthmaxup = args_info.dynbandwidthmaxup_arg;
+  _options.dynmaxdownload = args_info.dynmaxdownload_arg;
+  _options.dynwarning = args_info.dynwarning_arg;
+  _options.dynmaxupload = args_info.dynmaxupload_arg;
+  _options.dynexpirationtime = args_info.dynexpirationtime_arg;
+  _options.dyninteriminterval = args_info.dyninteriminterval_arg;
+  _options.dynidletimeout = args_info.dynidletimeout_arg;
+  _options.dynlimitperiod = args_info.dynlimitperiod_arg;
+  _options.dynlimitstart = args_info.dynlimitstart_arg;
+
+  _options.trialsessiontimeout = args_info.trialsessiontimeout_arg;
+  _options.trialinteriminterval = args_info.trialinteriminterval_arg;
+  _options.trialbandwidthmaxdown = args_info.trialbandwidthmaxdown_arg;
+  _options.trialbandwidthmaxup = args_info.trialbandwidthmaxup_arg;
+  _options.trialidletimeout = args_info.trialidletimeout_arg;
+  _options.trialmaxdownload = args_info.trialmaxdownload_arg;
+  _options.trialmaxupload = args_info.trialmaxupload_arg;
+  _options.trialwarning = args_info.trialwarning_arg;
+  _options.triallimitperiod = args_info.triallimitperiod_arg;
+  _options.triallimitstart = args_info.triallimitstart_arg;
+  _options.trialexpirationtime = args_info.dynexpirationtime_arg;
+
   _options.radiusnasporttype = args_info.radiusnasporttype_arg;
   _options.radiusauthport = args_info.radiusauthport_arg;
   _options.radiusacctport = args_info.radiusacctport_arg;
@@ -450,7 +496,7 @@
 #endif
 #if(_debug_ && !defined(ENABLE_RADPROXY))
   if (args_info.proxyport_arg)
-    syslog(LOG_ERR, "radproxy not implemented. build with --enable-radproxy");
+    chilli_log(LOG_ERR, "radproxy not implemented. build with --enable-radproxy");
 #endif
   _options.txqlen = args_info.txqlen_arg;
 #ifdef USING_MMAP
@@ -469,6 +515,7 @@
   _options.dhcp_broadcast = args_info.dhcpbroadcast_flag;
   _options.dhcpgwport = args_info.dhcpgatewayport_arg;
   _options.noc2c = args_info.noc2c_flag;
+  _options.radiusrequiremessageauth = args_info.radiusrequiremessageauth_flag;
   _options.tcpwin = args_info.tcpwin_arg;
   _options.tcpmss = args_info.tcpmss_arg;
   _options.max_clients = args_info.maxclients_arg;
@@ -477,13 +524,17 @@
   _options.uamdomain_ttl = args_info.uamdomainttl_arg;
   _options.seskeepalive = args_info.seskeepalive_flag;
   _options.uamallowpost = args_info.uamallowpost_flag;
+#ifdef ENABLE_UAMDOMAINFILE
+  _options.uamblocklist = args_info.uamblocklist_flag;
+#endif
   _options.redir = args_info.redir_flag;
   _options.redirurl = args_info.redirurl_flag;
   _options.statusfilesave = args_info.statusfilesave_flag;
   _options.dhcpnotidle = args_info.dhcpnotidle_flag;
+  _options.successuserurl = args_info.successuserurl_flag;
 #if(_debug_ && !defined(ENABLE_CHILLIREDIR))
   if (_options.redir)
-    syslog(LOG_ERR, "chilli_redir not implemented. build with --enable-chilliredir");
+    chilli_log(LOG_ERR, "chilli_redir not implemented. build with --enable-chilliredir");
 #endif
   _options.redirssl = args_info.redirssl_flag;
   _options.uamuissl = args_info.uamuissl_flag;
@@ -492,18 +543,18 @@
   _options.radsec = args_info.radsec_flag;
 #if(_debug_ && !defined(ENABLE_CHILLIRADSEC))
   if (_options.radsec)
-    syslog(LOG_ERR, "chilli_radsec not implemented. build with --enable-chilliradsec");
+    chilli_log(LOG_ERR, "chilli_radsec not implemented. build with --enable-chilliradsec");
 #endif
   _options.noradallow = args_info.noradallow_flag;
   _options.peerid = args_info.peerid_arg;
 #if(_debug_ && !defined(ENABLE_CLUSTER))
   if (_options.peerid)
-    syslog(LOG_ERR, "clustering not implemented. build with --enable-cluster");
+    chilli_log(LOG_ERR, "clustering not implemented. build with --enable-cluster");
 #endif
   _options.redirdnsreq = args_info.redirdnsreq_flag;
 #if(_debug_ && !defined(ENABLE_REDIRDNSREQ))
   if (_options.redirdnsreq)
-    syslog(LOG_ERR, "redirdnsreq not implemented. build with --enable-redirdnsreq");
+    chilli_log(LOG_ERR, "redirdnsreq not implemented. build with --enable-redirdnsreq");
 #endif
 
 #ifdef ENABLE_IPV6
@@ -522,11 +573,11 @@
       _options.ipv6 = 1;
       _options.ipv6only = 0;
     } else {
-      syslog(LOG_WARNING, "unknown ipv6mode %s", args_info.ipv6mode_arg);
+      chilli_log(LOG_WARNING, "unknown ipv6mode %s", args_info.ipv6mode_arg);
       _options.ipv6 = 0;
     }
   }
-  syslog(LOG_DEBUG, "IPv6 %sabled %s",
+  chilli_log(LOG_DEBUG, "IPv6 %sabled %s",
          _options.ipv6 ? "en" : "dis",
          args_info.ipv6mode_arg ? args_info.ipv6mode_arg : "");
 #endif
@@ -552,7 +603,7 @@
       switch (sscanf(args_info.proxylocattr_arg[numargs],
 		     "%u,%u", &i[0], &i[1])) {
         case 0:
-          syslog(LOG_ERR, "invalid input %s", args_info.proxylocattr_arg[numargs]);
+          chilli_log(LOG_ERR, "invalid input %s", args_info.proxylocattr_arg[numargs]);
           break;
         case 1:
           _options.proxy_loc[numargs].attr = i[0];
@@ -563,7 +614,7 @@
           break;
       }
 
-      syslog(LOG_DEBUG, "Proxy location attr %d %d",
+      chilli_log(LOG_DEBUG, "Proxy location attr %d %d",
              (int)_options.proxy_loc[numargs].attr_vsa,
              (int)_options.proxy_loc[numargs].attr);
     }
@@ -572,14 +623,14 @@
 
   if (args_info.dhcpgateway_arg &&
       !inet_aton(args_info.dhcpgateway_arg, &_options.dhcpgwip)) {
-    syslog(LOG_ERR, "Invalid DHCP gateway IP address: %s!", args_info.dhcpgateway_arg);
+    chilli_log(LOG_ERR, "Invalid DHCP gateway IP address: %s!", args_info.dhcpgateway_arg);
     if (!args_info.forgiving_flag)
       goto end_processing;
   }
 
   if (args_info.dhcprelayagent_arg &&
       !inet_aton(args_info.dhcprelayagent_arg, &_options.dhcprelayip)) {
-    syslog(LOG_ERR, "Invalid DHCP gateway relay IP address: %s!", args_info.dhcprelayagent_arg);
+    chilli_log(LOG_ERR, "Invalid DHCP gateway relay IP address: %s!", args_info.dhcprelayagent_arg);
     if (!args_info.forgiving_flag)
       goto end_processing;
   }
@@ -605,7 +656,7 @@
 #endif
 
   if (!args_info.radiussecret_arg) {
-    syslog(LOG_ERR, "radiussecret must be specified!");
+    chilli_log(LOG_ERR, "radiussecret must be specified!");
     if (!args_info.forgiving_flag)
       goto end_processing;
   }
@@ -621,7 +672,7 @@
     int	i;
 
     if ((macstrlen = strlen(args_info.nexthop_arg)) >= (RADIUS_ATTR_VLEN-1)) {
-      syslog(LOG_ERR, "MAC address too long");
+      chilli_log(LOG_ERR, "MAC address too long");
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -637,7 +688,7 @@
     if (sscanf (macstr, "%2x %2x %2x %2x %2x %2x",
 		&temp[0], &temp[1], &temp[2],
 		&temp[3], &temp[4], &temp[5]) != 6) {
-      syslog(LOG_ERR, "MAC conversion failed!");
+      chilli_log(LOG_ERR, "MAC conversion failed!");
       return -1;
     }
 
@@ -659,7 +710,7 @@
     int	i;
 
     if ((macstrlen = strlen(args_info.dhcpmac_arg)) >= (RADIUS_ATTR_VLEN-1)) {
-      syslog(LOG_ERR, "MAC address too long");
+      chilli_log(LOG_ERR, "MAC address too long");
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -675,7 +726,7 @@
     if (sscanf (macstr, "%2x %2x %2x %2x %2x %2x",
 		&temp[0], &temp[1], &temp[2],
 		&temp[3], &temp[4], &temp[5]) != 6) {
-      syslog(LOG_ERR, "MAC conversion failed!");
+      chilli_log(LOG_ERR, "MAC conversion failed!");
       return -1;
     }
 
@@ -688,7 +739,7 @@
 
   if (args_info.net_arg) {
     if (option_aton(&_options.net, &_options.mask, args_info.net_arg, 0)) {
-      syslog(LOG_ERR, "Invalid network address: %s!", args_info.net_arg);
+      chilli_log(LOG_ERR, "Invalid network address: %s!", args_info.net_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -696,7 +747,7 @@
       _options.uamlisten.s_addr = htonl(ntohl(_options.net.s_addr)+1);
     }
     else if (!inet_aton(args_info.uamlisten_arg, &_options.uamlisten)) {
-      syslog(LOG_ERR, "Invalid UAM IP address: %s!", args_info.uamlisten_arg);
+      chilli_log(LOG_ERR, "Invalid UAM IP address: %s!", args_info.uamlisten_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -704,26 +755,32 @@
       _options.dhcplisten.s_addr = _options.uamlisten.s_addr;
     }
     else if (!inet_aton(args_info.dhcplisten_arg, &_options.dhcplisten)) {
-      syslog(LOG_ERR, "Invalid DHCP IP address: %s!", args_info.dhcplisten_arg);
+      chilli_log(LOG_ERR, "Invalid DHCP IP address: %s!", args_info.dhcplisten_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
   }
   else {
-    syslog(LOG_ERR, "Network address must be specified ('net' parameter)!");
+    chilli_log(LOG_ERR, "Network address must be specified ('net' parameter)!");
     if (!args_info.forgiving_flag)
       goto end_processing;
   }
 
-  syslog(LOG_DEBUG, "DHCP Listen: %s", inet_ntoa(_options.dhcplisten));
-  syslog(LOG_DEBUG, "UAM Listen: %s", inet_ntoa(_options.uamlisten));
+  chilli_log(LOG_DEBUG, "DHCP Listen: %s", inet_ntoa(_options.dhcplisten));
+  chilli_log(LOG_DEBUG, "UAM Listen: %s", inet_ntoa(_options.uamlisten));
+
+#ifdef HAVE_NETFILTER_COOVA
+  if (args_info.kname_arg) {
+    chilli_log(LOG_DEBUG, "Using kernel module for %s", args_info.kname_arg);
+  }
+#endif
 
   if (args_info.rfc7710uri_given) {
     /*
      * When given, but set to an empty string, the feature is disabled.
      */
     if (strlen(args_info.rfc7710uri_arg) > 255) {
-      syslog(LOG_ERR, "Captive portal URI is too long for DHCP option.");
+      chilli_log(LOG_ERR, "Captive portal URI is too long for DHCP option.");
       if (!args_info.forgiving_flag)
 	goto end_processing;
     } else {
@@ -740,57 +797,66 @@
   }
 
   if (!args_info.uamserver_arg) {
-    syslog(LOG_ERR, "WARNING: No uamserver defined!");
+    chilli_log(LOG_ERR, "WARNING: No uamserver defined!");
   }
 
   if (args_info.uamserver_arg) {
     int uamserverport=80;
 
     if (_options.debug & DEBUG_CONF) {
-      syslog(LOG_DEBUG, "Uamserver: %s\n", args_info.uamserver_arg);
+      chilli_log(LOG_DEBUG, "Uamserver: %s\n", args_info.uamserver_arg);
     }
 
     if (get_urlparts(args_info.uamserver_arg, hostname, USERURLSIZE,
 		     &uamserverport, 0)) {
-      syslog(LOG_ERR, "Failed to parse uamserver: %s!", args_info.uamserver_arg);
+      chilli_log(LOG_ERR, "Failed to parse uamserver: %s!", args_info.uamserver_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
 
-    if (!args_info.uamaliasname_arg ||
-	strncmp(args_info.uamaliasname_arg, hostname,
-		strlen(args_info.uamaliasname_arg))) {
-      if (!(host = gethostbyname(hostname))) {
-	syslog(LOG_ERR, "Could not resolve IP address of uamserver: %s!",
-               args_info.uamserver_arg);
+    // local domain should resolve to local ip
+    if (args_info.uamaliasname_arg && args_info.domain_arg) {
+      char full_local_hostname[USERURLSIZE];
+      strncpy(full_local_hostname, args_info.uamaliasname_arg, USERURLSIZE - 1);
+      strncat(full_local_hostname, ".", 1);
+      strncat(full_local_hostname, args_info.domain_arg, USERURLSIZE - strlen(full_local_hostname) - 1);
+      if (strcmp(full_local_hostname, hostname) == 0) {
+        strncpy(hostname, inet_ntoa(_options.uamlisten), USERURLSIZE - 1);
+        hostname[USERURLSIZE - 1] = '\0';
       }
-      else {
-	int j = 0;
-	pass_through pt;
+    }
 
-	memset(&pt, 0, sizeof(pt));
-	pt.port = uamserverport;
-	pt.mask.s_addr = ~0;
-
-	while (host->h_addr_list[j] != NULL) {
-	  if (_options.debug & DEBUG_CONF) {
-	    syslog(LOG_DEBUG, "Uamserver IP address #%d: %s\n", j,
-                   inet_ntoa(*(struct in_addr*) host->h_addr_list[j]));
-	  }
+    if (!(host = gethostbyname(hostname))) {
+chilli_log(LOG_ERR, "Could not resolve IP address of uamserver: %s!",
+            args_info.uamserver_arg);
+    }
+    else {
+
+int j = 0;
+pass_through pt;
+
+memset(&pt, 0, sizeof(pt));
+pt.port = uamserverport;
+pt.mask.s_addr = ~0;
+
+while (host->h_addr_list[j] != NULL) {
+  if (_options.debug & DEBUG_CONF) {
+    chilli_log(LOG_DEBUG, "Uamserver IP address #%d: %s\n", j,
+                  inet_ntoa(*(struct in_addr*) host->h_addr_list[j]));
+  }
 
-	  pt.host.s_addr = ((struct in_addr*) host->h_addr_list[j++])->s_addr;
+  pt.host.s_addr = ((struct in_addr*) host->h_addr_list[j++])->s_addr;
 
-	  if (pass_through_add(_options.pass_throughs,
-			       MAX_PASS_THROUGHS,
-			       &_options.num_pass_throughs, &pt, 0
+  if (pass_through_add(_options.pass_throughs,
+          MAX_PASS_THROUGHS,
+          &_options.num_pass_throughs, &pt, 0
 #ifdef HAVE_PATRICIA
-			       , 0
+          , 0
 #endif
-			       ))
-	    syslog(LOG_ERR, "Too many pass-throughs! skipped %s:%d",
-                   inet_ntoa(pt.host), pt.port);
-	}
-      }
+          ))
+    chilli_log(LOG_ERR, "Too many pass-throughs! skipped %s:%d",
+                inet_ntoa(pt.host), pt.port);
+}
     }
   }
 
@@ -800,7 +866,7 @@
     _options.forcedns1_addr.s_addr = _options.uamlisten.s_addr;
   } else if (args_info.forcedns1_arg) {
     if (!inet_aton(args_info.forcedns1_arg, &_options.forcedns1_addr)) {
-      syslog(LOG_ERR, "Invalid DNS IP address: %s!", args_info.forcedns1_arg);
+      chilli_log(LOG_ERR, "Invalid DNS IP address: %s!", args_info.forcedns1_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -810,7 +876,7 @@
     _options.forcedns2_addr.s_addr = _options.uamlisten.s_addr;
   } else if (args_info.forcedns2_arg) {
     if (!inet_aton(args_info.forcedns2_arg, &_options.forcedns2_addr)) {
-      syslog(LOG_ERR, "Invalid DNS IP address: %s!", args_info.forcedns2_arg);
+      chilli_log(LOG_ERR, "Invalid DNS IP address: %s!", args_info.forcedns2_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -881,7 +947,7 @@
     int bin_length = hex_length / 2;
     if (hex_length > 0 && (bin_length * 2) == hex_length &&
 	bin_length < sizeof(binopt)) {
-      syslog(LOG_DEBUG, "DHCP Options %s", args_info.dhcpopt_arg[numargs]);
+      chilli_log(LOG_DEBUG, "DHCP Options %s", args_info.dhcpopt_arg[numargs]);
       if (redir_hextochar((unsigned char *)args_info.dhcpopt_arg[numargs],
 			  hex_length, binopt, bin_length) == 0) {
 	if (_options.dhcp_options_len + bin_length <
@@ -891,13 +957,13 @@
 		 binopt, bin_length);
 	  _options.dhcp_options_len += bin_length;
 	} else {
-	  syslog(LOG_DEBUG, "No room for DHCP option %d", (int)binopt[0]);
+	  chilli_log(LOG_DEBUG, "No room for DHCP option %d", (int)binopt[0]);
 	}
       } else {
-	syslog(LOG_DEBUG, "Bad DHCP option hex encoding");
+	chilli_log(LOG_DEBUG, "Bad DHCP option hex encoding");
       }
     } else {
-      syslog(LOG_DEBUG, "DHCP options are hex encoded binary");
+      chilli_log(LOG_DEBUG, "DHCP options are hex encoded binary");
     }
   }
 #endif
@@ -965,7 +1031,7 @@
       for (str = tb ; i < MAX_UAM_DOMAINS; str = NULL) {
 	tok = strtok_r(str, ",", &ptr);
 	if (!tok) break;
-	syslog(LOG_DEBUG, "uamdomain %s", tok);
+	chilli_log(LOG_DEBUG, "uamdomain %s", tok);
 	_options.uamdomains[i++] = STRDUP(tok);
       }
     }
@@ -990,7 +1056,7 @@
       struct in_addr mask;
       _options.dynip = STRDUP(args_info.dynip_arg);
       if (option_aton(&addr, &mask, _options.dynip, 0)) {
-	syslog(LOG_ERR, "Failed to parse dynamic IP address pool!");
+	chilli_log(LOG_ERR, "Failed to parse dynamic IP address pool!");
 	if (!args_info.forgiving_flag)
 	  goto end_processing;
       }
@@ -1003,7 +1069,7 @@
     struct in_addr mask;
     _options.statip = STRDUP(args_info.statip_arg);
     if (option_aton(&addr, &mask, _options.statip, 0)) {
-      syslog(LOG_ERR, "Failed to parse static IP address pool!");
+      chilli_log(LOG_ERR, "Failed to parse static IP address pool!");
       return -1;
     }
     _options.allowstat = 1;
@@ -1016,7 +1082,7 @@
     if (option_aton(&_options.uamnatanyipex_addr,
 		    &_options.uamnatanyipex_mask,
 		    args_info.uamnatanyipex_arg, 0)) {
-      syslog(LOG_ERR, "Failed to parse uamnatanyipex network!");
+      chilli_log(LOG_ERR, "Failed to parse uamnatanyipex network!");
       return -1;
     }
   }
@@ -1024,7 +1090,7 @@
     if (option_aton(&_options.uamanyipex_addr,
 		    &_options.uamanyipex_mask,
 		    args_info.uamanyipex_arg, 0)) {
-      syslog(LOG_ERR, "Failed to parse uamanyipex network!");
+      chilli_log(LOG_ERR, "Failed to parse uamanyipex network!");
       return -1;
     }
   }
@@ -1032,7 +1098,7 @@
 
   if (args_info.dns1_arg) {
     if (!inet_aton(args_info.dns1_arg, &_options.dns1)) {
-      syslog(LOG_ERR, "Invalid primary DNS address: %s!",
+      chilli_log(LOG_ERR, "Invalid primary DNS address: %s!",
              args_info.dns1_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1047,7 +1113,7 @@
 
   if (args_info.dns2_arg) {
     if (!inet_aton(args_info.dns2_arg, &_options.dns2)) {
-      syslog(LOG_ERR, "Invalid secondary DNS address: %s!",
+      chilli_log(LOG_ERR, "Invalid secondary DNS address: %s!",
              args_info.dns1_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1065,7 +1131,7 @@
   /* Do hostname lookup to translate hostname to IP address       */
   if (args_info.radiuslisten_arg) {
     if (!(host = gethostbyname(args_info.radiuslisten_arg))) {
-      syslog(LOG_ERR, "Invalid listening address: %s! [%s]",
+      chilli_log(LOG_ERR, "Invalid listening address: %s! [%s]",
              args_info.radiuslisten_arg, strerror(errno));
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1081,7 +1147,7 @@
 #ifdef ENABLE_NETNAT
   if (args_info.natip_arg) {
     if (!(host = gethostbyname(args_info.natip_arg))) {
-      syslog(LOG_WARNING, "Invalid natip address: %s! [%s]",
+      chilli_log(LOG_WARNING, "Invalid natip address: %s! [%s]",
              args_info.natip_arg, strerror(errno));
     }
     else {
@@ -1092,7 +1158,7 @@
 
   if (args_info.uamlogoutip_arg) {
     if (!(host = gethostbyname(args_info.uamlogoutip_arg))) {
-      syslog(LOG_WARNING, "Invalid uamlogoutup address: %s! [%s]",
+      chilli_log(LOG_WARNING, "Invalid uamlogoutup address: %s! [%s]",
              args_info.uamlogoutip_arg, strerror(errno));
     }
     else {
@@ -1102,7 +1168,7 @@
 
   if (args_info.uamaliasip_arg) {
     if (!(host = gethostbyname(args_info.uamaliasip_arg))) {
-      syslog(LOG_WARNING, "Invalid uamaliasip address: %s! [%s]",
+      chilli_log(LOG_WARNING, "Invalid uamaliasip address: %s! [%s]",
              args_info.uamlogoutip_arg, strerror(errno));
     }
     else {
@@ -1112,7 +1178,7 @@
 
   if (args_info.postauthproxy_arg) {
     if (!(host = gethostbyname(args_info.postauthproxy_arg))) {
-      syslog(LOG_WARNING, "Invalid postauthproxy address: %s! [%s]",
+      chilli_log(LOG_WARNING, "Invalid postauthproxy address: %s! [%s]",
              args_info.postauthproxy_arg, strerror(errno));
     }
     else {
@@ -1122,7 +1188,7 @@
 
   if (args_info.radiusserver1_arg) {
     if (!(host = gethostbyname(args_info.radiusserver1_arg))) {
-      syslog(LOG_ERR, "Invalid radiusserver1 address: %s! [%s]",
+      chilli_log(LOG_ERR, "Invalid radiusserver1 address: %s! [%s]",
              args_info.radiusserver1_arg, strerror(errno));
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1132,14 +1198,14 @@
     }
   }
   else {
-    syslog(LOG_ERR, "No radiusserver1 address given!");
+    chilli_log(LOG_ERR, "No radiusserver1 address given!");
     if (!args_info.forgiving_flag)
       goto end_processing;
   }
 
   if (args_info.radiusserver2_arg) {
     if (!(host = gethostbyname(args_info.radiusserver2_arg))) {
-      syslog(LOG_ERR, "Invalid radiusserver2 address: %s! [%s]",
+      chilli_log(LOG_ERR, "Invalid radiusserver2 address: %s! [%s]",
              args_info.radiusserver2_arg, strerror(errno));
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1157,7 +1223,7 @@
   if (args_info.proxylisten_arg) {
 #ifdef ENABLE_RADPROXY
     if (!(host = gethostbyname(args_info.proxylisten_arg))) {
-      syslog(LOG_ERR, "Invalid listening address: %s! [%s]",
+      chilli_log(LOG_ERR, "Invalid listening address: %s! [%s]",
              args_info.proxylisten_arg, strerror(errno));
       if (!args_info.forgiving_flag)
 	goto end_processing;
@@ -1169,7 +1235,7 @@
   else {
     _options.proxylisten.s_addr = htonl(INADDR_ANY);
 #elif (_debug_)
-    syslog(LOG_WARNING, "radproxy not implemented. build with --enable-radproxy");
+    chilli_log(LOG_WARNING, "radproxy not implemented. build with --enable-radproxy");
 #endif
   }
 
@@ -1178,7 +1244,7 @@
 #ifdef ENABLE_RADPROXY
     if(option_aton(&_options.proxyaddr, &_options.proxymask,
 		   args_info.proxyclient_arg, 0)) {
-      syslog(LOG_ERR, "Invalid proxy client address: %s!", args_info.proxyclient_arg);
+      chilli_log(LOG_ERR, "Invalid proxy client address: %s!", args_info.proxyclient_arg);
       if (!args_info.forgiving_flag)
 	goto end_processing;
     }
@@ -1187,7 +1253,7 @@
     _options.proxyaddr.s_addr = ~0; /* Let nobody through */
     _options.proxymask.s_addr = 0;
 #elif (_debug_)
-    syslog(LOG_WARNING, "radproxy not implemented. build with --enable-radproxy");
+    chilli_log(LOG_WARNING, "radproxy not implemented. build with --enable-radproxy");
 #endif
   }
 
@@ -1203,16 +1269,16 @@
 
     unsigned int mac[6];
 
-    syslog(LOG_DEBUG, "Macallowed #%d: %s", numargs, args_info.macallowed_arg[numargs]);
+    chilli_log(LOG_DEBUG, "Macallowed #%d: %s", numargs, args_info.macallowed_arg[numargs]);
 
-    strcpy(p3, args_info.macallowed_arg[numargs]);
+    strncpy(p3, args_info.macallowed_arg[numargs], strlen(args_info.macallowed_arg[numargs]));
     p1 = p3;
     if ((p2 = strchr(p1, ','))) {
       *p2 = '\0';
     }
     while (p1) {
       if (_options.macoklen>=MACOK_MAX) {
-	syslog(LOG_ERR, "Too many addresses in macallowed %s!",
+	chilli_log(LOG_ERR, "Too many addresses in macallowed %s!",
                *args_info.macallowed_arg);
       }
       else {
@@ -1222,11 +1288,11 @@
 
 	if (sscanf (p1, "%2x %2x %2x %2x %2x %2x",
 		    &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) != 6) {
-	  syslog(LOG_ERR, "Failed to convert macallowed option to MAC Address");
+	  chilli_log(LOG_ERR, "Failed to convert macallowed option to MAC Address");
 	}
 	else {
 
-	  syslog(LOG_DEBUG, "Macallowed address #%d: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
+	  chilli_log(LOG_DEBUG, "Macallowed address #%d: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
                  _options.macoklen,
                  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
@@ -1275,21 +1341,21 @@
   _options.ipwhitelist = STRDUP(args_info.ipwhitelist_arg);
 #else
   if (args_info.ipwhitelist_arg)
-    syslog(LOG_ERR, "option ipwhitelist given when no support built-in");
+    chilli_log(LOG_ERR, "option ipwhitelist given when no support built-in");
 #endif
 
 #ifdef ENABLE_UAMDOMAINFILE
   _options.uamdomainfile = STRDUP(args_info.uamdomainfile_arg);
 #else
   if (args_info.uamdomainfile_arg)
-    syslog(LOG_ERR, "option uamdomainfile given when no support built-in");
+    chilli_log(LOG_ERR, "option uamdomainfile given when no support built-in");
 #endif
 
 #ifdef ENABLE_MODULES
   _options.moddir = STRDUP(args_info.moddir_arg);
 #else
   if (args_info.moddir_arg)
-    syslog(LOG_ERR, "option moddir given when no support built-in");
+    chilli_log(LOG_ERR, "option moddir given when no support built-in");
 #endif
 
 #ifdef ENABLE_RADPROXY
@@ -1317,7 +1383,7 @@
 	char s[256];
 
 	if (sscanf(args_info.extadmvsa_arg[numargs],
-		   "%u,%u:%s", &i[0], &i[1], s) == 3) {
+		   "%u,%u:%256s", &i[0], &i[1], s) == 3) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr_vsa = i[0];
 	  _options.extadmvsa[numargs].attr = i[1];
@@ -1329,7 +1395,7 @@
                     idx + 1, sizeof(_options.extadmvsa[numargs].data));
 	  }
 	} else if (sscanf(args_info.extadmvsa_arg[numargs],
-			  "%u:%s", &i[0], s) == 2) {
+			  "%u:%256s", &i[0], s) == 2) {
 	  char *idx = strchr(s, ':');
 	  _options.extadmvsa[numargs].attr = i[0];
 	  if (idx) *idx = 0;
@@ -1340,11 +1406,11 @@
                     idx + 1, sizeof(_options.extadmvsa[numargs].data));
 	  }
 	} else {
-	  syslog(LOG_ERR, "invalid input %s", args_info.extadmvsa_arg[numargs]);
+	  chilli_log(LOG_ERR, "invalid input %s", args_info.extadmvsa_arg[numargs]);
 	}
       }
 
-      syslog(LOG_DEBUG, "Extended admin-user attr (%d/%d) data=%s script=%s",
+      chilli_log(LOG_DEBUG, "Extended admin-user attr (%d/%d) data=%s script=%s",
              (int)_options.extadmvsa[numargs].attr_vsa,
              (int)_options.extadmvsa[numargs].attr,
              _options.extadmvsa[numargs].data,
@@ -1358,7 +1424,14 @@
   _options.wwwdir = STRDUP(args_info.wwwdir_arg);
   _options.wwwbin = STRDUP(args_info.wwwbin_arg);
   _options.uamui = STRDUP(args_info.uamui_arg);
-  _options.localusers = STRDUP(args_info.localusers_arg);
+  _options.localusers = args_info.localusers_flag;
+#ifdef USING_CURL
+  _options.oidc = args_info.oidc_flag;
+  _options.oidcforcehttps = args_info.oidcforcehttps_flag;
+  _options.oidcdiscoveryurl = STRDUP(args_info.oidcdiscoveryurl_arg);
+  _options.oidcclientid = STRDUP(args_info.oidcclientid_arg);
+  _options.oidcclientsecret = STRDUP(args_info.oidcclientsecret_arg);
+#endif
   _options.uamurl = STRDUP(args_info.uamserver_arg);
   _options.uamaaaurl = STRDUP(args_info.uamaaaurl_arg);
   _options.uamhomepage = STRDUP(args_info.uamhomepage_arg);
@@ -1391,6 +1464,7 @@
   _options.ipdown = STRDUP(args_info.ipdown_arg);
   _options.conup = STRDUP(args_info.conup_arg);
   _options.condown = STRDUP(args_info.condown_arg);
+  _options.conrestart = STRDUP(args_info.conrestart_arg);
   _options.macup = STRDUP(args_info.macup_arg);
   _options.macdown = STRDUP(args_info.macdown_arg);
   _options.pidfile = STRDUP(args_info.pidfile_arg);
@@ -1409,6 +1483,43 @@
   _options.locationupdate = STRDUP(args_info.locationupdate_arg);
 #endif
   _options.nochallenge = args_info.nochallenge_flag;
+  _options.successurlcustom = STRDUP(args_info.successurlcustom_arg);
+  _options.dbpath = STRDUP(args_info.dbpath_arg);
+  _options.usersdbpath = STRDUP(args_info.usersdbpath_arg);
+  _options.smsusers = args_info.smsusers_flag;
+  _options.duplicateusers = args_info.duplicateusers_flag;
+  _options.macusers = args_info.macusers_flag;
+  _options.trialusers = args_info.trialusers_flag;
+  _options.usersignup = STRDUP(args_info.usersignup_arg);
+  _options.macpass = STRDUP(args_info.macpass_arg);
+  _options.tos = args_info.tos_flag;
+  _options.registerusers = args_info.registerusers_flag;
+
+  _options.paramuamip = STRDUP(args_info.paramuamip_arg);
+  _options.paramuamport = STRDUP(args_info.paramuamport_arg);
+  _options.paramcalled  = STRDUP(args_info.paramcalled_arg);
+  _options.parammac = STRDUP(args_info.parammac_arg);
+  _options.paramip = STRDUP(args_info.paramip_arg);
+  _options.paramnasid = STRDUP(args_info.paramnasid_arg);
+  _options.paramsessionid = STRDUP(args_info.paramsessionid_arg);
+  _options.paramuserurl = STRDUP(args_info.paramuserurl_arg);
+  _options.paramchallenge = STRDUP(args_info.paramchallenge_arg);
+  _options.param1 = STRDUP(args_info.param1_arg);
+  _options.param1value = STRDUP(args_info.param1value_arg);
+  _options.param2  = STRDUP(args_info.param2_arg);
+  _options.param2value = STRDUP(args_info.param2value_arg);
+
+  _options.testtime = args_info.testtime_flag;
+#ifdef ENABLE_GSM
+  _options.modemid = STRDUP(args_info.modemid_arg);
+  if (!_options.modemid) {
+  	struct ubus_context *ubus;
+  	if ((ubus = ubus_connect(NULL))) {
+  		_options.modemid = STRDUP(lgsmu_get_default_modem_id(ubus));
+  		ubus_shutdown(ubus);
+  	}
+  }
+#endif
 #ifdef EX_OPT_MAIN
 #include EX_OPT_MAIN
 #endif
@@ -1418,14 +1529,14 @@
   if (_options.binconfig) { /* save out the configuration */
     bstring bt = bfromcstr("");
     int ok = options_save(_options.binconfig, bt);
-    if (!ok) syslog(LOG_ERR, "could not save configuration options!");
+    if (!ok) chilli_log(LOG_ERR, "could not save configuration options!");
     bdestroy(bt);
   }
 
   if (args_info.reload_flag) {
     if (execl(SBINDIR "/chilli_query", "chilli_query",
 	      args_info.cmdsocket_arg, "reload", (char *) 0) != 0) {
-      syslog(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
       exit(2);
     }
   }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-proxy.c src/src/main-proxy.c
--- upstream/src/main-proxy.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-proxy.c	2025-11-06 13:20:13.000000000 +0000
@@ -93,7 +93,7 @@
 
   for (i=0; i < max_requests; i++) {
     req = &requests[i];
-    syslog(LOG_INFO, "%.3d. inuse=%d prev=%.3d next=%.3d url=%s fd=%d",
+    chilli_log(LOG_INFO, "%.3d. inuse=%d prev=%.3d next=%.3d url=%s fd=%d",
            req->index, req->inuse ? 1 : 0,
            req->prev ? req->prev->index : -1,
            req->next ? req->next->index : -1,
@@ -133,17 +133,17 @@
   }
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "connections free %d", num_requests_free);
+  chilli_log(LOG_DEBUG, "connections free %d", num_requests_free);
 #endif
 
   if (!req) {
     /* problem */
-    syslog(LOG_ERR, "out of connections");
+    chilli_log(LOG_ERR, "out of connections");
     print_requests();
     return 0;
   }
 
-  syslog(LOG_DEBUG, "request index %d", req->index);
+  chilli_log(LOG_DEBUG, "request index %d", req->index);
   req->lasttime = time(NULL);
   req->next = req->prev = 0;
   req->inuse = 1;
@@ -172,7 +172,7 @@
 
 static void close_request(proxy_request *req) {
 
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
 
   if (req->url)  bdestroy(req->url);
   if (req->data) bdestroy(req->data);
@@ -198,7 +198,7 @@
   num_requests_free++;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "connections free %d", num_requests_free);
+  chilli_log(LOG_DEBUG, "connections free %d", num_requests_free);
 #endif
 }
 
@@ -208,11 +208,11 @@
 
 #ifdef USING_CURL
 #if(_debug_)
-  syslog(LOG_DEBUG, "calling curl_easy_cleanup()");
+  chilli_log(LOG_DEBUG, "calling curl_easy_cleanup()");
 #endif
   if (req->curl) {
     if (req->error_buffer[0])
-      syslog(LOG_DEBUG, "curl error %s", req->error_buffer);
+      chilli_log(LOG_DEBUG, "curl error %s", req->error_buffer);
     curl_multi_remove_handle(curl_multi, req->curl);
     curl_easy_cleanup(req->curl);
     req->curl = 0;
@@ -224,7 +224,7 @@
 
   if (req->data && req->data->slen) {
 #if(_debug_)
-    syslog(LOG_DEBUG, "Received: %s\n",req->data->data);
+    chilli_log(LOG_DEBUG, "Received: %s\n",req->data->data);
 #endif
     req->authorized = !memcmp(req->data->data, "Auth: 1", 7);
     req->challenge = !memcmp(req->data->data, "Auth: 2", 7);
@@ -234,14 +234,14 @@
   switch(req->radius_req.code) {
     case RADIUS_CODE_ACCOUNTING_REQUEST:
 #if(_debug_)
-      syslog(LOG_DEBUG, "Accounting-Response");
+      chilli_log(LOG_DEBUG, "Accounting-Response");
 #endif
       radius_default_pack(radius, &req->radius_res, RADIUS_CODE_ACCOUNTING_RESPONSE);
       break;
 
     case RADIUS_CODE_ACCESS_REQUEST:
 #if(_debug_)
-      syslog(LOG_DEBUG, "Access-%s", req->authorized ? "Accept" :
+      chilli_log(LOG_DEBUG, "Access-%s", req->authorized ? "Accept" :
              req->challenge ? "Challenge" : "Reject");
 #endif
       radius_default_pack(radius, &req->radius_res,
@@ -325,11 +325,11 @@
 	    switch(attrs[i].t) {
               case 0: /*integer*/
                 {
-                  uint32_t v = (uint32_t) atoi(ptr+strlen(attrs[i].n));
+                  uint32_t v = (uint32_t) strtol(ptr+strlen(attrs[i].n), NULL, 0);
                   if (v > 0) {
                     radius_addattr(radius, &req->radius_res, attrs[i].a, attrs[i].v, attrs[i].va, v, NULL, 0);
 #if(_debug_)
-                    syslog(LOG_DEBUG, "Setting %s = %d", attrs[i].n, v);
+                    chilli_log(LOG_DEBUG, "Setting %s = %d", attrs[i].n, v);
 #endif
                   }
                 }
@@ -339,7 +339,7 @@
                   radius_addattr(radius, &req->radius_res, attrs[i].a, attrs[i].v, attrs[i].va, 0,
                                  (uint8_t *)ptr+strlen(attrs[i].n), strlen(ptr)-strlen(attrs[i].n));
 #if(_debug_)
-                  syslog(LOG_DEBUG, "Setting %s = %s", attrs[i].n, ptr+strlen(attrs[i].n));
+                  chilli_log(LOG_DEBUG, "Setting %s = %s", attrs[i].n, ptr+strlen(attrs[i].n));
 #endif
                 }
                 break;
@@ -377,7 +377,7 @@
                   }
 
 #if(_debug_)
-                  syslog(LOG_DEBUG, "Setting %s = %s", attrs[i].n, ptr+strlen(attrs[i].n));
+                  chilli_log(LOG_DEBUG, "Setting %s = %s", attrs[i].n, ptr+strlen(attrs[i].n));
 #endif
                   bdestroy(tmp);
                   bdestroy(tmp2);
@@ -435,7 +435,7 @@
   if (size > 0 && nmemb > 0) {
     int rsize = size * nmemb;
     bcatblk(s,ptr,rsize);
-    syslog(LOG_DEBUG, "read %d", rsize);
+    chilli_log(LOG_DEBUG, "read %d", rsize);
     return rsize;
   }
   return 0;
@@ -469,7 +469,7 @@
 
     if (cert && strlen(cert)) {
 #if(_debug_)
-      syslog(LOG_DEBUG, "using cert [%s]",cert);
+      chilli_log(LOG_DEBUG, "using cert [%s]",cert);
 #endif
       curl_easy_setopt(curl, CURLOPT_SSLCERT, cert);
       curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, "PEM");
@@ -477,13 +477,13 @@
 
     if (key && strlen(key)) {
 #if(_debug_)
-      syslog(LOG_DEBUG, "using key [%s]",key);
+      chilli_log(LOG_DEBUG, "using key [%s]",key);
 #endif
       curl_easy_setopt(curl, CURLOPT_SSLKEY, key);
       curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, "PEM");
       if (keypwd && strlen(keypwd)) {
 #if(_debug_)
-	syslog(LOG_DEBUG, "using key pwd [%s]",keypwd);
+	chilli_log(LOG_DEBUG, "using key pwd [%s]",keypwd);
 #endif
 #ifdef CURLOPT_SSLCERTPASSWD
 	curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, keypwd);
@@ -502,7 +502,7 @@
     if (ca && strlen(ca)) {
 #ifdef CURLOPT_ISSUERCERT
 #if(_debug_)
-      syslog(LOG_DEBUG, "using ca [%s]",ca);
+      chilli_log(LOG_DEBUG, "using ca [%s]",ca);
 #endif
       curl_easy_setopt(curl, CURLOPT_ISSUERCERT, ca);
       curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1);
@@ -618,7 +618,7 @@
 	  curl_multi_perform(curl_multi, &still_running));
 
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "curl still running %d", still_running);
+    chilli_log(LOG_DEBUG, "curl still running %d", still_running);
 #endif
 #endif
 
@@ -639,7 +639,7 @@
   process_options(i, argv, 1);
 
   if (!_options.uamaaaurl) {
-    syslog(LOG_ERR, "uamaaaurl not defined in configuration");
+    chilli_log(LOG_ERR, "uamaaaurl not defined in configuration");
     exit(-1);
   }
 
@@ -696,7 +696,7 @@
   if (http_aaa_setup(0, &req) == 0) {
 
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "==> %s\npost:%s", req.url->data, req.post->data);
+    chilli_log(LOG_DEBUG, "==> %s\npost:%s", req.url->data, req.post->data);
 #endif
 
 #ifdef USING_CURL
@@ -704,7 +704,7 @@
 #endif
 
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "<== %s", req.data->data);
+    chilli_log(LOG_DEBUG, "<== %s", req.data->data);
 #endif
 
 #ifdef USING_CURL
@@ -714,7 +714,7 @@
 
   if (req.data->slen)
     if (safe_write(1, req.data->data, req.data->slen) < 0)
-      syslog(LOG_ERR, "%s: write()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
   bdestroy(req.url);
   bdestroy(req.data);
@@ -745,7 +745,7 @@
   if (!req) return;
 
   if (!_options.uamaaaurl) {
-    syslog(LOG_ERR, "No --uamaaaurl parameter defined");
+    chilli_log(LOG_ERR, "No --uamaaaurl parameter defined");
     return;
   }
 
@@ -812,7 +812,7 @@
             bcatcstr(req->url, "down");
             break;
           default:
-            syslog(LOG_ERR, "unsupported acct-status-type %d", ntohl(attr->v.i));
+            chilli_log(LOG_ERR, "unsupported acct-status-type %d", ntohl(attr->v.i));
             error = "Unsupported acct-status-type";
             break;
         }
@@ -1032,13 +1032,13 @@
       redir_md_param(req->url, _options.uamsecret, "&");
 
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "==> %s", req->url->data);
+    chilli_log(LOG_DEBUG, "==> %s", req->url->data);
 #endif
     if (http_aaa(radius, req) < 0)
       close_request(req);
 
   } else {
-    syslog(LOG_ERR, "problem: %s", error);
+    chilli_log(LOG_ERR, "problem: %s", error);
   }
 
   bdestroy(tmp);
@@ -1122,7 +1122,7 @@
 		 _options.radiusauthport : RADIUS_AUTHPORT,
 		 0, 0) ||
       radius_init_q(radius_auth, 0)) {
-    syslog(LOG_ERR, "Failed to create radius");
+    chilli_log(LOG_ERR, "Failed to create radius");
     return -1;
   }
 
@@ -1131,7 +1131,7 @@
 		 _options.radiusacctport : RADIUS_ACCTPORT,
 		 0, 0) ||
       radius_init_q(radius_acct, 0)) {
-    syslog(LOG_ERR, "Failed to create radius");
+    chilli_log(LOG_ERR, "Failed to create radius");
     return -1;
   }
 
@@ -1139,12 +1139,12 @@
   radius_set(radius_acct, 0, 0);
 
   if (_options.gid && setgid(_options.gid)) {
-    syslog(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
+    chilli_log(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
            errno, _options.gid, getgid());
   }
 
   if (_options.uid && setuid(_options.uid)) {
-    syslog(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
+    chilli_log(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
            errno, _options.uid, getuid());
   }
 
@@ -1168,7 +1168,7 @@
     for (idx=0; idx < max_requests; idx++) {
       if (requests[idx].inuse &&
 	  requests[idx].lasttime < expired_time) {
-	syslog(LOG_DEBUG, "remove expired index %d", idx);
+	chilli_log(LOG_DEBUG, "remove expired index %d", idx);
 	http_aaa_finish(&requests[idx]);
       }
     }
@@ -1195,7 +1195,7 @@
     switch (status) {
       case -1:
         if (EINTR != errno) {
-          syslog(LOG_ERR, "%s: select() returned -1!", strerror(errno));
+          chilli_log(LOG_ERR, "%s: select() returned -1!", strerror(errno));
         }
         break;
 
@@ -1210,7 +1210,7 @@
             int signo = chilli_handle_signal(0, 0);
             if (signo) {
 #if(_debug_)
-              syslog(LOG_DEBUG, "main-proxy signal %d", signo);
+              chilli_log(LOG_DEBUG, "main-proxy signal %d", signo);
 #endif
               switch(signo) {
                 case SIGUSR2: print_requests(); break;
@@ -1227,7 +1227,7 @@
             if ((status = recvfrom(radius_auth->fd,
                                    &radius_pack, sizeof(radius_pack), 0,
                                    (struct sockaddr *) &addr, &fromlen)) <= 0) {
-              syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+              chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
 
               return -1;
             }
@@ -1241,13 +1241,13 @@
              */
 
 #if(_debug_)
-            syslog(LOG_DEBUG, "received accounting");
+            chilli_log(LOG_DEBUG, "received accounting");
 #endif
 
             if ((status = recvfrom(radius_acct->fd,
                                    &radius_pack, sizeof(radius_pack), 0,
                                    (struct sockaddr *) &addr, &fromlen)) <= 0) {
-              syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+              chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
               return -1;
             }
 
@@ -1260,13 +1260,13 @@
               curl_multi_perform(curl_multi, &still_running));
 
 #if(_debug_ > 1)
-        syslog(LOG_DEBUG, "curl still running %d", still_running);
+        chilli_log(LOG_DEBUG, "curl still running %d", still_running);
 #endif
 
         while ((msg = curl_multi_info_read(curl_multi, &msgs_left))) {
 
 #if(_debug_ > 1)
-          syslog(LOG_DEBUG, "curl messages left %d", msgs_left);
+          chilli_log(LOG_DEBUG, "curl messages left %d", msgs_left);
 #endif
 
           if (msg->msg == CURLMSG_DONE) {
@@ -1280,11 +1280,11 @@
             if (found) {
               --idx;
 #if(_debug_)
-              syslog(LOG_DEBUG, "HTTP completed with status %d\n", msg->data.result);
+              chilli_log(LOG_DEBUG, "HTTP completed with status %d\n", msg->data.result);
 #endif
               http_aaa_finish(&requests[idx]);
             } else {
-              syslog(LOG_ERR, "%s: Could not find request in queue", strerror(errno));
+              chilli_log(LOG_ERR, "%s: Could not find request in queue", strerror(errno));
             }
           }
         }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-query.c src/src/main-query.c
--- upstream/src/main-query.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-query.c	2025-11-06 13:20:13.000000000 +0000
@@ -150,6 +150,11 @@
     sizeof(request.d.sess.params.maxoutputoctets),
     &request.d.sess.params.maxoutputoctets,
     "Max output octets (bytes)", 0, 0 },
+  { "warningoctets",
+    CMDSOCK_FIELD_INTEGER,
+    sizeof(request.d.sess.params.warningoctets),
+    &request.d.sess.params.warningoctets,
+    "Data amount over which an SMS warning is sent (bytes)", 0, 0 },
   { "maxbwup",
     CMDSOCK_FIELD_INTEGER,
     sizeof(request.d.sess.params.bandwidthmaxup),
@@ -180,6 +185,11 @@
     &request.d.sess.params.url,
     "Set redirect url",
     &request.d.sess.params.flags, REQUIRE_REDIRECT },
+  { "userurl",
+    CMDSOCK_FIELD_STRING,
+    sizeof(request.d.sess.userurl),
+    &request.d.sess.userurl,
+    "Set URL requested by user", 0, 0 },
 #ifdef ENABLE_MULTIROUTE
   { "routeidx",
     CMDSOCK_FIELD_INTEGER,
@@ -323,16 +333,16 @@
           case CMDSOCK_FIELD_INTEGER:
             switch(args[i].length) {
               case 1:
-                *((uint8_t *)args[i].field) |= (uint8_t)atoi(argv[argidx+1]);
+                *((uint8_t *)args[i].field) |= (uint8_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 2:
-                *((uint16_t *)args[i].field) |= (uint16_t)atoi(argv[argidx+1]);
+                *((uint16_t *)args[i].field) |= (uint16_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 4:
-                *((uint32_t *)args[i].field) |= (uint32_t)atol(argv[argidx+1]);
+                *((uint32_t *)args[i].field) |= (uint32_t)strtol(argv[argidx+1], NULL, 0);
                 break;
               case 8:
-                *((uint64_t *)args[i].field) |= (uint64_t)atol(argv[argidx+1]);
+                *((uint64_t *)args[i].field) |= (uint64_t)strtol(argv[argidx+1], NULL, 0);
                 break;
             }
             break;
@@ -425,7 +435,7 @@
   int query_timeout = QUERY_TIMEOUT;
 
   if ((query_timeout_env = getenv("QUERY_TIMEOUT"))) {
-    query_timeout = atoi(query_timeout_env);
+    query_timeout = strtol(query_timeout_env, NULL, 0);
   }
 
   set_signal(SIGALRM, timeout_alarm);
@@ -437,7 +447,7 @@
   itval.it_value.tv_usec = 0;
 
   if (setitimer(ITIMER_REAL, &itval, NULL)) {
-    syslog(LOG_ERR, "%s: setitimer() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: setitimer() failed!", strerror(errno));
   }
 
   if (argc < 2) return usage(argv[0]);
@@ -459,7 +469,7 @@
     } else if (!strcmp(argv[argidx], "-p")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      peerid = atoi(argv[argidx++]);
+      peerid = strtol(argv[argidx++], NULL, 0);
 #endif
     } else if (!strcmp(argv[argidx], "-json")) {
       request.options |= CMDSOCK_OPT_JSON;
@@ -467,7 +477,7 @@
     } else if (!strcmp(argv[argidx], "-P")) {
       argidx++;
       if (argidx >= argc) return usage(argv[0]);
-      cmdsockport = atoi(argv[argidx++]);
+      cmdsockport = strtol(argv[argidx++], NULL, 0);
     }
   }
 
@@ -548,7 +558,7 @@
               request.mac[i] = temp[i];
 
             argidx++;
-            request.d.sess.params.routeidx = atoi(argv[argidx]);
+            request.d.sess.params.routeidx = strtol(argv[argidx], NULL, 0);
 
             if (request.type != CMDSOCK_ROUTE_GW)
               request.type = CMDSOCK_ROUTE_SET;
@@ -579,7 +589,7 @@
     printf("blen %d\n", blen);
 
     if (fd < 0) {
-      syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
       exit(1);
     }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-radconfig.c src/src/main-radconfig.c
--- upstream/src/main-radconfig.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-radconfig.c	2025-11-06 13:20:13.000000000 +0000
@@ -35,20 +35,20 @@
   size_t offset = 0;
 
   if (!pack) {
-    syslog(LOG_ERR, "Radius request timed out");
+    chilli_log(LOG_ERR, "Radius request timed out");
     return 0;
   }
 
   if ((pack->code != RADIUS_CODE_ACCESS_REJECT) &&
       (pack->code != RADIUS_CODE_ACCESS_CHALLENGE) &&
       (pack->code != RADIUS_CODE_ACCESS_ACCEPT)) {
-    syslog(LOG_ERR, "Unknown radius access reply code %d", pack->code);
+    chilli_log(LOG_ERR, "Unknown radius access reply code %d", pack->code);
     return 0;
   }
 
   /* ACCESS-ACCEPT */
   if (pack->code != RADIUS_CODE_ACCESS_ACCEPT) {
-    syslog(LOG_ERR, "Administrative-User Login Failed");
+    chilli_log(LOG_ERR, "Administrative-User Login Failed");
     return 0;
   }
 
@@ -74,17 +74,17 @@
   int ret=-1;
 
   if (!_options.adminuser || !_options.adminpasswd) {
-    syslog(LOG_ERR, "Must be used with --adminuser and --adminpasswd");
+    chilli_log(LOG_ERR, "Must be used with --adminuser and --adminpasswd");
     return 1;
   }
 
   if (radius_new(&radius, &_options.radiuslisten, 0, 0, 0)) {
-    syslog(LOG_ERR, "radius_new: Failed to create radius");
+    chilli_log(LOG_ERR, "radius_new: Failed to create radius");
     return ret;
   }
 
   if (radius_init_q(radius, 4)) {
-     syslog(LOG_ERR, "radius_init: Failed to initialize radius");
+     chilli_log(LOG_ERR, "radius_init: Failed to initialize radius");
      radius_free(radius);
      return ret;
   }
@@ -100,7 +100,7 @@
       memset(&ifr, 0, sizeof(ifr));
       strlcpy(ifr.ifr_name, _options.dhcpif, IFNAMSIZ);
       if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0) {
-	syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), fd, SIOCGIFHWADDR);
+	chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), fd, SIOCGIFHWADDR);
       }
       memcpy(hwaddr, ifr.ifr_hwaddr.sa_data, PKT_ETH_ALEN);
       close(fd);
@@ -114,7 +114,7 @@
   ret = chilli_auth_radius(radius);
 
   if (radius->fd <= 0) {
-    syslog(LOG_ERR, "not a valid socket!");
+    chilli_log(LOG_ERR, "not a valid socket!");
     return ret;
   }
 
@@ -134,7 +134,7 @@
 
     switch (status = select(maxfd + 1, &fds, NULL, NULL, &idleTime)) {
       case -1:
-        syslog(LOG_ERR, "%s: select() returned -1!", strerror(errno));
+        chilli_log(LOG_ERR, "%s: select() returned -1!", strerror(errno));
         break;
       case 0:
         radius_timeout(radius);
@@ -145,7 +145,7 @@
     if (status > 0) {
       if (FD_ISSET(radius->fd, &fds)) {
 	if (radius_decaps(radius, 0) < 0) {
-	  syslog(LOG_ERR, "radius_ind() failed!");
+	  chilli_log(LOG_ERR, "radius_ind() failed!");
 	}
 	else {
 	  ret = 0;
@@ -167,7 +167,7 @@
   options_init();
 
   if (process_options(argc, argv, 1)) {
-    syslog(LOG_ERR, "%s: Exiting...", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Exiting...", strerror(errno));
     exit(1);
   }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-radsec.c src/src/main-radsec.c
--- upstream/src/main-radsec.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-radsec.c	2025-11-06 13:20:13.000000000 +0000
@@ -50,7 +50,7 @@
   }
   server.conn.sslcon = openssl_connect_fd(server.env, server.conn.sock, 10);
   if (!server.conn.sslcon) {
-    syslog(LOG_ERR, "%s: Failed to connect to %s:%d", strerror(errno), inet_ntoa(*addr), port);
+    chilli_log(LOG_ERR, "%s: Failed to connect to %s:%d", strerror(errno), inet_ntoa(*addr), port);
     return -1;
   }
   return 0;
@@ -73,30 +73,30 @@
 try_again:
 
   if (attempts++ == 5) {
-    syslog(LOG_ERR, "%s: Dropping RADIUS packet!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Dropping RADIUS packet!", strerror(errno));
     return;
   }
 
-  syslog(LOG_DEBUG, "%s:%s", __FILE__, __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s:%s", __FILE__, __FUNCTION__);
 
   if (!server.conn.connected) {
-    syslog(LOG_DEBUG, "RADSEC: Connecting to %s:2083",
+    chilli_log(LOG_DEBUG, "RADSEC: Connecting to %s:2083",
            inet_ntoa(_options.radiusserver1));
     if (connect_ssl(&_options.radiusserver1, 2083)) {
-      syslog(LOG_ERR, "%d Could not connect to RadSec server %s!",
+      chilli_log(LOG_ERR, "%d Could not connect to RadSec server %s!",
              errno, inet_ntoa(_options.radiusserver1));
-      syslog(LOG_DEBUG, "RADSEC: Connecting to %s:2083",
+      chilli_log(LOG_DEBUG, "RADSEC: Connecting to %s:2083",
              inet_ntoa(_options.radiusserver1));
       if (connect_ssl(&_options.radiusserver2, 2083)) {
-	syslog(LOG_ERR, "%d Could not connect to RadSec server %s!",
+	chilli_log(LOG_ERR, "%d Could not connect to RadSec server %s!",
                errno, inet_ntoa(_options.radiusserver2));
       } else {
-	syslog(LOG_DEBUG, "RADSEC: Connected to %s:2083",
+	chilli_log(LOG_DEBUG, "RADSEC: Connected to %s:2083",
                inet_ntoa(_options.radiusserver2));
 	server.conn.connected = 1;
       }
     } else {
-      syslog(LOG_DEBUG, "RADSEC: Connected to %s:2083",
+      chilli_log(LOG_DEBUG, "RADSEC: Connected to %s:2083",
              inet_ntoa(_options.radiusserver1));
       server.conn.connected = 1;
     }
@@ -109,7 +109,7 @@
 
   {
     int l = openssl_write(server.conn.sslcon, (char *)pack, len, 0);
-    syslog(LOG_DEBUG, "ssl_write %d",l);
+    chilli_log(LOG_DEBUG, "ssl_write %d",l);
     if (l <= 0) {
       shutdown_ssl();
       /*
@@ -123,29 +123,29 @@
 static void process_radius_reply() {
   uint8_t *d = (uint8_t *) &server.pack;
   int l = openssl_read(server.conn.sslcon, (char *)d, 4, 0);
-  syslog(LOG_DEBUG, "reply %d", l);
+  chilli_log(LOG_DEBUG, "reply %d", l);
   if (l == 4) {
     int len = ntohs(server.pack.length) - 4;
     l = openssl_read(server.conn.sslcon, (char *)(d + 4), len, 0);
-    syslog(LOG_DEBUG, "reply %d", l);
+    chilli_log(LOG_DEBUG, "reply %d", l);
     if (l == len) {
-      syslog(LOG_DEBUG, "reply +%d", len);
+      chilli_log(LOG_DEBUG, "reply +%d", len);
       switch (server.pack.code) {
         case RADIUS_CODE_ACCESS_ACCEPT:
         case RADIUS_CODE_ACCESS_REJECT:
         case RADIUS_CODE_ACCESS_CHALLENGE:
-          syslog(LOG_DEBUG, "reply auth %d", len);
+          chilli_log(LOG_DEBUG, "reply auth %d", len);
           radius_pkt_send(server.radius_auth, &server.pack, &server.auth_peer);
           break;
         case RADIUS_CODE_ACCOUNTING_RESPONSE:
-          syslog(LOG_DEBUG, "reply acct %d", len);
+          chilli_log(LOG_DEBUG, "reply acct %d", len);
           radius_pkt_send(server.radius_acct, &server.pack, &server.acct_peer);
           break;
         case RADIUS_CODE_COA_REQUEST:
         case RADIUS_CODE_DISCONNECT_REQUEST:
         case RADIUS_CODE_STATUS_REQUEST:
           if (_options.coaport) {
-            syslog(LOG_DEBUG, "reply coa %d", len);
+            chilli_log(LOG_DEBUG, "reply coa %d", len);
             radius_pkt_send(server.radius_cli, &server.pack, &server.acct_peer);
           }
           break;
@@ -196,28 +196,28 @@
   memset(&server, 0, sizeof(server));
 
   if (!(server.env = initssl_cli())) {
-    syslog(LOG_ERR, "Failed to create ssl environment");
+    chilli_log(LOG_ERR, "Failed to create ssl environment");
     return -1;
   }
 
   if (radius_new(&server.radius_auth, &radiuslisten,
 		 _options.radiusauthport ? _options.radiusauthport : RADIUS_AUTHPORT,
 		 0, 0)) {
-    syslog(LOG_ERR, "Failed to create radius");
+    chilli_log(LOG_ERR, "Failed to create radius");
     return -1;
   }
 
   if (radius_new(&server.radius_acct, &radiuslisten,
 		 _options.radiusacctport ? _options.radiusacctport : RADIUS_ACCTPORT,
 		 0, 0)) {
-    syslog(LOG_ERR, "Failed to create radius");
+    chilli_log(LOG_ERR, "Failed to create radius");
     return -1;
   }
 
   if (_options.coaport) {
     if (radius_new(&server.radius_cli, &radiuslisten, 0, 0, 0) ||
 	radius_init_q(server.radius_cli, 8)) {
-      syslog(LOG_ERR, "Failed to create radius");
+      chilli_log(LOG_ERR, "Failed to create radius");
       return -1;
     }
     radius_set(server.radius_cli, 0, 0);
@@ -228,12 +228,12 @@
   radius_set(server.radius_acct, 0, 0);
 
   if (_options.gid && setgid(_options.gid)) {
-    syslog(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
+    chilli_log(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
            errno, _options.gid, getgid());
   }
 
   if (_options.uid && setuid(_options.uid)) {
-    syslog(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
+    chilli_log(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
            errno, _options.uid, getuid());
   }
 
@@ -278,7 +278,7 @@
     switch (status) {
       case -1:
         if (errno != EINTR)
-          syslog(LOG_ERR, "%s: select() returned -1!", strerror(errno));
+          chilli_log(LOG_ERR, "%s: select() returned -1!", strerror(errno));
         break;
 
       case 0:
@@ -298,7 +298,7 @@
 
             if ((status = recvfrom(server.radius_auth->fd, &radius_pack, sizeof(radius_pack), 0,
                                    (struct sockaddr *) &addr, &fromlen)) <= 0) {
-              syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+              chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
 
               return -1;
             }
@@ -313,11 +313,11 @@
              *    ---> Accounting
              */
 
-            syslog(LOG_DEBUG, "received accounting");
+            chilli_log(LOG_DEBUG, "received accounting");
 
             if ((status = recvfrom(server.radius_acct->fd, &radius_pack, sizeof(radius_pack), 0,
                                    (struct sockaddr *) &addr, &fromlen)) <= 0) {
-              syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+              chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
               return -1;
             }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-redir.c src/src/main-redir.c
--- upstream/src/main-redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-redir.c	2025-11-06 13:20:13.000000000 +0000
@@ -97,7 +97,7 @@
 	req = req->next;
 	cnt++;
       }
-      syslog(LOG_DEBUG, "redir free connections %d", cnt);;
+      chilli_log(LOG_DEBUG, "redir free connections %d", cnt);;
     }
     req = requests_free;
     requests_free = requests_free->next;
@@ -107,7 +107,7 @@
 
   if (!req) {
     /* problem */
-    syslog(LOG_ERR,"out of connections!");
+    chilli_log(LOG_ERR,"out of connections!");
     return 0;
   }
 
@@ -120,14 +120,14 @@
   req->ibuf = string_init_reset(req->ibuf);
 
   /*
-    syslog(LOG_DEBUG, "url->len  %d",req->url->slen);
-    syslog(LOG_DEBUG, "data->len %d",req->data->slen);
-    syslog(LOG_DEBUG, "post->len %d",req->post->slen);
+    chilli_log(LOG_DEBUG, "url->len  %d",req->url->slen);
+    chilli_log(LOG_DEBUG, "data->len %d",req->data->slen);
+    chilli_log(LOG_DEBUG, "post->len %d",req->post->slen);
   */
-  syslog(LOG_DEBUG, "dbuf->len %d",req->dbuf->slen);
-  syslog(LOG_DEBUG, "wbuf->len %d",req->wbuf->slen);
-  syslog(LOG_DEBUG, "hbuf->len %d",req->hbuf->slen);
-  syslog(LOG_DEBUG, "ibuf->len %d",req->ibuf->slen);
+  chilli_log(LOG_DEBUG, "dbuf->len %d",req->dbuf->slen);
+  chilli_log(LOG_DEBUG, "wbuf->len %d",req->wbuf->slen);
+  chilli_log(LOG_DEBUG, "hbuf->len %d",req->hbuf->slen);
+  chilli_log(LOG_DEBUG, "ibuf->len %d",req->ibuf->slen);
 
   req->read_closed = 0;
   req->write_closed = 0;
@@ -141,7 +141,7 @@
 }
 
 static void close_request(redir_request *req) {
-  syslog(LOG_DEBUG, "closing request");
+  chilli_log(LOG_DEBUG, "closing request");
   req->inuse = 0;
   req->proxy = 0;
   req->socket_fd = 0;
@@ -174,7 +174,7 @@
   memcpy(&msg.mdata.baddress, baddress, sizeof(msg.mdata.baddress));
 
   if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
-    syslog(LOG_ERR, "%s: socket()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket()", strerror(errno));
     return -1;
   }
 
@@ -190,19 +190,19 @@
   len = offsetof(struct sockaddr_un, sun_path) + strlen(remote.sun_path);
 
   if (safe_connect(s, (struct sockaddr *)&remote, len) == -1) {
-    syslog(LOG_ERR, "%s: could not connect to %s", strerror(errno), remote.sun_path);
+    chilli_log(LOG_ERR, "%s: could not connect to %s", strerror(errno), remote.sun_path);
     close(s);
     return -1;
   }
 
   if (safe_write(s, &msg, sizeof(msg)) != sizeof(msg)) {
-    syslog(LOG_ERR, "%s: could not write to %s", strerror(errno), remote.sun_path);
+    chilli_log(LOG_ERR, "%s: could not write to %s", strerror(errno), remote.sun_path);
     close(s);
     return -1;
   }
 
   if (safe_read(s, conn, sizeof(*conn)) != sizeof(*conn)) {
-    syslog(LOG_WARNING, "no session available from %s", remote.sun_path);
+    chilli_log(LOG_WARNING, "no session available from %s", remote.sun_path);
     close(s);
     return -1;
   }
@@ -230,7 +230,7 @@
        char b[256];
        char *inject = inject_fmt(req);
        int w = net_write(req->socket_fd, inject, strlen(inject));
-       syslog(LOG_DEBUG, "injected %d bytes", w);
+       chilli_log(LOG_DEBUG, "injected %d bytes", w);
        }
     */
 #endif
@@ -266,17 +266,17 @@
 		      conn->read_buf->slen -
 		      conn->read_pos);
     if (w < 0 && errno != EWOULDBLOCK && errno != EAGAIN) {
-      syslog(LOG_ERR, "%d net_write(%d)",
+      chilli_log(LOG_ERR, "%d net_write(%d)",
              errno, conn->read_buf->slen - conn->read_pos);
       redir_conn_finish(conn, req);
       return -1;
     } else if (w > 0) {
 #if(_debug_)
-      syslog(LOG_DEBUG, "client (re)write: %d", w);
+      chilli_log(LOG_DEBUG, "client (re)write: %d", w);
 #endif
       conn->read_pos += w;
       if (conn->read_pos == conn->read_buf->slen) {
-	syslog(LOG_DEBUG, "emptying write queue");
+	chilli_log(LOG_DEBUG, "emptying write queue");
 	conn->read_pos = 0;
 	bassigncstr(conn->read_buf, "");
       }
@@ -297,15 +297,15 @@
     w = net_write(req->socket_fd, d, l);
 
 #if(_debug_ )
-    syslog(LOG_DEBUG, "client write: %d", w);
-    /*syslog(LOG_DEBUG, "write: [%s]", b);*/
+    chilli_log(LOG_DEBUG, "client write: %d", w);
+    /*chilli_log(LOG_DEBUG, "write: [%s]", b);*/
 #endif
   }
 
   if (w >= 0) {
     if (w < l) {
       bcatblk(req->dbuf, d + w, l - w);
-      syslog(LOG_WARNING, "%s: buffering %d - %d = %d (%d queued)",
+      chilli_log(LOG_WARNING, "%s: buffering %d - %d = %d (%d queued)",
              strerror(errno), l, w, l-w, req->dbuf->slen);
     }
   }
@@ -324,13 +324,13 @@
   r = safe_recv(conn->sock, bb, sizeof(bb)-1, 0);
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "conn_read: %d clen=%d", r, req->clen);
+  chilli_log(LOG_DEBUG, "conn_read: %d clen=%d", r, req->clen);
 #endif
 
   if (r == 0) {
 
     if (req->read_closed && redir_cli_rewrite(req, conn) == 0) {
-      syslog(LOG_DEBUG, "done reading and writing");
+      chilli_log(LOG_DEBUG, "done reading and writing");
       redir_conn_finish(conn, req);
       return -1;
     }
@@ -340,7 +340,7 @@
   } else if (r < 0 &&
 	     errno != EWOULDBLOCK && errno != EAGAIN) {
 
-    syslog(LOG_DEBUG, "ERRNO %d", errno);
+    chilli_log(LOG_DEBUG, "ERRNO %d", errno);
     redir_conn_finish(conn, ctx);
 
   } else if (r > 0) {
@@ -370,7 +370,7 @@
 	if (strncmp((char *)req->hbuf->data, "HTTP/1.", 7) ||
 	    strncmp((char *)req->hbuf->data+8, " 2", 2)) {
 
-	  syslog(LOG_DEBUG, "Not HTTP/1.X 2XX reply");
+	  chilli_log(LOG_DEBUG, "Not HTTP/1.X 2XX reply");
 	  bcatblk(newhdr, req->hbuf->data, header_len + 4);
 
 	} else {
@@ -396,8 +396,8 @@
 	    if (!strncasecmp(hdr, "content-length:", 15)) {
 	      char c = hdr[l];
 	      hdr[l] = 0;
-	      clen = req->clen = atoi(hdr+15);
-	      syslog(LOG_DEBUG, "Detected Content Length %d", req->clen);
+	      clen = req->clen = strtol(hdr+15, NULL, 0);
+	      chilli_log(LOG_DEBUG, "Detected Content Length %d", req->clen);
 	      hdr[l] = c;
 	    } else if (!strncasecmp(hdr, "content-type:", 13)) {
 	      if (strstr(hdr, "text/html")) {
@@ -444,7 +444,7 @@
 	      }
 	    }
 
-	    syslog(LOG_DEBUG, "Resp Header [%d] %.*s%s",
+	    chilli_log(LOG_DEBUG, "Resp Header [%d] %.*s%s",
                    l, l, hdr, skip ? " [Skipped]" : "");
 
 	    if (!skip) {
@@ -496,7 +496,7 @@
     }
 #endif
   }
-  /*syslog(LOG_DEBUG, "leaving redir_conn_read()");*/
+  /*chilli_log(LOG_DEBUG, "leaving redir_conn_read()");*/
   return 0;
 }
 
@@ -505,7 +505,7 @@
   int ret;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "Checking %s =~ %s", s, regex);
+  chilli_log(LOG_DEBUG, "Checking %s =~ %s", s, regex);
 #endif
 
 #if defined (__FreeBSD__) || defined (__APPLE__) || defined (__OpenBSD__) || defined (__NetBSD__)
@@ -517,7 +517,7 @@
       if ((ret = regcomp(re, regex, REG_EXTENDED | REG_NOSUB)) != 0) {
         char error[512];
         regerror(ret, re, error, sizeof(error));
-        syslog(LOG_ERR, "regcomp(%s) failed (%s)", regex, error);
+        chilli_log(LOG_ERR, "regcomp(%s) failed (%s)", regex, error);
         regex[0] = 0;
         return -1;
       }
@@ -525,7 +525,7 @@
 
   if ((ret = regexec(re, s, 0, 0, 0)) == 0) {
 
-    syslog(LOG_DEBUG, "Matched regex %s", regex);
+    chilli_log(LOG_DEBUG, "Matched regex %s", regex);
     return 0;
 
   }
@@ -572,12 +572,12 @@
       */
 
 #if(_debug_)
-      syslog(LOG_DEBUG, "REGEX host=[%s] path=[%s] qs=[%s]",
+      chilli_log(LOG_DEBUG, "REGEX host=[%s] path=[%s] qs=[%s]",
              _options.regex_pass_throughs[i].regex_host,
              _options.regex_pass_throughs[i].regex_path,
              _options.regex_pass_throughs[i].regex_qs);
 
-      syslog(LOG_DEBUG, "Host %s", httpreq->host);
+      chilli_log(LOG_DEBUG, "Host %s", httpreq->host);
 #endif
 
       if (_options.regex_pass_throughs[i].regex_host[0]) {
@@ -617,7 +617,7 @@
 #endif
 
   if (matches) {
-    syslog(LOG_DEBUG, "Matched for Host %s", httpreq->host);
+    chilli_log(LOG_DEBUG, "Matched for Host %s", httpreq->host);
 
     req->proxy = 1;
 
@@ -665,7 +665,7 @@
       }
 
       if (req->wbuf->slen != newhdr->slen) {
-	syslog(LOG_DEBUG, "Changed HTTP Headers");
+	chilli_log(LOG_DEBUG, "Changed HTTP Headers");
       }
 
       bassign(req->wbuf, newhdr);
@@ -676,12 +676,12 @@
 
     if ((p = strchr(httpreq->host, ':'))) {
       *p++ = 0;
-      port = atoi(p);
+      port = strtol(p, NULL, 0);
     }
 
     if (conn_setup(&req->conn, httpreq->host, port,
 		   req->wbuf, req->dbuf)) {
-      syslog(LOG_ERR, "%s: conn_setup()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: conn_setup()", strerror(errno));
       return -1;
     }
 
@@ -708,13 +708,13 @@
 				(struct sockaddr *)&address,
 				&addrlen)) < 0) {
     if (errno != ECONNABORTED)
-      syslog(LOG_ERR, "%s: accept()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: accept()", strerror(errno));
 
     return 0;
   }
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "new redir socket %d from %s", new_socket,
+  chilli_log(LOG_DEBUG, "new redir socket %d from %s", new_socket,
          inet_ntoa(address.sin_addr));
 #endif
 
@@ -722,17 +722,17 @@
 
   if (getsockname(new_socket, (struct sockaddr *)&baddress,
 		  &addrlen) < 0) {
-    syslog(LOG_WARNING, "%s: getsockname() failed!", strerror(errno));
+    chilli_log(LOG_WARNING, "%s: getsockname() failed!", strerror(errno));
   }
 
   if (ndelay_on(new_socket) < 0) {
-    syslog(LOG_ERR, "%s: could not set ndelay", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not set ndelay", strerror(errno));
   }
 
   if (idx == 1 && _options.uamui) {
 
     if ((status = redir_fork(new_socket, new_socket)) < 0) {
-      syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
       close(new_socket);
       return 0;
     }
@@ -762,7 +762,7 @@
 
     req->parent = redir;
 
-    syslog(LOG_DEBUG, "redir_main() for %s", inet_ntoa(address.sin_addr));
+    chilli_log(LOG_DEBUG, "redir_main() for %s", inet_ntoa(address.sin_addr));
 
     req->last_active = mainclock_tick();
     memcpy(&req->conn.peer, &address, sizeof (struct sockaddr_in));
@@ -777,18 +777,18 @@
     switch (redir_main(redir, new_socket, new_socket,
 		       &address, &baddress, idx, req)) {
       case 1:
-        syslog(LOG_DEBUG, "redir queued %s socket_fd=%d conn.fd=%d",
+        chilli_log(LOG_DEBUG, "redir queued %s socket_fd=%d conn.fd=%d",
                inet_ntoa(address.sin_addr),
                req->socket_fd, req->conn.sock);
         req->state |= REDIR_SOCKET_FD;
         net_select_addfd(&sctx, req->socket_fd, SELECT_READ);
         return 1;
       case 0:
-        syslog(LOG_DEBUG, "redir completed %s", inet_ntoa(address.sin_addr));
+        chilli_log(LOG_DEBUG, "redir completed %s", inet_ntoa(address.sin_addr));
         redir_conn_finish(&req->conn, req);
         return 0;
       default:
-        syslog(LOG_DEBUG, "redir completed %s", inet_ntoa(address.sin_addr));
+        chilli_log(LOG_DEBUG, "redir completed %s", inet_ntoa(address.sin_addr));
         redir_conn_finish(&req->conn, req);
         return -1;
     }
@@ -827,7 +827,7 @@
   if (ioctl(fd, SIOCGIFHWADDR, (caddr_t)&ifr) == 0) {
     memcpy(hwaddr, ifr.ifr_hwaddr.sa_data, PKT_ETH_ALEN);
   } else {
-    syslog(LOG_ERR, "%s: could not get MAC address", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not get MAC address", strerror(errno));
     return -1;
   }
 #endif
@@ -842,12 +842,12 @@
 		0
 #endif
 		)) {
-    syslog(LOG_ERR, "Failed to create redir");
+    chilli_log(LOG_ERR, "Failed to create redir");
     return -1;
   }
 
   if (redir_listen(redir)) {
-    syslog(LOG_ERR, "Failed to create redir listen");
+    chilli_log(LOG_ERR, "Failed to create redir listen");
     return -1;
   }
 
@@ -857,7 +857,7 @@
   redir->cb_handle_url = redir_handle_url;
 
   if (net_select_init(&sctx))
-    syslog(LOG_ERR, "%s: select init", strerror(errno));
+    chilli_log(LOG_ERR, "%s: select init", strerror(errno));
 
   selfpipe = selfpipe_init();
 
@@ -867,12 +867,12 @@
   net_select_addfd(&sctx, redir->fd[1], SELECT_READ);
 
   if (_options.gid && setgid(_options.gid)) {
-    syslog(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
+    chilli_log(LOG_ERR, "%d setgid(%d) failed while running with gid = %d\n",
            errno, _options.gid, getgid());
   }
 
   if (_options.uid && setuid(_options.uid)) {
-    syslog(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
+    chilli_log(LOG_ERR, "%d setuid(%d) failed while running with uid = %d\n",
            errno, _options.uid, getuid());
   }
 
@@ -903,7 +903,7 @@
 	int timeout = 60;
 
 	if (now - requests[idx].last_active > timeout) {
-	  syslog(LOG_DEBUG, "timeout connection %d", idx);
+	  chilli_log(LOG_DEBUG, "timeout connection %d", idx);
 	  redir_conn_finish(&requests[idx].conn, &requests[idx]);
 	} else {
 	  int evt = SELECT_READ;
@@ -948,7 +948,7 @@
 			    " (timeout)");
 	    }
 
-	    syslog(LOG_DEBUG, "%s", line);
+	    chilli_log(LOG_DEBUG, "%s", line);
 	  }
 	}
 #endif
@@ -956,7 +956,7 @@
     }
 
     if (active != active_last) {
-      syslog(LOG_DEBUG, "active connections: %d", active);
+      chilli_log(LOG_DEBUG, "active connections: %d", active);
       active_last = active;
     }
 
@@ -965,9 +965,9 @@
 #if defined(USING_POLL) && defined(HAVE_SYS_EPOLL_H) && (_debug_ > 1)
     if (_options.debug && status > 0) {
       int i;
-      syslog(LOG_DEBUG, "epoll %d", status);
+      chilli_log(LOG_DEBUG, "epoll %d", status);
       for (i=0; i < status; i++) {
-	syslog(LOG_DEBUG, "epoll fd %d %d",
+	chilli_log(LOG_DEBUG, "epoll fd %d %d",
                sctx.events[i].data.fd,
                sctx.events[i].events);
       }
@@ -976,7 +976,7 @@
 
     switch (status) {
       case -1:
-        syslog(LOG_ERR, "%s: select() returned -1!", strerror(errno));
+        chilli_log(LOG_ERR, "%s: select() returned -1!", strerror(errno));
         break;
 
       default:
@@ -989,12 +989,12 @@
           if (redir->fd[0])
             if (net_select_read_fd(&sctx, redir->fd[0])==1 &&
                 redir_accept2(redir, 0) < 0)
-              syslog(LOG_ERR, "redir_accept() failed!");
+              chilli_log(LOG_ERR, "redir_accept() failed!");
 
           if (redir->fd[1])
             if (net_select_read_fd(&sctx, redir->fd[1])==1 &&
                 redir_accept2(redir, 1) < 0)
-              syslog(LOG_ERR, "redir_accept() failed!");
+              chilli_log(LOG_ERR, "redir_accept() failed!");
 
           for (idx=0; idx < max_requests; idx++) {
 
@@ -1012,7 +1012,7 @@
 #ifdef HAVE_SSL
               if (requests[idx].sslcon) {
                 if (openssl_check_accept(requests[idx].sslcon, 0) < 0) {
-                  syslog(LOG_DEBUG, "ssl error %d", errno);
+                  chilli_log(LOG_DEBUG, "ssl error %d", errno);
                   redir_conn_finish(&requests[idx].conn, &requests[idx]);
                   continue;
                 }
@@ -1021,14 +1021,14 @@
 
               switch (net_select_write_fd(&sctx, fd)) {
                 case 1:
-                  syslog(LOG_DEBUG, "client writeable");
+                  chilli_log(LOG_DEBUG, "client writeable");
                   redir_cli_rewrite(&requests[idx], &requests[idx].conn);
                   break;
               }
 
               switch (net_select_read_fd(&sctx, fd)) {
                 case -1:
-                  syslog(LOG_DEBUG, "EXCEPTION");
+                  chilli_log(LOG_DEBUG, "EXCEPTION");
                   redir_conn_finish(&requests[idx].conn,
                                     &requests[idx]);
                   break;
@@ -1042,7 +1042,7 @@
 #ifdef HAVE_SSL
                       if (requests[idx].sslcon) {
                         /*
-                          syslog(LOG_DEBUG, "proxy_read_ssl");
+                          chilli_log(LOG_DEBUG, "proxy_read_ssl");
                         */
                         r = openssl_read(requests[idx].sslcon,
                                          b, sizeof(b)-1, 0);
@@ -1051,12 +1051,12 @@
                         r = safe_read(fd, b, sizeof(b)-1);
 
                       /*
-                        syslog(LOG_DEBUG, "proxy_read: %d %d", fd, r);
+                        chilli_log(LOG_DEBUG, "proxy_read: %d %d", fd, r);
                       */
 
                       if (r <= 0) {
 
-                        syslog(LOG_DEBUG, "recv %d %d %d", r,
+                        chilli_log(LOG_DEBUG, "recv %d %d %d", r,
                                requests[idx].conn.read_buf->slen -
                                requests[idx].conn.read_pos,
                                errno);
@@ -1065,7 +1065,7 @@
                               (errno == EWOULDBLOCK || errno == EAGAIN))) {
                           if (redir_cli_rewrite(&requests[idx],
                                                 &requests[idx].conn) == 0) {
-                            syslog(LOG_DEBUG, "done reading and writing");
+                            chilli_log(LOG_DEBUG, "done reading and writing");
                             redir_conn_finish(&requests[idx].conn,
                                               &requests[idx]);
                           }
@@ -1078,10 +1078,10 @@
                         w = net_write(requests[idx].conn.sock, b, r);
 
                         /*
-                          syslog(LOG_DEBUG, "proxy_write: %d", w);
+                          chilli_log(LOG_DEBUG, "proxy_write: %d", w);
                         */
                         if (r != w) {
-                          syslog(LOG_ERR, "%s: problem writing what we read from client", strerror(errno));
+                          chilli_log(LOG_ERR, "%s: problem writing what we read from client", strerror(errno));
                           redir_conn_finish(&requests[idx].conn,
                                             &requests[idx]);
                         }
@@ -1097,19 +1097,19 @@
                                          requests[idx].uiidx,
                                          &requests[idx])) {
                         case 1:
-                          /*syslog(LOG_DEBUG, "redir cont'ed");*/
+                          /*chilli_log(LOG_DEBUG, "redir cont'ed");*/
 #ifdef HAVE_SSL
                           if (requests[idx].sslcon &&
                               openssl_pending(requests[idx].sslcon) > 0) {
-                            syslog(LOG_DEBUG, "ssl_pending, trying again");
+                            chilli_log(LOG_DEBUG, "ssl_pending, trying again");
                             goto go_again;
                           }
 #endif
                           break;
                         case -1:
-                          syslog(LOG_DEBUG, "redir error");
+                          chilli_log(LOG_DEBUG, "redir error");
                         default:
-                          syslog(LOG_DEBUG, "redir completed");
+                          chilli_log(LOG_DEBUG, "redir completed");
                           redir_conn_finish(&requests[idx].conn,
                                             &requests[idx]);
                           break;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-response.c src/src/main-response.c
--- upstream/src/main-response.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-response.c	2025-11-06 13:20:13.000000000 +0000
@@ -97,7 +97,7 @@
     return usage(argv[0]);
 
   if (argc == 5)
-    chap_ident = atoi(argv[idx+4]);
+    chap_ident = strtol(argv[idx+4], NULL, 0);
 
   /* challenge - argv 1 */
   if (strlen(argv[idx+1]) >= sizeof(buffer))
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-rtmon.c src/src/main-rtmon.c
--- upstream/src/main-rtmon.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-rtmon.c	2025-11-06 13:20:13.000000000 +0000
@@ -70,14 +70,14 @@
     } else if (strcmp(argv[i], "-file")==0) {
       chilli_conf = argv[i+1];
     } else if (strcmp(argv[i], "-pid")==0) {
-      chilli_pid = atoi(argv[i+1]);
+      chilli_pid = strtol(argv[i+1], NULL, 0);
     }
   }
 
   _options.foreground = debug;
   _options.debug = debug;
 
-  syslog(LOG_DEBUG, "running");
+  chilli_log(LOG_DEBUG, "running");
 
   chilli_signals(&keep_going, &reload_config);
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main-script.c src/src/main-script.c
--- upstream/src/main-script.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main-script.c	2025-11-06 13:20:13.000000000 +0000
@@ -30,73 +30,104 @@
 #define CHILLI_GROUP "chilli"
 #endif
 
-static void usage(char *prog) {
-  fprintf(stderr,"%s chilli-bin script-path [script-arguments]\n", prog);
-  exit(-1);
+static void usage(char *prog)
+{
+	fprintf(stderr, "%s chilli-bin script-path [script-arguments]\n", prog);
+	exit(-1);
 }
 
-int main(int argc, char **argv) {
-  struct stat statbuf;
-  uid_t uid = getuid();
-  uid_t gid = getgid();
-  uid_t euid = geteuid();
-  uid_t egid = getegid();
-
-  struct passwd * pwd = getpwuid(uid);
-  struct group * grp = getgrgid(gid);
-
-  if (argc < 3)
-    usage(argv[0]);
-
-  options_init();
-
-  openlog(PACKAGE, LOG_PID, LOG_DAEMON);
-
-  memset(&statbuf, 0, sizeof(statbuf));
-
-  if (!options_binload(argv[1])) {
-    syslog(LOG_ERR, "invalid binary config file %s", argv[1]);
-    usage(argv[0]);
-  }
-
-  if (uid != 0) {
-    if (strcmp(pwd->pw_name, CHILLI_USER)) {
-      syslog(LOG_ERR, "has to run as user %s or root", CHILLI_USER);
-      usage(argv[0]);
-    }
-
-    if (strcmp(grp->gr_name, CHILLI_GROUP)) {
-      syslog(LOG_ERR, "has to run as group %s or root", CHILLI_GROUP);
-      usage(argv[0]);
-    }
-  }
-
-  syslog(LOG_DEBUG, "USER %s(%d/%d), GROUP %s(%d/%d) CHILLI[UID %d, GID %d]",
-         pwd->pw_name, uid, euid, grp->gr_name, gid, egid,
-         _options.uid, _options.gid);
-
-  if (stat(argv[2], &statbuf)) {
-    syslog(LOG_ERR, "%s: %s does not exist", strerror(errno), argv[2]);
-    usage(argv[0]);
-  }
-
-  if (_options.uid &&                        /* chilli is running as non-root */
-      _options.uid == euid &&                /* current euid same as chilli uid */
-      _options.gid == egid &&                /* current egid same as chilli gid */
-      statbuf.st_uid == 0 &&                 /* script owned by root */
-      statbuf.st_gid == _options.gid &&      /* script group same as chilli gid */
-      (statbuf.st_mode & 0400) == 0400) {
-
-    if (setuid(0))
-      syslog(LOG_ERR, "%s: setuid %s", strerror(errno), argv[0]);
-  }
-
-  syslog(LOG_INFO, "Running %s (%d/%d)", argv[2], getuid(), geteuid());
-
-  if (execv(argv[2], &argv[2])) {
-    syslog(LOG_ERR, "%s: exec %s", strerror(errno), argv[2]);
-    usage(argv[0]);
-  }
+int main(int argc, char **argv)
+{
+	struct stat statbuf;
+	uid_t uid  = getuid();
+	uid_t gid  = getgid();
+	uid_t euid = geteuid();
+	uid_t egid = getegid();
+
+	struct passwd *pwd = getpwuid(uid);
+	struct group *grp  = getgrgid(gid);
+
+	struct passwd *chilli_pwd = getpwnam(CHILLI_USER);
+	struct group *chilli_grp  = getgrnam(CHILLI_GROUP);
+
+	if (isatty(STDIN_FILENO) || argc < 3 || !chilli_pwd || !chilli_grp)
+		usage(argv[0]);
+
+	uid_t chilli_uid = chilli_pwd->pw_uid;
+	gid_t chilli_gid = chilli_grp->gr_gid;
+
+	options_init();
+
+	openlog(PACKAGE, LOG_PID, LOG_DAEMON);
+
+	memset(&statbuf, 0, sizeof(statbuf));
+
+	if (!options_binload(argv[1])) {
+		chilli_log(LOG_ERR, "invalid binary config file %s", argv[1]);
+		usage(argv[0]);
+	}
+
+	if (strstr(argv[2], "..") || argv[2][0] != '/') {
+		if (_options.debug)
+			chilli_log(LOG_ERR, "script path %s is not absolute", argv[2]);
+		usage(argv[0]);
+	}
+
+	char resolved_path[PATH_MAX];
+	if (realpath(argv[2], resolved_path) == NULL) {
+		if (_options.debug)
+			chilli_log(LOG_ERR, "%s: %s", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
+
+	if (strncmp(resolved_path, "/etc/chilli/", 12) != 0 &&
+	    strncmp(resolved_path, "/tmp/run/chilli/", 16) != 0) {
+		if (_options.debug)
+			chilli_log(LOG_ERR, "script path %s is not valid", resolved_path);
+		usage(argv[0]);
+	}
+
+	if (uid != 0) {
+		if (strcmp(pwd->pw_name, CHILLI_USER)) {
+			if (_options.debug)
+				chilli_log(LOG_ERR, "has to run as user %s or root", CHILLI_USER);
+			usage(argv[0]);
+		}
+
+		if (strcmp(grp->gr_name, CHILLI_GROUP)) {
+			if (_options.debug)
+				chilli_log(LOG_ERR, "has to run as group %s or root", CHILLI_GROUP);
+			usage(argv[0]);
+		}
+	}
+
+	if (_options.debug) {
+		chilli_log(LOG_DEBUG, "USER %s(%d/%d), GROUP %s(%d/%d) CHILLI[UID %d, GID %d]", pwd->pw_name, uid,
+		       euid, grp->gr_name, gid, egid, chilli_uid, chilli_gid);
+	}
+
+	if (stat(argv[2], &statbuf)) {
+		if (_options.debug)
+			chilli_log(LOG_ERR, "%s: %s does not exist", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
+
+	if (chilli_uid && /* chilli user exists */
+	    statbuf.st_uid == 0 && /* script owned by root */
+	    statbuf.st_gid == chilli_gid && /* script group same as chilli gid */
+	    (statbuf.st_mode & 0400) == 0400) {
+		if (setuid(0))
+			chilli_log(LOG_ERR, "%s: setuid %s", strerror(errno), argv[0]);
+	} else {
+		usage(argv[0]);
+	}
+
+	chilli_log(LOG_INFO, "Running %s (%d/%d)", argv[2], getuid(), geteuid());
+
+	if (execv(argv[2], &argv[2])) {
+		chilli_log(LOG_ERR, "%s: exec %s", strerror(errno), argv[2]);
+		usage(argv[0]);
+	}
 
-  return 0;
+	return 0;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/main.c src/src/main.c
--- upstream/src/main.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/main.c	2025-11-06 13:20:13.000000000 +0000
@@ -83,14 +83,14 @@
 
 #if defined(__linux__)
   if ((ev = getenv("CHILLI_PRIORITY")) != NULL) {
-    if (setpriority(PRIO_PROCESS, getpid(), atoi(ev))) {
+    if (setpriority(PRIO_PROCESS, getpid(), strtol(ev, NULL, 0))) {
       perror("setpriority");
     }
   }
 
 #ifdef __NR_ioprio_set
   if ((ev = getenv("CHILLI_IOPRIO_RT")) != NULL) {
-    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), atoi(ev) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
+    if (syscall(__NR_ioprio_set, IOPRIO_WHO_PROCESS, getpid(), strtol(ev, NULL, 0) | IOPRIO_CLASS_RT << IOPRIO_CLASS_SHIFT) == -1) {
       perror("ioprio_set");
     }
   }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/md5.h src/src/md5.h
--- upstream/src/md5.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/md5.h	2025-11-06 13:20:13.000000000 +0000
@@ -22,11 +22,22 @@
 #include "system.h"
 
 #if HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#include <openssl/evp.h>
+#else
 #include <openssl/md5.h>
+#endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#define MD5_CTX EVP_MD_CTX*
+#define MD5Init(context) do { *(context) = EVP_MD_CTX_new(); EVP_DigestInit_ex(*(context), EVP_md5(), NULL); } while(0)
+#define MD5Update(context, data, length) EVP_DigestUpdate(*(context), data, length)
+#define MD5Final(output, context) do { EVP_DigestFinal(*(context), output, NULL); EVP_MD_CTX_free(*(context)); } while(0)
+#else
 #define MD5Init MD5_Init
 #define MD5Update MD5_Update
 #define MD5Final MD5_Final
+#endif
 
 #elif HAVE_CYASSL
 #include <cyassl/openssl/md5.h>
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ms_chap.c src/src/ms_chap.c
--- upstream/src/ms_chap.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ms_chap.c	2025-11-06 13:20:13.000000000 +0000
@@ -41,6 +41,10 @@
 #include <openssl/md4.h>
 #include <openssl/md5.h>
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#include <openssl/evp.h>
+#endif
+
 /*
  * Documentation & specifications:
  *
@@ -69,6 +73,29 @@
   u_char UseNT;	/* If 1, ignore the LANMan response field */
 };
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+static void /* IN 8 octets IN 7 octets OUT 8 octets */
+DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
+{
+  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
+  const EVP_CIPHER *cipher_type = EVP_des_ecb();
+  int len;
+
+  if (!ctx) {
+    return;
+  }
+
+  if (!EVP_EncryptInit_ex(ctx, cipher_type, NULL, key, NULL) ||
+      !EVP_EncryptUpdate(ctx, cipher, &len, clear, 8) ||
+      !EVP_EncryptFinal_ex(ctx, cipher + len, &len))
+  {
+    EVP_CIPHER_CTX_free(ctx);
+    return;
+  }
+
+  EVP_CIPHER_CTX_free(ctx);
+}
+#else
 static u_char
 Get7Bits(u_char *input, int startBit)
 {
@@ -96,22 +123,30 @@
   des_key[6] = Get7Bits(key, 42);
   des_key[7] = Get7Bits(key, 49);
 
-  des_set_odd_parity((des_cblock *)des_key);
+  DES_set_odd_parity((DES_cblock *)des_key);
 }
 
 static void /* IN 8 octets IN 7 octest OUT 8 octets */
 DesEncrypt(u_char *clear, u_char *key, u_char *cipher)
 {
-  des_cblock		des_key;
-  des_key_schedule	key_schedule;
+	DES_cblock des_key;
+	DES_key_schedule key_schedule;
 
-  MakeKey(key, des_key);
-  des_set_key(&des_key, key_schedule);
-  des_ecb_encrypt((des_cblock *)clear, (des_cblock *)cipher, key_schedule, 1);
+	MakeKey(key, des_key);
+	DES_set_key(&des_key, &key_schedule);
+	DES_ecb_encrypt((DES_cblock *)clear, (DES_cblock *)cipher,
+			&key_schedule, 1);
 }
+#endif
 
 #define LENGTH 20
-static u_char *SHA1_End(SHA_CTX *ctx, u_char *buf)
+static u_char *SHA1_End(
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx,
+#else
+  SHA_CTX *ctx,
+#endif
+  u_char *buf)
 {
   int i;
   unsigned char digest[LENGTH];
@@ -123,7 +158,11 @@
   if (!buf)
     return 0;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_DigestFinal(ctx, digest, NULL);
+#else
   SHA1_Final(digest, ctx);
+#endif
 
   for (i = 0; i < LENGTH; i++) {
     buf[i+i] = hex[digest[i] >> 4];
@@ -167,15 +206,22 @@
 {
   if (!Password) return;
   else {
-    MD4_CTX MD4context;
-
     u_char *uniPassword = to_unicode(Password);
 
     len *= 2;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+    EVP_DigestInit(ctx, EVP_md4());
+    EVP_DigestUpdate(ctx, uniPassword, len);
+    EVP_DigestFinal(ctx, hash, NULL);
+    EVP_MD_CTX_free(ctx);
+#else
+    MD4_CTX MD4context;
     MD4_Init(&MD4context);
     MD4_Update(&MD4context, uniPassword, len);
     MD4_Final(hash, &MD4context);
+#endif
 
     free(uniPassword);
   }
@@ -184,18 +230,24 @@
 void
 HashNtPasswordHash(u_char *hash, u_char *hashhash)
 {
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_md4());
+  EVP_DigestUpdate(ctx, hash, 16);
+  EVP_DigestFinal(ctx, hashhash, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
   MD4_CTX MD4context;
-
   MD4_Init(&MD4context);
   MD4_Update(&MD4context, hash, 16);
   MD4_Final(hashhash, &MD4context);
+#endif
 }
 
 void
 ChallengeHash(u_char *PeerChallenge, u_char *AuthenticatorChallenge,
               u_char *UserName, int UserNameLen, u_char *Challenge)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
   u_char *Name;
 
@@ -205,6 +257,16 @@
   else
     Name++;
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PeerChallenge, 16);
+  EVP_DigestUpdate(ctx, AuthenticatorChallenge, 16);
+  EVP_DigestUpdate(ctx, Name, strlen((char *)Name));
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
 
   SHA1_Update(&Context, PeerChallenge, 16);
@@ -212,6 +274,7 @@
   SHA1_Update(&Context, Name, strlen((char *)Name));
 
   SHA1_Final(Digest, &Context);
+#endif
   memcpy(Challenge, Digest, 8);
 }
 
@@ -236,7 +299,6 @@
                               u_char *AuthenticatorChallenge, u_char *UserName,
                               int UserNameLen, u_char *AuthenticatorResponse)
 {
-  SHA_CTX Context;
   u_char PasswordHash[16];
   u_char PasswordHashHash[16];
   u_char Challenge[8];
@@ -268,18 +330,37 @@
    */
   HashNtPasswordHash(PasswordHash, PasswordHashHash);
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PasswordHashHash, 16);
+  EVP_DigestUpdate(ctx, NTResponse, 24);
+  EVP_DigestUpdate(ctx, Magic1, 39);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, PasswordHashHash, 16);
   SHA1_Update(&Context, NTResponse, 24);
   SHA1_Update(&Context, Magic1, 39);
   SHA1_Final(Digest, &Context);
+#endif
 
   ChallengeHash(PeerChallenge, AuthenticatorChallenge, UserName, UserNameLen, Challenge);
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, Digest, 20);
+  EVP_DigestUpdate(ctx, Challenge, 8);
+  EVP_DigestUpdate(ctx, Magic2, 41);
+#else
   SHA1_Init(&Context);
   SHA1_Update(&Context, Digest, 20);
   SHA1_Update(&Context, Challenge, 8);
   SHA1_Update(&Context, Magic2, 41);
+#endif
 
   /*
    * Encode the value of 'Digest' as "S=" followed by
@@ -290,7 +371,12 @@
    */
   AuthenticatorResponse[0] = 'S';
   AuthenticatorResponse[1] = '=';
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  SHA1_End(ctx, AuthenticatorResponse + 2);
+  EVP_MD_CTX_free(ctx);
+#else
   SHA1_End(&Context, AuthenticatorResponse + 2);
+#endif
 
   for (i=2; i<42; i++)
     AuthenticatorResponse[i] = toupper(AuthenticatorResponse[i]);
@@ -299,18 +385,28 @@
 void
 GetMasterKey(char *PasswordHashHash, char *NTResponse, char *MasterKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
   static u_char Magic1[27] =
       {0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
        0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
        0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79};
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, PasswordHashHash, 16);
+  EVP_DigestUpdate(ctx, NTResponse, 24);
+  EVP_DigestUpdate(ctx, Magic1, 27);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, PasswordHashHash, 16);
   SHA1_Update(&Context, NTResponse, 24);
   SHA1_Update(&Context, Magic1, 27);
   SHA1_Final(Digest, &Context);
+#endif
   memcpy(MasterKey, Digest, 16);
 }
 
@@ -319,7 +415,6 @@
                      int IsSend, int IsServer)
 {
   u_char Digest[SHA_DIGEST_LENGTH];
-  SHA_CTX Context;
   u_char *s;
 
   static u_char Magic2[84] =
@@ -358,12 +453,24 @@
     }
   }
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, MasterKey, 16);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, s, 84);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, MasterKey, 16);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, s, 84);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(SessionKey, Digest, SessionKeyLength);
 }
@@ -372,15 +479,26 @@
 GetNewKeyFromSHA(char *StartKey, char *SessionKey, long SessionKeyLength,
                  char *InterimKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, StartKey, SessionKeyLength);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, SessionKey, SessionKeyLength);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, StartKey, SessionKeyLength);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, SessionKey, SessionKeyLength);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(InterimKey, Digest, SessionKeyLength);
 }
@@ -390,15 +508,26 @@
 Get_Key(char *InitialSessionKey, char *CurrentSessionKey,
         int LengthOfDesiredKey)
 {
-  SHA_CTX Context;
   u_char Digest[SHA_DIGEST_LENGTH];
 
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+  EVP_DigestInit(ctx, EVP_sha1());
+  EVP_DigestUpdate(ctx, InitialSessionKey, LengthOfDesiredKey);
+  EVP_DigestUpdate(ctx, SHA1_Pad1, 40);
+  EVP_DigestUpdate(ctx, CurrentSessionKey, LengthOfDesiredKey);
+  EVP_DigestUpdate(ctx, SHA1_Pad2, 40);
+  EVP_DigestFinal(ctx, Digest, NULL);
+  EVP_MD_CTX_free(ctx);
+#else
+  SHA_CTX Context;
   SHA1_Init(&Context);
   SHA1_Update(&Context, InitialSessionKey, LengthOfDesiredKey);
   SHA1_Update(&Context, SHA1_Pad1, 40);
   SHA1_Update(&Context, CurrentSessionKey, LengthOfDesiredKey);
   SHA1_Update(&Context, SHA1_Pad2, 40);
   SHA1_Final(Digest, &Context);
+#endif
 
   memcpy(CurrentSessionKey, Digest, LengthOfDesiredKey);
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/mssl/httpsClient.c src/src/mssl/httpsClient.c
--- upstream/src/mssl/httpsClient.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/mssl/httpsClient.c	2025-11-06 13:20:13.000000000 +0000
@@ -156,7 +156,7 @@
 	  err_exit("Out of memory");
 	break;
       case 'p':
-	if(!(port=atoi(optarg)))
+	if(!(port=strtol(optarg, NULL, 0)))
 	  err_exit("Bogus port specified");
 	break;
       case 's':
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/mssl.c src/src/mssl.c
--- upstream/src/mssl.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/mssl.c	2025-11-06 13:20:13.000000000 +0000
@@ -99,7 +99,7 @@
   int  rc;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "MatrixSSL_accept()");
+  chilli_log(LOG_DEBUG, "MatrixSSL_accept()");
 #endif
 
 readMore:
@@ -126,26 +126,26 @@
   int  rc;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "MatrixSSL_accept2()");
+  chilli_log(LOG_DEBUG, "MatrixSSL_accept2()");
 #endif
 
   rc = _ssl_read(ssl, buf, sizeof(buf));
 
   if (rc == 0) {
     if (ssl->status == SSL_SOCKET_EOF || ssl->status == SSL_SOCKET_CLOSE_NOTIFY) {
-      syslog(LOG_DEBUG, "EOF or Closed");
+      chilli_log(LOG_DEBUG, "EOF or Closed");
       return -1;
     }
     return 0;
   } else if (rc > 0) {
-    syslog(LOG_DEBUG, "Accept2() returning %d", rc);
+    chilli_log(LOG_DEBUG, "Accept2() returning %d", rc);
     return rc;
   } else {
 
     if (ssl->status == EAGAIN || ssl->status == EWOULDBLOCK)
       return 0;
 
-    syslog(LOG_WARNING, "%d Error rc %d", ssl->status, rc);
+    chilli_log(LOG_WARNING, "%d Error rc %d", ssl->status, rc);
     return -1;
   }
 
@@ -155,7 +155,7 @@
 int SSL_is_init_finished(SSL *ssl) {
   int v = matrixSslHandshakeIsComplete(ssl->ssl) != 0;
 #if(_debug_)
-  syslog(LOG_DEBUG, "MatrixSSL is_finished %d", v);
+  chilli_log(LOG_DEBUG, "MatrixSSL is_finished %d", v);
 #endif
   return v;
 }
@@ -168,7 +168,7 @@
   int rc;
 readMore:
   rc = _ssl_read(ssl, buf, len);
-  syslog(LOG_DEBUG, "SSL_read(%d) = %d", len, rc);
+  chilli_log(LOG_DEBUG, "SSL_read(%d) = %d", len, rc);
   if (rc <= 0) {
     if (rc < 0 || ssl->status == SSL_SOCKET_EOF ||
 	ssl->status == SSL_SOCKET_CLOSE_NOTIFY) {
@@ -206,12 +206,12 @@
     available = 1;
     ssl->pending=0;
   }
-  syslog(LOG_DEBUG, "SSL_pending() = %d", available);
+  chilli_log(LOG_DEBUG, "SSL_pending() = %d", available);
   return (int) available;
 }
 
 void SSL_free(SSL * ssl) {
-  syslog(LOG_DEBUG, "Matrix SSL_Free()");
+  chilli_log(LOG_DEBUG, "Matrix SSL_Free()");
   if (ssl->ssl)
     matrixSslDeleteSession(ssl->ssl);
   ssl->ssl = 0;
@@ -353,7 +353,7 @@
   char buf[32];
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "MatrixSSL %s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "MatrixSSL %s", __FUNCTION__);
 #endif
 
   if (fd != -1) {
@@ -371,14 +371,14 @@
   unsigned char error, alertLevel, alertDescription, performRead;
 
 #if(_debug_)
-  syslog(LOG_DEBUG, "MatrixSSL %s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "MatrixSSL %s", __FUNCTION__);
 #endif
 
   ssl->status = 0;
 
   if (ssl->ssl == NULL || len <= 0) {
 #if(_debug_)
-    syslog(LOG_DEBUG, "MatrixSSL %s null", __FUNCTION__);
+    chilli_log(LOG_DEBUG, "MatrixSSL %s null", __FUNCTION__);
 #endif
     return -1;
   }
@@ -424,7 +424,7 @@
     if (bytes == -1) {
       ssl->status = errno;
 
-      syslog(LOG_WARNING, "%s: recv()", strerror(errno));
+      chilli_log(LOG_WARNING, "%s: recv()", strerror(errno));
 
       if (errno == EWOULDBLOCK || errno == EAGAIN)
 	return 0;
@@ -440,7 +440,7 @@
   /*
     Define a temporary sslBuf
   */
-  syslog(LOG_DEBUG, "SSL buffer sized %d", len);
+  chilli_log(LOG_DEBUG, "SSL buffer sized %d", len);
   ssl->inbuf.start = ssl->inbuf.end = ssl->inbuf.buf = (unsigned char *)malloc(len);
   ssl->inbuf.size = len;
   /*
@@ -458,13 +458,13 @@
       Successfully decoded a record that did not return data or require a response.
     */
     case SSL_SUCCESS:
-      syslog(LOG_DEBUG, "SSL_SUCCESS");
+      chilli_log(LOG_DEBUG, "SSL_SUCCESS");
       return 0;
       /*
         Successfully decoded an application data record, and placed in tmp buf
       */
     case SSL_PROCESS_DATA:
-      syslog(LOG_DEBUG, "SSL_PROCESS_DATA");
+      chilli_log(LOG_DEBUG, "SSL_PROCESS_DATA");
       /*
         Copy as much as we can from the temp buffer into the caller's buffer
         and leave the remainder in conn->inbuf until the next call to read
@@ -483,7 +483,7 @@
         to the outgoing data buffer and flush it out.
       */
     case SSL_SEND_RESPONSE:
-      syslog(LOG_DEBUG, "SSL_SEND_RESPONSE");
+      chilli_log(LOG_DEBUG, "SSL_SEND_RESPONSE");
       bytes = send(ssl->fd, (char *)ssl->inbuf.start,
                    (int)(ssl->inbuf.end - ssl->inbuf.start), MSG_NOSIGNAL);
       if (bytes == -1) {
@@ -523,8 +523,8 @@
         Since we're closing on error, we don't worry too much about a clean flush.
       */
     case SSL_ERROR:
-      syslog(LOG_DEBUG, "SSL_ERROR");
-      syslog(LOG_DEBUG, "ssl error");
+      chilli_log(LOG_DEBUG, "SSL_ERROR");
+      chilli_log(LOG_DEBUG, "ssl error");
       if (ssl->inbuf.start < ssl->inbuf.end) {
         _ssl_setSocketNonblock(ssl->fd);
         bytes = send(ssl->fd, (char *)ssl->inbuf.start,
@@ -536,8 +536,8 @@
         matrixSslDecode are filled in with the specifics.
       */
     case SSL_ALERT:
-      syslog(LOG_DEBUG, "SSL_ALERT");
-      syslog(LOG_DEBUG, "ssl alert");
+      chilli_log(LOG_DEBUG, "SSL_ALERT");
+      chilli_log(LOG_DEBUG, "ssl alert");
       if (alertDescription == SSL_ALERT_CLOSE_NOTIFY) {
         ssl->status = SSL_SOCKET_CLOSE_NOTIFY;
         goto readZero;
@@ -549,7 +549,7 @@
         here so that we CAN read more data when called the next time.
       */
     case SSL_PARTIAL:
-      syslog(LOG_DEBUG, "SSL_PARTIAL");
+      chilli_log(LOG_DEBUG, "SSL_PARTIAL");
       if (ssl->insock.start == ssl->insock.buf && ssl->insock.end ==
           (ssl->insock.buf + ssl->insock.size)) {
         if (ssl->insock.size > SSL_MAX_BUF_SIZE) {
@@ -573,7 +573,7 @@
         data.  Increase the size of the buffer and call decode again
       */
     case SSL_FULL:
-      syslog(LOG_DEBUG, "SSL_FULL");
+      chilli_log(LOG_DEBUG, "SSL_FULL");
       ssl->inbuf.size *= 2;
       if (ssl->inbuf.buf != (unsigned char*)buf) {
         free(ssl->inbuf.buf);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/net.c src/src/net.c
--- upstream/src/net.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.c	2025-11-06 13:20:13.000000000 +0000
@@ -48,12 +48,12 @@
   strlcpy(ifr.ifr_name, dev, IFNAMSIZ);
 
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
   if (ioctl(fd, SIOCSIFFLAGS, &ifr)) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCSIFFLAGS) failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCSIFFLAGS) failed", strerror(errno));
     close(fd);
     return -1;
   }
@@ -71,12 +71,12 @@
   strlcpy(ifr.ifr_name, dev, IFNAMSIZ);
 
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
   if (ioctl(fd, SIOCGIFFLAGS, &ifr)) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCSIFFLAGS) failed on %s", strerror(errno), dev);
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCSIFFLAGS) failed on %s", strerror(errno), dev);
     close(fd);
     return -1;
   }
@@ -101,7 +101,7 @@
 
   /* Create a channel to the NET kernel. */
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -116,10 +116,10 @@
     ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr = address->s_addr;
     if (ioctl(fd, SIOCSIFADDR, (void *) &ifr) < 0) {
       if (errno != EEXIST) {
-	syslog(LOG_ERR, "%s: ioctl(SIOCSIFADDR) failed", strerror(errno));
+	chilli_log(LOG_ERR, "%s: ioctl(SIOCSIFADDR) failed", strerror(errno));
       }
       else {
-	syslog(LOG_WARNING, "%d ioctl(SIOCSIFADDR): Address already exists",
+	chilli_log(LOG_WARNING, "%d ioctl(SIOCSIFADDR): Address already exists",
                errno);
       }
       close(fd);
@@ -130,7 +130,7 @@
   if (dstaddr) { /* Set the destination address */
     ((struct sockaddr_in *) &ifr.ifr_dstaddr)->sin_addr.s_addr = dstaddr->s_addr;
     if (ioctl(fd, SIOCSIFDSTADDR, (caddr_t) &ifr) < 0) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCSIFDSTADDR) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCSIFDSTADDR) failed", strerror(errno));
       close(fd);
       return -1;
     }
@@ -139,7 +139,7 @@
   if (netmask) { /* Set the netmask */
     ((struct sockaddr_in *) &ifr.ifr_netmask)->sin_addr.s_addr =  netmask->s_addr;
     if (ioctl(fd, SIOCSIFNETMASK, (void *) &ifr) < 0) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCSIFNETMASK) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCSIFNETMASK) failed", strerror(errno));
       close(fd);
       return -1;
     }
@@ -165,10 +165,10 @@
 
   if (ioctl(fd, SIOCAIFADDR, (void *) &ifr) < 0) {
     if (errno != EEXIST) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCAIFADDR) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCAIFADDR) failed", strerror(errno));
     }
     else {
-      syslog(LOG_WARNING, "%d ioctl(SIOCAIFADDR): Address already exists",
+      chilli_log(LOG_WARNING, "%d ioctl(SIOCAIFADDR): Address already exists",
              errno);
     }
     close(fd);
@@ -221,7 +221,7 @@
     net_sflags(netif, netif->devflags | IFF_NOARP);
     memset(&noaddr, 0, sizeof(noaddr));
     if (_options.debug)
-      syslog(LOG_DEBUG, "removing ip address from %s", netif->devname);
+      chilli_log(LOG_DEBUG, "removing ip address from %s", netif->devname);
     dev_set_address(netif->devname, &noaddr, NULL, NULL);
   }
 
@@ -231,7 +231,7 @@
 static int net_setsockopt(int s, int l, int op, void *v, socklen_t vl) {
 
   if (setsockopt(s, l, op, v, vl) < 0) {
-    syslog(LOG_ERR, "%d setsockopt(s=%d, level=%d, optname=%d, optlen=%d) failed",
+    chilli_log(LOG_ERR, "%d setsockopt(s=%d, level=%d, optname=%d, optlen=%d) failed",
            errno, s, l, op, (int) vl);
     return -1;
   }
@@ -245,7 +245,7 @@
   socklen_t len;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "net_reopen(%s)", netif->devname);
+    chilli_log(LOG_DEBUG, "net_reopen(%s)", netif->devname);
 
   net_open(netif);
 
@@ -258,12 +258,12 @@
   len = sizeof(default_sndbuf);
   getsockopt(netif->fd, SOL_SOCKET, SO_SNDBUF, &default_sndbuf, &len);
   if (_options.debug)
-    syslog(LOG_DEBUG, "Net SNDBUF %d", default_sndbuf);
+    chilli_log(LOG_DEBUG, "Net SNDBUF %d", default_sndbuf);
 
   len = sizeof(default_sndbuf);
   getsockopt(netif->fd, SOL_SOCKET, SO_RCVBUF, &default_rcvbuf, &len);
   if (_options.debug)
-    syslog(LOG_DEBUG, "Net RCVBUF %d", default_rcvbuf);
+    chilli_log(LOG_DEBUG, "Net RCVBUF %d", default_rcvbuf);
 
   if (netif->sctx)
     net_select_rereg(netif->sctx, previous_fd, netif->fd);
@@ -285,7 +285,7 @@
 #if defined(USING_POLL) && defined(HAVE_SYS_EPOLL_H)
   sctx->efd = epoll_create(MAX_SELECT);
   if (sctx->efd <= 0) {
-    syslog(LOG_ERR, "%s: !! could not create epoll !!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: !! could not create epoll !!", strerror(errno));
     return -1;
   }
 #endif
@@ -377,14 +377,14 @@
 	event.data.fd = oldfd;
 	event.events = EPOLLIN | EPOLLOUT;
 	if (epoll_ctl(sctx->efd, EPOLL_CTL_DEL, oldfd, &event))
-	  syslog(LOG_ERR, "%s: epoll fd %d not found", strerror(errno), oldfd);
+	  chilli_log(LOG_ERR, "%s: epoll fd %d not found", strerror(errno), oldfd);
 
 	memset(&event, 0, sizeof(event));
 	if (sctx->desc[i].evts & SELECT_READ) event.events |= EPOLLIN;
 	if (sctx->desc[i].evts & SELECT_WRITE) event.events |= EPOLLOUT;
 	event.data.ptr = &sctx->desc[i];
 	if (epoll_ctl(sctx->efd, EPOLL_CTL_ADD, newfd, &event))
-	  syslog(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
+	  chilli_log(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
       }
 #endif
       return 0;
@@ -414,7 +414,7 @@
     if (evts & SELECT_WRITE) event.events |= EPOLLOUT;
     event.data.ptr = &sctx->desc[sctx->count];
     if (epoll_ctl(sctx->efd, EPOLL_CTL_ADD, fd, &event))
-      syslog(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
+      chilli_log(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
   }
 #endif
 #else
@@ -422,7 +422,7 @@
 #endif
   sctx->count++;
   if (_options.debug)
-    syslog(LOG_DEBUG, "net select count: %d", sctx->count);
+    chilli_log(LOG_DEBUG, "net select count: %d", sctx->count);
   return 0;
 }
 
@@ -459,10 +459,10 @@
   memset(&event, 0, sizeof(event));
   event.data.fd = fd;
   if (_options.debug)
-    syslog(LOG_DEBUG, "epoll rm %d", fd);
+    chilli_log(LOG_DEBUG, "epoll rm %d", fd);
 
   if (epoll_ctl(sctx->efd, EPOLL_CTL_DEL, fd, &event))
-    syslog(LOG_ERR, "%d Failed to remove fd %d (%d)",
+    chilli_log(LOG_ERR, "%d Failed to remove fd %d (%d)",
            errno, fd, sctx->efd);
 #endif
   return 0;
@@ -476,11 +476,11 @@
   if (evts & SELECT_READ) event.events |= EPOLLIN;
   if (evts & SELECT_WRITE) event.events |= EPOLLOUT;
   if (_options.debug)
-    syslog(LOG_DEBUG, "epoll add %d (%d)", fd, sctx->efd);
+    chilli_log(LOG_DEBUG, "epoll add %d (%d)", fd, sctx->efd);
   /*
    */
   if (epoll_ctl(sctx->efd, EPOLL_CTL_ADD, fd, &event))
-    syslog(LOG_ERR, "%d Failed to add fd %d (%d)",
+    chilli_log(LOG_ERR, "%d Failed to add fd %d (%d)",
            errno, fd, sctx->efd);
 #endif
   return 0;
@@ -493,9 +493,9 @@
   event.data.fd = fd;
   if (evts & SELECT_READ) event.events |= EPOLLIN;
   if (evts & SELECT_WRITE) event.events |= EPOLLOUT;
-  /*syslog(LOG_DEBUG, "epoll mod %d", fd);*/
+  /*chilli_log(LOG_DEBUG, "epoll mod %d", fd);*/
   if (epoll_ctl(sctx->efd, EPOLL_CTL_MOD, fd, &event))
-    syslog(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Failed to watch fd", strerror(errno));
 #endif
   return 0;
 }
@@ -551,17 +551,17 @@
 		    &sctx->idleTime);
 
 #if(0)
-    if (status) syslog(LOG_DEBUG, "select() == %d", status);
+    if (status) chilli_log(LOG_DEBUG, "select() == %d", status);
     {int i;
       for (i=0; i<FD_SETSIZE; i++)
 	if (FD_ISSET(i, &sctx->rfds))
-	  syslog(LOG_DEBUG, "rfds[%d]",i);
+	  chilli_log(LOG_DEBUG, "rfds[%d]",i);
       for (i=0; i<FD_SETSIZE; i++)
 	if (FD_ISSET(i, &sctx->wfds))
-	  syslog(LOG_DEBUG, "wfds[%d]",i);
+	  chilli_log(LOG_DEBUG, "wfds[%d]",i);
       for (i=0; i<FD_SETSIZE; i++)
 	if (FD_ISSET(i, &sctx->efds))
-	  syslog(LOG_DEBUG, "efds[%d]",i);
+	  chilli_log(LOG_DEBUG, "efds[%d]",i);
     }
 #endif
 
@@ -603,7 +603,7 @@
     if (sctx->events[idx].data.fd == fd) {
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "write %d", (sctx->events[idx].events & EPOLLOUT) != 0);
+        chilli_log(LOG_DEBUG, "write %d", (sctx->events[idx].events & EPOLLOUT) != 0);
 #endif
       if (sctx->events[idx].events & EPOLLOUT)
 	return 1;
@@ -765,7 +765,7 @@
 
 #ifdef USING_MMAP
   if (netif->rx_ring.frames) {
-    syslog(LOG_ERR, "shouldn't be reading a mmap'ed interface this way, use dispatch");
+    chilli_log(LOG_ERR, "shouldn't be reading a mmap'ed interface this way, use dispatch");
     return -1;
   } else
 #endif
@@ -821,17 +821,17 @@
 #endif
       if (len < 0) {
 
-        syslog(LOG_ERR, "%s: could not read packet", strerror(errno));
+        chilli_log(LOG_ERR, "%s: could not read packet", strerror(errno));
 
       } else {
 
         if (len == 0) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "read zero, enable ieee8021q?");
+            chilli_log(LOG_DEBUG, "read zero, enable ieee8021q?");
         }
 
         if (len > dlen) {
-          syslog(LOG_WARNING, "data truncated %zu/%zd, sending ICMP error",
+          chilli_log(LOG_WARNING, "data truncated %zu/%zd, sending ICMP error",
 		 len, dlen);
           return -1;
         }
@@ -848,7 +848,7 @@
 #endif
 
       if (len < 0) {
-        syslog(LOG_ERR, "%d net_read_eth(fd=%d, len=%zu, mtu=%d) == %zd",
+        chilli_log(LOG_ERR, "%d net_read_eth(fd=%d, len=%zu, mtu=%d) == %zd",
                errno, netif->fd, dlen, netif->mtu, len);
         return -1;
       }
@@ -873,14 +873,14 @@
 
           if (ulen < 2 * PKT_ETH_ALEN ||
               len >= (dlen - 4)) {
-            syslog(LOG_ERR, "bad pkt length to add 802.1q header %d/%zd",
+            chilli_log(LOG_ERR, "bad pkt length to add 802.1q header %d/%zd",
                    ulen, len);
             break;
           }
 
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "adding 8021q header from auxdata");
+            chilli_log(LOG_DEBUG, "adding 8021q header from auxdata");
 #endif
 
           memmove(d + (2 * PKT_ETH_ALEN) + 4,
@@ -912,7 +912,7 @@
 #endif
 		  );
     if (w < 0) {
-      syslog(LOG_ERR, "%s: safe_send(%d, d+%d,%d)", strerror(errno), sock, off, left);
+      chilli_log(LOG_ERR, "%s: safe_send(%d, d+%d,%d)", strerror(errno), sock, off, left);
       return (errno == EWOULDBLOCK || errno == EAGAIN) ? off : -1;
     }
     left -= w;
@@ -939,7 +939,8 @@
   if (len < 0) {
     switch (errno) {
       case EWOULDBLOCK:
-        syslog(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
+        if (_options.debug)
+          chilli_log(LOG_ERR, "%s: packet dropped due to congestion", strerror(errno));
         break;
 
 #ifdef ENETDOWN
@@ -960,7 +961,9 @@
 #endif
     }
 
-    syslog(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+    if (_options.debug)
+      chilli_log(LOG_ERR, "%s: net_write_eth(fd=%d, len=%zu) failed", strerror(errno), netif->fd, dlen);
+
     return -1;
   }
 
@@ -977,7 +980,7 @@
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   ifr.ifr_mtu = mtu;
   if (ioctl(fd, SIOCSIFMTU, &ifr) < 0) {
-    syslog(LOG_ERR, "%d could not set MTU of %zu on dev=%s",
+    chilli_log(LOG_ERR, "%d could not set MTU of %zu on dev=%s",
            errno, mtu, netif->devname);
     close(fd);
     return -1;
@@ -1001,7 +1004,7 @@
 
   /* Create a channel to the NET kernel. */
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -1014,14 +1017,14 @@
 
   if (delete) {
     if (ioctl(fd, SIOCDELRT, (void *) &r) < 0) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCDELRT) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCDELRT) failed", strerror(errno));
       close(fd);
       return -1;
     }
   }
   else {
     if (ioctl(fd, SIOCADDRT, (void *) &r) < 0) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCADDRT) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCADDRT) failed", strerror(errno));
       close(fd);
       return -1;
     }
@@ -1042,7 +1045,7 @@
   struct rt_msghdr *rtm;
 
   if ((fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -1075,16 +1078,13 @@
   req.gate.sin_addr.s_addr = gateway->s_addr;
 
   if (safe_write(fd, rtm, rtm->rtm_msglen) < 0) {
-    syslog(LOG_ERR, "%s: write() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: write() failed", strerror(errno));
     close(fd);
     return -1;
   }
   close(fd);
   return 0;
 
-#elif defined(__sun__)
-  syslog(LOG_ERR, "%s: Could not set up routing on Solaris. Please add route manually.", strerror(errno));
-  return 0;
 #else
 #error  "Unknown platform!"
 #endif
@@ -1095,30 +1095,30 @@
   netif->h = nfq_open();
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "netif nfqueue %d", (int)q);
+    chilli_log(LOG_DEBUG, "netif nfqueue %d", (int)q);
 
   if (!netif->h) {
-    syslog(LOG_ERR, "%s: nfq_open() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: nfq_open() failed", strerror(errno));
     return -1;
   }
 
   if (nfq_unbind_pf(netif->h, AF_INET) < 0) {
-    syslog(LOG_ERR, "%s: error during nfq_unbind_pf()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: error during nfq_unbind_pf()", strerror(errno));
   }
 
   if (nfq_bind_pf(netif->h, AF_INET) < 0) {
-    syslog(LOG_ERR, "%s: error during nfq_bind_pf()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: error during nfq_bind_pf()", strerror(errno));
     return -1;
   }
 
   netif->qh = nfq_create_queue(netif->h,  q, cb, NULL);
   if (!netif->qh) {
-    syslog(LOG_ERR, "%s: error during nfq_create_queue(%d)", strerror(errno), (int)q);
+    chilli_log(LOG_ERR, "%s: error during nfq_create_queue(%d)", strerror(errno), (int)q);
     return -1;
   }
 
   if (nfq_set_mode(netif->qh, NFQNL_COPY_PACKET, 21 /*0xffff*/) < 0) {
-    syslog(LOG_ERR, "%s: error during nfq_set_mode()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: error during nfq_set_mode()", strerror(errno));
     return -1;
   }
 
@@ -1126,7 +1126,7 @@
 
   return 0;
 #else
-  syslog(LOG_ERR, "Not implemeneted; build with --with-nfqueue");
+  chilli_log(LOG_ERR, "Not implemeneted; build with --with-nfqueue");
   return -1;
 #endif
 }
@@ -1177,10 +1177,10 @@
 
   netif->pd = pcap_open_live(netif->devname, 2500, 1, 10, errbuf);
 
-  syslog(LOG_INFO, "opening pcap device: %s", netif->devname);
+  chilli_log(LOG_INFO, "opening pcap device: %s", netif->devname);
 
   if (!netif->pd) {
-    syslog(LOG_ERR, "%s: pcap: %s", strerror(errno), errbuf);
+    chilli_log(LOG_ERR, "%s: pcap: %s", strerror(errno), errbuf);
     return -1;
   }
 
@@ -1191,7 +1191,7 @@
   /* Get ifindex */
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, SIOCGIFINDEX, (caddr_t)&ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCFIGINDEX) failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCFIGINDEX) failed", strerror(errno));
   }
 
   netif->ifindex = ifr.ifr_ifindex;
@@ -1199,7 +1199,7 @@
   /* Get the MAC address of our interface */
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, SIOCGIFHWADDR, (caddr_t)&ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFHWADDR);
+    chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFHWADDR);
     return -1;
   }
 
@@ -1211,7 +1211,7 @@
       strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
       memcpy(ifr.ifr_hwaddr.sa_data, netif->hwaddr, PKT_ETH_ALEN);
       if (ioctl(netif->fd, SIOCSIFHWADDR, (caddr_t)&ifr) < 0) {
-	syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCSIFHWADDR);
+	chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCSIFHWADDR);
 	return -1;
       }
     }
@@ -1246,10 +1246,10 @@
 			  /*XXX netif->idx ? SOCK_DGRAM : */SOCK_RAW,
 			  htons(netif->protocol))) < 0) {
     if (errno == EPERM) {
-      syslog(LOG_ERR, "%s: Cannot create raw socket. Must be root.", strerror(errno));
+      chilli_log(LOG_ERR, "%s: Cannot create raw socket. Must be root.", strerror(errno));
     }
 
-    syslog(LOG_ERR, "%d socket(domain=%d, type=%d, protocol=%d) failed",
+    chilli_log(LOG_ERR, "%d socket(domain=%d, type=%d, protocol=%d) failed",
            errno, PF_PACKET, SOCK_RAW, netif->protocol);
 
     return -1;
@@ -1263,11 +1263,6 @@
     ndelay_on(netif->fd);
     coe(netif->fd);
 
-    option = 1;
-    if (net_setsockopt(netif->fd, SOL_SOCKET, TCP_NODELAY,
-		       &option, sizeof(option)) < 0)
-      return -1;
-
     /* Enable reception and transmission of broadcast frames */
     option = 1;
     if (net_setsockopt(netif->fd, SOL_SOCKET, SO_BROADCAST,
@@ -1289,11 +1284,11 @@
       len = sizeof(default_sndbuf);
       getsockopt(netif->fd, SOL_SOCKET, SO_SNDBUF, &default_sndbuf, &len);
       if (_options.debug)
-        syslog(LOG_DEBUG, "Net SNDBUF %d", default_sndbuf);
+        chilli_log(LOG_DEBUG, "Net SNDBUF %d", default_sndbuf);
       len = sizeof(default_sndbuf);
       getsockopt(netif->fd, SOL_SOCKET, SO_RCVBUF, &default_rcvbuf, &len);
       if (_options.debug)
-        syslog(LOG_DEBUG, "Net RCVBUF %d", default_rcvbuf);
+        chilli_log(LOG_DEBUG, "Net RCVBUF %d", default_rcvbuf);
     }
 #ifdef USING_MMAP
   }
@@ -1302,7 +1297,7 @@
   /* Get the MAC address of our interface */
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, SIOCGIFHWADDR, (caddr_t)&ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFHWADDR);
+    chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFHWADDR);
     return -1;
   }
 
@@ -1314,14 +1309,14 @@
       strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
       memcpy(ifr.ifr_hwaddr.sa_data, netif->hwaddr, PKT_ETH_ALEN);
       if (ioctl(netif->fd, SIOCSIFHWADDR, (caddr_t)&ifr) < 0) {
-	syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCSIFHWADDR);
+	chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCSIFHWADDR);
 	return -1;
       }
     }
   }
 
   if (netif->hwaddr[0] & 0x01) {
-    syslog(LOG_ERR, "Ethernet has broadcast or multicast address: %.16s",
+    chilli_log(LOG_ERR, "Ethernet has broadcast or multicast address: %.16s",
            netif->devname);
   }
 
@@ -1331,11 +1326,11 @@
   /* Verify that MTU = ETH_DATA_LEN */
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, SIOCGIFMTU, (caddr_t)&ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFMTU);
+    chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), netif->fd, SIOCGIFMTU);
     return -1;
   }
   if (ifr.ifr_mtu > PKT_BUFFER) {
-    syslog(LOG_ERR, "MTU is larger than PKT_BUFFER: %d > %d",
+    chilli_log(LOG_ERR, "MTU is larger than PKT_BUFFER: %d > %d",
            ifr.ifr_mtu, PKT_BUFFER);
     return -1;
   }
@@ -1344,12 +1339,12 @@
   /* Get ifindex */
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, SIOCGIFINDEX, (caddr_t)&ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCFIGINDEX) failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCFIGINDEX) failed", strerror(errno));
   }
   netif->ifindex = ifr.ifr_ifindex;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "device %s ifindex %d", netif->devname, netif->ifindex);
+    chilli_log(LOG_DEBUG, "device %s ifindex %d", netif->devname, netif->ifindex);
 
 #ifdef ENABLE_IPV6
   {
@@ -1362,7 +1357,7 @@
 	family = ifa->ifa_addr->sa_family;
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s  address family: %d%s",
+          chilli_log(LOG_DEBUG, "%s  address family: %d%s",
                  ifa->ifa_name, family,
                  (family == AF_PACKET) ? " (AF_PACKET)" :
                  (family == AF_INET) ?   " (AF_INET)" :
@@ -1380,10 +1375,10 @@
 			  host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
 	  if (s != 0) {
             if (_options.debug)
-              syslog(LOG_DEBUG, "getnameinfo() failed: %s\n", strerror(s));
+              chilli_log(LOG_DEBUG, "getnameinfo() failed: %s\n", strerror(s));
 	  } else {
             if (_options.debug)
-              syslog(LOG_DEBUG, "address: <%s>\n", host);
+              chilli_log(LOG_DEBUG, "address: <%s>\n", host);
 	  }
 	}
       }
@@ -1407,12 +1402,12 @@
     memset(&ifr, 0, sizeof(ifr));
     strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
     if (ioctl(netif->fd, SIOCGIFFLAGS, (caddr_t)&ifr) == -1) {
-      syslog(LOG_ERR, "%s: ioctl(SIOCGIFFLAGS)", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFFLAGS)", strerror(errno));
     } else {
       netif->devflags = ifr.ifr_flags;
       ifr.ifr_flags |= IFF_PROMISC;
       if (ioctl (netif->fd, SIOCSIFFLAGS, (caddr_t)&ifr) == -1) {
-	syslog(LOG_ERR, "%s: Could not set flag IFF_PROMISC", strerror(errno));
+	chilli_log(LOG_ERR, "%s: Could not set flag IFF_PROMISC", strerror(errno));
       }
     }
 
@@ -1432,7 +1427,7 @@
   sa.sll_ifindex = netif->ifindex;
 
   if (bind(netif->fd, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
-    syslog(LOG_ERR, "%s: bind(sockfd=%d) failed", strerror(errno), netif->fd);
+    chilli_log(LOG_ERR, "%s: bind(sockfd=%d) failed", strerror(errno), netif->fd);
     return -1;
   }
 
@@ -1447,7 +1442,7 @@
   option = 1;
   if (setsockopt(netif->fd, SOL_PACKET, PACKET_AUXDATA, &option,
 		 sizeof(option)) == -1 && errno != ENOPROTOOPT) {
-    syslog(LOG_ERR, "%s: auxdata", strerror(errno));
+    chilli_log(LOG_ERR, "%s: auxdata", strerror(errno));
   }
 #endif
 
@@ -1477,7 +1472,7 @@
   struct sockaddr_dl *sdl;
 
   if (getifaddrs(&ifap)) {
-    syslog(LOG_ERR, "%s: getifaddrs() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: getifaddrs() failed!", strerror(errno));
     return -1;
   }
 
@@ -1496,7 +1491,7 @@
           continue;
       }
       if (sdl->sdl_alen != PKT_ETH_ALEN) {
-	syslog(LOG_ERR, "%s: Wrong sdl_alen!", strerror(errno));
+	chilli_log(LOG_ERR, "%s: Wrong sdl_alen!", strerror(errno));
 	freeifaddrs(ifap);
 	return -1;
       }
@@ -1551,7 +1546,7 @@
     if (errno != EBUSY) break;
   }
   if (netif->fd < 0) {
-    syslog(LOG_ERR, "%s: Can't find bpf device", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't find bpf device", strerror(errno));
     return -1;
   }
 
@@ -1559,31 +1554,31 @@
   memset(&ifr, 0, sizeof(ifr));
   strlcpy(ifr.ifr_name, netif->devname, sizeof(ifr.ifr_name));
   if (ioctl(netif->fd, BIOCSETIF, &ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl() failed", strerror(errno));
     return -1;
   }
 
   /* Get and validate BPF version */
   if (ioctl(netif->fd, BIOCVERSION, &bv) < 0) {
-    syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
     return -1;
   }
   if (bv.bv_major != BPF_MAJOR_VERSION ||
       bv.bv_minor < BPF_MINOR_VERSION) {
-    syslog(LOG_ERR, "%s: wrong BPF version!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: wrong BPF version!", strerror(errno));
     return -1;
   }
 
   /* Get the MAC address of our interface */
   if (net_getmac(netif->devname, (char *)netif->hwaddr)) {
-    syslog(LOG_ERR,"Did not find MAC address!");
+    chilli_log(LOG_ERR,"Did not find MAC address!");
   }
   else {
     netif->flags |= NET_ETHHDR;
   }
 
   if (netif->hwaddr[0] & 0x01) {
-    syslog(LOG_ERR, "Ethernet has broadcast or multicast address: %.16s",
+    chilli_log(LOG_ERR, "Ethernet has broadcast or multicast address: %.16s",
            netif->devname);
     return -1;
   }
@@ -1592,19 +1587,19 @@
   if (netif->flags & NET_PROMISC) {
     value = 1;
     if (ioctl(netif->fd, BIOCPROMISC, NULL) < 0) {
-      syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
       return -1;
     }
     value = 1;
     if (ioctl(netif->fd, BIOCSHDRCMPLT, &value) < 0) {
-      syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
       return -1;
     }
   }
   else {
     value = 0;
     if (ioctl(netif->fd, BIOCSHDRCMPLT, &value) < 0) {
-      syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
       return -1;
     }
   }
@@ -1612,7 +1607,7 @@
   /* Make sure reads return as soon as packet has been received */
   value = 1;
   if (ioctl(netif->fd, BIOCIMMEDIATE, &value) < 0) {
-    syslog(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl() failed!", strerror(errno));
     return -1;
   }
 
@@ -1627,7 +1622,7 @@
     int ret = send(iface->fd, NULL, 0, MSG_DONTWAIT | MSG_NOSIGNAL);
 
     if (ret == -1 && errno != EAGAIN)
-      syslog(LOG_ERR, "Async write error");
+      chilli_log(LOG_ERR, "Async write error");
     else
       ++iface->stats.tx_runs;
 
@@ -1656,7 +1651,7 @@
       iface->rx_ring.idx = 0;
 
     if (h->tp_snaplen < (int)sizeof(struct pkt_ethhdr_t)) {
-      syslog(LOG_ERR, "Packet too short");
+      chilli_log(LOG_ERR, "Packet too short");
       ++iface->stats.dropped;
       goto next;
     }
@@ -1667,7 +1662,7 @@
      tv.tv_nsec = h->tp_nsec;*/
 
     if (_options.debug > 100)
-      syslog(LOG_DEBUG, "RX len=%d spanlen=%d (idx %d)", h->tp_len, h->tp_snaplen, iface->ifindex);
+      chilli_log(LOG_DEBUG, "RX len=%d spanlen=%d (idx %d)", h->tp_len, h->tp_snaplen, iface->ifindex);
 
     pkt_buffer_init(&pb, (uint8_t *)data, h->tp_snaplen, h->tp_mac);
     pb.length = h->tp_len;
@@ -1692,7 +1687,7 @@
       iface->stats.dropped += stats.tp_drops;
 
     if (_options.logfacility > 100)
-      syslog(LOG_DEBUG, "RX drops %d", iface->stats.dropped);
+      chilli_log(LOG_DEBUG, "RX drops %d", iface->stats.dropped);
   }
 
   ++iface->stats.rx_runs;
@@ -1712,7 +1707,7 @@
 #if (0)
   if (length > (unsigned)iface->mtu) {
     /*drop_request(q);*/
-    syslog(LOG_ERR, "dropping packet len=%d", length);
+    chilli_log(LOG_ERR, "dropping packet len=%d", length);
     /*return -1;*/
   }
 #endif
@@ -1734,13 +1729,13 @@
       iface->congested = TRUE;
       }
     */
-    syslog(LOG_WARNING, "dropped packet, buffer full");
+    chilli_log(LOG_WARNING, "dropped packet, buffer full");
     return -1;
   }
 
   /* Should not happen */
   if (h->tp_status == TP_STATUS_WRONG_FORMAT)
-    syslog(LOG_ERR, "Bad packet format on send");
+    chilli_log(LOG_ERR, "Bad packet format on send");
 
   /* Fill the frame */
   data = (void *)h + iface->tp_hdrlen;
@@ -1753,7 +1748,7 @@
   h->tp_status = TP_STATUS_SEND_REQUEST;
 
   if (_options.debug > 100)
-    syslog(LOG_DEBUG, "TX sent=%zu (idx %d)", length, iface->ifindex);
+    chilli_log(LOG_DEBUG, "TX sent=%zu (idx %d)", length, iface->ifindex);
 
   if (!iface->is_active) {
     iface->is_active = 1;
@@ -1776,7 +1771,7 @@
   page_size = sysconf(_SC_PAGESIZE);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "Creating %s ring: ring_size=%d; page_size=%d; mtu=%d",
+    chilli_log(LOG_DEBUG, "Creating %s ring: ring_size=%d; page_size=%d; mtu=%d",
            name, ring_size, page_size, mtu);
 
   /* For RX, the frame looks like:
@@ -1839,7 +1834,7 @@
     req.tp_block_size >>= 1;
   }
   if (ret) {
-    syslog(LOG_ERR, "%d Failed to set up the %s ring buffer; "
+    chilli_log(LOG_ERR, "%d Failed to set up the %s ring buffer; "
            "block_sz=%d block_nr=%d frame_sz=%d frame_nr=%d page_size=%d", errno, name,
            req.tp_block_size, req.tp_block_nr, req.tp_frame_size, req.tp_frame_nr, page_size);
     memset(ring, 0, sizeof(*ring));
@@ -1851,7 +1846,7 @@
   ring->cnt = req.tp_frame_nr;
   ring->frames = calloc(sizeof(void *), req.tp_frame_nr);
 
-  syslog(LOG_INFO, "Created %s ring: len=%d; block size=%d; frame size=%d, cnt=%d",
+  chilli_log(LOG_INFO, "Created %s ring: len=%d; block size=%d; frame size=%d, cnt=%d",
          name, ring->len, req.tp_block_size, req.tp_frame_size, ring->cnt);
 }
 
@@ -1904,7 +1899,7 @@
   ret = net_setsockopt(iface->fd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));
 
   if (ret) {
-    syslog(LOG_ERR, "%s: Failed to set version 2 ring buffer format", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Failed to set version 2 ring buffer format", strerror(errno));
     return;
   }
 
@@ -1913,7 +1908,7 @@
   ret = getsockopt(iface->fd, SOL_PACKET, PACKET_HDRLEN, &val, &len);
 
   if (ret) {
-    syslog(LOG_ERR, "%s: Failed to determine the header length of the ring buffer", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Failed to determine the header length of the ring buffer", strerror(errno));
     return;
   }
 
@@ -1924,7 +1919,7 @@
   ret = net_setsockopt(iface->fd, SOL_PACKET, PACKET_LOSS, &val, sizeof(val));
 
   if (ret)
-    syslog(LOG_ERR, "%s: Failed to set packet drop mode", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Failed to set packet drop mode", strerror(errno));
 
   /* The RX and TX rings share the memory mapped area, so give
    * half the requested size to each */
@@ -1945,7 +1940,7 @@
 			 MAP_SHARED, iface->fd, 0);
 
   if (iface->ring_ptr == MAP_FAILED) {
-    syslog(LOG_ERR, "%s: Failed to mmap the ring buffer", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Failed to mmap the ring buffer", strerror(errno));
     destroy_one_ring(iface, PACKET_RX_RING);
     destroy_one_ring(iface, PACKET_TX_RING);
     iface->ring_ptr = NULL;
@@ -1964,7 +1959,7 @@
     setup_frames(&iface->tx_ring, iface->ring_ptr + len);
 
   /*len = human_format(iface->ring_len, &unit);*/
-  syslog(LOG_INFO, "Set up ring buffer (%u RX/%u TX packets)",
+  chilli_log(LOG_INFO, "Set up ring buffer (%u RX/%u TX packets)",
          iface->rx_ring.cnt, iface->tx_ring.cnt);
 }
 
@@ -1976,7 +1971,7 @@
 
   ret = net_setsockopt(iface->fd, SOL_SOCKET, what, &size, sizeof(size));
   if (ret) {
-    syslog(LOG_ERR, "%d Failed to set the %s buffer size",
+    chilli_log(LOG_ERR, "%d Failed to set the %s buffer size",
            errno, what == SO_SNDBUF ? "send" : "receive");
     return;
   }
@@ -1986,7 +1981,7 @@
     val = size;
 
   /*ret = human_format(val, &unit);
-    syslog(LOG_INFO, "The %s buffer is %d %s",
+    chilli_log(LOG_INFO, "The %s buffer is %d %s",
     what == SO_SNDBUF ? "send" : "receive", ret, unit);*/
 }
 
@@ -2037,7 +2032,7 @@
     };
 
     if (net_setsockopt(iface->fd, SOL_SOCKET, SO_ATTACH_FILTER, &prog, sizeof(prog)))
-      syslog(LOG_ERR, "%s: Failed to set up the socket filter", strerror(errno));
+      chilli_log(LOG_ERR, "%s: Failed to set up the socket filter", strerror(errno));
   }
 }
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/net.h src/src/net.h
--- upstream/src/net.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/net.h	2025-11-06 13:20:13.000000000 +0000
@@ -177,6 +177,7 @@
   struct pollfd pfds[MAX_SELECT];
 #endif
 #else
+  char padding[2]; // add padding to separate src and prot
   int maxfd;
   fd_set rfds, wfds, efds;
   struct timeval idleTime;
@@ -191,6 +192,7 @@
   uint8_t hwtype;
   uint8_t hwaddr[PKT_ETH_ALEN];
   char devname[IFNAMSIZ+1];
+  char padding[2]; // add padding to separate src and prot
   int devflags;
   int ifindex;
   int mtu;
@@ -251,6 +253,7 @@
   nat_t *nat;
 #endif
 
+  char padding2[2]; // add padding to separate src and prot
   select_ctx *sctx;
 
   uint8_t flags;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oauth2.c src/src/oauth2.c
--- upstream/src/oauth2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/oauth2.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,828 @@
+#include <inttypes.h>
+#include "chilli.h"
+#include <curl/curl.h>
+#include <json-c/json.h>
+#include <openssl/rsa.h>
+#include <openssl/sha.h>
+#include <openssl/bn.h>
+#include <openssl/evp.h>
+#include <openssl/core_names.h>
+#include <openssl/param_build.h>
+
+static int base64url_decode(const char *src, unsigned char *dest, size_t dest_len)
+{
+	size_t len	    = strlen(src);
+	size_t max_temp_len = len + 3;
+	char *temp	    = calloc(max_temp_len + 1, sizeof(char));
+	strncpy(temp, src, max_temp_len);
+
+	for (size_t i = 0; i < len; i++) {
+		if (temp[i] == '-') {
+			temp[i] = '+';
+		} else if (temp[i] == '_') {
+			temp[i] = '/';
+		}
+	}
+
+	size_t padding_len = 4 - (len % 4);
+	if (padding_len < 4) {
+		memset(temp + len, '=', padding_len);
+		len += padding_len;
+	}
+	temp[len] = '\0';
+
+	int ret = b64_decode(temp, dest, dest_len);
+	free(temp);
+	return ret;
+}
+
+static size_t write_callback(void *contents, size_t size, size_t nmemb, void *resp)
+{
+	size_t realsize		  = size * nmemb;
+	struct memory_struct *mem = (struct memory_struct *)resp;
+
+	size_t new_size = mem->size + realsize + 1;
+	mem->memory	= realloc(mem->memory, new_size + 1024);
+	if (mem->memory == NULL) {
+		free(mem->memory);
+		return OAUTH2_OK;
+	}
+
+	memcpy(&(mem->memory[mem->size]), contents, realsize);
+	mem->size += realsize;
+	mem->memory[mem->size] = 0;
+
+	return realsize;
+}
+
+static int oauth2_get_jwk_by_kid(_oauth2_session *session, const char *kid)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->jwks_uri;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	if (res != CURLE_OK) {
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+
+	struct json_object *root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	struct json_object *keys_obj;
+	if (!json_object_object_get_ex(root_obj, "keys", &keys_obj)) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	int keys_len		    = json_object_array_length(keys_obj);
+	struct json_object *key_obj = NULL;
+	const char *key_kid	    = NULL;
+	struct json_object *n_obj   = NULL;
+	struct json_object *e_obj   = NULL;
+
+	for (int i = 0; i < keys_len; i++) {
+		key_obj = json_object_array_get_idx(keys_obj, i);
+		if (json_object_object_get_ex(key_obj, "kid", &n_obj))
+			key_kid = json_object_get_string(n_obj);
+
+		if (key_kid != NULL && !strcmp(kid, key_kid))
+			break;
+
+		key_obj = NULL;
+		key_kid = NULL;
+	}
+
+	if (key_obj != NULL && json_object_object_get_ex(key_obj, "n", &n_obj) &&
+	    json_object_object_get_ex(key_obj, "e", &e_obj)) {
+		const char *n_value = json_object_get_string(n_obj);
+		const char *e_value = json_object_get_string(e_obj);
+
+		session->jwks_n = strdup(n_value);
+		session->jwks_e = strdup(e_value);
+
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_OK;
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+	return OAUTH2_ERR;
+}
+
+static int verify_jwt_alg_rs(const EVP_MD *sha_alg, _oauth2_session *session, char *header, char *payload,
+			     unsigned char *decoded_signature, int decoded_signature_len)
+{
+	OSSL_PARAM_BLD *bld;
+	OSSL_PARAM *params = NULL;
+	EVP_PKEY *pkey	   = NULL;
+
+	unsigned char decoded_n[4096];
+	int n_len = base64url_decode(session->jwks_n, decoded_n, sizeof(decoded_n));
+
+	unsigned char decoded_e[4096];
+	int e_len = base64url_decode(session->jwks_e, decoded_e, sizeof(decoded_e));
+
+	BIGNUM *bn_n = BN_bin2bn(decoded_n, n_len, NULL);
+	BIGNUM *bn_e = BN_bin2bn(decoded_e, e_len, NULL);
+	if (!bn_n || !bn_e) {
+		BN_free(bn_n);
+		BN_free(bn_e);
+		return OAUTH2_ERR;
+	}
+
+	bld = OSSL_PARAM_BLD_new();
+	if (bld && OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_RSA_N, bn_n) &&
+	    OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_RSA_E, bn_e)) {
+		params = OSSL_PARAM_BLD_to_param(bld);
+	}
+	OSSL_PARAM_BLD_free(bld);
+	BN_free(bn_n);
+	BN_free(bn_e);
+
+	EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_from_name(NULL, "RSA", NULL);
+	if (!params || !ctx || EVP_PKEY_fromdata_init(ctx) <= 0 ||
+	    EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
+		EVP_PKEY_CTX_free(ctx);
+		OSSL_PARAM_free(params);
+		return OAUTH2_ERR;
+	}
+
+	EVP_PKEY_CTX_free(ctx);
+	OSSL_PARAM_free(params);
+
+	EVP_MD_CTX *ctx_md = EVP_MD_CTX_new();
+	if (!ctx_md) {
+		EVP_PKEY_free(pkey);
+		return OAUTH2_ERR;
+	}
+
+	if (!EVP_VerifyInit_ex(ctx_md, sha_alg, NULL) || !EVP_VerifyUpdate(ctx_md, header, strlen(header)) ||
+	    !EVP_VerifyUpdate(ctx_md, ".", 1) || !EVP_VerifyUpdate(ctx_md, payload, strlen(payload))) {
+		EVP_MD_CTX_free(ctx_md);
+		EVP_PKEY_free(pkey);
+		return OAUTH2_ERR;
+	}
+
+	int ret = OAUTH2_ERR;
+	if (EVP_VerifyFinal(ctx_md, decoded_signature, decoded_signature_len, pkey) == 1) {
+		ret = OAUTH2_OK;
+	}
+
+	EVP_MD_CTX_free(ctx_md);
+	EVP_PKEY_free(pkey);
+	return ret;
+}
+
+static int verify_jwt_alg(_oauth2_session *session, const char *alg, const char *kid, char *header,
+			  char *payload, unsigned char *decoded_signature, int decoded_signature_len)
+{
+	if (oauth2_get_jwk_by_kid(session, kid) != OAUTH2_OK) {
+		return OAUTH2_ERR;
+	}
+
+	if (alg && !strcmp(alg, "RS256")) {
+		return verify_jwt_alg_rs(EVP_sha256(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	if (alg && !strcmp(alg, "RS384")) {
+		return verify_jwt_alg_rs(EVP_sha384(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	if (alg && !strcmp(alg, "RS512")) {
+		return verify_jwt_alg_rs(EVP_sha512(), session, header, payload, decoded_signature,
+				     decoded_signature_len);
+	}
+	return OAUTH2_ERR;
+}
+
+static int validate_jwt_token(_oauth2_session *session)
+{
+	int ret	     = OAUTH2_ERR;
+	char *header = NULL, *payload = NULL, *signature = NULL;
+	char *token_copy = strdup(session->id_token);
+
+	char *saveptr = NULL;
+	header	      = strtok_r(token_copy, ".", &saveptr);
+	payload	      = strtok_r(NULL, ".", &saveptr);
+	signature     = strtok_r(NULL, ".", &saveptr);
+
+	unsigned char *decoded_header	 = calloc(strlen(header) * 2, sizeof(unsigned char));
+	unsigned char *decoded_payload	 = calloc(strlen(payload) * 2, sizeof(unsigned char));
+	unsigned char *decoded_signature = calloc(strlen(signature) * 2, sizeof(unsigned char));
+	if (!decoded_header || !decoded_payload || !decoded_signature) {
+		goto clean;
+	}
+
+	int decoded_header_len = base64url_decode(header, decoded_header, strlen(header) * 2);
+	if (decoded_header_len < 0) {
+		goto clean;
+	}
+
+	int decoded_payload_len = base64url_decode(payload, decoded_payload, strlen(payload) * 2);
+	if (decoded_payload_len < 0) {
+		goto clean;
+	}
+
+	int decoded_signature_len = base64url_decode(signature, decoded_signature, strlen(signature) * 2);
+	if (decoded_signature_len < 0) {
+		goto clean;
+	}
+
+	json_object *header_json  = json_tokener_parse((const char *)decoded_header);
+	json_object *payload_json = json_tokener_parse((const char *)decoded_payload);
+	if (!header_json || !payload_json) {
+		goto clean;
+	}
+
+	json_object *iss_obj;
+	if (!json_object_object_get_ex(payload_json, "iss", &iss_obj) ||
+	    strcmp(json_object_get_string(iss_obj), session->issuer) != 0) {
+		goto clean;
+	}
+
+	json_object *aud_obj;
+	if (!json_object_object_get_ex(payload_json, "aud", &aud_obj) ||
+	    strcmp(json_object_get_string(aud_obj), session->client_id) != 0) {
+		goto clean;
+	}
+
+	json_object *exp_obj;
+	if (json_object_object_get_ex(payload_json, "exp", &exp_obj)) {
+		time_t current_time = time(NULL);
+		uint64_t exp_time   = json_object_get_int64(exp_obj);
+		if (exp_time < (uint64_t)current_time) {
+			goto clean;
+		}
+	} else {
+		goto clean;
+	}
+
+	json_object *username_obj;
+	if (json_object_object_get_ex(payload_json, "preferred_username", &username_obj)) {
+		const char *username = json_object_get_string(username_obj);
+		if (username && username[0] != '\0') {
+			session->username = strdup(username);
+		}
+	}
+
+	const char *alg = NULL;
+	json_object *alg_obj;
+	if (json_object_object_get_ex(header_json, "alg", &alg_obj)) {
+		alg = json_object_get_string(alg_obj);
+	} else {
+		goto clean;
+	}
+
+	const char *kid = NULL;
+	json_object *kid_obj;
+	if (json_object_object_get_ex(header_json, "kid", &kid_obj)) {
+		kid = json_object_get_string(kid_obj);
+	} else {
+		goto clean;
+	}
+
+	ret = verify_jwt_alg(session, alg, kid, header, payload, decoded_signature, decoded_signature_len);
+
+clean:
+	free(token_copy);
+	free(decoded_header);
+	free(decoded_payload);
+	free(decoded_signature);
+	return ret;
+}
+
+void oauth2_init_session(_oauth2_session *session)
+{
+	session->response_type		= NULL;
+	session->oidc_endpoint		= NULL;
+	session->client_id		= NULL;
+	session->client_secret		= NULL;
+	session->redirect_uri		= NULL;
+	session->scope			= NULL;
+	session->state			= NULL;
+	session->code			= NULL;
+	session->token_endpoint		= NULL;
+	session->authorization_endpoint = NULL;
+	session->userinfo_endpoint	= NULL;
+	session->jwks_uri		= NULL;
+	session->authorization_url	= NULL;
+	session->id_token		= NULL;
+	session->access_token		= NULL;
+	session->username		= NULL;
+	session->issuer			= NULL;
+	session->jwks_n			= NULL;
+	session->jwks_e			= NULL;
+	session->token_type		= OAUTH2_TOKEN_UNKNOWN;
+}
+
+static void oauth2_set_str_parameter(_oauth2_session *session, unsigned int option, char *value)
+{
+	switch (option) {
+	case OAUTH2_OPT_OIDC_ENDPOINT:
+		session->oidc_endpoint = strdup(value);
+		break;
+	case OAUTH2_OPT_CLIENT_ID:
+		session->client_id = strdup(value);
+		break;
+	case OAUTH2_OPT_CLIENT_SECRET:
+		session->client_secret = strdup(value);
+		break;
+	case OAUTH2_OPT_REDIRECT_URI:
+		session->redirect_uri = strdup(value);
+		break;
+	case OAUTH2_OPT_SCOPE:
+		session->scope = strdup(value);
+		break;
+	case OAUTH2_OPT_STATE:
+		session->state = strdup(value);
+		break;
+	case OAUTH2_OPT_CODE:
+		session->code = strdup(value);
+		break;
+	default:
+		break;
+	}
+}
+
+static void oauth2_set_int_parameter(_oauth2_session *session, unsigned int option, unsigned int value)
+{
+	switch (option) {
+	case OAUTH2_OPT_RESPONSE_TYPE: {
+		switch (value) {
+		case OAUTH2_RESPONSE_TYPE_CODE:
+			session->response_type = "code";
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+static int oauth2_add_session_tokens(_oauth2_session *session, const char *id_token, const char *access_token,
+				     const char *token_type)
+{
+	int ret = OAUTH2_OK;
+	if (!session->id_token && id_token && id_token[0] != '\0') {
+		session->id_token = strdup(id_token);
+		ret		  = validate_jwt_token(session);
+	}
+
+	if (!session->access_token && access_token && access_token[0] != '\0') {
+		session->access_token = strdup(access_token);
+	}
+
+	if (token_type && !strcmp(token_type, "Bearer")) {
+		session->token_type = OAUTH2_TOKEN_BEARER;
+	} else {
+		session->token_type = OAUTH2_TOKEN_UNKNOWN;
+	}
+
+	return ret;
+}
+
+void oauth2_set_parameter_list(_oauth2_session *session, ...)
+{
+	va_list args;
+	va_start(args, session);
+
+	unsigned int option = 0;
+	while ((option = va_arg(args, unsigned int)) != OAUTH2_OPT_NONE) {
+		switch (option) {
+		case OAUTH2_OPT_OIDC_ENDPOINT:
+		case OAUTH2_OPT_CLIENT_ID:
+		case OAUTH2_OPT_CLIENT_SECRET:
+		case OAUTH2_OPT_REDIRECT_URI:
+		case OAUTH2_OPT_STATE:
+		case OAUTH2_OPT_SCOPE:
+		case OAUTH2_OPT_CODE: {
+			char *value = va_arg(args, char *);
+			oauth2_set_str_parameter(session, option, value);
+			break;
+		}
+		case OAUTH2_OPT_RESPONSE_TYPE: {
+			unsigned int value = va_arg(args, unsigned int);
+			oauth2_set_int_parameter(session, option, value);
+			break;
+		}
+		default:
+			break;
+		}
+	}
+
+	va_end(args);
+}
+
+int oauth2_get_openid_config(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->oidc_endpoint;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	if (session->token_endpoint || session->authorization_endpoint || session->jwks_uri ||
+	    session->userinfo_endpoint) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 openid endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 openid endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+
+	struct json_object *root_obj, *token_endpoint_obj, *authorization_endpoint_obj, *jwks_uri_obj,
+		*userinfo_endpoint_obj, *issuer_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_object_get_ex(root_obj, "token_endpoint", &token_endpoint_obj);
+	json_object_object_get_ex(root_obj, "authorization_endpoint", &authorization_endpoint_obj);
+	json_object_object_get_ex(root_obj, "jwks_uri", &jwks_uri_obj);
+	json_object_object_get_ex(root_obj, "userinfo_endpoint", &userinfo_endpoint_obj);
+	json_object_object_get_ex(root_obj, "issuer", &issuer_obj);
+
+	if (!token_endpoint_obj || !authorization_endpoint_obj || !jwks_uri_obj || !userinfo_endpoint_obj ||
+	    !issuer_obj) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	const char *token_endpoint	   = json_object_get_string(token_endpoint_obj);
+	const char *authorization_endpoint = json_object_get_string(authorization_endpoint_obj);
+	const char *jwks_uri		   = json_object_get_string(jwks_uri_obj);
+	const char *userinfo_endpoint	   = json_object_get_string(userinfo_endpoint_obj);
+	const char *issuer		   = json_object_get_string(issuer_obj);
+
+	if (!token_endpoint || !authorization_endpoint || !jwks_uri || !userinfo_endpoint || !issuer) {
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	session->token_endpoint		= strdup(token_endpoint);
+	session->authorization_endpoint = strdup(authorization_endpoint);
+	session->jwks_uri		= strdup(jwks_uri);
+	session->userinfo_endpoint	= strdup(userinfo_endpoint);
+	session->issuer			= strdup(issuer);
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	return OAUTH2_OK;
+}
+
+int oauth2_build_authorization_url(_oauth2_session *session)
+{
+	if (!session->authorization_endpoint || !session->client_id || !session->redirect_uri ||
+	    !session->scope || !session->response_type || !session->state) {
+		return OAUTH2_ERR;
+	}
+	if (session->authorization_url) {
+		free(session->authorization_url);
+		session->authorization_url = NULL;
+	}
+
+	int result = asprintf(&session->authorization_url,
+			      "%s?client_id=%s&redirect_uri=%s&scope=%s&response_type=%s&state=%s",
+			      session->authorization_endpoint, session->client_id, session->redirect_uri,
+			      session->scope, session->response_type, session->state);
+	if (result == -1) {
+		return OAUTH2_ERR;
+	}
+
+	return OAUTH2_OK;
+}
+
+int oauth2_exchange_token(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->token_endpoint;
+	struct memory_struct chunk = { 0 };
+	char *post_data = NULL;
+	char *auth_header = NULL;
+
+	if (!url || url[0] == '\0') {
+		return OAUTH2_ERR;
+	}
+
+	if (!session->code || !session->redirect_uri || !session->client_secret || !session->client_id ||
+	    !session->response_type || (session->response_type && strcmp(session->response_type, "code"))) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	asprintf(&post_data, "grant_type=authorization_code&client_id=%s&client_secret=%s&redirect_uri=%s&code=%s",
+		 session->client_id, session->client_secret, session->redirect_uri, session->code);
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, (long)strlen(post_data));
+
+	asprintf(&auth_header, "%s:%s", session->client_id, session->client_secret);
+	curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
+	curl_easy_setopt(curl, CURLOPT_USERPWD, auth_header);
+
+	struct curl_slist *headers = NULL;
+	headers = curl_slist_append(headers, "Content-Type: application/x-www-form-urlencoded");
+	headers = curl_slist_append(headers, "Accept: application/json");
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+
+	res = curl_easy_perform(curl);
+	free(post_data);
+	free(auth_header);
+
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 token endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200 && http_code != 201) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 token endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+	curl_slist_free_all(headers);
+
+	struct json_object *root_obj, *access_token_obj, *id_token_obj, *token_type_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_object_get_ex(root_obj, "access_token", &access_token_obj);
+	json_object_object_get_ex(root_obj, "id_token", &id_token_obj);
+	json_object_object_get_ex(root_obj, "token_type", &token_type_obj);
+
+	const char *access_token = access_token_obj ? json_object_get_string(access_token_obj) : NULL;
+	const char *id_token	 = id_token_obj ? json_object_get_string(id_token_obj) : NULL;
+	const char *token_type	 = token_type_obj ? json_object_get_string(token_type_obj) : NULL;
+
+	if (oauth2_add_session_tokens(session, id_token, access_token, token_type) != OAUTH2_OK) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Failed to get session tokens", __FUNCTION__, __LINE__);
+		json_object_put(root_obj);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	if (!access_token && !id_token && !token_type) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Failed to get either access_token, id_token or token_type",
+			       __FUNCTION__, __LINE__);
+		return OAUTH2_ERR;
+	}
+
+	return OAUTH2_OK;
+}
+
+int oauth2_get_userinfo(_oauth2_session *session)
+{
+	CURL *curl;
+	CURLcode res;
+	long http_code;
+	char *url		   = session->userinfo_endpoint;
+	struct memory_struct chunk = { 0 };
+
+	if (!url || url[0] == '\0' || !session->access_token || session->token_type != OAUTH2_TOKEN_BEARER) {
+		return OAUTH2_ERR;
+	}
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl) {
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	struct curl_slist *headers = NULL;
+	char *bearer_header;
+	asprintf(&bearer_header, "Authorization: Bearer %s", session->access_token);
+	headers = curl_slist_append(headers, bearer_header);
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
+	res = curl_easy_perform(curl);
+	free(bearer_header);
+
+	if (res != CURLE_OK) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Failed to get response from oauth2 userinfo endpoint",
+			       __FUNCTION__, __LINE__);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+	if (http_code != 200) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Incorrect response gotten from oauth2 userinfo endpoint: %s",
+			       __FUNCTION__, __LINE__, chunk.memory);
+		curl_easy_cleanup(curl);
+		curl_global_cleanup();
+		curl_slist_free_all(headers);
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	curl_easy_cleanup(curl);
+	curl_global_cleanup();
+	curl_slist_free_all(headers);
+
+	struct json_object *root_obj, *email_obj, *username_obj, *name_obj;
+	root_obj = json_tokener_parse(chunk.memory);
+	if (root_obj == NULL) {
+		free(chunk.memory);
+		return OAUTH2_ERR;
+	}
+
+	// prefered username is in JWT token for Microsoft,
+	// other providers may handle usernames differently
+	if (!session->username) {
+		json_object_object_get_ex(root_obj, "email", &email_obj);
+		json_object_object_get_ex(root_obj, "username", &username_obj);
+		json_object_object_get_ex(root_obj, "name", &name_obj);
+
+		const char *email    = email_obj ? json_object_get_string(email_obj) : NULL;
+		const char *username = username_obj ? json_object_get_string(username_obj) : NULL;
+		const char *name     = name_obj ? json_object_get_string(name_obj) : NULL;
+
+		if (email) {
+			session->username = strdup(email);
+		} else if (username) {
+			session->username = strdup(username);
+		} else if (name) {
+			session->username = strdup(name);
+		}
+	}
+
+	json_object_put(root_obj);
+	free(chunk.memory);
+
+	return OAUTH2_OK;
+}
+
+void oauth2_clean_session(_oauth2_session *session)
+{
+	if (session->oidc_endpoint != NULL) {
+		free(session->oidc_endpoint);
+	}
+	if (session->client_id != NULL) {
+		free(session->client_id);
+	}
+	if (session->client_secret != NULL) {
+		free(session->client_secret);
+	}
+	if (session->redirect_uri != NULL) {
+		free(session->redirect_uri);
+	}
+	if (session->scope != NULL) {
+		free(session->scope);
+	}
+	if (session->state != NULL) {
+		free(session->state);
+	}
+	if (session->code != NULL) {
+		free(session->code);
+	}
+	if (session->token_endpoint != NULL) {
+		free(session->token_endpoint);
+	}
+	if (session->authorization_endpoint != NULL) {
+		free(session->authorization_endpoint);
+	}
+	if (session->userinfo_endpoint != NULL) {
+		free(session->userinfo_endpoint);
+	}
+	if (session->jwks_uri != NULL) {
+		free(session->jwks_uri);
+	}
+	if (session->authorization_url != NULL) {
+		free(session->authorization_url);
+	}
+	if (session->id_token != NULL) {
+		free(session->id_token);
+	}
+	if (session->access_token != NULL) {
+		free(session->access_token);
+	}
+	if (session->username != NULL) {
+		free(session->username);
+	}
+	if (session->issuer != NULL) {
+		free(session->issuer);
+	}
+	if (session->jwks_n != NULL) {
+		free(session->jwks_n);
+	}
+	if (session->jwks_e != NULL) {
+		free(session->jwks_e);
+	}
+	oauth2_init_session(session);
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oauth2.h src/src/oauth2.h
--- upstream/src/oauth2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/oauth2.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,58 @@
+#ifndef OAUTH2_H
+#define OAUTH2_H
+
+#define OAUTH2_OK 0
+#define OAUTH2_ERR 1
+
+#define OAUTH2_OPT_NONE		 0
+#define OAUTH2_OPT_RESPONSE_TYPE 1
+#define OAUTH2_OPT_OIDC_ENDPOINT 2
+#define OAUTH2_OPT_CLIENT_ID	 3
+#define OAUTH2_OPT_CLIENT_SECRET 4
+#define OAUTH2_OPT_REDIRECT_URI	 5
+#define OAUTH2_OPT_SCOPE	 6
+#define OAUTH2_OPT_STATE	 7
+#define OAUTH2_OPT_CODE		 8
+
+#define OAUTH2_RESPONSE_TYPE_CODE 1
+
+#define OAUTH2_TOKEN_UNKNOWN 0
+#define OAUTH2_TOKEN_BEARER 1
+
+struct memory_struct {
+	char *memory;
+	size_t size;
+};
+
+typedef struct {
+	char *response_type;
+	char *oidc_endpoint;
+	char *token_endpoint;
+	char *authorization_endpoint;
+	char *userinfo_endpoint;
+	char *authorization_url;
+	char *jwks_uri;
+	char *jwks_n;
+	char *jwks_e;
+	char *client_id;
+	char *client_secret;
+	char *redirect_uri;
+	char *scope;
+	char *state;
+	char *code;
+	char *access_token;
+	char *id_token;
+	char *username;
+	char *issuer;
+	unsigned int token_type;
+} _oauth2_session;
+
+void oauth2_init_session(_oauth2_session *session);
+void oauth2_set_parameter_list(_oauth2_session *session, ...);
+int oauth2_get_openid_config(_oauth2_session *session);
+int oauth2_build_authorization_url(_oauth2_session *session);
+int oauth2_exchange_token(_oauth2_session *session);
+int oauth2_get_userinfo(_oauth2_session *session);
+void oauth2_clean_session(_oauth2_session *session);
+
+#endif //OAUTH2_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/options.c src/src/options.c
--- upstream/src/options.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.c	2025-11-06 13:20:13.000000000 +0000
@@ -57,31 +57,31 @@
       break;
     case 5:
       if (m1 > 32) {
-        syslog(LOG_ERR, "Invalid mask");
+        chilli_log(LOG_ERR, "Invalid mask");
         return -1; /* Invalid mask */
       }
       mask->s_addr = m1 > 0 ? htonl(0xffffffff << (32 - m1)) : 0;
       break;
     case 8:
       if (m1 >= 256 ||  m2 >= 256 || m3 >= 256 || m4 >= 256) {
-        syslog(LOG_ERR, "Invalid mask");
+        chilli_log(LOG_ERR, "Invalid mask");
         return -1; /* Wrong mask format */
       }
       m = m1 * 0x1000000 + m2 * 0x10000 + m3 * 0x100 + m4;
       for (masklog = 0; ((1 << masklog) < ((~m)+1)); masklog++);
       if (((~m)+1) != (1 << masklog)) {
-        syslog(LOG_ERR, "Invalid mask");
+        chilli_log(LOG_ERR, "Invalid mask");
         return -1; /* Wrong mask format (not all ones followed by all zeros)*/
       }
       mask->s_addr = htonl(m);
       break;
     default:
-      syslog(LOG_ERR, "Invalid mask");
+      chilli_log(LOG_ERR, "Invalid mask");
       return -1; /* Invalid mask */
   }
 
   if (a1 >= 256 ||  a2 >= 256 || a3 >= 256 || a4 >= 256) {
-    syslog(LOG_ERR, "Wrong IP address format");
+    chilli_log(LOG_ERR, "Wrong IP address format");
     return -1;
   }
   else
@@ -113,10 +113,11 @@
 
   chilli_binconfig(file, sizeof(file), 0);
 
-  syslog(LOG_DEBUG, "(Re)processing options [%s]", file);
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "(Re)processing options [%s]", file);
 
   if ((status = fork()) < 0) {
-    syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
     return -1;
   }
 
@@ -137,10 +138,11 @@
   newargs[i++] = file;
   newargs[i++] = reload ? "-r" : NULL;
 
-  syslog(LOG_DEBUG, "running chilli_opt on %s", file);
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "running chilli_opt on %s", file);
 
   if (execv(SBINDIR "/chilli_opt", newargs) != 0) {
-    syslog(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: execl() did not return 0!", strerror(errno));
     exit(0);
   }
 
@@ -180,7 +182,7 @@
 	  break;
 	}
 
-	syslog(LOG_WARNING, "could not generate configuration (%s), sleeping one second", file);
+	chilli_log(LOG_WARNING, "could not generate configuration (%s), sleeping one second", file);
 	sleep(1);
       }
     }
@@ -189,7 +191,8 @@
   if (fd < 0) return 0;
   done_before = 1;
 
-  syslog(LOG_DEBUG, "PID %d rereading binary file %s", getpid(), file);
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "PID %d rereading binary file %s", getpid(), file);
   return options_fromfd(fd, bt);
 }
 
@@ -201,19 +204,19 @@
         /* not necessarily a directory */
         unlink(path);
         if (mkdir(path, S_IRWXU | S_IRWXG | S_IRWXO)) {
-          syslog(LOG_ERR, "%s: mkdir %s", strerror(errno), path);
+          chilli_log(LOG_ERR, "%s: mkdir %s", strerror(errno), path);
           return -1;
         }
         break;
       default:
-        syslog(LOG_ERR, "%s: mkdir %s", strerror(errno), path);
+        chilli_log(LOG_ERR, "%s: mkdir %s", strerror(errno), path);
         return -1;
     }
   }
 
   if (_options.uid && geteuid() == 0) {
     if (chown(path, _options.uid, _options.gid)) {
-      syslog(LOG_ERR, "%s: could not chown() %s", strerror(errno), path);
+      chilli_log(LOG_ERR, "%s: could not chown() %s", strerror(errno), path);
     }
   }
   return 0;
@@ -255,7 +258,7 @@
   close(fd);
 
   if (has_error) {
-    syslog(LOG_ERR, "could not read configuration, "
+    chilli_log(LOG_ERR, "could not read configuration, "
            "some kind of mismatch fd=%d %s", fd, SBINDIR);
     return 0;
   }
@@ -274,6 +277,7 @@
   if (!option_s_l(bt, &o.ipdown)) return 0;
   if (!option_s_l(bt, &o.conup)) return 0;
   if (!option_s_l(bt, &o.condown)) return 0;
+  if (!option_s_l(bt, &o.conrestart)) return 0;
   if (!option_s_l(bt, &o.macup)) return 0;
   if (!option_s_l(bt, &o.macdown)) return 0;
 #ifdef ENABLE_IEEE8021Q
@@ -311,6 +315,12 @@
   if (!option_s_l(bt, &o.macsuffix)) return 0;
   if (!option_s_l(bt, &o.macpasswd)) return 0;
 
+#ifdef USING_CURL
+  if (!option_s_l(bt, &o.oidcdiscoveryurl)) return 0;
+  if (!option_s_l(bt, &o.oidcclientid)) return 0;
+  if (!option_s_l(bt, &o.oidcclientsecret)) return 0;
+#endif
+
   if (!option_s_l(bt, &o.uamsecret)) return 0;
   if (!option_s_l(bt, &o.uamurl)) return 0;
   if (!option_s_l(bt, &o.uamaaaurl)) return 0;
@@ -320,7 +330,6 @@
   if (!option_s_l(bt, &o.wwwdir)) return 0;
   if (!option_s_l(bt, &o.wwwbin)) return 0;
   if (!option_s_l(bt, &o.uamui)) return 0;
-  if (!option_s_l(bt, &o.localusers)) return 0;
 #ifdef HAVE_SSL
   if (!option_s_l(bt, &o.sslkeyfile)) return 0;
   if (!option_s_l(bt, &o.sslkeypass)) return 0;
@@ -371,6 +380,29 @@
       return 0;
   }
 
+  if (!option_s_l(bt, &o.successurlcustom)) return 0;
+  if (!option_s_l(bt, &o.dbpath)) return 0;
+  if (!option_s_l(bt, &o.usersdbpath)) return 0;
+  if (!option_s_l(bt, &o.usersignup)) return 0;
+  if (!option_s_l(bt, &o.macpass)) return 0;
+  if (!option_s_l(bt, &o.paramuamip)) return 0;
+  if (!option_s_l(bt, &o.paramuamport)) return 0;
+  if (!option_s_l(bt, &o.paramcalled)) return 0;
+  if (!option_s_l(bt, &o.parammac)) return 0;
+  if (!option_s_l(bt, &o.paramip)) return 0;
+  if (!option_s_l(bt, &o.paramnasid)) return 0;
+  if (!option_s_l(bt, &o.paramsessionid)) return 0;
+  if (!option_s_l(bt, &o.paramuserurl)) return 0;
+  if (!option_s_l(bt, &o.paramchallenge)) return 0;
+  if (!option_s_l(bt, &o.param1)) return 0;
+  if (!option_s_l(bt, &o.param1value)) return 0;
+  if (!option_s_l(bt, &o.param2)) return 0;
+  if (!option_s_l(bt, &o.param2value)) return 0;
+
+#ifdef ENABLE_GSM
+  if (!option_s_l(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_LOAD
 #include EX_OPTIONS_LOAD
 #endif
@@ -405,7 +437,7 @@
       if (m->destroy)
 	m->destroy(isReload[i]);
     }
-    syslog(LOG_DEBUG, "Unloading module %s",_options.modules[i].name);
+    chilli_log(LOG_DEBUG, "Unloading module %s",_options.modules[i].name);
     chilli_module_unload(_options.modules[i].ctx);
   }
 #endif
@@ -415,10 +447,10 @@
   _options._data = (char *)bt->data;
 
 #ifdef ENABLE_MODULES
-  syslog(LOG_DEBUG, "Loading modules");
+  chilli_log(LOG_DEBUG, "Loading modules");
   for (i=0; i < MAX_MODULES; i++) {
     if (!_options.modules[i].name[0]) break;
-    syslog(LOG_DEBUG, "Loading module %s",_options.modules[i].name);
+    chilli_log(LOG_DEBUG, "Loading module %s",_options.modules[i].name);
     chilli_module_load(&_options.modules[i].ctx,
 		       _options.modules[i].name);
     if (_options.modules[i].ctx) {
@@ -447,7 +479,7 @@
   mode_t oldmask;
   int fd, i;
 
-  syslog(LOG_DEBUG, "PID %d saving options to %s", getpid(), file);
+  chilli_log(LOG_DEBUG, "PID %d saving options to %s", getpid(), file);
 
   memcpy(&o, &_options, sizeof(o));
 
@@ -473,6 +505,7 @@
   if (!option_s_s(bt, &o.ipdown)) return 0;
   if (!option_s_s(bt, &o.conup)) return 0;
   if (!option_s_s(bt, &o.condown)) return 0;
+  if (!option_s_s(bt, &o.conrestart)) return 0;
   if (!option_s_s(bt, &o.macup)) return 0;
   if (!option_s_s(bt, &o.macdown)) return 0;
 #ifdef ENABLE_IEEE8021Q
@@ -511,6 +544,12 @@
   if (!option_s_s(bt, &o.macsuffix)) return 0;
   if (!option_s_s(bt, &o.macpasswd)) return 0;
 
+#ifdef USING_CURL
+  if (!option_s_s(bt, &o.oidcdiscoveryurl)) return 0;
+  if (!option_s_s(bt, &o.oidcclientid)) return 0;
+  if (!option_s_s(bt, &o.oidcclientsecret)) return 0;
+#endif
+
   if (!option_s_s(bt, &o.uamsecret)) return 0;
   if (!option_s_s(bt, &o.uamurl)) return 0;
   if (!option_s_s(bt, &o.uamaaaurl)) return 0;
@@ -520,7 +559,6 @@
   if (!option_s_s(bt, &o.wwwdir)) return 0;
   if (!option_s_s(bt, &o.wwwbin)) return 0;
   if (!option_s_s(bt, &o.uamui)) return 0;
-  if (!option_s_s(bt, &o.localusers)) return 0;
 #ifdef HAVE_SSL
   if (!option_s_s(bt, &o.sslkeyfile)) return 0;
   if (!option_s_s(bt, &o.sslkeypass)) return 0;
@@ -571,6 +609,28 @@
       return 0;
   }
 
+  if (!option_s_s(bt, &o.successurlcustom)) return 0;
+  if (!option_s_s(bt, &o.dbpath)) return 0;
+  if (!option_s_s(bt, &o.usersdbpath)) return 0;
+  if (!option_s_s(bt, &o.usersignup)) return 0;
+  if (!option_s_s(bt, &o.macpass)) return 0;
+  if (!option_s_s(bt, &o.paramuamip)) return 0;
+  if (!option_s_s(bt, &o.paramuamport)) return 0;
+  if (!option_s_s(bt, &o.paramcalled)) return 0;
+  if (!option_s_s(bt, &o.parammac)) return 0;
+  if (!option_s_s(bt, &o.paramip)) return 0;
+  if (!option_s_s(bt, &o.paramnasid)) return 0;
+  if (!option_s_s(bt, &o.paramsessionid)) return 0;
+  if (!option_s_s(bt, &o.paramuserurl)) return 0;
+  if (!option_s_s(bt, &o.paramchallenge)) return 0;
+  if (!option_s_s(bt, &o.param1)) return 0;
+  if (!option_s_s(bt, &o.param1value)) return 0;
+  if (!option_s_s(bt, &o.param2)) return 0;
+  if (!option_s_s(bt, &o.param2value)) return 0;
+#ifdef ENABLE_GSM
+  if (!option_s_s(bt, &o.modemid)) return 0;
+#endif
+
 #ifdef EX_OPTIONS_SAVE
 #include EX_OPTIONS_SAVE
 #endif
@@ -583,32 +643,32 @@
 
   if (fd < 0) {
 
-    syslog(LOG_ERR, "%s: could not save to %s", strerror(errno), file);
+    chilli_log(LOG_ERR, "%s: could not save to %s", strerror(errno), file);
 
     return 0;
 
   } else {
     if (safe_write(fd, &o, sizeof(o)) < 0)
-      syslog(LOG_ERR, "%s: write()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
     size_t len = bt->slen;
 
     if (safe_write(fd, &len, sizeof(len)) < 0)
-      syslog(LOG_ERR, "%s: write()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
     if (safe_write(fd, bt->data, len) < 0)
-      syslog(LOG_ERR, "%s: write()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
     options_md5(&o, cksum);
 
     if (safe_write(fd, cksum, sizeof(cksum)) < 0)
-      syslog(LOG_ERR, "%s: write()", strerror(errno));
+      chilli_log(LOG_ERR, "%s: write()", strerror(errno));
 
     close(fd);
 
     if (_options.uid) {
       if (chown(file, _options.uid, _options.gid)) {
-	syslog(LOG_ERR, "%d could not chown() %s",
+	chilli_log(LOG_ERR, "%d could not chown() %s",
                errno, _options.binconfig);
       }
     }
@@ -622,7 +682,7 @@
   int ok = 0;
   if (fd >= 0) {
     bstring bt = bfromcstr("");
-    syslog(LOG_DEBUG, "PID %d loading binary options file %s", getpid(), file);
+    chilli_log(LOG_DEBUG, "PID %d loading binary options file %s", getpid(), file);
     ok = options_fromfd(fd, bt);
     bdestroy(bt);
     return ok;
@@ -661,7 +721,8 @@
 int reload_options(int argc, char **argv) {
   bstring bt = bfromcstr("");
   int ok = options_load(argc, argv, bt);
-  syslog(LOG_DEBUG, "PID %d reloaded binary options file", getpid());
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "PID %d reloaded binary options file", getpid());
   bdestroy(bt);
   return ok;
 }
@@ -685,14 +746,14 @@
       if (m->destroy)
 	m->destroy(0);
     }
-    syslog(LOG_DEBUG, "Unloading module %s",_options.modules[i].name);
+    chilli_log(LOG_DEBUG, "Unloading module %s",_options.modules[i].name);
     chilli_module_unload(_options.modules[i].ctx);
   }
 #endif
 
   chilli_binconfig(file, sizeof(file), getpid());
-  syslog(LOG_DEBUG, "Removing %s", file);
-  if (remove(file)) syslog(LOG_DEBUG, "remove(%s) failed", file);
+  chilli_log(LOG_DEBUG, "Removing %s", file);
+  if (remove(file)) chilli_log(LOG_DEBUG, "remove(%s) failed", file);
   options_destroy();
 }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/options.h src/src/options.h
--- upstream/src/options.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/options.h	2025-11-06 13:20:13.000000000 +0000
@@ -63,6 +63,7 @@
   char * ipdown;                 /* Script to run after link-down */
   char * conup;                  /* Script to run after session/connection-up */
   char * condown;                /* Script to run after session/connection-down */
+  char * conrestart;             /* Script to run after session info changed */
   char * macup;
   char * macdown;
   int txqlen;
@@ -188,7 +189,10 @@
   uint16_t forcedns2_port;        /* Port to force DNS to */
 #endif
 
+
+
   /* booleans */
+  uint8_t radiusrequiremessageauth:1; /* Radius packets must have valid Message-Authenticator  */
   uint8_t layer3;                   /* Layer3 only support */
   uint8_t allowdyn:1;               /* Allow dynamic address allocation */
   uint8_t allowstat:1;              /* Allow static address allocation */
@@ -240,6 +244,10 @@
   uint8_t uamauthedallowed:1;
   uint8_t postauth_proxyssl:1;
   uint8_t nochallenge:1;
+  uint8_t successuserurl:1;         /* Do not return to the UAM server on success, original url instead */
+  uint8_t maclower:1;
+
+  uint16_t macdelimiter;
 
 #ifdef USING_MMAP
   uint8_t mmapring:1;
@@ -338,6 +346,36 @@
   uint64_t defbandwidthmaxup;
   uint32_t defidletimeout;
   uint16_t definteriminterval;
+  uint64_t defmaxdownload;
+  uint64_t defmaxupload;
+  uint64_t defwarning;
+  uint16_t deflimitperiod;
+  uint16_t deflimitstart;
+  uint64_t defexpirationtime;
+
+  uint64_t dynsessiontimeout;
+  uint64_t dynbandwidthmaxdown;
+  uint64_t dynbandwidthmaxup;
+  uint32_t dynidletimeout;
+  uint16_t dyninteriminterval;
+  uint64_t dynmaxdownload;
+  uint64_t dynmaxupload;
+  uint64_t dynwarning;
+  uint16_t dynlimitperiod;
+  uint16_t dynlimitstart;
+  uint64_t dynexpirationtime;
+
+    uint64_t trialsessiontimeout;
+    uint64_t trialbandwidthmaxdown;
+    uint64_t trialbandwidthmaxup;
+    uint32_t trialidletimeout;
+    uint16_t trialinteriminterval;
+    uint64_t trialmaxdownload;
+    uint64_t trialmaxupload;
+    uint64_t trialwarning;
+    uint16_t triallimitperiod;
+    uint16_t triallimitstart;
+    uint64_t trialexpirationtime;
 
   uint32_t challengetimeout;
   uint32_t challengetimeout2;
@@ -363,7 +401,16 @@
   char *wwwdir;
   char *wwwbin;
   char *uamui;
-  char *localusers;
+  uint8_t localusers:1;
+
+#ifdef USING_CURL
+  /* OIDC configuration */
+  uint8_t oidc:1;
+  uint8_t oidcforcehttps:1;
+  char* oidcdiscoveryurl;
+  char* oidcclientid;
+  char* oidcclientsecret;
+#endif
 
   /* Admin RADIUS Authentication & Configuration */
   char *adminuser;
@@ -388,6 +435,7 @@
 
 #ifdef ENABLE_UAMDOMAINFILE
   char *uamdomainfile;
+  uint8_t uamblocklist:1;
 #endif
 
   /* Command-Socket */
@@ -426,6 +474,37 @@
   char *moddir;
 #endif
 
+  char *successurlcustom;
+  char *dbpath;
+  char *usersdbpath;
+  char * usersignup;                /* Script to run after user has been created */
+  char * macpass;
+#ifdef ENABLE_GSM
+  char *modemid;
+#endif
+  uint8_t smsusers:1;
+  uint8_t macusers:1;
+  uint8_t trialusers:1;
+  uint8_t registerusers:1;
+  uint8_t tos:1;
+  uint8_t duplicateusers:1;
+
+  char *paramuamip;
+  char *paramuamport;
+  char *paramcalled;
+  char *parammac;
+  char *paramip;
+  char *paramnasid;
+  char *paramsessionid;
+  char *paramuserurl;
+  char *paramchallenge;
+  char *param1;
+  char *param1value;
+  char *param2;
+  char *param2value;
+
+  uint8_t testtime:1;
+
   char * _data; /* actual data buffer for loaded options */
 };
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_md5crypt.c src/src/passwd_md5crypt.c
--- upstream/src/passwd_md5crypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,293 @@
+#include "chilli.h"
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+
+#define MD5_CTX MD5_CTX_OpenSSL
+#include <openssl/md5.h>
+#undef MD5_CTX
+
+static unsigned const char cov_2char[64] = {
+	/* from crypto/des/fcrypt.c */
+	0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
+	0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,
+	0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
+	0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
+	0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
+	0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 1 && *src; size--) {
+		*dst++ = *src++;
+		l++;
+	}
+	if (size)
+		*dst = CH_ZERO;
+	return l + strlen(src);
+}
+
+size_t OPENSSL_strlcat(char *dst, const char *src, size_t size)
+{
+	size_t l = 0;
+	for (; size > 0 && *dst; size--, dst++)
+		l++;
+	return l + OPENSSL_strlcpy(dst, src, size);
+}
+
+/*
+ * MD5-based password algorithm (should probably be available as a library
+ * function; then the static buffer would not be acceptable). For magic
+ * string "1", this should be compatible to the MD5-based BSD password
+ * algorithm. For 'magic' string "apr1", this is compatible to the MD5-based
+ * Apache password algorithm. (Apparently, the Apache password algorithm is
+ * identical except that the 'magic' string was changed -- the laziest
+ * application of the NIH principle I've ever encountered.)
+ */
+char *md5crypt(const char *passwd, const char *magic, const char *salt)
+{
+	/* "$apr1$..salt..$.......md5hash..........\0" */
+	static char out_buf[6 + 9 + 24 + 2];
+	unsigned char buf[MD5_DIGEST_LENGTH];
+	char ascii_magic[5]; /* "apr1" plus '\0' */
+	char ascii_salt[9]; /* Max 8 chars plus '\0' */
+	char *ascii_passwd = NULL;
+	char *salt_out;
+	int n;
+	unsigned int i;
+	EVP_MD_CTX *md = NULL, *md2 = NULL;
+	size_t passwd_len, salt_len, magic_len;
+
+	passwd_len = strlen(passwd);
+
+	out_buf[0] = 0;
+	magic_len  = strlen(magic);
+	OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+	if ((magic[0] & 0x80) != 0) /* High bit is 1 in EBCDIC alnums */
+		ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+	/* The salt gets truncated to 8 chars */
+	OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+	salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+	ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+	ascii_passwd = OPENSSL_strdup(passwd);
+	if (ascii_passwd == NULL)
+		return NULL;
+	ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+	passwd = ascii_passwd;
+#endif
+
+	if (magic_len > 0) {
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+
+		if (magic_len > 4) /* assert it's  "1" or "apr1" */
+			goto err;
+
+		OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+		OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+	}
+
+	OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+	if (strlen(out_buf) > 6 + 8) /* assert "$apr1$..salt.." */
+		goto err;
+
+	salt_out = out_buf;
+	if (magic_len > 0)
+		salt_out += 2 + magic_len;
+
+	if (salt_len > 8)
+		goto err;
+
+	md = EVP_MD_CTX_new();
+	if (md == NULL || !EVP_DigestInit_ex(md, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md, passwd, passwd_len))
+		goto err;
+
+	if (magic_len > 0)
+		if (!EVP_DigestUpdate(md, ascii_dollar, 1) ||
+		    !EVP_DigestUpdate(md, ascii_magic, magic_len) ||
+		    !EVP_DigestUpdate(md, ascii_dollar, 1))
+			goto err;
+
+	if (!EVP_DigestUpdate(md, ascii_salt, salt_len))
+		goto err;
+
+	md2 = EVP_MD_CTX_new();
+	if (md2 == NULL || !EVP_DigestInit_ex(md2, EVP_md5(), NULL) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestUpdate(md2, ascii_salt, salt_len) ||
+	    !EVP_DigestUpdate(md2, passwd, passwd_len) ||
+	    !EVP_DigestFinal_ex(md2, buf, NULL))
+		goto err;
+
+	for (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {
+		if (!EVP_DigestUpdate(md, buf, sizeof(buf)))
+			goto err;
+	}
+	if (!EVP_DigestUpdate(md, buf, i))
+		goto err;
+
+	n = passwd_len;
+	while (n) {
+		if (!EVP_DigestUpdate(md, (n & 1) ? "\0" : passwd, 1))
+			goto err;
+		n >>= 1;
+	}
+	if (!EVP_DigestFinal_ex(md, buf, NULL))
+		return NULL;
+
+	for (i = 0; i < 1000; i++) {
+		if (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))
+			goto err;
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? (unsigned const char *)passwd : buf,
+			    (i & 1) ? passwd_len : sizeof(buf)))
+			goto err;
+		if (i % 3) {
+			if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+				goto err;
+		}
+		if (i % 7) {
+			if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+				goto err;
+		}
+		if (!EVP_DigestUpdate(
+			    md2, (i & 1) ? buf : (unsigned const char *)passwd,
+			    (i & 1) ? sizeof(buf) : passwd_len))
+			goto err;
+		if (!EVP_DigestFinal_ex(md2, buf, NULL))
+			goto err;
+	}
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	md2 = NULL;
+	md  = NULL;
+
+	{
+		/* transform buf into output string */
+		unsigned char buf_perm[sizeof(buf)];
+		int dest, source;
+		char *output;
+
+		/* silly output permutation */
+		for (dest = 0, source = 0; dest < 14;
+		     dest++, source   = (source + 6) % 17)
+			  buf_perm[dest] = buf[source];
+		buf_perm[14] = buf[5];
+		buf_perm[15] = buf[11];
+#ifndef PEDANTIC /* Unfortunately, this generates a "no \
+                  * effect" warning */
+		assert(16 == sizeof(buf_perm));
+#endif
+
+		output = salt_out + salt_len;
+		// assert(output == out_buf + strlen(out_buf));
+		if (output != out_buf + strlen(out_buf))
+			return NULL;
+
+		*output++ = ascii_dollar[0];
+
+		for (i = 0; i < 15; i += 3) {
+			*output++ = cov_2char[buf_perm[i + 2] & 0x3f];
+			*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |
+					      (buf_perm[i + 2] >> 6)];
+			*output++ = cov_2char[((buf_perm[i] & 3) << 4) |
+					      (buf_perm[i + 1] >> 4)];
+			*output++ = cov_2char[buf_perm[i] >> 2];
+		}
+		assert(i == 15);
+		*output++ = cov_2char[buf_perm[i] & 0x3f];
+		*output++ = cov_2char[buf_perm[i] >> 6];
+		*output	  = 0;
+		assert(strlen(out_buf) < sizeof(out_buf));
+#ifdef CHARSET_EBCDIC
+		ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+	}
+
+	return out_buf;
+
+err:
+	OPENSSL_free(ascii_passwd);
+	EVP_MD_CTX_free(md2);
+	EVP_MD_CTX_free(md);
+	return NULL;
+}
+
+int make_md5_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 8;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_md5_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(md5crypt(password, "1", salt));
+
+	return NULL;
+}
+
+char *hash_md5(char *password)
+{
+	char *salt = NULL;
+	if (!make_md5_salt(&salt)) {
+		char *hashed = hash_md5_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+// char *extract_salt(char *hash)
+// {
+// 	size_t i	    = 0;
+// 	int salt_offset	    = 0;
+// 	int separator_count = 0;
+// 	char *salt	    = malloc(strlen(hash) + 1);
+
+// 	if (!salt)
+// 		return NULL;
+
+// 	for (; i < strlen(hash); i++) {
+// 		if (separator_count == 1) {
+// 			salt_offset = i + 1;
+// 		} else if (separator_count == 2) {
+// 			salt[i - salt_offset] = hash[i];
+// 		} else if (separator_count >= 3) {
+// 			salt[i - salt_offset - 1] = '\0';
+// 			return salt;
+// 		}
+// 		if (hash[i] == '$')
+// 			separator_count++;
+// 	}
+
+// 	free(salt);
+// 	return NULL;
+// }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_md5crypt.h src/src/passwd_md5crypt.h
--- upstream/src/passwd_md5crypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_md5crypt.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,11 @@
+#ifndef PASSWD_MD5CRYPT_H__
+#define PASSWD_MD5CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+int make_md5_salt(char **salt_p);
+char *hash_md5_with_salt(char *password, char *salt);
+char *hash_md5(char *password);
+// char *extract_salt(char *hash);
+
+#endif /* passwd_md5crypt.h */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_shacrypt.c src/src/passwd_shacrypt.c
--- upstream/src/passwd_shacrypt.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,406 @@
+#include <assert.h>
+#include <openssl/rand.h>
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <string.h>
+
+#include "passwd_shacrypt.h"
+
+static const unsigned char cov_2char[64] = {
+    /* from crypto/des/fcrypt.c */
+    0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
+    0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
+    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
+    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
+    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
+    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
+    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
+    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
+};
+
+static const char ascii_dollar[] = { 0x24, 0x00 };
+
+/*
+ * SHA based password algorithm, describe by Ulrich Drepper here:
+ * https://www.akkadia.org/drepper/SHA-crypt.txt
+ * (note that it's in the public domain)
+ */
+static char *shacrypt(const char *passwd, const char *magic, const char *salt)
+{
+    /* Prefix for optional rounds specification.  */
+    static const char rounds_prefix[] = "rounds=";
+    /* Maximum salt string length.  */
+# define SALT_LEN_MAX 16
+    /* Default number of rounds if not explicitly specified.  */
+# define ROUNDS_DEFAULT 5000
+    /* Minimum number of rounds.  */
+# define ROUNDS_MIN 1000
+    /* Maximum number of rounds.  */
+# define ROUNDS_MAX 999999999
+
+    /* "$6$rounds=<N>$......salt......$...shahash(up to 86 chars)...\0" */
+    static char out_buf[3 + 17 + 17 + 86 + 1];
+    unsigned char buf[SHA512_DIGEST_LENGTH];
+    unsigned char temp_buf[SHA512_DIGEST_LENGTH];
+    size_t buf_size = 0;
+    char ascii_magic[2];
+    char ascii_salt[17];          /* Max 16 chars plus '\0' */
+    char *ascii_passwd = NULL;
+    size_t n;
+    EVP_MD_CTX *md = NULL, *md2 = NULL;
+    const EVP_MD *sha = NULL;
+    size_t passwd_len, salt_len, magic_len;
+    unsigned int rounds = ROUNDS_DEFAULT;        /* Default */
+    char rounds_custom = 0;
+    char *p_bytes = NULL;
+    char *s_bytes = NULL;
+    char *cp = NULL;
+
+    passwd_len = strlen(passwd);
+    magic_len = strlen(magic);
+
+    /* assert it's "5" or "6" */
+    if (magic_len != 1)
+        return NULL;
+
+    switch (magic[0]) {
+    case '5':
+        sha = EVP_sha256();
+        buf_size = 32;
+        break;
+    case '6':
+        sha = EVP_sha512();
+        buf_size = 64;
+        break;
+    default:
+        return NULL;
+    }
+
+    if (strncmp(salt, rounds_prefix, sizeof(rounds_prefix) - 1) == 0) {
+        const char *num = salt + sizeof(rounds_prefix) - 1;
+        char *endp;
+        unsigned long int srounds = strtoul (num, &endp, 10);
+        if (*endp == '$') {
+            salt = endp + 1;
+            if (srounds > ROUNDS_MAX)
+                rounds = ROUNDS_MAX;
+            else if (srounds < ROUNDS_MIN)
+                rounds = ROUNDS_MIN;
+            else
+                rounds = (unsigned int)srounds;
+            rounds_custom = 1;
+        } else {
+            return NULL;
+        }
+    }
+
+    OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));
+#ifdef CHARSET_EBCDIC
+    if ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */
+        ebcdic2ascii(ascii_magic, ascii_magic, magic_len);
+#endif
+
+    /* The salt gets truncated to 16 chars */
+    OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));
+    salt_len = strlen(ascii_salt);
+#ifdef CHARSET_EBCDIC
+    ebcdic2ascii(ascii_salt, ascii_salt, salt_len);
+#endif
+
+#ifdef CHARSET_EBCDIC
+    ascii_passwd = OPENSSL_strdup(passwd);
+    if (ascii_passwd == NULL)
+        return NULL;
+    ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);
+    passwd = ascii_passwd;
+#endif
+
+    out_buf[0] = 0;
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
+    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    if (rounds_custom) {
+        char tmp_buf[80]; /* "rounds=999999999" */
+        sprintf(tmp_buf, "rounds=%u", rounds);
+#ifdef CHARSET_EBCDIC
+        /* In case we're really on a ASCII based platform and just pretend */
+        if (tmp_buf[0] != 0x72)  /* ASCII 'r' */
+            ebcdic2ascii(tmp_buf, tmp_buf, strlen(tmp_buf));
+#endif
+        OPENSSL_strlcat(out_buf, tmp_buf, sizeof(out_buf));
+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
+    }
+    OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));
+
+    /* assert "$5$rounds=999999999$......salt......" */
+    if (strlen(out_buf) > 3 + 17 * rounds_custom + salt_len)
+        goto err;
+
+    md = EVP_MD_CTX_new();
+    if (md == NULL
+        || !EVP_DigestInit_ex(md, sha, NULL)
+        || !EVP_DigestUpdate(md, passwd, passwd_len)
+        || !EVP_DigestUpdate(md, ascii_salt, salt_len))
+        goto err;
+
+    md2 = EVP_MD_CTX_new();
+    if (md2 == NULL
+        || !EVP_DigestInit_ex(md2, sha, NULL)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestUpdate(md2, ascii_salt, salt_len)
+        || !EVP_DigestUpdate(md2, passwd, passwd_len)
+        || !EVP_DigestFinal_ex(md2, buf, NULL))
+        goto err;
+
+    for (n = passwd_len; n > buf_size; n -= buf_size) {
+        if (!EVP_DigestUpdate(md, buf, buf_size))
+            goto err;
+    }
+    if (!EVP_DigestUpdate(md, buf, n))
+        goto err;
+
+    n = passwd_len;
+    while (n) {
+        if (!EVP_DigestUpdate(md,
+                              (n & 1) ? buf : (const unsigned char *)passwd,
+                              (n & 1) ? buf_size : passwd_len))
+            goto err;
+        n >>= 1;
+    }
+    if (!EVP_DigestFinal_ex(md, buf, NULL))
+        goto err;
+
+    /* P sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = passwd_len; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, passwd, passwd_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((p_bytes = OPENSSL_zalloc(passwd_len)) == NULL)
+        goto err;
+    for (cp = p_bytes, n = passwd_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    /* S sequence */
+    if (!EVP_DigestInit_ex(md2, sha, NULL))
+        goto err;
+
+    for (n = 16 + buf[0]; n > 0; n--)
+        if (!EVP_DigestUpdate(md2, ascii_salt, salt_len))
+            goto err;
+
+    if (!EVP_DigestFinal_ex(md2, temp_buf, NULL))
+        goto err;
+
+    if ((s_bytes = OPENSSL_zalloc(salt_len)) == NULL)
+        goto err;
+    for (cp = s_bytes, n = salt_len; n > buf_size; n -= buf_size, cp += buf_size)
+        memcpy(cp, temp_buf, buf_size);
+    memcpy(cp, temp_buf, n);
+
+    for (n = 0; n < rounds; n++) {
+        if (!EVP_DigestInit_ex(md2, sha, NULL))
+            goto err;
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? (const unsigned char *)p_bytes : buf,
+                              (n & 1) ? passwd_len : buf_size))
+            goto err;
+        if (n % 3) {
+            if (!EVP_DigestUpdate(md2, s_bytes, salt_len))
+                goto err;
+        }
+        if (n % 7) {
+            if (!EVP_DigestUpdate(md2, p_bytes, passwd_len))
+                goto err;
+        }
+        if (!EVP_DigestUpdate(md2,
+                              (n & 1) ? buf : (const unsigned char *)p_bytes,
+                              (n & 1) ? buf_size : passwd_len))
+                goto err;
+        if (!EVP_DigestFinal_ex(md2, buf, NULL))
+                goto err;
+    }
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    md2 = NULL;
+    md = NULL;
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    p_bytes = NULL;
+    s_bytes = NULL;
+
+    cp = out_buf + strlen(out_buf);
+    *cp++ = ascii_dollar[0];
+
+# define b64_from_24bit(B2, B1, B0, N)                                   \
+    do {                                                                \
+        unsigned int w = ((B2) << 16) | ((B1) << 8) | (B0);             \
+        int i = (N);                                                    \
+        while (i-- > 0)                                                 \
+            {                                                           \
+                *cp++ = cov_2char[w & 0x3f];                            \
+                w >>= 6;                                                \
+            }                                                           \
+    } while (0)
+
+    switch (magic[0]) {
+    case '5':
+        b64_from_24bit (buf[0], buf[10], buf[20], 4);
+        b64_from_24bit (buf[21], buf[1], buf[11], 4);
+        b64_from_24bit (buf[12], buf[22], buf[2], 4);
+        b64_from_24bit (buf[3], buf[13], buf[23], 4);
+        b64_from_24bit (buf[24], buf[4], buf[14], 4);
+        b64_from_24bit (buf[15], buf[25], buf[5], 4);
+        b64_from_24bit (buf[6], buf[16], buf[26], 4);
+        b64_from_24bit (buf[27], buf[7], buf[17], 4);
+        b64_from_24bit (buf[18], buf[28], buf[8], 4);
+        b64_from_24bit (buf[9], buf[19], buf[29], 4);
+        b64_from_24bit (0, buf[31], buf[30], 3);
+        break;
+    case '6':
+        b64_from_24bit (buf[0], buf[21], buf[42], 4);
+        b64_from_24bit (buf[22], buf[43], buf[1], 4);
+        b64_from_24bit (buf[44], buf[2], buf[23], 4);
+        b64_from_24bit (buf[3], buf[24], buf[45], 4);
+        b64_from_24bit (buf[25], buf[46], buf[4], 4);
+        b64_from_24bit (buf[47], buf[5], buf[26], 4);
+        b64_from_24bit (buf[6], buf[27], buf[48], 4);
+        b64_from_24bit (buf[28], buf[49], buf[7], 4);
+        b64_from_24bit (buf[50], buf[8], buf[29], 4);
+        b64_from_24bit (buf[9], buf[30], buf[51], 4);
+        b64_from_24bit (buf[31], buf[52], buf[10], 4);
+        b64_from_24bit (buf[53], buf[11], buf[32], 4);
+        b64_from_24bit (buf[12], buf[33], buf[54], 4);
+        b64_from_24bit (buf[34], buf[55], buf[13], 4);
+        b64_from_24bit (buf[56], buf[14], buf[35], 4);
+        b64_from_24bit (buf[15], buf[36], buf[57], 4);
+        b64_from_24bit (buf[37], buf[58], buf[16], 4);
+        b64_from_24bit (buf[59], buf[17], buf[38], 4);
+        b64_from_24bit (buf[18], buf[39], buf[60], 4);
+        b64_from_24bit (buf[40], buf[61], buf[19], 4);
+        b64_from_24bit (buf[62], buf[20], buf[41], 4);
+        b64_from_24bit (0, 0, buf[63], 2);
+        break;
+    default:
+        goto err;
+    }
+    *cp = '\0';
+#ifdef CHARSET_EBCDIC
+    ascii2ebcdic(out_buf, out_buf, strlen(out_buf));
+#endif
+
+    return out_buf;
+
+ err:
+    EVP_MD_CTX_free(md2);
+    EVP_MD_CTX_free(md);
+    OPENSSL_free(p_bytes);
+    OPENSSL_free(s_bytes);
+    OPENSSL_free(ascii_passwd);
+    return NULL;
+}
+
+int make_sha512_salt(char **salt_p)
+{
+	if (salt_p == NULL)
+		return -1;
+
+	size_t saltlen = 16;
+	size_t i;
+
+	*salt_p = malloc(saltlen + 1);
+
+	if (RAND_bytes((unsigned char *)*salt_p, saltlen) <= 0)
+		return -1;
+
+	for (i = 0; i < saltlen; i++)
+		(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f]; /* 6 bits */
+	(*salt_p)[i] = 0;
+
+	return 0;
+}
+
+char *hash_sha512_with_salt(char *password, char *salt)
+{
+	if (password != NULL && salt != NULL)
+		return strdup(shacrypt(password, "6", salt));
+
+	return NULL;
+}
+
+char *hash_sha512(char *password)
+{
+	char *salt = NULL;
+	if (!make_sha512_salt(&salt)) {
+		char *hashed = hash_sha512_with_salt(password, salt);
+		free(salt);
+		return hashed;
+	}
+
+	return NULL;
+}
+
+char *extract_salt(char *hash)
+{
+	size_t i	    = 0;
+	int salt_offset	    = 0;
+	int separator_count = 0;
+	char *salt	    = malloc(strlen(hash) + 1);
+
+	if (!salt)
+		return NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1) {
+			salt_offset = i + 1;
+		} else if (separator_count == 2) {
+			salt[i - salt_offset] = hash[i];
+		} else if (separator_count >= 3) {
+			salt[i - salt_offset - 1] = '\0';
+			return salt;
+		}
+		if (hash[i] == '$')
+			separator_count++;
+	}
+
+	free(salt);
+	return NULL;
+}
+
+hash_type get_hash_type(char *hash) {
+	hash_type hash_type = HASH_NULL;
+	size_t i	    = 0;
+	int hash_id_offset	    = 0;
+	int separator_count = 0;
+	char *hash_id	    = malloc(strlen(hash) + 1);
+
+	if (!hash_id)
+		return HASH_NULL;
+
+	for (; i < strlen(hash); i++) {
+		if (separator_count == 1 && hash[i] != '$') {
+			hash_id[i - hash_id_offset] = hash[i];
+		} else {
+			hash_id[i - hash_id_offset] = '\0';
+			hash_id_offset++;
+		}
+		if (hash[i] == '$') {
+			separator_count++;
+		}
+	}
+
+	if (!strcmp(hash_id, "1")) {
+		hash_type = HASH_MD5;
+	} else if (!strcmp(hash_id, "6")) {
+		hash_type = HASH_SHA512;
+	}
+
+	free(hash_id);
+	return hash_type;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/passwd_shacrypt.h src/src/passwd_shacrypt.h
--- upstream/src/passwd_shacrypt.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/passwd_shacrypt.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,18 @@
+#ifndef PASSWD_SHA512CRYPT_H__
+#define PASSWD_SHA512CRYPT_H__
+
+#define CH_ZERO		'\0'
+
+typedef enum {
+	HASH_MD5,
+	HASH_SHA512,
+	HASH_NULL
+} hash_type;
+
+int make_sha512_salt(char **salt_p);
+char *hash_sha512_with_salt(char *password, char *salt);
+char *hash_sha512(char *password);
+char *extract_salt(char *hash);
+hash_type get_hash_type(char *hash);
+
+#endif /* passwd_sha512crypt.h */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/patricia.c src/src/patricia.c
--- upstream/src/patricia.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/patricia.c	2025-11-06 13:20:13.000000000 +0000
@@ -264,7 +264,7 @@
 #endif /* HAVE_IPV6 */
 
   if ((cp = strchr (string, '/')) != NULL) {
-    bitlen = atol (cp + 1);
+    bitlen = strtol(cp + 1, NULL, 0);
     /* *cp = '\0'; */
     /* copy the string to save. Avoid destroying the string */
     assert (cp - string < MAXLINE);
@@ -464,10 +464,10 @@
     if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_search_exact: take right %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_search_exact: take right %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_search_exact: take right at %u",
+	chilli_log(LOG_DEBUG,  "patricia_search_exact: take right at %u",
                node->bit);
       }
 #endif /* PATRICIA_DEBUG */
@@ -476,10 +476,10 @@
     else {
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_search_exact: take left %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_search_exact: take left %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_search_exact: take left at %u",
+	chilli_log(LOG_DEBUG,  "patricia_search_exact: take left at %u",
                node->bit);
       }
 #endif /* PATRICIA_DEBUG */
@@ -492,10 +492,10 @@
 
 #ifdef PATRICIA_DEBUG
   if (node->prefix) {
-    syslog(LOG_DEBUG,  "patricia_search_exact: stop at %s/%d",
+    chilli_log(LOG_DEBUG,  "patricia_search_exact: stop at %s/%d",
            prefix_toa (node->prefix), node->prefix->bitlen);
   } else {
-    syslog(LOG_DEBUG,  "patricia_search_exact: stop at %u", node->bit);
+    chilli_log(LOG_DEBUG,  "patricia_search_exact: stop at %u", node->bit);
   }
 #endif /* PATRICIA_DEBUG */
   if (node->bit > bitlen || node->prefix == NULL)
@@ -505,7 +505,7 @@
   if (comp_with_mask (prefix_tochar (node->prefix), prefix_tochar (prefix),
 		      bitlen)) {
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_search_exact: found %s/%d",
+    chilli_log(LOG_DEBUG,  "patricia_search_exact: found %s/%d",
            prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     return (node);
@@ -539,7 +539,7 @@
 
     if (node->prefix) {
 #ifdef PATRICIA_DEBUG
-      syslog(LOG_DEBUG,  "patricia_search_best: push %s/%d",
+      chilli_log(LOG_DEBUG,  "patricia_search_best: push %s/%d",
              prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
       stack[cnt++] = node;
@@ -548,10 +548,10 @@
     if (BIT_TEST (addr[node->bit >> 3], 0x80 >> (node->bit & 0x07))) {
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_search_best: take right %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_search_best: take right %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_search_best: take right at %u",
+	chilli_log(LOG_DEBUG,  "patricia_search_best: take right at %u",
                node->bit);
       }
 #endif /* PATRICIA_DEBUG */
@@ -560,10 +560,10 @@
     else {
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_search_best: take left %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_search_best: take left %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_search_best: take left at %u",
+	chilli_log(LOG_DEBUG,  "patricia_search_best: take left at %u",
                node->bit);
       }
 #endif /* PATRICIA_DEBUG */
@@ -579,12 +579,12 @@
 
 #ifdef PATRICIA_DEBUG
   if (node == NULL) {
-    syslog(LOG_DEBUG,  "patricia_search_best: stop at null");
+    chilli_log(LOG_DEBUG,  "patricia_search_best: stop at null");
   } else if (node->prefix) {
-    syslog(LOG_DEBUG,  "patricia_search_best: stop at %s/%d",
+    chilli_log(LOG_DEBUG,  "patricia_search_best: stop at %s/%d",
            prefix_toa (node->prefix), node->prefix->bitlen);
   } else {
-    syslog(LOG_DEBUG,  "patricia_search_best: stop at %u", node->bit);
+    chilli_log(LOG_DEBUG,  "patricia_search_best: stop at %u", node->bit);
   }
 #endif /* PATRICIA_DEBUG */
 
@@ -594,14 +594,14 @@
   while (--cnt >= 0) {
     node = stack[cnt];
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_search_best: pop %s/%d",
+    chilli_log(LOG_DEBUG,  "patricia_search_best: pop %s/%d",
            prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     if (comp_with_mask (prefix_tochar (node->prefix),
 			prefix_tochar (prefix),
 			node->prefix->bitlen) && node->prefix->bitlen <= bitlen) {
 
-      syslog(LOG_DEBUG,  "patricia_search_best: found %s/%d",
+      chilli_log(LOG_DEBUG,  "patricia_search_best: found %s/%d",
              prefix_toa (node->prefix), node->prefix->bitlen);
 
       return (node);
@@ -639,7 +639,7 @@
     node->data = NULL;
     patricia->head = node;
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_lookup: new_node #0 %s/%d (head)",
+    chilli_log(LOG_DEBUG,  "patricia_lookup: new_node #0 %s/%d (head)",
            prefix_toa (prefix), prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     patricia->num_active_node++;
@@ -658,10 +658,10 @@
 	break;
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_lookup: take right %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_lookup: take right %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_lookup: take right at %u", node->bit);
+	chilli_log(LOG_DEBUG,  "patricia_lookup: take right at %u", node->bit);
       }
 #endif /* PATRICIA_DEBUG */
       node = node->r;
@@ -671,10 +671,10 @@
 	break;
 #ifdef PATRICIA_DEBUG
       if (node->prefix) {
-	syslog(LOG_DEBUG,  "patricia_lookup: take left %s/%d",
+	chilli_log(LOG_DEBUG,  "patricia_lookup: take left %s/%d",
                prefix_toa (node->prefix), node->prefix->bitlen);
       } else {
-	syslog(LOG_DEBUG,  "patricia_lookup: take left at %u", node->bit);
+	chilli_log(LOG_DEBUG,  "patricia_lookup: take left at %u", node->bit);
       }
 #endif /* PATRICIA_DEBUG */
       node = node->l;
@@ -685,7 +685,7 @@
 
   assert (node->prefix);
 #ifdef PATRICIA_DEBUG
-  syslog(LOG_DEBUG,  "patricia_lookup: stop at %s/%d",
+  chilli_log(LOG_DEBUG,  "patricia_lookup: stop at %s/%d",
          prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
 
@@ -711,7 +711,7 @@
   if (differ_bit > check_bit)
     differ_bit = check_bit;
 #ifdef PATRICIA_DEBUG
-  syslog(LOG_DEBUG,  "patricia_lookup: differ_bit %d", differ_bit);
+  chilli_log(LOG_DEBUG,  "patricia_lookup: differ_bit %d", differ_bit);
 #endif /* PATRICIA_DEBUG */
 
   parent = node->parent;
@@ -720,10 +720,10 @@
     parent = node->parent;
 #ifdef PATRICIA_DEBUG
     if (node->prefix) {
-      syslog(LOG_DEBUG,  "patricia_lookup: up to %s/%d",
+      chilli_log(LOG_DEBUG,  "patricia_lookup: up to %s/%d",
              prefix_toa (node->prefix), node->prefix->bitlen);
     } else {
-      syslog(LOG_DEBUG,  "patricia_lookup: up to %u", node->bit);
+      chilli_log(LOG_DEBUG,  "patricia_lookup: up to %u", node->bit);
     }
 #endif /* PATRICIA_DEBUG */
   }
@@ -731,14 +731,14 @@
   if (differ_bit == bitlen && node->bit == bitlen) {
     if (node->prefix) {
 #ifdef PATRICIA_DEBUG
-      syslog(LOG_DEBUG,  "patricia_lookup: found %s/%d",
+      chilli_log(LOG_DEBUG,  "patricia_lookup: found %s/%d",
              prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
       return (node);
     }
     node->prefix = patricia_prefix_ref (prefix);
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_lookup: new node #1 %s/%d (glue mod)",
+    chilli_log(LOG_DEBUG,  "patricia_lookup: new node #1 %s/%d (glue mod)",
            prefix_toa (prefix), prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     assert (node->data == NULL);
@@ -765,7 +765,7 @@
       node->l = new_node;
     }
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_lookup: new_node #2 %s/%d (child)",
+    chilli_log(LOG_DEBUG,  "patricia_lookup: new_node #2 %s/%d (child)",
            prefix_toa (prefix), prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     return (new_node);
@@ -792,7 +792,7 @@
     }
     node->parent = new_node;
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_lookup: new_node #3 %s/%d (parent)",
+    chilli_log(LOG_DEBUG,  "patricia_lookup: new_node #3 %s/%d (parent)",
            prefix_toa (prefix), prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
   }
@@ -826,7 +826,7 @@
     }
     node->parent = glue;
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_lookup: new_node #4 %s/%d (glue+node)",
+    chilli_log(LOG_DEBUG,  "patricia_lookup: new_node #4 %s/%d (glue+node)",
            prefix_toa (prefix), prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
   }
@@ -844,7 +844,7 @@
 
   if (node->r && node->l) {
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_remove: #0 %s/%d (r & l)",
+    chilli_log(LOG_DEBUG,  "patricia_remove: #0 %s/%d (r & l)",
            prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
 
@@ -860,7 +860,7 @@
 
   if (node->r == NULL && node->l == NULL) {
 #ifdef PATRICIA_DEBUG
-    syslog(LOG_DEBUG,  "patricia_remove: #1 %s/%d (!r & !l)",
+    chilli_log(LOG_DEBUG,  "patricia_remove: #1 %s/%d (!r & !l)",
            prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
     parent = node->parent;
@@ -907,7 +907,7 @@
   }
 
 #ifdef PATRICIA_DEBUG
-  syslog(LOG_DEBUG,  "patricia_remove: #2 %s/%d (r ^ l)",
+  chilli_log(LOG_DEBUG,  "patricia_remove: #2 %s/%d (r ^ l)",
          prefix_toa (node->prefix), node->prefix->bitlen);
 #endif /* PATRICIA_DEBUG */
   if (node->r) {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pkt.c src/src/pkt.c
--- upstream/src/pkt.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/pkt.c	2025-11-06 13:20:13.000000000 +0000
@@ -26,7 +26,7 @@
     /*log_dbg("TCP Window %d", ntohs(tcph->win));*/
     if (ntohs(tcph->win) > win) {
 #if(_debug_ > 1)
-      syslog(LOG_DEBUG, "Rewriting TCP Window %d", win);
+      chilli_log(LOG_DEBUG, "Rewriting TCP Window %d", win);
 #endif
       tcph->win = htons(win);
       chksum(iph);
@@ -46,7 +46,7 @@
     int hasmss = 0;
 
 #if(0)
-    syslog(LOG_DEBUG, "-->> offset: %d", off);
+    chilli_log(LOG_DEBUG, "-->> offset: %d", off);
 #endif
 
     if (off > 15 || off < 0)
@@ -68,24 +68,24 @@
 
           case 1:
 #if(0)
-            syslog(LOG_DEBUG, "TCP OPTIONS: NOP");
+            chilli_log(LOG_DEBUG, "TCP OPTIONS: NOP");
 #endif
             break;
 
           default:
             len = (int) opts[i++];
             if (len < 2 || len > TCP_MAX_OPTION_LEN) {
-              syslog(LOG_ERR, "bad TCP option during parse, len=%d", len);
+              chilli_log(LOG_ERR, "bad TCP option during parse, len=%d", len);
               return -1;
             }
             if (type == 2 && len == 4) {
 #if(1)
-              syslog(LOG_DEBUG, "TCP OPTIONS: MSS %d",
+              chilli_log(LOG_DEBUG, "TCP OPTIONS: MSS %d",
                      ntohs(*((uint16_t *)&opts[i])));
 #endif
               if (ntohs(*((uint16_t *)&opts[i])) > optval) {
 
-                syslog(LOG_DEBUG, "Rewriting TCP MSS to %d", optval);
+                chilli_log(LOG_DEBUG, "Rewriting TCP MSS to %d", optval);
 
                 *((uint16_t *)&opts[i]) = htons(optval);
                 chksum(iph);
@@ -93,7 +93,7 @@
               hasmss = 1;
 #ifdef ENABLE_LEAKYBUCKET
             } else if (_options.scalewin && type == 3 && len == 3) {
-              syslog(LOG_DEBUG, "TCP OPTIONS: window scale was %d",
+              chilli_log(LOG_DEBUG, "TCP OPTIONS: window scale was %d",
                      (int) opts[i]);
               if (opts[i] > 0) {
                 opts[i]=0;
@@ -102,7 +102,7 @@
 #endif
             } else {
 #if(0)
-              syslog(LOG_DEBUG, "TCP OPTIONS: type %d len %d", type, len);
+              chilli_log(LOG_DEBUG, "TCP OPTIONS: type %d len %d", type, len);
 #endif
             }
             i += len - 2;
@@ -115,7 +115,7 @@
       uint8_t p[PKT_BUFFER];
       memcpy(p, packet, *length);
 
-      syslog(LOG_DEBUG, "Adding TCP MSS to %d", optval);
+      chilli_log(LOG_DEBUG, "Adding TCP MSS to %d", optval);
 
       {
 	struct pkt_iphdr_t *p_iph = pkt_iphdr(p);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pkt.h src/src/pkt.h
--- upstream/src/pkt.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/pkt.h	2025-11-06 13:20:13.000000000 +0000
@@ -560,7 +560,20 @@
 #define pkt_buffer_is_eth(pb)  ((pb)->offset == PKT_BUFFER_ETHOFF)
 #define pkt_buffer_is_vlan(pb) ((pb)->offset == PKT_BUFFER_VLANOFF)
 
-#define MAC_FMT "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X"
-#define MAC_ARG(x) (x)[0],(x)[1],(x)[2],(x)[3],(x)[4],(x)[5]
+#define MAC_DELIM_DASH	0
+#define MAC_DELIM_COLON 1
+#define MAC_DELIM_NONE	2
+
+#define MAC_FMT_UPPER_DASH  "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X"
+#define MAC_FMT_UPPER_COLON "%.2X:%.2X:%.2X:%.2X:%.2X:%.2X"
+#define MAC_FMT_UPPER_NONE  "%.2X%.2X%.2X%.2X%.2X%.2X"
+
+#define MAC_FMT_LOWER_DASH  "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
+#define MAC_FMT_LOWER_COLON "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x"
+#define MAC_FMT_LOWER_NONE  "%.2x%.2x%.2x%.2x%.2x%.2x"
+
+#define MAC_FMT MAC_FMT_UPPER_DASH
+
+#define MAC_ARG(x) (x)[0], (x)[1], (x)[2], (x)[3], (x)[4], (x)[5]
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius.c src/src/radius.c
--- upstream/src/radius.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius.c	2025-11-06 13:20:13.000000000 +0000
@@ -25,6 +25,9 @@
 
 #define deeplog 0
 
+static int radius_verify_message_authenticator(struct radius_t *this, 
+		 struct radius_packet_t *pack, struct radius_packet_t *pack_req);
+
 static int
 radius_authcheck(struct radius_t *this, struct radius_packet_t *pack,
 		 struct radius_packet_t *pack_req);
@@ -224,12 +227,12 @@
   qnext = this->qnext;
 
 #if(_debug_ > 1)
-  syslog(LOG_DEBUG, "qnext=%d",qnext);
+  chilli_log(LOG_DEBUG, "qnext=%d",qnext);
 #endif
 
   if (this->queue[qnext].state == 1) {
 
-    syslog(LOG_DEBUG, "skipping over active idx %d radius-id=%d",
+    chilli_log(LOG_DEBUG, "skipping over active idx %d radius-id=%d",
            qnext, RADIUS_QUEUE_PKT(this->queue[qnext].p,id));
 
     if (attempt++ < (this->qsize ? this->qsize : 256)) {
@@ -241,7 +244,7 @@
       goto try_again;
     }
 
-    syslog(LOG_ERR, "radius queue is full! qnext=%d qsize=%d",
+    chilli_log(LOG_ERR, "radius queue is full! qnext=%d qsize=%d",
            qnext, this->qsize);
 
     return -1;
@@ -268,7 +271,7 @@
     idx %= sz;
     if (RADIUS_QUEUE_HASPKT(this->queue[idx].p)) {
 #if(_debug_ > 1)
-      syslog(LOG_DEBUG, "idx %d pid %d id %d", idx,
+      chilli_log(LOG_DEBUG, "idx %d pid %d id %d", idx,
              RADIUS_QUEUE_PKT(this->queue[idx].p,id), id);
 #endif
       if (RADIUS_QUEUE_PKT(this->queue[idx].p,id) == id)
@@ -302,7 +305,7 @@
     return -1;
 
 #if(_debug_ > 1)
-  syslog(LOG_DEBUG, "RADIUS queue-in id=%d idx=%d", pack->id, qnext);
+  chilli_log(LOG_DEBUG, "RADIUS queue-in id=%d idx=%d", pack->id, qnext);
 #endif
 
   /* If packet contains message authenticator: Calculate it! */
@@ -363,7 +366,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "sending radius packet (code=%d, id=%d, len=%d)\n",
+    chilli_log(LOG_DEBUG, "sending radius packet (code=%d, id=%d, len=%d)\n",
            pack->code, pack->id, ntohs(pack->length));
 
     radius_printqueue(2, this);
@@ -390,30 +393,33 @@
   }
 
   if (idx < 0) {
-    syslog(LOG_ERR, "bad idx (%d)", idx);
+    chilli_log(LOG_ERR, "bad idx (%d)", idx);
     return -1;
   }
 
   if (this->queue[idx].state != 1) {
-    syslog(LOG_ERR, "RADIUS id=%d idx=%d with state != 1",
+    chilli_log(LOG_ERR, "RADIUS id=%d idx=%d with state != 1",
            id, idx);
     return -1;
   }
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "radius_queue_out");
+    chilli_log(LOG_DEBUG, "radius_queue_out");
     radius_printqueue(2, this);
   }
 #endif
 
   if (RADIUS_QUEUE_HASPKT(this->queue[idx].p)) {
-    if (pack_in &&
-	radius_authcheck(this, pack_in,
-			 RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
-      syslog(LOG_WARNING, "Authenticator does not match! req-id=%d res-id=%d",
-             RADIUS_QUEUE_PKT(this->queue[idx].p,id),
-             pack_in->id);
+    if (pack_in && radius_authcheck(this, pack_in, RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
+      chilli_log(LOG_WARNING, "Authenticator does not match! req-id=%d res-id=%d",
+            RADIUS_QUEUE_PKT(this->queue[idx].p,id),
+            pack_in->id);
+      return -1;
+    }
+
+    if (pack_in && radius_verify_message_authenticator(this, pack_in, RADIUS_QUEUE_PKTPTR(this->queue[idx].p))) {
+      chilli_log(LOG_WARNING, "Message-Authenticator is invalid!");
       return -1;
     }
 
@@ -425,7 +431,7 @@
 
   *cbp = this->queue[idx].cbp;
 
-  syslog(LOG_DEBUG, "RADIUS queue-out id=%d idx=%d", pack_out->id, idx);
+  chilli_log(LOG_DEBUG, "RADIUS queue-out id=%d idx=%d", pack_out->id, idx);
 
   this->queue[idx].state = 0;
 
@@ -442,7 +448,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "radius_queue_out end");
+    chilli_log(LOG_DEBUG, "radius_queue_out end");
     radius_printqueue(2, this);
   }
 #endif
@@ -458,16 +464,16 @@
   struct timeval *tv;
 
   if (this->queue[idx].state != 1) {
-    syslog(LOG_ERR, "No such id in radius queue: id=%d!", idx);
+    chilli_log(LOG_ERR, "No such id in radius queue: id=%d!", idx);
     return -1;
   }
 
-  syslog(LOG_DEBUG, "Rescheduling RADIUS request id=%d idx=%d",
+  chilli_log(LOG_DEBUG, "Rescheduling RADIUS request id=%d idx=%d",
          RADIUS_QUEUE_PKT(this->queue[idx].p,id), idx);
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "radius_reschedule");
+    chilli_log(LOG_DEBUG, "radius_reschedule");
     radius_printqueue(2, this);
   }
 #endif
@@ -654,7 +660,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "radius_timeout(%d) %8d %8d", this->first,
+    chilli_log(LOG_DEBUG, "radius_timeout(%d) %8d %8d", this->first,
            (int)now.tv_sec, (int)now.tv_usec);
     radius_printqueue(2, this);
   }
@@ -707,14 +713,14 @@
       }
 
       if (radius_queue_reschedule(this, this->first)) {
-	syslog(LOG_WARNING, "Matching request was not found in queue: %d!", this->first);
+	chilli_log(LOG_WARNING, "Matching request was not found in queue: %d!", this->first);
 	return -1;
       }
     }
     else { /* Finished retrans */
       if (radius_queue_out(this, this->first,
 			   0, &pack_req, &cbp)) {
-	syslog(LOG_WARNING, "RADIUS idx=%d was not found in queue!",
+	chilli_log(LOG_WARNING, "RADIUS idx=%d was not found in queue!",
                this->first);
 	return -1;
       }
@@ -731,9 +737,9 @@
 
 #if(_debug_ > 1)
   if (_options.debug) {
-    syslog(LOG_DEBUG, "radius_timeout");
+    chilli_log(LOG_DEBUG, "radius_timeout");
     if (this->first > 0) {
-      syslog(LOG_DEBUG, "first %d, timeout %8d %8d", this->first,
+      chilli_log(LOG_DEBUG, "first %d, timeout %8d %8d", this->first,
 	     (int) this->queue[this->first].timeout.tv_sec,
 	     (int) this->queue[this->first].timeout.tv_usec);
     }
@@ -784,13 +790,13 @@
     }
 
     if (vlen > RADIUS_ATTR_VLEN) {
-      syslog(LOG_WARNING, "Truncating RADIUS attribute (type:%d/%d/%d) from %d to %d bytes [%s]",
+      chilli_log(LOG_WARNING, "Truncating RADIUS attribute (type:%d/%d/%d) from %d to %d bytes [%s]",
              type, vendor_id, vendor_type, vlen, RADIUS_ATTR_VLEN, data);
       vlen = RADIUS_ATTR_VLEN;
     }
 
     if ((length+vlen+2) > RADIUS_PACKSIZE) {
-      syslog(LOG_ERR, "No more space!");
+      chilli_log(LOG_ERR, "No more space!");
       return -1;
     }
 
@@ -817,13 +823,13 @@
     }
 
     if (vlen > RADIUS_ATTR_VLEN-8) {
-      syslog(LOG_WARNING, "Truncating RADIUS attribute (type:%d/%d/%d) from %d to %d [%s]",
+      chilli_log(LOG_WARNING, "Truncating RADIUS attribute (type:%d/%d/%d) from %d to %d [%s]",
              type, vendor_id, vendor_type, vlen, RADIUS_ATTR_VLEN-8, data);
       vlen = RADIUS_ATTR_VLEN-8;
     }
 
     if ((length+vlen+8) > RADIUS_PACKSIZE) {
-      syslog(LOG_ERR, "No more space!");
+      chilli_log(LOG_ERR, "No more space!");
       return -1;
     }
 
@@ -858,7 +864,7 @@
     memcpy(m, state->vsa, state->vsalen);
     length += state->vsalen;
     pack->length = htons(length);
-    syslog(LOG_DEBUG, "Recalled VSA with length %d",length);
+    chilli_log(LOG_DEBUG, "Recalled VSA with length %d",length);
   }
   return 0;
 }
@@ -975,14 +981,14 @@
   int i, n;
 
   if (srclen < 18) {
-    syslog(LOG_ERR, "radius_keydecode MPPE attribute content len must be at least 18, len=%zd", srclen);
+    chilli_log(LOG_ERR, "radius_keydecode MPPE attribute content len must be at least 18, len=%zd", srclen);
     return -1;
   }
 
   blocks = ((int)srclen - 2) / RADIUS_MD5LEN;
 
   if ((blocks * RADIUS_MD5LEN + 2) != (int)srclen) {
-    syslog(LOG_ERR, "radius_keydecode: srclen must be 2 plus n*16");
+    chilli_log(LOG_ERR, "radius_keydecode: srclen must be 2 plus n*16");
     return -1;
   }
 
@@ -997,12 +1003,12 @@
   *dstlen = (size_t)(src[2] ^ b[0]);
 
   if (*dstlen > (srclen - 3)) {
-    syslog(LOG_ERR,"radius_keydecode not enough encrypted data bytes for indicated key length = %zd (bytes)", *dstlen);
+    chilli_log(LOG_ERR,"radius_keydecode not enough encrypted data bytes for indicated key length = %zd (bytes)", *dstlen);
     return -1;
   }
 
   if (*dstlen > dstsize) {
-    syslog(LOG_ERR,"radius_keydecode output buffer for plaintext key is too small");
+    chilli_log(LOG_ERR,"radius_keydecode output buffer for plaintext key is too small");
     return -1;
   }
 
@@ -1047,7 +1053,7 @@
   if ((blocks * RADIUS_MD5LEN) < ((int)srclen + 1)) blocks++;
 
   if (((blocks * RADIUS_MD5LEN) + 2) > (int)dstsize) {
-    syslog(LOG_ERR, "radius_keyencode dstsize too small");
+    chilli_log(LOG_ERR, "radius_keyencode dstsize too small");
     return -1;
   }
 
@@ -1055,7 +1061,7 @@
 
   /* Read two salt octets */
   if (fread(dst, 1, 2, this->urandom_fp) != 2) {
-    syslog(LOG_ERR, "%s: fread() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fread() failed", strerror(errno));
     return -1;
   }
 
@@ -1103,16 +1109,16 @@
   unsigned char output[RADIUS_MD5LEN];
 
 #if(_debug_ > 1)
-  syslog(LOG_DEBUG, "pw decode secret=%s", secret);
+  chilli_log(LOG_DEBUG, "pw decode secret=%s", secret);
 #endif
 
   if (srclen > dstsize) {
-    syslog(LOG_ERR, "radius_pwdecode srclen larger than dstsize");
+    chilli_log(LOG_ERR, "radius_pwdecode srclen larger than dstsize");
     return -1;
   }
 
   if (srclen % RADIUS_MD5LEN) {
-    syslog(LOG_ERR, "radius_pwdecode srclen is not multiple of 16 octets");
+    chilli_log(LOG_ERR, "radius_pwdecode srclen is not multiple of 16 octets");
     return -1;
   }
 
@@ -1190,7 +1196,7 @@
   size_t i, n;
 
 #if(_debug_ > 1)
-  syslog(LOG_DEBUG, "pw encode secret=%s", secret);
+  chilli_log(LOG_DEBUG, "pw encode secret=%s", secret);
 #endif
 
   memset(dst, 0, dstsize);
@@ -1250,7 +1256,7 @@
 
   /* Allocate storage for instance */
   if (!(new_radius = calloc(sizeof(struct radius_t), 1))) {
-    syslog(LOG_ERR, "calloc() failed");
+    chilli_log(LOG_ERR, "calloc() failed");
     return -1;
   }
 
@@ -1298,7 +1304,7 @@
 
   /* Initialise radius socket */
   if ((new_radius->fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
-    syslog(LOG_ERR, "%s: socket() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed!", strerror(errno));
     fclose(new_radius->urandom_fp);
     free(new_radius);
     return -1;
@@ -1309,19 +1315,19 @@
   addr.sin_addr = new_radius->ouraddr;
   addr.sin_port = htons(new_radius->ourport);
 
-  syslog(LOG_DEBUG, "RADIUS client %s:%d",
+  chilli_log(LOG_DEBUG, "RADIUS client %s:%d",
          inet_ntoa(new_radius->ouraddr),
          new_radius->ourport);
 
   if (bind(new_radius->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-    syslog(LOG_ERR, "%s: bind() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: bind() failed!", strerror(errno));
     close(new_radius->fd);
     free(new_radius);
     return -1;
   }
 
   if ((new_radius->urandom_fp = fopen("/dev/urandom", "r")) == 0) {
-    syslog(LOG_ERR, "%s: fopen(/dev/urandom, r) failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fopen(/dev/urandom, r) failed", strerror(errno));
     close(new_radius->fd);
     free(new_radius);
     return -1;
@@ -1331,7 +1337,7 @@
   if (proxy) {     /* Initialise proxy socket */
 
     if ((new_radius->proxyfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
-      syslog(LOG_ERR, "%s: socket() failed for proxyfd!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: socket() failed for proxyfd!", strerror(errno));
       fclose(new_radius->urandom_fp);
       close(new_radius->fd);
       free(new_radius);
@@ -1344,7 +1350,7 @@
     addr.sin_port = htons(new_radius->proxyport);
 
     if (bind(new_radius->proxyfd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
-      syslog(LOG_ERR, "%s: bind() failed for proxylisten!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: bind() failed for proxylisten!", strerror(errno));
       fclose(new_radius->urandom_fp);
       close(new_radius->fd);
       close(new_radius->proxyfd);
@@ -1389,18 +1395,18 @@
   if (this->urandom_fp) {
     fd = fileno(this->urandom_fp);
     if (fclose(this->urandom_fp)) {
-      syslog(LOG_ERR, "radius: %s: fclose(urandom_fp=%d) failed!",
+      chilli_log(LOG_ERR, "radius: %s: fclose(urandom_fp=%d) failed!",
              strerror(errno), fd);
     }
   }
   fd = this->fd;
   if (close(this->fd)) {
-    syslog(LOG_ERR, "radius: %s: close(fd=%d) failed!", strerror(errno), fd);
+    chilli_log(LOG_ERR, "radius: %s: close(fd=%d) failed!", strerror(errno), fd);
   }
 #ifdef ENABLE_RADPROXY
   fd = this->proxyfd;
   if (this->proxyfd > 0 && close(this->proxyfd)) {
-     syslog(LOG_ERR, "radius: %s: close(proxyfd=%d) failed!", strerror(errno),
+     chilli_log(LOG_ERR, "radius: %s: close(proxyfd=%d) failed!", strerror(errno),
             fd);
   }
 #endif
@@ -1423,7 +1429,7 @@
     this->hisaddr1.s_addr = _options.radiusserver2.s_addr;
 
     if ((this->secretlen = strlen(_options.radiussecret)) > RADIUS_SECRETSIZE) {
-      syslog(LOG_ERR, "Radius secret too long. Truncating to %d characters",
+      chilli_log(LOG_ERR, "Radius secret too long. Truncating to %d characters",
              RADIUS_SECRETSIZE);
       this->secretlen = RADIUS_SECRETSIZE;
     }
@@ -1519,7 +1525,7 @@
 
   if (sendto(this->fd, pack, len, 0,(struct sockaddr *) peer,
        sizeof(struct sockaddr_in)) < 0) {
-    syslog(LOG_ERR, "%s: sendto() failed!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: sendto() failed!", strerror(errno));
     return -1;
   }
 
@@ -1539,7 +1545,7 @@
 
   /* Place packet in queue */
   if (radius_queue_in(this, pack, cbp)) {
-    syslog(LOG_ERR, "could not put in queue");
+    chilli_log(LOG_ERR, "could not put in queue");
     return -1;
   }
 
@@ -1559,7 +1565,7 @@
     addr.sin_port = htons(this->authport);
 
 #if(_debug_ > 1)
-  syslog(LOG_DEBUG, "RADIUS id=%d sent to %s:%d",
+  chilli_log(LOG_DEBUG, "RADIUS id=%d sent to %s:%d",
          pack->id,
          inet_ntoa(addr.sin_addr),
          ntohs(addr.sin_port));
@@ -1655,7 +1661,7 @@
 
   if (fread(pack->authenticator, 1, RADIUS_AUTHLEN,
 	    this->urandom_fp) != RADIUS_AUTHLEN) {
-    syslog(LOG_ERR, "%s: fread() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fread() failed", strerror(errno));
     return -1;
   }
 
@@ -1702,6 +1708,40 @@
   return 0;
 }
 
+/*
+ * radius_verify_message_authenticator()
+ * RFC2869 Section 5.14
+ */
+static int radius_verify_message_authenticator(struct radius_t *this, 
+		 struct radius_packet_t *pack, struct radius_packet_t *pack_req)
+{
+  struct radius_attr_t *ma = NULL;
+
+  /* If packet contains message authenticator: Validate it */
+  if (!radius_getattr(pack, &ma, RADIUS_ATTR_MESSAGE_AUTHENTICATOR, 0, 0, 0)) {
+    uint8_t reply[RADIUS_AUTHLEN];
+
+    memcpy(reply, ma->v.t, RADIUS_AUTHLEN);
+    memset(ma->v.t, 0, RADIUS_AUTHLEN);
+
+    memcpy(pack->authenticator, pack_req->authenticator, RADIUS_AUTHLEN);
+
+    radius_hmac_md5(this, pack, this->secret, this->secretlen, ma->v.t);
+
+    if (_options.debug) {
+      chilli_log(LOG_DEBUG, "Message-Authenticator "
+            AUTH_FMT"(pkt) == "AUTH_FMT"(calc)",
+            AUTH_ARG(reply),
+            AUTH_ARG(ma->v.t));
+    }
+
+    if (memcmp(ma->v.t, reply, RADIUS_AUTHLEN) != 0) return 1;
+  /* If packet doesn't contain message authenticator but it's required: Discard packet */
+  } else if (pack_req->code == RADIUS_CODE_ACCESS_REQUEST && _options.radiusrequiremessageauth) {
+    return 1;
+  }
+  return 0;
+}
 
 /*
  * radius_authcheck()
@@ -1725,7 +1765,7 @@
 
   res = memcmp(pack->authenticator, auth, RADIUS_AUTHLEN);
   if (res)
-    syslog(LOG_WARNING, "Authenticator "
+    chilli_log(LOG_WARNING, "Authenticator "
            AUTH_FMT"(pkt) != "AUTH_FMT"(calc)",
            AUTH_ARG(pack->authenticator),
            AUTH_ARG(auth));
@@ -1787,24 +1827,24 @@
 	  continue;
 
 	if (stat(_options.extadmvsa[i].data, &statbuf)) {
-	  syslog(LOG_DEBUG, "Skipping %s, does not exist",
+	  chilli_log(LOG_DEBUG, "Skipping %s, does not exist",
                  _options.extadmvsa[i].data);
 	  continue;
 	}
 
 	if (statbuf.st_size > 127) {
-	  syslog(LOG_ERR, "%d File %s too big",
+	  chilli_log(LOG_ERR, "%d File %s too big",
                  errno, _options.extadmvsa[i].data);
 	  continue;
 	}
 
 	if ((fd = open(_options.extadmvsa[i].data, O_RDONLY)) < 0) {
-	  syslog(LOG_ERR, "%s: Failed to open %s", strerror(errno), _options.extadmvsa[i].data);
+	  chilli_log(LOG_ERR, "%s: Failed to open %s", strerror(errno), _options.extadmvsa[i].data);
 	  continue;
 	}
 
 #if(_debug_)
-	syslog(LOG_DEBUG, "Reading %s", _options.extadmvsa[i].data);
+	chilli_log(LOG_DEBUG, "Reading %s", _options.extadmvsa[i].data);
 #endif
 
 	len = read(fd, b, sizeof(b));
@@ -1833,23 +1873,23 @@
 
 	if (!_options.extadmvsa[i].attr_vsa) {
 #if(_debug_)
-	  syslog(LOG_DEBUG, "looking for attr %d", _options.extadmvsa[i].attr);
+	  chilli_log(LOG_DEBUG, "looking for attr %d", _options.extadmvsa[i].attr);
 #endif
 	  if (radius_getattr(resp, &attr, _options.extadmvsa[i].attr,
 			     0, 0, 0)) {
-	    syslog(LOG_DEBUG, "didn't find attr %d", _options.extadmvsa[i].attr);
+	    chilli_log(LOG_DEBUG, "didn't find attr %d", _options.extadmvsa[i].attr);
 	    attr = 0;
 	  }
 	} else {
 #if(_debug_)
-	  syslog(LOG_DEBUG, "looking for attr %d/%d", _options.extadmvsa[i].attr_vsa,
+	  chilli_log(LOG_DEBUG, "looking for attr %d/%d", _options.extadmvsa[i].attr_vsa,
                  _options.extadmvsa[i].attr);
 #endif
 	  if (radius_getattr(resp, &attr,
 			     RADIUS_ATTR_VENDOR_SPECIFIC,
 			     _options.extadmvsa[i].attr_vsa,
 			     _options.extadmvsa[i].attr, 0)) {
-	    syslog(LOG_DEBUG, "didn't find attr %d/%d", _options.extadmvsa[i].attr_vsa,
+	    chilli_log(LOG_DEBUG, "didn't find attr %d/%d", _options.extadmvsa[i].attr_vsa,
                    _options.extadmvsa[i].attr);
 	    attr = 0;
 	  }
@@ -1858,7 +1898,7 @@
 	  char v[256];
 	  memset(v, 0, sizeof(v));
 	  memcpy(v, attr->v.t, attr->l - 2);
-	  syslog(LOG_DEBUG, "Running script %s %d",
+	  chilli_log(LOG_DEBUG, "Running script %s %d",
                  _options.extadmvsa[i].script,
                  attr->l - 2);
 	  if (chilli_fork(CHILLI_PROC_SCRIPT,
@@ -1872,12 +1912,12 @@
 #endif
                     _options.extadmvsa[i].script,
                     v, (char *) 0) != 0) {
-	      syslog(LOG_ERR, "%d exec %s failed",
+	      chilli_log(LOG_ERR, "%d exec %s failed",
                      errno, _options.extadmvsa[i].script);
 	    }
 	    exit(0);
 	  } else {
-	    syslog(LOG_ERR, "%s: forking %s", strerror(errno), _options.extadmvsa[i].script);
+	    chilli_log(LOG_ERR, "%s: forking %s", strerror(errno), _options.extadmvsa[i].script);
 	  }
 	}
       }
@@ -1900,24 +1940,24 @@
 
   if ((status = recvfrom(this->fd, &pack, sizeof(pack), 0,
 			 (struct sockaddr *) &addr, &fromlen)) <= 0) {
-    syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
     return -1;
   }
 
   if (status < RADIUS_HDRSIZE) {
-    syslog(LOG_WARNING, "Received radius packet which is too short: %zd < %d!",
+    chilli_log(LOG_WARNING, "Received radius packet which is too short: %zd < %d!",
            status, RADIUS_HDRSIZE);
     return -1;
   }
 
   if (ntohs(pack.length) != (uint16_t)status) {
-    syslog(LOG_WARNING,
+    chilli_log(LOG_WARNING,
            "%d Received radius packet with wrong length field %d !=%zd!",
            errno, ntohs(pack.length), status);
     return -1;
   }
 
-  syslog(LOG_DEBUG, "Received RADIUS packet id=%d", pack.id);
+  chilli_log(LOG_DEBUG, "Received RADIUS packet id=%d", pack.id);
 
   switch (pack.code) {
     case RADIUS_CODE_DISCONNECT_REQUEST:
@@ -1926,14 +1966,14 @@
         /* Check that request is from correct address */
         if ((addr.sin_addr.s_addr != this->hisaddr0.s_addr) &&
             (addr.sin_addr.s_addr != this->hisaddr1.s_addr)) {
-          syslog(LOG_WARNING, "Received RADIUS from wrong address %.8x!",
+          chilli_log(LOG_WARNING, "Received RADIUS from wrong address %.8x!",
 		 addr.sin_addr.s_addr);
           return -1;
         }
       }
 
       if (radius_acctcheck(this, &pack)) {
-        syslog(LOG_WARNING, "RADIUS id=%d Authenticator did not match!", pack.id);
+        chilli_log(LOG_WARNING, "RADIUS id=%d Authenticator did not match!", pack.id);
         return -1;
       }
       break;
@@ -1942,7 +1982,7 @@
       /* Check that reply is from correct address */
       if ((addr.sin_addr.s_addr != this->hisaddr0.s_addr) &&
           (addr.sin_addr.s_addr != this->hisaddr1.s_addr)) {
-        syslog(LOG_WARNING, "Received radius reply from wrong address %s!",
+        chilli_log(LOG_WARNING, "Received radius reply from wrong address %s!",
 	       inet_ntoa(addr.sin_addr));
         return -1;
       }
@@ -1950,13 +1990,13 @@
       /* Check that UDP source port is correct */
       if ((addr.sin_port != htons(this->authport)) &&
           (addr.sin_port != htons(this->acctport))) {
-        syslog(LOG_WARNING, "Received radius packet from wrong port %d!",
+        chilli_log(LOG_WARNING, "Received radius packet from wrong port %d!",
 	       ntohs(addr.sin_port));
         return -1;
       }
 
       if (radius_queue_out(this, -1, &pack, &pack_req, &cbp)) {
-        syslog(LOG_WARNING, "RADIUS id %d was not found in queue!",
+        chilli_log(LOG_WARNING, "RADIUS id %d was not found in queue!",
 	       (int) pack.id);
         return -1;
       }
@@ -2028,11 +2068,11 @@
       break;
 #endif
     default:
-      syslog(LOG_WARNING, "Received unknown RADIUS packet %d!", pack.code);
+      chilli_log(LOG_WARNING, "Received unknown RADIUS packet %d!", pack.code);
       return -1;
   }
 
-  syslog(LOG_WARNING, "Received unknown RADIUS packet %d!", pack.code);
+  chilli_log(LOG_WARNING, "Received unknown RADIUS packet %d!", pack.code);
   return -1;
 }
 
@@ -2049,20 +2089,20 @@
 
   if ((status = recvfrom(this->proxyfd, &pack, sizeof(pack), 0,
 			 (struct sockaddr *) &addr, &fromlen)) <= 0) {
-    syslog(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: recvfrom() failed", strerror(errno));
     return -1;
   }
 
-  syslog(LOG_DEBUG, "Received RADIUS proxy packet id=%d", pack.id);
+  chilli_log(LOG_DEBUG, "Received RADIUS proxy packet id=%d", pack.id);
 
   if (status < RADIUS_HDRSIZE) {
-    syslog(LOG_WARNING, "Received RADIUS packet which is too short: %zd < %d!",
+    chilli_log(LOG_WARNING, "Received RADIUS packet which is too short: %zd < %d!",
            status, RADIUS_HDRSIZE);
     return -1;
   }
 
   if (ntohs(pack.length) != (uint16_t)status) {
-    syslog(LOG_ERR, "Received RADIUS packet with wrong length field %d != %zd!",
+    chilli_log(LOG_ERR, "Received RADIUS packet with wrong length field %d != %zd!",
            ntohs(pack.length), status);
     return -1;
   }
@@ -2076,7 +2116,7 @@
     if ( (addr.sin_addr.s_addr   & this->proxymask.s_addr) !=
 	 (this->proxyaddr.s_addr & this->proxymask.s_addr) ) {
 
-      syslog(LOG_WARNING, "Received RADIUS proxy request from wrong address %s",
+      chilli_log(LOG_WARNING, "Received RADIUS proxy request from wrong address %s",
              inet_ntoa(addr.sin_addr));
 
       return -1;
@@ -2085,7 +2125,7 @@
     return this->cb_ind(this, &pack, &addr);
   }
 
-  syslog(LOG_WARNING, "Received unknown RADIUS proxy packet %d!", pack.code);
+  chilli_log(LOG_WARNING, "Received unknown RADIUS proxy packet %d!", pack.code);
   return -1;
 }
 
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius.h src/src/radius.h
--- upstream/src/radius.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius.h	2025-11-06 13:20:13.000000000 +0000
@@ -202,9 +202,9 @@
   struct in_addr addr0;
   struct in_addr addr1;
   char secret[RADIUS_SECRETSIZE];
-  size_t secretlen;
   uint16_t authport;
   uint16_t acctport;
+  size_t secretlen;
 };
 
 struct radius_t {
@@ -224,6 +224,8 @@
 
   struct in_addr hisaddr0;       /* Server address */
   struct in_addr hisaddr1;       /* Server address */
+  /* Padding to separate secret from preceding field */
+  char padding1[2];
   char secret[RADIUS_SECRETSIZE];/* Shared secret */
   size_t secretlen;              /* Length of sharet secret */
 
@@ -241,11 +243,15 @@
   uint16_t proxyport;            /* Proxy port to listen to */
   struct in_addr proxyaddr;      /* Proxy client address */
   struct in_addr proxymask;      /* Proxy client mask */
+  /* Padding to separate proxysecret from preceding field */
+  char padding2[2];
   char proxysecret[RADIUS_SECRETSIZE]; /* Proxy secret */
   size_t proxysecretlen;            /* Length of sharet secret */
 #endif
 
   unsigned char nas_hwaddr[6];   /* Hardware address of NAS */
+  /* Padding to separate debug from preceding field */
+  char padding3[2];
   int debug;                     /* Print debug messages */
 
   int (*cb_ind)       (struct radius_t *radius, struct radius_packet_t *pack,
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/radius_coovachilli.h src/src/radius_coovachilli.h
--- upstream/src/radius_coovachilli.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/radius_coovachilli.h	2025-11-06 13:20:13.000000000 +0000
@@ -49,6 +49,7 @@
 #define	RADIUS_ATTR_COOVACHILLI_LOCATION                  25 /* string */
 #define	RADIUS_ATTR_COOVACHILLI_OLD_LOCATION              26 /* string */
 #define	RADIUS_ATTR_COOVACHILLI_LOCATION_CHANGE_COUNT     27 /* integer */
+#define	RADIUS_ATTR_COOVACHILLI_SSID                      28 /* string */
 
 #define RADIUS_ATTR_COOVACHILLI_SYS_UPTIME                40 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_SYS_LOADAVG               41 /* string */
@@ -84,6 +85,7 @@
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_OCTETS       85 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_INPUT_GIGAWORDS     86 /* integer */
 #define RADIUS_ATTR_COOVACHILLI_OTHER_OUTPUT_GIGAWORDS    87 /* integer */
+#define	RADIUS_ATTR_COOVACHILLI_WARNING_OCTETS            88 /* integer */
 
 #define RADIUS_VALUE_COOVACHILLI_NAS_VIEWPOINT             1
 #define RADIUS_VALUE_COOVACHILLI_CLIENT_VIEWPOINT          2
@@ -100,5 +102,6 @@
 #define RADIUS_VALUE_COOVACHILLI_SESSION_OUT_DATALIMIT_REACHED    15
 #define RADIUS_VALUE_COOVACHILLI_SESSION_TOTAL_DATALIMIT_REACHED  16
 #define RADIUS_VALUE_COOVACHILLI_SESSION_LOCATION_CHANGE          17
+#define RADIUS_VALUE_COOVACHILLI_SESSION_USER_EXPIRED	          18
 
 #endif	/* !_RADIUS_COOVACHILLI_H */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/redir.c src/src/redir.c
--- upstream/src/redir.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.c	2025-11-06 13:20:13.000000000 +0000
@@ -18,21 +18,24 @@
  *
  */
 
+#include <inttypes.h>
 #include "system.h"
 #include "chilli.h"
 #ifdef ENABLE_MODULES
 #include "chilli_module.h"
+#include "chilli_module.h"
 #endif
 #ifdef ENABLE_EWTAPI
 #include "ewt.h"
 #endif
 #include "json/json.h"
+#include <uci.h>
 
 static int optionsdebug = 0; /* TODO: Should be changed to instance */
 
 static int termstate = REDIR_TERM_INIT;    /* When we were terminated */
 
-char credits[] =
+const char credits[] =
     "<H1>CoovaChilli " VERSION "</H1>"
     "<p>Copyright 2002-2005 Mondru AB</p>"
     "<p>Copyright 2006-2012 David Bird (Coova Technologies)</p>"
@@ -45,13 +48,13 @@
 
 /* Termination handler for clean shutdown
    static void redir_termination(int signum) {
-   syslog(LOG_DEBUG, "Terminating redir client!");
+   chilli_log(LOG_DEBUG, "Terminating redir client!");
    exit(0);
    }*/
 
 /* Alarm handler for ensured shutdown */
 static void redir_alarm(int signum) {
-  syslog(LOG_WARNING, "Client process timed out: %d", termstate);
+  chilli_log(LOG_WARNING, "Client process timed out: %d", termstate);
   exit(0);
 }
 
@@ -62,12 +65,12 @@
   if (_options.nochallenge) return 0;
 
   if ((file = fopen("/dev/urandom", "r")) == NULL) {
-    syslog(LOG_ERR, "%s: fopen(/dev/urandom)", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fopen(/dev/urandom)", strerror(errno));
     return -1;
   }
 
   if (fread(dst, 1, REDIR_MD5LEN, file) != REDIR_MD5LEN) {
-    syslog(LOG_ERR, "%s: fread() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fread() failed", strerror(errno));
     fclose(file);
     return -1;
   }
@@ -93,7 +96,7 @@
         case 0:  y = 0;
         case 1:  break;
         default:
-          syslog(LOG_ERR, "%s: HEX conversion failed (src='%s', len=%d, n=%d, y=%d)!",
+          chilli_log(LOG_ERR, "%s: HEX conversion failed (src='%s', len=%d, n=%d, y=%d)!",
                  strerror(errno), src, len, n, y);
           return -1;
       }
@@ -202,16 +205,6 @@
   bcatcstr(s, "P3P: CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"\r\n");
 }
 
-static int bstrtocstr(bstring src, char *dst, unsigned int len) {
-  if (!src || src->slen == 0) {
-    dst[0] = 0;
-    return 0;
-  }
-
-  strlcpy(dst, (char*)src->data, len);
-  return 0;
-}
-
 /* Encode src as urlencoded and place null terminated result in dst */
 int redir_urlencode(bstring src, bstring dst) {
   char x[3];
@@ -314,9 +307,9 @@
   }
 
   /*
-    if (optionsdebug) syslog(LOG_DEBUG, "Base64 encoder: input len: %d\n", len_in);
-    if (optionsdebug) syslog(LOG_DEBUG, "Base64 encoder: output len without padding: %d\n", len_out);
-    if (optionsdebug) syslog(LOG_DEBUG, "Base64 encoder: output len with padding: %d\n", len_out_padd);
+    if (optionsdebug) chilli_log(LOG_DEBUG, "Base64 encoder: input len: %d\n", len_in);
+    if (optionsdebug) chilli_log(LOG_DEBUG, "Base64 encoder: output len without padding: %d\n", len_out);
+    if (optionsdebug) chilli_log(LOG_DEBUG, "Base64 encoder: output len with padding: %d\n", len_out_padd);
   */
 
   while(x_in < len_in) {
@@ -412,21 +405,22 @@
 }
 
 static void bstring_buildurl(bstring str, struct redir_conn_t *conn,
-			     struct redir_t *redir, char *redir_url, char *resp,
+			     struct redir_t *redir, char *redir_url, const char *resp,
 			     long int timeleft, char* hexchal, char* uid,
 			     char* userurl, char* reply, char* redirurl,
 			     uint8_t *hismac, struct in_addr *hisip, char *amp) {
   bstring bt = bfromcstr("");
   bstring bt2 = bfromcstr("");
 
-  bassignformat(str, "%s%sres=%s%suamip=%s%suamport=%d",
-		redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
-		inet_ntoa(redir->addr), amp,
-		redir->port);
+  bassignformat(str, "%s%sres=%s%s%s=%s%s%s=%d",
+                redir_url, strchr(redir_url, '?') ? amp : "?", resp, amp,
+                _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                amp, _options.paramuamport ? _options.paramuamport : "uamport", redir->port);
 
   if (!_options.nochallenge && hexchal) {
     bcatcstr(str, amp);
-    bassignformat(bt, "challenge=%s", hexchal);
+    bassignformat(bt, "%s=%s", _options.paramchallenge ? _options.paramchallenge : "challenge",
+                  hexchal);
     bconcat(str, bt);
     bassigncstr(bt,"");
   }
@@ -440,28 +434,68 @@
       sessiontime = timenow - starttime;
 
       bcatcstr(str, amp);
-      bassignformat(bt, "starttime=%ld", (long) starttime);
+      bassignformat(bt, "starttime=%" PRId64, (uint64_t) starttime);
       bconcat(str, bt);
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontime=%ld", (long) sessiontime);
+      bassignformat(bt, "sessiontime=%" PRId64, (uint64_t) sessiontime);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessiontimeout) {
       bcatcstr(str, amp);
-      bassignformat(bt, "sessiontimeout=%ld", (long) conn->s_params.sessiontimeout);
+      bassignformat(bt, "sessiontimeout=%" PRId64, (uint64_t) conn->s_params.sessiontimeout);
       bconcat(str, bt);
     }
 
     if (conn->s_params.sessionterminatetime) {
       bcatcstr(str, amp);
-      bassignformat(bt, "stoptime=%ld", (long) conn->s_params.sessionterminatetime);
+      bassignformat(bt, "stoptime=%" PRId64, (uint64_t) conn->s_params.sessionterminatetime);
+      bconcat(str, bt);
+    }
+  }
+
+  if (conn->type == REDIR_TRIAL || conn->type == REDIR_LOGIN || conn->type == REDIR_STATUS){
+    if (conn->s_params.maxinputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxinputoctets=%lld", conn->s_params.maxinputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.maxoutputoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "maxoutputoctets=%lld", conn->s_params.maxoutputoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.warningoctets) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "warningoctets=%lld", conn->s_params.warningoctets);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxup) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "bandwidthmaxup=%lld", conn->s_params.bandwidthmaxup);
+      bconcat(str, bt);
+    }
+
+    if (conn->s_params.bandwidthmaxdown) {
+	  bcatcstr(str, amp);
+	  bassignformat(bt, "bandwidthmaxdown=%lld", conn->s_params.bandwidthmaxdown);
+	  bconcat(str, bt);
+	}
+
+    if (conn->s_params.expiration &&
+        conn->s_state.redir.auth_mode != AUTH_TRIAL_USER) {
+      bcatcstr(str, amp);
+      bassignformat(bt, "expiration=%lld", conn->s_params.expiration);
       bconcat(str, bt);
     }
   }
 
   bcatcstr(str, amp);
-  bcatcstr(str, "called=");
+  bcatcstr(str, _options.paramcalled ? _options.paramcalled : "called");
+  bcatcstr(str, "=");
   if (_options.nasmac)
     bassigncstr(bt, _options.nasmac);
   else
@@ -488,7 +522,8 @@
 
   if (hismac) {
     bcatcstr(str, amp);
-    bcatcstr(str, "mac=");
+    bcatcstr(str, _options.parammac ? _options.parammac : "mac");
+    bcatcstr(str, "=");
     bassignformat(bt, "%.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
 		  hismac[0], hismac[1],
 		  hismac[2], hismac[3],
@@ -499,7 +534,7 @@
 
   if (hisip) {
     bcatcstr(str, amp);
-    bassignformat(bt, "ip=%s", inet_ntoa(*hisip));
+    bassignformat(bt, "%s=%s", _options.paramip ? _options.paramip : "ip", inet_ntoa(*hisip));
     bconcat(str, bt);
   }
 
@@ -521,12 +556,45 @@
 
   if (_options.radiusnasid) {
     bcatcstr(str, amp);
-    bcatcstr(str, "nasid=");
+    bcatcstr(str, _options.paramnasid ? _options.paramnasid : "nasid");
+    bcatcstr(str, "=");
     bassigncstr(bt, _options.radiusnasid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+	if (_options.tos) {
+		bcatcstr(str, amp);
+		bcatcstr(str, "tos=1");
+	}
+
+    if (_options.macpass) {
+      bcatcstr(str, amp);
+      bcatcstr(str, "macpass=1");
+    }
+
+#ifdef USING_CURL
+    if (_options.oidc) {
+      bcatcstr(str, amp);
+      bcatcstr(str, "oidc=1");
+    }
+#endif
+
+    if (_options.registerusers) {
+        bcatcstr(str, amp);
+        bcatcstr(str, "signup=1"); 
+    }
+
+  if (_options.trialusers) {
+    bcatcstr(str, amp);
+    bcatcstr(str, "trial=1");
+  }
+
+    if (conn->s_state.terminate_cause_ui){
+		bcatcstr(str, amp);
+		bassignformat(bt, "termcause=%d", (long) conn->s_state.terminate_cause_ui);
+		bconcat(str, bt);
+  	}
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && conn->s_state.tag8021q) {
     bcatcstr(str, amp);
@@ -564,7 +632,7 @@
     redir_urlencode(bt, bt2);
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): found %.*s", __FUNCTION__, __LINE__,
+      chilli_log(LOG_DEBUG, "%s(%d): found %.*s", __FUNCTION__, __LINE__,
              bt->slen, bt->data);
 
     bconcat(str, bt2);
@@ -580,8 +648,8 @@
   }
 
   if (conn->s_state.sessionid[0]) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "sessionid=");
+    bassignformat(bt, "%s%s=", amp, _options.paramsessionid ? _options.paramsessionid : "sessionid");
+    bconcat(str, bt);
     bassigncstr(bt, conn->s_state.sessionid);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
@@ -597,13 +665,19 @@
     bcatcstr(str, amp);
     bcatcstr(str, "ssl=");
     if (_options.uamaliasname && _options.domain) {
-      bassignformat(bt, "https://%s.%s:%d/",
-                    _options.uamaliasname,
-                    _options.domain,
-                    _options.uamuiport);
+      if (_options.redirssl) {
+        bassignformat(bt, "https://%s.%s/",
+              _options.uamaliasname,
+              _options.domain);
+      } else {
+        bassignformat(bt, "https://%s.%s:%d/",
+              _options.uamaliasname,
+              _options.domain,
+              _options.uamuiport);
+      }
     } else {
       bassignformat(bt, "https://%s:%d/",
-                    inet_ntoa(_options.uamalias),
+                    inet_ntoa(_options.uamlisten),
                     _options.uamuiport);
     }
     redir_urlencode(bt, bt2);
@@ -620,13 +694,23 @@
   }
 
   if (userurl) {
-    bcatcstr(str, amp);
-    bcatcstr(str, "userurl=");
+    bassignformat(bt, "%s%s=", amp, _options.paramuserurl ? _options.paramuserurl : "userurl");
+    bconcat(str, bt);
     bassigncstr(bt, userurl);
     redir_urlencode(bt, bt2);
     bconcat(str, bt2);
   }
 
+  if (_options.param1 && _options.param1value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param1, _options.param1value);
+    bconcat(str, bt);
+  }
+
+  if (_options.param2 && _options.param2value){
+    bassignformat(bt, "%s%s=%s", amp, _options.param2, _options.param2value);
+    bconcat(str, bt);
+  }
+
   if (redir->secret && *redir->secret) {
     /* take the md5 of the url+uamsecret as a checksum */
     redir_md_param(str, redir->secret, amp);
@@ -680,8 +764,8 @@
 
         bcatcstr(b, "<State>1</State>\r\n");
 
-        bassignformat(bt, "<StartTime>%d</StartTime>\r\n" ,
-                      conn->s_state.start_time);
+        bassignformat(bt, "<StartTime>%"PRId64"</StartTime>\r\n" ,
+                      (uint64_t)conn->s_state.start_time);
         bconcat(b, bt);
 
         bassignformat(bt, "<SessionTime>%d</SessionTime>\r\n",
@@ -717,6 +801,10 @@
         bassignformat(bt, "<MaxTotalOctets>%d</MaxTotalOctets>\r\n",
                       conn->s_params.maxtotaloctets);
         bconcat(b, bt);
+
+        bassignformat(bt, "<WarningOctets>%d</WarningOctets>\r\n",
+                      conn->s_params.warningoctets);
+        bconcat(b, bt);
       }
       else {
         bcatcstr(b, "<State>0</State>\r\n");
@@ -733,7 +821,10 @@
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       if (reply) {
         bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
         bconcat(b, bt);
@@ -760,9 +851,17 @@
 
     case REDIR_REQERROR:
       break;
-
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
     default:
-      syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
+      chilli_log(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
   bcatcstr(b, "</CoovaChilliSession>\r\n"
 	   "-->\r\n");
@@ -779,9 +878,6 @@
 			 char* reply, char* redirurl, bstring b) {
   bstring bt = bfromcstr("");;
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -816,10 +912,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;&s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -860,7 +958,10 @@
     case REDIR_ERROR_PROTOCOL:
     case REDIR_FAILED_MTU:
     case REDIR_FAILED_TIMEOUT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       bcatcstr(b,
                "<AuthenticationPollReply>\r\n"
                "<MessageType>140</MessageType>\r\n" /* response to authentication notification */
@@ -953,8 +1054,31 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      bcatcstr(b,
+                "<AuthenticationPollReply>\r\n"
+                "<MessageType>170</MessageType>\r\n"  /* response to notification */
+                "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      bcatcstr(b, "</AuthenticationPollReply>\r\n");
+      break;
     default:
-      syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
+      chilli_log(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
   bcatcstr(b, "</WISPAccessGatewayParam>\r\n"
 	   "-->\r\n");
@@ -990,9 +1114,6 @@
   bstring bt = bfromcstr("");
   char eap64str [MAX_EAP_LEN*2];
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d):", __FUNCTION__, __LINE__);
-
   bcatcstr(b,
 	   "<!--\r\n"
 	   "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
@@ -1037,10 +1158,12 @@
         bconcat(b, bt);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;u%s=%s&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bassignformat(bt, "<AbortLoginURL>http://%s:%d/abort</AbortLoginURL>\r\n",
@@ -1053,12 +1176,12 @@
 
       if (!base64encoder(&(conn->authdata.v.eapmsg),
                          eap64str, MAX_EAP_LEN*2)){
-        /*	syslog(LOG_DEBUG, "Encoded radius eap msg: %s", eap64str);  */
+        /*	chilli_log(LOG_DEBUG, "Encoded radius eap msg: %s", eap64str);  */
         bassignformat(bt, "<EAPMsg>%s</EAPMsg>\r\n", eap64str);
         bconcat(b, bt);
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Base64 encoding of eap identity request failed", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Base64 encoding of eap identity request failed", __FUNCTION__, __LINE__);
       }
       bcatcstr(b, "</Redirect>\r\n");
       break;
@@ -1134,7 +1257,10 @@
       write_authentication_msg_footer(conn,b);
       break;
 
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
+    case REDIR_FAILED_TOS:
       write_authentication_msg_header(conn,b);
 
       bcatcstr(b,
@@ -1163,13 +1289,15 @@
         bconcat(b, bt);
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
       }
 
-      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;uamip=%s&amp;continue=1&amp;uamport=%d&amp;challenge=%s</LoginURL>\r\n",
+      bassignformat(bt, "<LoginURL>%s%sres=wispr&amp;%s=%s&amp;continue=1&amp;%s=%d&amp;%s=%s</LoginURL>\r\n",
                     _options.wisprlogin ? _options.wisprlogin : redir->url,
                     strchr(_options.wisprlogin ? _options.wisprlogin : redir->url, '?') ? "&amp;" : "?",
-                    inet_ntoa(redir->addr), redir->port, hexchal);
+                    _options.paramuamip ? _options.paramuamip : "uamip", inet_ntoa(redir->addr),
+                    _options.paramuamport ? _options.paramuamport : "uamport", redir->port,
+                    _options.paramchallenge ? _options.paramchallenge : "challenge", hexchal);
       bconcat(b, bt);
 
       bcatcstr(b, "</EAPAuthenticationReply>\r\n");
@@ -1185,12 +1313,12 @@
         if (!base64encoder(&(conn->authdata.v.eapmsg),
                            eap64str, MAX_EAP_LEN*2)){
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Encoded radius eap msg: %s", __FUNCTION__, __LINE__, eap64str);
+            chilli_log(LOG_DEBUG, "%s(%d): Encoded radius eap msg: %s", __FUNCTION__, __LINE__, eap64str);
           bassignformat(bt, "<EAPMsg>%s</EAPMsg>\r\n", eap64str);
           bconcat(b, bt);
         } else {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): Base64 encoding of radius eap message failed", __FUNCTION__, __LINE__);
         }
       }
 
@@ -1259,8 +1387,27 @@
     case REDIR_REQERROR:
       break;
 
+    case REDIR_SMSSIGNUP_SUCCESS:
+    case REDIR_SMSSIGNUP_FAILED:
+    case REDIR_SMSSIGNUP_ALREADY:
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+    case REDIR_SIGNUP_SUCCESS:
+#ifdef USING_CURL
+    case REDIR_SSO_FAILED:
+#endif
+    	break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      write_authentication_msg_header(conn,b);
+      bcatcstr(b, "<ResponseCode>110</ResponseCode>\r\n");  /* login failed (Users duplicate) */
+      if (reply) {
+        bassignformat(bt, "<ReplyMessage>%s</ReplyMessage>\r\n", reply);
+        bconcat(b, bt);
+      } else {
+        bcatcstr(b, "<ReplyMessage>A user with the entered password already exists!</ReplyMessage>\r\n");
+      }
+      write_authentication_msg_footer(conn, b);
     default:
-      syslog(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
+      chilli_log(LOG_ERR, "redir_wispr1_reply: Unhandled response code in switch: %d", res);
   }
 
   bcatcstr(b, "</WISPAccessGatewayParam>\r\n"
@@ -1300,6 +1447,8 @@
       break;
 
     case REDIR_FAILED_REJECT:
+    case REDIR_FAILED_DATA:
+    case REDIR_FAILED_TIME:
     case REDIR_FAILED_OTHER:
       flg |= FLG_chlg;
       flg |= FLG_redir;
@@ -1412,7 +1561,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): sending json: %s\n", __FUNCTION__, __LINE__, json->data);
+    chilli_log(LOG_DEBUG, "%s(%d): sending json: %s\n", __FUNCTION__, __LINE__, json->data);
 #endif
 
   bdestroy(json);
@@ -1423,7 +1572,7 @@
 #endif
 
 static void redir_buildurl(struct redir_conn_t *conn, bstring str,
-			   struct redir_t *redir, char *resp,
+			   struct redir_t *redir, const char *resp,
 			   long int timeleft, char* hexchal, char* uid,
 			   char* userurl, char* reply, char* redirurl,
 			   uint8_t *hismac, struct in_addr *hisip) {
@@ -1474,7 +1623,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): redir_write(%zd)", __FUNCTION__, __LINE__, len);
+    chilli_log(LOG_DEBUG, "%s(%d): redir_write(%zd)", __FUNCTION__, __LINE__, len);
 #endif
 
   while (r < len) {
@@ -1500,7 +1649,7 @@
 		char* userurl, char* reply, char* redirurl,
 		uint8_t *hismac, struct in_addr *hisip, char *qs) {
 
-  char *resp = NULL;
+  const char *resp = NULL;
   bstring buffer;
 
   switch (res) {
@@ -1508,7 +1657,7 @@
       resp = "already";
       break;
     case REDIR_FAILED_REJECT:
-      resp = "failed&reason=reject";
+        resp = "failed&reason=reject";
       break;
     case REDIR_FAILED_TIMEOUT:
       resp = "failed&reason=timeout";
@@ -1516,10 +1665,19 @@
     case REDIR_FAILED_MTU:
       resp = "failed&reason=mtu";
       break;
+    case REDIR_FAILED_DATA:
+      resp = "failed&reason=data_limit";
+      break;
+    case REDIR_FAILED_TIME:
+      resp = "failed&reason=time_limit";
+        break;
     case REDIR_FAILED_OTHER:
     case REDIR_ERROR_PROTOCOL:
       resp = "failed&reason=other";
       break;
+    case REDIR_FAILED_TOS:
+      resp = "failed&reason=tos";
+      break;
     case REDIR_REQERROR:
       resp = "failed";
       break;
@@ -1530,7 +1688,7 @@
       resp = "logoff";
       break;
     case REDIR_NOTYET:
-      resp = "notyet";
+      resp = (_options.smsusers && conn->s_state.redir.otp_state == 1) ? "notyet&otpstate=active" : "notyet";
       break;
     case REDIR_SPLASH:
       resp = "splash";
@@ -1550,14 +1708,64 @@
     case REDIR_CHALLENGE:
       resp = "challenge";
       break;
+    case REDIR_SMSSIGNUP_FAILED:
+      resp = "smssignup_fail&reason=err";
+      break;
+  	case REDIR_SMSSIGNUP_ALREADY:
+      resp = "smssignup_fail&reason=already";
+      break;
+    case REDIR_SMSSIGNUP_SMS_FAIL:
+      resp = "smssignup_fail&reason=sms";
+      break;
+  	case REDIR_SMSSIGNUP_DENIED:
+      resp = "smssignup_fail&reason=denied";
+      break;
+    case REDIR_SMSSIGNUP_SUCCESS:
+      resp = "smssuccess";
+      break;
+  	case REDIR_SIGNUP_SUCCESS:
+      resp = "signup_success";
+      break;
+  	case REDIR_SIGNUP_FAILED:
+      resp = "signup_fail&reason=err";
+      break;
+  	case REDIR_SIGNUP_ALREADY:
+      resp = "signup_fail&reason=already";
+      break;
+    case REDIR_SIGNUP_DENIED:
+      resp = "signup_fail&reason=denied";
+      break;
+    case REDIR_TRIALLOGIN_DENIED:
+      resp = "failed&reason=trial_denied";
+      break;
+    case REDIR_TRIALLOGIN_FAILED:
+      resp = "failed&reason=trial_fail";
+      break;
+#ifdef USING_CURL
+    case REDIR_SSO_DENIED:
+      resp = "failed&reason=sso_denied";
+      break;
+    case REDIR_SSO_FAILED:
+      resp = "failed&reason=sso_fail";
+      break;
+#endif
+    case REDIR_TRIAL_FAILED_DATA:
+      resp = "failed&reason=data_limit_trial";
+          break;
+    case REDIR_TRIAL_FAILED_TIME:
+      resp = "failed&reason=time_limit_trial";
+          break;
+    case REDIR_FAILED_USER_DUPLICATE:
+      resp = "failed&reason=user_duplicate";
+      break;
     default:
-      syslog(LOG_ERR, "Unknown res in switch");
+      chilli_log(LOG_ERR, "Unknown res in switch");
       return -1;
   }
 
   buffer = bfromcstralloc(1024, "");
   if (!buffer) {
-    syslog(LOG_ERR, "%s: bfromcstralloc() memory allocation error.", __FUNCTION__);
+    chilli_log(LOG_ERR, "%s: bfromcstralloc() memory allocation error.", __FUNCTION__);
     return -1;
   }
 
@@ -1577,12 +1785,10 @@
       bcatcstr(buffer, "Location: ");
 
       if (url) {
-
-        bconcat(buffer, url);
-
-      } else if (!_options.redirurl && redirurl && *redirurl) {
-	bcatcstr(buffer, redirurl);
-      } else {
+          bconcat(buffer, url);
+      }else if (!_options.redirurl && redirurl && *redirurl)
+	    bcatcstr(buffer, redirurl);
+      else {
         bt = bfromcstralloc(1024,"");
         redir_buildurl(conn, bt, redir, resp, timeleft, hexchal,
                        uid, userurl, reply, redirurl, hismac, hisip);
@@ -1646,7 +1852,7 @@
     }
 
   if (redir_write(sock, (char*)buffer->data, buffer->slen) < 0) {
-    syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
     bdestroy(buffer);
     return -1;
   }
@@ -1660,7 +1866,7 @@
 	      struct in_addr *addr, int port, int uiport) {
 
   if (!(*redir = calloc(1, sizeof(struct redir_t)))) {
-    syslog(LOG_ERR, "%s: calloc() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: calloc() failed", strerror(errno));
     return EOF;
   }
 
@@ -1680,7 +1886,7 @@
   int optval;
 
   if ((redir->fd[0] = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -1689,7 +1895,7 @@
 #ifdef ENABLE_UAMUIPORT
   if (redir->uiport) {
     if ((redir->fd[1] = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-      syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
       close(redir->fd[0]);
       return -1;
     }
@@ -1722,7 +1928,7 @@
 
     optval = 1;
     if (setsockopt(redir->fd[n], SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval))) {
-      syslog(LOG_ERR, "%s: setsockopt(SO_REUSEADDR)", strerror(errno));
+      chilli_log(LOG_ERR, "%s: setsockopt(SO_REUSEADDR)", strerror(errno));
       safe_close(redir->fd[n]);
       redir->fd[n]=0;
       break;
@@ -1731,16 +1937,16 @@
 #ifdef SO_REUSEPORT
     optval = 1;
     if (setsockopt(redir->fd[n], SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval))) {
-      syslog(LOG_ERR, "%s: setsockopt(SO_REUSEPORT)", strerror(errno));
+      chilli_log(LOG_ERR, "%s: setsockopt(SO_REUSEPORT)", strerror(errno));
       if (errno != ENOPROTOOPT) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): setsockopt(SO_REUSEPORT) failed hard, aborting.", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): setsockopt(SO_REUSEPORT) failed hard, aborting.", __FUNCTION__, __LINE__);
 	safe_close(redir->fd[n]);
 	redir->fd[n]=0;
 	return -1;
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): setsockopt(SO_REUSEPORT) failed due to proto not available "
+          chilli_log(LOG_DEBUG, "%s(%d): setsockopt(SO_REUSEPORT) failed due to proto not available "
                  "(probably compiled with newer header files), continueing anyways...", __FUNCTION__, __LINE__);
       }
     }
@@ -1748,7 +1954,7 @@
 
     while (bind(redir->fd[n], (struct sockaddr *)&address, sizeof(address)) == -1) {
       if ((EADDRINUSE == errno) && (10 > tries++)) {
-	syslog(LOG_WARNING, "%d IP: %s Port: %d - Waiting for retry.",
+	chilli_log(LOG_WARNING, "%d IP: %s Port: %d - Waiting for retry.",
                errno, inet_ntoa(address.sin_addr), ntohs(address.sin_port));
 	if (sleep(5)) { /* In case we got killed */
 	  safe_close(redir->fd[n]);
@@ -1757,10 +1963,10 @@
 	}
       }
       else {
-	syslog(LOG_ERR, "%d bind() failed for %s:%d",
+	chilli_log(LOG_ERR, "%d bind() failed for %s:%d",
                errno, inet_ntoa(address.sin_addr), ntohs(address.sin_port));
 	if (n == 0 && address.sin_addr.s_addr != INADDR_ANY) {
-	  syslog(LOG_WARNING, "trying INADDR_ANY instead");
+	  chilli_log(LOG_WARNING, "trying INADDR_ANY instead");
 	  address.sin_addr.s_addr = INADDR_ANY;
 	} else {
 	  safe_close(redir->fd[n]);
@@ -1772,7 +1978,7 @@
 
     if (redir->fd[n]) {
       if (listen(redir->fd[n], REDIR_MAXLISTEN)) {
-	syslog(LOG_ERR, "%d listen() failed for %s:%d",
+	chilli_log(LOG_ERR, "%d listen() failed for %s:%d",
                errno, inet_ntoa(address.sin_addr), ntohs(address.sin_port));
 	safe_close(redir->fd[n]);
 	redir->fd[n]=0;
@@ -1793,7 +1999,7 @@
 
   if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
 
-    syslog(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
 
   } else {
 
@@ -1809,18 +2015,18 @@
 
     if (bind(sock, (struct sockaddr *)&local,
 	     sizeof(struct sockaddr_un)) == -1) {
-      syslog(LOG_ERR, "%s: could bind UNIX Socket to %s!", strerror(errno), filedest);
+      chilli_log(LOG_ERR, "%s: could bind UNIX Socket to %s!", strerror(errno), filedest);
       safe_close(sock);
     } else {
       if (listen(sock, 128) == -1) {
-	syslog(LOG_ERR, "%s: could listen to UNIX Socket!", strerror(errno));
+	chilli_log(LOG_ERR, "%s: could listen to UNIX Socket!", strerror(errno));
 	safe_close(sock);
       } else {
 	redir->msgfd = sock;
 
 	if (_options.uid) {
 	  if (chown(filedest, _options.uid, _options.gid)) {
-	    syslog(LOG_ERR, "%s: could not chown() %s", strerror(errno), filedest);
+	    chilli_log(LOG_ERR, "%s: could not chown() %s", strerror(errno), filedest);
 	  }
 	}
       }
@@ -1828,8 +2034,8 @@
   }
 #else
   if ((redir->msgid = msgget(IPC_PRIVATE, 0)) < 0) {
-    syslog(LOG_ERR, "%s: msgget() failed", strerror(errno));
-    syslog(LOG_ERR, "Most likely your computer does not have System V IPC installed");
+    chilli_log(LOG_ERR, "%s: msgget() failed", strerror(errno));
+    chilli_log(LOG_ERR, "Most likely your computer does not have System V IPC installed");
     return -1;
   }
 
@@ -1837,14 +2043,14 @@
     struct msqid_ds ds;
     memset(&ds, 0, sizeof(ds));
     if (msgctl(redir->msgid, IPC_STAT, &ds) < 0) {
-      syslog(LOG_ERR, "%s: msgctl(stat) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: msgctl(stat) failed", strerror(errno));
       return -1;
     }
     ds.msg_perm.uid = _options.uid;
     if (_options.gid) ds.msg_perm.gid = _options.gid;
     ds.msg_perm.mode = (ds.msg_perm.mode & ~0777) | 0600;
     if (msgctl(redir->msgid, IPC_SET, &ds) < 0) {
-      syslog(LOG_ERR, "%s: msgctl(set) failed", strerror(errno));
+      chilli_log(LOG_ERR, "%s: msgctl(set) failed", strerror(errno));
       return -1;
     }
   }
@@ -1862,7 +2068,7 @@
   for (n = 0; n < 2 && redir->fd[n]; n++) {
     fd = redir->fd[n];
     if (safe_close(redir->fd[n])) {
-      syslog(LOG_ERR, "redir: %s: close(fd=%d[%d]) failed", strerror(errno),
+      chilli_log(LOG_ERR, "redir: %s: close(fd=%d[%d]) failed", strerror(errno),
 	     fd, n);
     }
   }
@@ -1871,7 +2077,7 @@
   safe_close(redir->msgfd);
 #else
   if (msgctl(redir->msgid, IPC_RMID, NULL)) {
-    syslog(LOG_ERR, "%s: msgctl() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: msgctl() failed", strerror(errno));
   }
 #endif
 
@@ -1912,7 +2118,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): getparam(%s)", __FUNCTION__, __LINE__, sstr);
+    chilli_log(LOG_DEBUG, "%s(%d): getparam(%s)", __FUNCTION__, __LINE__, sstr);
 #endif
 
   len = strlen(sstr);
@@ -1938,7 +2144,7 @@
     bassigncstr(dst, "");
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): The parameter %s is: [%.*s]", __FUNCTION__, __LINE__, param, dst->slen, dst->data);
+    chilli_log(LOG_DEBUG, "%s(%d): The parameter %s is: [%.*s]", __FUNCTION__, __LINE__, param, dst->slen, dst->data);
 
   return 0;
 }
@@ -1998,12 +2204,12 @@
 
       switch(status) {
         case -1:
-          syslog(LOG_ERR, "%s: select(%d)", strerror(errno), fd);
+          chilli_log(LOG_ERR, "%s: select(%d)", strerror(errno), fd);
           return -1;
 
           /*
             case 0:
-            syslog(LOG_DEBUG, "HTTP request timeout!");
+            chilli_log(LOG_DEBUG, "HTTP request timeout!");
             done = 1;
             break;
           */
@@ -2027,7 +2233,7 @@
     if (read_waiting || !forked) {
 
       if (buflen + 2 >= sizeof(buffer)) { /* ensure space for a least one more byte + null */
-        syslog(LOG_ERR, "Too much data in http request! %d", (int) buflen);
+        chilli_log(LOG_ERR, "Too much data in http request! %d", (int) buflen);
         return -1;
       }
 
@@ -2048,13 +2254,13 @@
 	if (errno == EWOULDBLOCK && !forked) {
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Continue... (would block)", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): Continue... (would block)", __FUNCTION__, __LINE__);
 #endif
 	  wblock = 1;
 	} else {
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): %s_read(%d) failed!", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): %s_read(%d) failed!", __FUNCTION__, __LINE__,
 #ifdef HAVE_SSL
                    sock->sslcon ? "SSL" :
 #endif
@@ -2079,14 +2285,14 @@
     }
 
     if (httpreq->data_in && forked) {
-      syslog(LOG_ERR,"should not happen");
+      chilli_log(LOG_ERR,"should not happen");
       exit(1);
     }
 
     if (httpreq->data_in && !forked) {
-      /*syslog(LOG_DEBUG, "buffer (%d)", httpreq->data_in->slen);*/
+      /*chilli_log(LOG_DEBUG, "buffer (%d)", httpreq->data_in->slen);*/
       if (httpreq->data_in->slen >= sizeof(buffer)) {
-	syslog(LOG_ERR, "buffer too long (%d)", httpreq->data_in->slen);
+	chilli_log(LOG_ERR, "buffer too long (%d)", httpreq->data_in->slen);
 	return -1;
       } else {
 	buflen = httpreq->data_in->slen;
@@ -2097,7 +2303,7 @@
 
     if (buflen == 0) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): No data in HTTP request!", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): No data in HTTP request!", __FUNCTION__, __LINE__);
       if (!forked && wblock) return 1;
       return -1;
     }
@@ -2118,7 +2324,7 @@
 	  httpreq->is_post = 1;
 	} else {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Unhandled http request: %s %d", __FUNCTION__, __LINE__, p1,
+            chilli_log(LOG_DEBUG, "%s(%d): Unhandled http request: %s %d", __FUNCTION__, __LINE__, p1,
                    _options.uamallowpost);
 	  return -1;
 	}
@@ -2136,18 +2342,18 @@
 	}
 
 	if (*p1 == '/') p1++;
-	else { syslog(LOG_ERR, "parse error"); return -1; }
+	else { chilli_log(LOG_ERR, "parse error"); return -1; }
 
 	/* The path ends with a ? or a space */
 	p2 = strchr(p1, qs_delim);
 	if (!p2) { qs_delim = ' '; p2 = strchr(p1, qs_delim); }
-	if (!p2) { syslog(LOG_ERR, "parse error"); return -1; }
+	if (!p2) { chilli_log(LOG_ERR, "parse error"); return -1; }
 	*p2 = 0;
 
 	strlcpy(path, p1, sizeof(httpreq->path));
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): The path: %s", __FUNCTION__, __LINE__, path);
+          chilli_log(LOG_DEBUG, "%s(%d): The path: %s", __FUNCTION__, __LINE__, path);
 
 	/* TODO: Should also check the Host: to make sure we are talking directly to uamlisten */
 
@@ -2163,7 +2369,7 @@
 	  path[last]=0;
 
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): The (json format) path: %s", __FUNCTION__, __LINE__, path);
+            chilli_log(LOG_DEBUG, "%s(%d): The (json format) path: %s", __FUNCTION__, __LINE__, path);
 	}
 #endif
 
@@ -2171,6 +2377,18 @@
 	  conn->type = REDIR_LOGIN;
 	else if ((!strcmp(path, "logoff")) || (!strcmp(path, "logout")))
 	  conn->type = REDIR_LOGOUT;
+	else if (!strcmp(path, "trial"))
+	  conn->type = REDIR_TRIAL;
+    else if ((!strcmp(path, "signup")) || (!strcmp(path, "register")))
+      conn->type = REDIR_SIGNUP;
+    else if ((!strcmp(path, "smssignup")) || (!strcmp(path, "smsregister")))
+      conn->type = REDIR_SMSSIGNUP;
+#ifdef USING_CURL
+    else if (!strcmp(path, "ssologin"))
+      { conn->type = REDIR_SSOLOGIN; }
+    else if (!strcmp(path, "ssocallback"))
+      conn->type = REDIR_SSOCALLBACK;
+#endif
 	else if (!strncmp(path, "www/", 4) && strlen(path) > 4)
 	  conn->type = REDIR_WWW;
 	else if (!strcmp(path, "status"))
@@ -2203,7 +2421,7 @@
 
 #if(_debug_ > 1)
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Query string: %s", __FUNCTION__, __LINE__, httpreq->qs);
+              chilli_log(LOG_DEBUG, "%s(%d): Query string: %s", __FUNCTION__, __LINE__, httpreq->qs);
 #endif
 	  }
 	}
@@ -2211,7 +2429,7 @@
 	/* end of headers */
 #if(_debug_ > 1)
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): end of http-request", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): end of http-request", __FUNCTION__, __LINE__);
 #endif
 	done = 1;
 	eoh = 1;
@@ -2227,17 +2445,26 @@
 	  strlcpy(httpreq->host, p, sizeof(httpreq->host));
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Host: %s", __FUNCTION__, __LINE__, httpreq->host);
+            chilli_log(LOG_DEBUG, "%s(%d): Host: %s", __FUNCTION__, __LINE__, httpreq->host);
 #endif
 	}
 	else if (!strncasecmp(buffer,"Content-Length:",15)) {
 	  p = buffer + 15;
 	  while (*p && isspace((int) *p)) p++;
 	  len = strlen(p);
-	  if (len > 0) httpreq->clen = atoi(p);
+	  if (len > 0) {
+		  char *endptr;
+		  long int clen = strtol(p, &endptr, 10);
+      if(p != endptr && *endptr != '\0')
+      {
+	      httpreq->clen = clen;
+      } else {
+        chilli_log(LOG_DEBUG, "%s(%d): Bad Content-Length: %s", __FUNCTION__, __LINE__, p);
+      }
+	  }
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Content-Length: %s", __FUNCTION__, __LINE__, p);
+            chilli_log(LOG_DEBUG, "%s(%d): Content-Length: %s", __FUNCTION__, __LINE__, p);
 #endif
 	}
 #ifdef ENABLE_USERAGENT
@@ -2248,7 +2475,7 @@
                   p, sizeof(conn->s_state.redir.useragent));
 #if(_debug_)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): User-Agent: %s", __FUNCTION__, __LINE__, conn->s_state.redir.useragent);
+            chilli_log(LOG_DEBUG, "%s(%d): User-Agent: %s", __FUNCTION__, __LINE__, conn->s_state.redir.useragent);
 #endif
 	}
 #endif
@@ -2260,7 +2487,7 @@
                   p, sizeof(conn->s_state.redir.acceptlanguage));
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Accept-Language: %s", __FUNCTION__, __LINE__, conn->s_state.redir.acceptlanguage);
+            chilli_log(LOG_DEBUG, "%s(%d): Accept-Language: %s", __FUNCTION__, __LINE__, conn->s_state.redir.acceptlanguage);
 #endif
 	}
 #endif
@@ -2270,7 +2497,7 @@
 	  strlcpy(conn->httpcookie, p, sizeof(conn->httpcookie));
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Cookie: %s", __FUNCTION__, __LINE__, conn->httpcookie);
+            chilli_log(LOG_DEBUG, "%s(%d): Cookie: %s", __FUNCTION__, __LINE__, conn->httpcookie);
 #endif
 	}
       }
@@ -2280,16 +2507,16 @@
       for (i = 0; i < (int)(buflen - linelen); i++)
 	buffer[i] = buffer[(int)linelen + i];
 
-      /*syslog(LOG_DEBUG, "linelen=%d buflen=%d", linelen, buflen);*/
+
       buflen -= linelen;
     }
 
     if (!forked && !eoh && wblock) {
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Didn't see end of headers, continue...", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Didn't see end of headers, continue...", __FUNCTION__, __LINE__);
 #endif
-      /*syslog(LOG_DEBUG, "%.*s",httpreq->data_in->slen,httpreq->data_in->data);*/
+      /*chilli_log(LOG_DEBUG, "%.*s",httpreq->data_in->slen,httpreq->data_in->data);*/
       return 1;
     }
   }
@@ -2303,7 +2530,7 @@
     case REDIR_EWTAPI:
 #ifdef HAVE_SSL
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): EWT API pre-process", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): EWT API pre-process", __FUNCTION__, __LINE__);
       if (sock->sslcon) {
       }
 #endif
@@ -2317,18 +2544,29 @@
         if (!redir_getparam(redir, httpreq->qs, "lang", bt))
           bstrtocstr(bt, conn->lang, sizeof(conn->lang));
 
+	  	if (_options.tos){
+		  if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+		      if (_options.debug)
+			    chilli_log(LOG_ERR, "No agreetos found in login request");
+
+			  conn->response = REDIR_FAILED_TOS;
+			  bdestroy(bt);
+			  return 0;
+		  }
+		  conn->s_state.redir.tos = 1;
+	  	}
+
         if (redir_getparam(redir, httpreq->qs, "username", bt)) {
-          syslog(LOG_ERR, "No username found in login request");
+          chilli_log(LOG_ERR, "No username found in login request");
           conn->response = REDIR_ERROR_PROTOCOL;
           bdestroy(bt);
           return -1;
         }
 
-        bstrtocstr(bt, conn->s_state.redir.username,
-                   sizeof(conn->s_state.redir.username));
+        besc_strtocstr(bt, conn->s_state.redir.username, sizeof(conn->s_state.redir.username));
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): -->> Setting username=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.username);
+          chilli_log(LOG_DEBUG, "%s(%d): -->> Setting username=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.username);
 
         if (!redir_getparam(redir, httpreq->qs, "userurl", bt)) {
           bstring bt2 = bfromcstr("");
@@ -2336,7 +2574,7 @@
           bstrtocstr(bt2, conn->s_state.redir.userurl,
                      sizeof(conn->s_state.redir.userurl));
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
+            chilli_log(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
           bdestroy(bt2);
         }
 
@@ -2352,16 +2590,16 @@
           if (!strcmp(rxversion, "2.0")) {
             conn->s_state.redir.uamprotocol = REDIR_UAMPROT_WISPR2;
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 2.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
+              chilli_log(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 2.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
           } else {
             conn->s_state.redir.uamprotocol = REDIR_UAMPROT_WISPR1;
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 1.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
+              chilli_log(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 1.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
           }
         } else {
           conn->s_state.redir.uamprotocol = REDIR_UAMPROT_WISPR1;
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 1.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
+            chilli_log(LOG_DEBUG, "%s(%d): using uamprotocol: WISPr 1.0 (%d)", __FUNCTION__, __LINE__, conn->s_state.redir.uamprotocol);
         }
 
         if (!redir_getparam(redir, httpreq->qs, "ntresponse", bt)) {
@@ -2376,11 +2614,16 @@
                           conn->authdata.v.chapmsg.password,
                           RADIUS_CHAPSIZE);
 
-          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen)
-            conn->authdata.v.chapmsg.identity = atoi((char*)bt->data);
-          else
+          if (!redir_getparam(redir, httpreq->qs, "ident", bt) && bt->slen) {
+            char *endptr;
+            unsigned long value = strtoul((char *)bt->data, &endptr, 10);
+            if(*endptr == '\0' && value <= UINT8_MAX) {
+              conn->authdata.v.chapmsg.identity = (uint8_t)value;
+            }
+          } else {
             conn->authdata.v.chapmsg.identity = 0;
-        }
+          }
+	}
         else if (!redir_getparam(redir, httpreq->qs, "password", bt)) {
           conn->authdata.type = REDIR_AUTH_PAP;
           if (_options.nochallenge) {
@@ -2408,7 +2651,7 @@
             int rc;
 
             if (conn->authdata.type != REDIR_AUTH_NONE){
-              syslog(LOG_ERR, "Request contains both password and eap message");
+              chilli_log(LOG_ERR, "Request contains both password and eap message");
               conn->response = REDIR_ERROR_PROTOCOL;
               bdestroy(bt);
               return 0;
@@ -2418,14 +2661,14 @@
                                &(conn->authdata.v.eapmsg));
 
             if (rc == 1) {
-              syslog(LOG_ERR, "EAP message is too big, max allowed 1265 bytes");
+              chilli_log(LOG_ERR, "EAP message is too big, max allowed 1265 bytes");
               conn->response = REDIR_FAILED_MTU;
               bdestroy(bt);
               return 0;
             }
 
             if (rc == 2) {
-              syslog(LOG_ERR, "Invalid EAP message encoding");
+              chilli_log(LOG_ERR, "Invalid EAP message encoding");
               conn->response = REDIR_ERROR_PROTOCOL;
               bdestroy(bt);
               return 0;
@@ -2437,7 +2680,7 @@
                         conn->authdata.v.eapmsg.len, buffer,
                         conn->authdata.v.eapmsg.len*2+1);
               if (_options.debug)
-                syslog(LOG_DEBUG, "%s(%d): decoded eap message from WISPr request (%d): %s", __FUNCTION__, __LINE__,
+                chilli_log(LOG_DEBUG, "%s(%d): decoded eap message from WISPr request (%d): %s", __FUNCTION__, __LINE__,
                        conn->authdata.v.eapmsg.len, buffer);
             }
 
@@ -2447,7 +2690,7 @@
 
         if (conn->authdata.type == REDIR_AUTH_NONE) {
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): No password found!", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): No password found!", __FUNCTION__, __LINE__);
           bdestroy(bt);
           return -1;
         }
@@ -2465,13 +2708,177 @@
           bstrtocstr(bt2, conn->s_state.redir.userurl,
                      sizeof(conn->s_state.redir.userurl));
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
+            chilli_log(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
           bdestroy(bt2);
         }
         bdestroy(bt);
       }
       break;
+    case REDIR_SIGNUP:
+      {
+      	if (!_options.registerusers){
+      	  if (_options.debug)
+			chilli_log(LOG_ERR, "Signup method is not allowed");
+
+          conn->response = REDIR_SIGNUP_DENIED;
+          return 0;
+      	}
+
+        bstring bt = bfromcstr("");
+        if (redir_getparam(redir, httpreq->qs, "email", bt)) {
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No email found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+        besc_strtocstr(bt, conn->s_state.redir.email,
+                       sizeof(conn->s_state.redir.email));
+        if (redir_getparam(redir, httpreq->qs, "phone", bt)) {
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No phone found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.phone,
+                       sizeof(conn->s_state.redir.phone));
+        if (redir_getparam(redir, httpreq->qs, "password", bt)) {
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No password found in signup request");
+
+          conn->response = REDIR_SIGNUP_FAILED;
+          bdestroy(bt);
+          return -1;
+        }
+
+	  	besc_strtocstr(bt, conn->s_state.redir.signup_password,
+                       sizeof(conn->s_state.redir.signup_password));
+        bdestroy(bt);
+      }
+      break;
+    case REDIR_SMSSIGNUP:
+    {
+		if (!_options.smsusers){
+			chilli_log(LOG_ERR, "SMSsignup method not allowed");
+			conn->response = REDIR_SMSSIGNUP_DENIED;
+			return 0;
+		}
+
+		bstring bt = bfromcstr("");
+		if (redir_getparam(redir, httpreq->qs, "phone", bt)){
+		chilli_log(LOG_ERR, "No phone found in smssignup request");
+		conn->response = REDIR_SMSSIGNUP_FAILED;
+		bdestroy(bt);
+		return -1;
+		}
+
+		besc_strtocstr(bt, conn->s_state.redir.phone,
+					 sizeof(conn->s_state.redir.phone));
+		bdestroy(bt);
+    }
+    break;
+    case REDIR_TRIAL:
+    {
+		if (!_options.trialusers){
+			chilli_log(LOG_ERR, "Trial login is not allowed");
+			conn->response = REDIR_TRIALLOGIN_DENIED;
+			return 0;
+		}
+
+      bstring bt = bfromcstr("");
+
+      //if (!redir_getparam(redir, httpreq->qs, "lang", bt))
+        //bstrtocstr(bt, conn->lang, sizeof(conn->lang));
+
+      if (_options.tos){
+        if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No agreetos found in login request");
+
+          conn->response = REDIR_FAILED_TOS;
+          bdestroy(bt);
+          return 0;
+        }
+        conn->s_state.redir.tos = 1;
+      }
+
+      bdestroy(bt);
+    }
+    break;
+#ifdef USING_CURL
+    case REDIR_SSOCALLBACK:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid || !_options.oidcclientsecret) {
+          chilli_log(LOG_ERR, "SSO Login not allowed");
+          conn->response = REDIR_SSO_DENIED;
+          return 0;
+        }
+
+        char state[128];
+        bstring bt = bfromcstr("");
+        if (redir_getparam(redir, httpreq->qs, "state", bt)){
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No state found in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+        bstrtocstr(bt, state, sizeof(state));
+
+        char chal_buffer[64];
+        redir_chartohex(conn->s_state.redir.uamchal, chal_buffer, REDIR_MD5LEN);
+        if(strncmp(state, chal_buffer, sizeof(state))) {
+          if (_options.debug)
+            chilli_log(LOG_ERR, "Invalid state in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+
+        if (redir_getparam(redir, httpreq->qs, "code", bt)){
+          if (_options.debug)
+            chilli_log(LOG_ERR, "No code found in SSO callback");
+
+          conn->response = REDIR_SSO_FAILED;
+          bdestroy(bt);
+          return 0;
+        }
+
+        bstrtocstr(bt, conn->s_state.redir.code, sizeof(conn->s_state.redir.code));
+		    bdestroy(bt);
+      }
+      break;
+    case REDIR_SSOLOGIN:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid || !_options.oidcclientsecret) {
+          chilli_log(LOG_ERR, "SSO Login not allowed");
+          conn->response = REDIR_SSO_DENIED;
+          return 0;
+        }
 
+        bstring bt = bfromcstr("");
+        if (_options.tos) {
+          if (redir_getparam(redir, httpreq->qs, "agreetos", bt)){
+            if (_options.debug)
+              chilli_log(LOG_ERR, "No agreetos found in login request");
+
+            conn->response = REDIR_FAILED_TOS;
+            bdestroy(bt);
+            return 0;
+          }
+          conn->s_state.redir.tos = 1;
+        }
+        bdestroy(bt);
+      }
+      break;
+#endif
     case REDIR_WWW:
       {
         bstring bt = bfromcstr(path+4);
@@ -2479,7 +2886,7 @@
         redir_urldecode(bt, bt2);
         bstrtocstr(bt2, conn->wwwfile, sizeof(conn->wwwfile));
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Serving file %s", __FUNCTION__, __LINE__, conn->wwwfile);
+          chilli_log(LOG_DEBUG, "%s(%d): Serving file %s", __FUNCTION__, __LINE__, conn->wwwfile);
         bdestroy(bt2);
         bdestroy(bt);
       }
@@ -2488,7 +2895,7 @@
 #ifdef ENABLE_WPAD
     case REDIR_WPAD:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): WPAD", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): WPAD", __FUNCTION__, __LINE__);
       break;
 #endif
 
@@ -2502,7 +2909,7 @@
 		      httpreq->qs[0] ? httpreq->qs : "");
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
+          chilli_log(LOG_DEBUG, "%s(%d): -->> Setting userurl=[%s]", __FUNCTION__, __LINE__, conn->s_state.redir.userurl);
       }
       break;
 
@@ -2521,15 +2928,15 @@
   int instance = 0;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Received RADIUS response", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS response", __FUNCTION__, __LINE__);
 
   if (!conn) {
-    syslog(LOG_ERR, "No peer protocol defined");
+    chilli_log(LOG_ERR, "No peer protocol defined");
     return 0;
   }
 
   if (!pack) { /* Timeout */
-    syslog(LOG_ERR, "Radius request timed out");
+    chilli_log(LOG_ERR, "Radius request timed out");
     if (_options.noradallow) {
       conn->response = REDIR_SUCCESS;
       return 0;
@@ -2542,7 +2949,7 @@
   if ((pack->code != RADIUS_CODE_ACCESS_REJECT) &&
       (pack->code != RADIUS_CODE_ACCESS_CHALLENGE) &&
       (pack->code != RADIUS_CODE_ACCESS_ACCEPT)) {
-    syslog(LOG_ERR, "Unknown radius access reply code %d", pack->code);
+    chilli_log(LOG_ERR, "Unknown radius access reply code %d", pack->code);
     conn->response = REDIR_FAILED_OTHER;
     return 0;
   }
@@ -2568,7 +2975,7 @@
       char buffer[conn->s_state.redir.classlen*2+1];
       bytetohex(conn->s_state.redir.classbuf,conn->s_state.redir.classlen,buffer, conn->s_state.redir.classlen*2+1);
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): +attribute Class (%zu bytes): %s", __FUNCTION__, __LINE__, conn->s_state.redir.classlen, buffer);
+        chilli_log(LOG_DEBUG, "%s(%d): +attribute Class (%zu bytes): %s", __FUNCTION__, __LINE__, conn->s_state.redir.classlen, buffer);
     }
   } else {
     conn->s_state.redir.classlen = 0;
@@ -2582,7 +2989,7 @@
       char buffer[conn->s_state.redir.cuilen*2+1];
       bytetohex(conn->s_state.redir.cuibuf,conn->s_state.redir.cuilen,buffer, conn->s_state.redir.cuilen*2+1);
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): +attribute CUI (%zu bytes): %s", __FUNCTION__, __LINE__, conn->s_state.redir.cuilen, buffer);
+        chilli_log(LOG_DEBUG, "%s(%d): +attribute CUI (%zu bytes): %s", __FUNCTION__, __LINE__, conn->s_state.redir.cuilen, buffer);
     }
   } else {
     conn->s_state.redir.cuilen = 0;
@@ -2593,7 +3000,7 @@
     conn->s_state.redir.statelen = attr->l-2;
     memcpy(conn->s_state.redir.statebuf, attr->v.t, attr->l-2);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): +attribute State (%d bytes)", __FUNCTION__, __LINE__, conn->s_state.redir.statelen);
+      chilli_log(LOG_DEBUG, "%s(%d): +attribute State (%d bytes)", __FUNCTION__, __LINE__, conn->s_state.redir.statelen);
   } else {
     conn->s_state.redir.statelen = 0;
   }
@@ -2606,7 +3013,7 @@
     if (!radius_getattr(pack, &attr, RADIUS_ATTR_EAP_MESSAGE, 0, 0,
                         instance++)) {
       if ((conn->authdata.v.eapmsg.len + (size_t)attr->l-2) > MAX_EAP_LEN) {
-	syslog(LOG_ERR, "received EAP message from Radius packet is too big");
+	chilli_log(LOG_ERR, "received EAP message from Radius packet is too big");
 	conn->authdata.v.eapmsg.len = 0;
 	return -1;
       }
@@ -2626,7 +3033,7 @@
     bytetohex(conn->authdata.v.eapmsg.data,
 	      conn->authdata.v.eapmsg.len,buffer,
 	      conn->authdata.v.eapmsg.len*2+1);
-    syslog(LOG_DEBUG, "%s(%d): +attribute EAP msg (%d bytes): %s", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): +attribute EAP msg (%d bytes): %s", __FUNCTION__, __LINE__,
            conn->authdata.v.eapmsg.len, buffer);
   }
 
@@ -2648,11 +3055,11 @@
 			    radius->secretlen) != 0) {
 	bytetosphex(dstbuffer, dstlen, hexString, sizeof(hexString));
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): plainstring MPPE_SEND_KEY: len %zu key %s", __FUNCTION__, __LINE__, dstlen, hexString);
+          chilli_log(LOG_DEBUG, "%s(%d): plainstring MPPE_SEND_KEY: len %zu key %s", __FUNCTION__, __LINE__, dstlen, hexString);
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): received radius MPPE_SEND_KEY attribute (%d bytes): %s", __FUNCTION__, __LINE__, attr->l, hexString);
-	syslog(LOG_ERR, "Decryption of MPPE_SEND_KEY failed");
+          chilli_log(LOG_DEBUG, "%s(%d): received radius MPPE_SEND_KEY attribute (%d bytes): %s", __FUNCTION__, __LINE__, attr->l, hexString);
+	chilli_log(LOG_ERR, "Decryption of MPPE_SEND_KEY failed");
       }
     }
     if (!radius_getattr(pack, &attr, RADIUS_ATTR_VENDOR_SPECIFIC,
@@ -2668,11 +3075,11 @@
 			    radius->secretlen) != 0) {
 	bytetosphex(dstbuffer, dstlen, hexString, sizeof(hexString));
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): plainstring MPPE_RECV_KEY: len %zu key %s", __FUNCTION__, __LINE__, dstlen, hexString);
+          chilli_log(LOG_DEBUG, "%s(%d): plainstring MPPE_RECV_KEY: len %zu key %s", __FUNCTION__, __LINE__, dstlen, hexString);
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): received radius MPPE_RECV_KEY attribute (%d bytes): %s", __FUNCTION__, __LINE__, attr->l, hexString);
-	syslog(LOG_ERR, "Decryption of MPPE_RECV_KEY failed");
+          chilli_log(LOG_DEBUG, "%s(%d): received radius MPPE_RECV_KEY attribute (%d bytes): %s", __FUNCTION__, __LINE__, attr->l, hexString);
+	chilli_log(LOG_ERR, "Decryption of MPPE_RECV_KEY failed");
       }
     }
   }
@@ -2681,7 +3088,7 @@
     time_t timenow = mainclock_now();
     if (timenow > conn->s_params.sessionterminatetime) {
       conn->response = REDIR_FAILED_OTHER;
-      syslog(LOG_WARNING, "WISPr-Session-Terminate-Time in the past received: %s", attrs);
+      chilli_log(LOG_WARNING, "WISPr-Session-Terminate-Time in the past received: %s", attrs);
       return 0;
     }
   }
@@ -2697,7 +3104,7 @@
       conn->response = REDIR_FAILED_REJECT;
       break;
     default:
-      syslog(LOG_ERR, "Unsupported radius access reply code %d", pack->code);
+      chilli_log(LOG_ERR, "Unsupported radius access reply code %d", pack->code);
       return -1;
   }
   return 0;
@@ -2724,12 +3131,12 @@
   int n, m;
 
   if (radius_new(&radius, &redir->radiuslisten, 0, 0, 0)) {
-    syslog(LOG_ERR, "radius_new: Failed to create radius");
+    chilli_log(LOG_ERR, "radius_new: Failed to create radius");
     return -1;
   } 
   
   if (radius_init_q(radius, 8)) {
-    syslog(LOG_ERR, "radius_init: Failed to create radius");
+    chilli_log(LOG_ERR, "radius_init: Failed to create radius");
     radius_free(radius);
     return -1;
   }
@@ -2746,7 +3153,7 @@
   radius_default_pack(radius, &radius_pack, RADIUS_CODE_ACCESS_REQUEST);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): created radius packet (code=%d, id=%d, len=%d)\n", __FUNCTION__, __LINE__, 
+    chilli_log(LOG_DEBUG, "%s(%d): created radius packet (code=%d, id=%d, len=%d)\n", __FUNCTION__, __LINE__, 
            radius_pack.code, radius_pack.id, ntohs(radius_pack.length));
 
   if(conn->lang[0])
@@ -2759,7 +3166,7 @@
 		 strlen(conn->s_state.redir.username));
 
   if (redir->secret && *redir->secret) {
-    //syslog(LOG_DEBUG, "SECRET: [%s]",redir->secret);
+    //chilli_log(LOG_DEBUG, "SECRET: [%s]",redir->secret);
     /* Get MD5 hash on challenge and uamsecret */
     MD5Init(&context);
     MD5Update(&context, conn->s_state.redir.uamchal, REDIR_MD5LEN);
@@ -2789,7 +3196,7 @@
       user_password[conn->authdata.v.papmsg.len] = 0;
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): User password %d [%s]", __FUNCTION__, __LINE__,
+        chilli_log(LOG_DEBUG, "%s(%d): User password %d [%s]", __FUNCTION__, __LINE__,
                conn->authdata.v.papmsg.len, user_password);
 
 #ifdef HAVE_OPENSSL
@@ -2866,7 +3273,7 @@
           if (radius_addattr(radius, &radius_pack,
                              RADIUS_ATTR_EAP_MESSAGE, 0, 0, 0,
                              conn->authdata.v.eapmsg.data + offset, eaplen)) {
-            syslog(LOG_ERR, "EAP message segmentation in EAP attributes failed");
+            chilli_log(LOG_ERR, "EAP message segmentation in EAP attributes failed");
             radius_free(radius);
             return -1;
           }
@@ -2878,13 +3285,13 @@
                     conn->authdata.v.eapmsg.len,buffer,
                     conn->authdata.v.eapmsg.len*2+1);
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): +attribute EAP msg (%d bytes): %s", __FUNCTION__, __LINE__,
+            chilli_log(LOG_DEBUG, "%s(%d): +attribute EAP msg (%d bytes): %s", __FUNCTION__, __LINE__,
                    conn->authdata.v.eapmsg.len, buffer);
         }
       }
       break;
     default:
-      syslog(LOG_ERR, "Invalid authentication type: %d",
+      chilli_log(LOG_ERR, "Invalid authentication type: %d",
              conn->authdata.type);
       radius_free(radius);
       return -1;
@@ -2914,7 +3321,7 @@
 		 0, 0, 0, NULL, RADIUS_MD5LEN);
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): sending radius packet (code=%d, id=%d, len=%d)\n", __FUNCTION__, __LINE__,
+    chilli_log(LOG_DEBUG, "%s(%d): sending radius packet (code=%d, id=%d, len=%d)\n", __FUNCTION__, __LINE__,
            radius_pack.code, radius_pack.id, ntohs(radius_pack.length));
 
   radius_req(radius, &radius_pack, conn);
@@ -2933,7 +3340,7 @@
 
     switch (status = select(maxfd + 1, &fds, NULL, NULL, &idleTime)) {
       case -1:
-        syslog(LOG_ERR, "%s: select() returned -1!", strerror(errno));
+        chilli_log(LOG_ERR, "%s: select() returned -1!", strerror(errno));
         break;
       case 0:
         radius_timeout(radius);
@@ -2945,7 +3352,7 @@
     if (status > 0) {
       if ((radius->fd != -1) && FD_ISSET(radius->fd, &fds) &&
 	  radius_decaps(radius, 0) < 0) {
-	syslog(LOG_ERR, "radius_ind() failed!");
+	chilli_log(LOG_ERR, "radius_ind() failed!");
       }
     }
 
@@ -2961,32 +3368,254 @@
   return 0;
 }
 
-int is_local_user(struct redir_t *redir, struct redir_conn_t *conn) {
-  uint8_t user_password[RADIUS_PWSIZE+1];
-  uint8_t chap_challenge[REDIR_MD5LEN];
-  char u[256]; char p[256];
-  size_t usernamelen, sz=1024;
-  ssize_t len;
-  int match=0;
-  char *line=0;
-  MD5_CTX context;
-  FILE *f;
+void session_param_from_config(struct session_params *params, const char *group_name) {
+  const char *tmp = NULL;
+
+  struct uci_context *uci_ctx = uci_alloc_context();
+  if (!uci_ctx) {
+    chilli_log(LOG_ERR, "Failed to allocate uci context");
+    return;
+  }
+
+  struct uci_package *package = NULL;
+  if (uci_load(uci_ctx, CHILLI_CONFIG, &package)) {
+    chilli_log(LOG_ERR, "Failed to load '%s' config", CHILLI_CONFIG);
+    uci_free_context(uci_ctx);
+    return;
+  }
+
+  struct uci_element *e = NULL;
+  uci_foreach_element(&package->sections, e) {
+    struct uci_section *s = uci_to_section(e);
+    if (!s || strcmp(s->type, "group"))
+      continue;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "name");
+    if (!tmp || strcmp(tmp, group_name))
+      continue;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "defsessiontimeout");
+    params->sessiontimeout = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "defidletimeout");
+    params->idletimeout = tmp ? strtoul(tmp, NULL, 0) : 0;
 
-  if (!_options.localusers) return 0;
+    tmp = uci_lookup_option_string(uci_ctx, s, "downloadlimit");
+    params->maxinputoctets = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "uploadlimit");
+    params->maxoutputoctets = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "downloadbandwidth");
+    params->bandwidthmaxdown = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "uploadbandwidth");
+    params->bandwidthmaxup = tmp ? strtoull(tmp, NULL, 0) : 0;
+
+    tmp = uci_lookup_option_string(uci_ctx, s, "period");
+    params->period = tmp ? strtol(tmp, NULL, 0) : 3;
+
+    switch (params->period) {
+    case 3:
+      tmp = uci_lookup_option_string(uci_ctx, s, "day");
+      break;
+    case 2:
+      tmp = uci_lookup_option_string(uci_ctx, s, "weekday");
+      break;
+    case 1:
+      tmp = uci_lookup_option_string(uci_ctx, s, "hour");
+      break;
+    default:
+      tmp = NULL;
+      break;
+    }
+    params->start = tmp ? strtol(tmp, NULL, 0) : 1;
+    goto clean;
+  }
+
+  params->sessiontimeout = 0;
+  params->idletimeout = 0;
+  params->maxinputoctets = 0;
+  params->maxoutputoctets = 0;
+  params->bandwidthmaxdown = 0;
+  params->bandwidthmaxup = 0;
+  params->period = 3;
+  params->start = 1;
+
+clean:
+  uci_unload(uci_ctx, package);
+  uci_free_context(uci_ctx);
+}
+
+int auth_chap(struct redir_conn_t *conn, MD5_CTX *context, uint8_t *chap_challenge,
+		uint8_t *user_password, char *password)
+{
+    uint8_t tmp[REDIR_MD5LEN];
+    MD5Init(context);
+    MD5Update(context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
+    MD5Update(context, (uint8_t*)password, strlen(password));
+    MD5Update(context, chap_challenge, REDIR_MD5LEN);
+    MD5Final(tmp, context);
+
+    if (!memcmp(user_password, tmp,  REDIR_MD5LEN)) {
+		return ACCESS_ACCEPTED;
+	}
+    else {
+      if (_options.debug)
+		chilli_log(LOG_INFO, "%s(%d): bad password", __FUNCTION__, __LINE__);
+	}
+
+	return ACCESS_DENIED;
+}
+
+void mac_block_invoke(const char *command, struct redir_conn_t *conn)
+{
+  uint32_t tmp_id = 0;
+  struct blob_buf b = { 0 };
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  ubus_ctx = ubus_connect(NULL);
+  if (!ubus_ctx) {
+    chilli_log(LOG_WARNING, "Warning: Failed to connect to ubus.");
+    return;
+  }
+
+  int ret = ubus_lookup_id(ubus_ctx, "ip_block", &tmp_id);
+  if (ret) {
+    chilli_log(LOG_WARNING, "Warning: Failed to find 'ip_block' object.");
+    goto end;
+  }
+
+  blob_buf_init(&b, 0);
+  blobmsg_add_string(&b, "mac", mac);
+  void *r = blobmsg_open_array(&b, "interface");
+  if(_options.dhcpif)
+    blobmsg_add_string(&b, NULL, _options.dhcpif);
+  for (int i = 0; i < MAX_MOREIF; i++) {
+    if(!_options.moreif[i].dhcpif)
+	    continue;
+    blobmsg_add_string(&b, NULL, _options.moreif[i].dhcpif);
+	}
+  blobmsg_close_array(&b, r);
+
+  ubus_invoke(ubus_ctx, tmp_id, command, b.head, NULL, NULL, 1000);
+  blob_buf_free(&b);
+
+end:
+  ubus_free(ubus_ctx);
+}
+
+int authenticator(struct redir_t *redir, struct redir_conn_t *conn, MD5_CTX *context,
+			  uint8_t *user_password, uint8_t *chap_challenge)
+{
+  char username_escaped[REDIR_USERNAMESIZE + 1];
+  int match = ACCESS_DENIED;
+	struct str_luser user;
+  sqlite3 *db;
+
+  if (!_options.usersdbpath)
+    return ACCESS_DENIED;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__, _options.localusers, conn->s_state.redir.username);
+    chilli_log(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.usersdbpath, conn->s_state.redir.username);
 
-  if (!(f = fopen(_options.localusers, "r"))) {
-    syslog(LOG_ERR, "%s: fopen() failed opening %s!", strerror(errno), _options.localusers);
-    return 0;
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    chilli_log(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return ACCESS_DENIED;
+  }
+
+  escape_cstr(conn->s_state.redir.username, username_escaped);
+  if (_options.debug)
+    chilli_log(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
+
+  if (!lusr_get_user(db, &user, username_escaped) &&
+	    !strncmp(user.username, username_escaped, USER_USERNAMENAMESIZE)) {
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+    char *salt = extract_salt(user.password);
+    char *plain_password = strndup((char *)user_password, sizeof(user.password));
+
+    if (salt) {
+      user_password	 = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
+
+      if (!user_password) {
+        chilli_log(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+          __FUNCTION__, __LINE__, user.username);
+        // When hashing fails, make sure password check fails too
+        user_password = (uint8_t *)strdup("");
+      }
+
+      // Check for hash match, if hashes do not match, try again with MD5 hash
+      if (strncmp((char *)user_password, user.password, sizeof(user.password))) {
+        user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+        if (!user_password) {
+          chilli_log(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+            __FUNCTION__, __LINE__, user.username);
+          // When hashing fails, make sure password check fails too
+          user_password = (uint8_t *)strdup("");
+        }
+      }
+}
+#endif
+      if (!strncmp((char *)user_password, user.password, sizeof(user.password))) {
+#ifdef HAVE_OPENSSL
+        // Update password hash on the database
+        if(get_hash_type(user.password) == HASH_MD5) {
+          chilli_log(LOG_INFO, "%s(%d): updating user MD5 hash to SHA-512",
+            __FUNCTION__, __LINE__);
+          // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+          lusr_update_user_pwd(db, &user, username_escaped, plain_password);
+        }
+#endif
+        match = ACCESS_ACCEPTED;
+      }
+
+#ifdef HAVE_OPENSSL
+      // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+      if (salt) {
+        free(user_password);
+        free(salt);
+      }
+      free(plain_password);
+#endif
+    }
+    else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.auth_mode = AUTH_LOCAL_USER;
+      session_param_from_config(&conn->s_params, user.group);
+    }
   }
 
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+      conn->s_state.redir.username,
+      match ? "found" : "not found");
+
+  sqlclose(db);
+
+  return match;
+}
+
+int is_local_user(struct redir_t *redir, struct redir_conn_t *conn,
+				  int (*cb_validator) (struct redir_t *, struct redir_conn_t *,
+				  		MD5_CTX *, uint8_t *, uint8_t *))
+{
+  uint8_t user_password[RADIUS_PWSIZE+1];
+  uint8_t chap_challenge[REDIR_MD5LEN];
+  int match=ACCESS_DENIED;
+  MD5_CTX context;
+
   if (_options.debug) {/*debug*/
     char buffer[64];
     redir_chartohex(conn->s_state.redir.uamchal, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
+      chilli_log(LOG_INFO, "%s(%d): challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   if (redir->secret && *redir->secret) {
@@ -3003,7 +3632,7 @@
     char buffer[64];
     redir_chartohex(chap_challenge, buffer, REDIR_MD5LEN);
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
+      chilli_log(LOG_INFO, "%s(%d): chap challenge: %s", __FUNCTION__, __LINE__, buffer);
   }/**/
 
   switch (conn->authdata.type){
@@ -3019,85 +3648,438 @@
             user_password[m] =
                 conn->authdata.v.papmsg.password[m] ^ chap_challenge[n];
       }
+      // Correctly NUL terminate password string
+      size_t len = conn->authdata.v.papmsg.len;
+      if (len >= sizeof(user_password))
+        len = sizeof(user_password) - 1;
+      user_password[len] = 0;
       break;
     case REDIR_AUTH_CHAP:
       memcpy(user_password, conn->authdata.v.chapmsg.password, REDIR_MD5LEN);
       break;
     default:
-      syslog(LOG_ERR, "Authentication method not supported for locally authenticated users: %d",
+      chilli_log(LOG_INFO, "Authentication method not supported for locally authenticated users: %d",
              conn->authdata.type);
-      fclose(f);
-      return 0;
+      conn->response = REDIR_FAILED_REJECT;
+      return ACCESS_DENIED;
   }
 
   user_password[RADIUS_PWSIZE] = 0;
+  if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_ACCEPTED) {
+  	conn->response = REDIR_SUCCESS;
+  }
+  else if ((match = cb_validator(redir, conn, &context, user_password, chap_challenge))
+  		== ACCESS_DENIED_UDUPCLICATE) {
+  	conn->response = REDIR_FAILED_USER_DUPLICATE;
+  }
+  else{
+    mac_block_invoke("push_mac", conn);
+  	conn->response = REDIR_FAILED_REJECT;
+  }
+
+#ifdef ENABLE_DATABASE
+	if (match == ACCESS_ACCEPTED){
+		if (conn->s_params.maxinputoctets || conn->s_params.maxoutputoctets ||
+				conn->s_params.sessiontimeout) {
+		  match = dbcheck_session(conn);
+		  switch (match){
+			case ACCESS_DENIED_DATA:
+			  conn->response = REDIR_FAILED_DATA;
+			  break;
+			case ACCESS_DENIED_TIME:
+			  conn->response = REDIR_FAILED_TIME;
+			  break;
+			case ACCESS_DENIED_UDUPCLICATE:
+			  conn->response = REDIR_FAILED_USER_DUPLICATE;
+			  break;
+		  }
+		}
+	}
+#endif
+
+  return match;
+}
+
+int dynamic_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+		MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge)
+{
+  char email_escaped[REDIR_USERNAMESIZE + 1];
+  int match = ACCESS_DENIED;
+	struct str_user user;
+  sqlite3 *db;
+
+  if (!_options.usersdbpath)
+    return ACCESS_DENIED;
 
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
-  usernamelen = strlen(conn->s_state.redir.username);
+    chilli_log(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+      _options.usersdbpath, conn->s_state.redir.username);
 
-  line=(char*)malloc(sz);
-  while ((len = getline(&line, &sz, f)) > 0) {
-    if (len > 3 && len < sizeof(u) && line[0] != '#') {
-      char *pl=line,  /* pointer to current line */
-          *pu=u,     /* pointer to username     */
-          *pp=p;     /* pointer to password     */
+  if (!(db = sqlopen(_options.usersdbpath))) {
+    chilli_log(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+    return ACCESS_DENIED;
+  }
 
-      /* username until the first ':' */
-      while (*pl && *pl != ':')	*pu++ = *pl++;
+  escape_cstr(conn->s_state.redir.username, email_escaped);
+  if (_options.debug)
+    chilli_log(LOG_INFO, "%s(%d): looking for %s", __FUNCTION__, __LINE__, conn->s_state.redir.username);
 
-      /* skip over ':' otherwise error */
-      if (*pl == ':') pl++;
-      else {
-	syslog(LOG_WARNING, "not a valid localusers line: %s", line);
-	continue;
+  if (!usr_get_user(db, &user, email_escaped) &&
+	    !strncmp(user.email, email_escaped, USER_EMAILSIZE)) {
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+#ifdef HAVE_OPENSSL
+    char *salt = extract_salt(user.password);
+    char *plain_password = strndup((char *)user_password, sizeof(user.password));
+
+    if (salt) {
+      user_password	 = (uint8_t *)hash_sha512_with_salt(plain_password, salt);
+
+      if (!user_password) {
+        chilli_log(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+          __FUNCTION__, __LINE__, user.username);
+        // When hashing fails, make sure password check fails too
+        user_password = (uint8_t *)strdup("");
+      }
+
+      // Check for hash match, if hashes do not match, try again with MD5 hash
+      if (strncmp((char *)user_password, user.password, sizeof(user.password))) {
+        user_password = (uint8_t *)hash_md5_with_salt(plain_password, salt);
+        if (!user_password) {
+          chilli_log(LOG_INFO, "%s(%d): failed to compute password hash for user %s",
+            __FUNCTION__, __LINE__, user.username);
+          // When hashing fails, make sure password check fails too
+          user_password = (uint8_t *)strdup("");
+        }
+      }
+}
+#endif
+      if (!strncmp((char *)user_password, user.password, sizeof(user.password))) {
+#ifdef HAVE_OPENSSL
+        // Update password hash on the database
+        if(get_hash_type(user.password) == HASH_MD5) {
+          chilli_log(LOG_INFO, "%s(%d): updating user MD5 hash to SHA-512",
+            __FUNCTION__, __LINE__);
+          // If stored password is MD5 hash, rehash it to SHA-512 using the plain password
+          usr_update_user_pwd(db, &user, email_escaped, plain_password);
+        }
+#endif
+        match = ACCESS_ACCEPTED;
       }
 
-      /* password until the next ':' */
-      while (*pl && *pl != ':' && *pl != '\n') *pp++ = *pl++;
+#ifdef HAVE_OPENSSL
+      // If salt is not NULL that means that user_password was changed to point to newly allocated memory and we need to free it.
+      if (salt) {
+        free(user_password);
+        free(salt);
+      }
+      free(plain_password);
+#endif
+    }
+    else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+    }
 
-      *pu = 0; /* null terminate */
-      *pp = 0;
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.user_time = user.user_time;
+      conn->s_state.redir.auth_mode = AUTH_DYN_USER;
+      session_params_dyn(&conn->s_params);
+      strlcpy(conn->s_state.redir.username, user.email, USER_EMAILSIZE);
+    }
+  }
 
-      if (usernamelen == strlen(u) &&
-	  !strncmp(conn->s_state.redir.username, u, usernamelen)) {
+  if (_options.debug)
+    chilli_log(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+      conn->s_state.redir.username, match ? "found" : "not found");
 
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): found %s, checking password", __FUNCTION__, __LINE__, u);
+  sqlclose(db);
 
-	if (conn->authdata.type == REDIR_AUTH_PAP) {
-	  if (!strcmp((char*)user_password, p))
-	    match = 1;
+  return match;
+}
+
+int sms_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+						   MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+	char user_pass_escaped[RADIUS_PWSIZE + 1];
+	int match = ACCESS_DENIED;
+	struct str_sms_user user = {0};
+	sqlite3 *db;
+
+	if (!_options.usersdbpath)
+		return ACCESS_DENIED;
+
+	if (_options.debug)
+		chilli_log(LOG_INFO, "%s(%d): checking %s for user %s", __FUNCTION__, __LINE__,
+			   _options.usersdbpath, conn->s_state.redir.username);
+
+	if (!(db = sqlopen(_options.usersdbpath))) {
+		chilli_log(LOG_INFO, "%s: sqlopen() failed opening %s!", strerror(errno), _options.usersdbpath);
+		return ACCESS_DENIED;
 	}
-	else if (conn->authdata.type == REDIR_AUTH_CHAP) {
-	  uint8_t tmp[REDIR_MD5LEN];
-	  MD5Init(&context);
-	  MD5Update(&context, (uint8_t*)&conn->authdata.v.chapmsg.identity, 1);
-	  MD5Update(&context, (uint8_t*)p, strlen(p));
-	  MD5Update(&context, chap_challenge, REDIR_MD5LEN);
-	  MD5Final(tmp, &context);
-
-	  if (!memcmp(user_password, tmp,  REDIR_MD5LEN))
-	    match = 1;
-	  else {
-            if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): bad password for %s", __FUNCTION__, __LINE__, u);
-	  }
+  
+	user_password[USER_RAND_PASSWORD_LEN] = 0;
+	escape_cstr((char *) user_password, user_pass_escaped);
+    if (_options.debug)
+      chilli_log(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, user_pass_escaped);
+
+	if (!usr_get_sms_user(db, &user, user_pass_escaped) && user.username[0] != '\0') {
+    if (user.used != 0) {
+      match = ACCESS_DENIED;
+    } else if (_options.duplicateusers && find_active_user(user.username)) {
+      chilli_log(LOG_INFO, "%s(%d): Found duplication on username: %s", __FUNCTION__, __LINE__, user.username);
+      match = ACCESS_DENIED_UDUPCLICATE;
+    }
+    else {
+      if (_options.duplicateusers) {
+        chilli_log(LOG_INFO, "%s(%d): Duplication on username %s was not found", __FUNCTION__, __LINE__, user.username);
+      }
+      if (_options.debug)
+        chilli_log(LOG_INFO, "%s(%d): found %s ", __FUNCTION__, __LINE__, user.username);
+
+      if (conn->authdata.type == REDIR_AUTH_PAP) {
+          if (!strncmp((char *) user_password, user.password, USER_RAND_PASSWORD_LEN))
+              match = ACCESS_ACCEPTED;
+      } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+          match = auth_chap(conn, context, chap_challenge, user_password, user.password);
+      }
+
+      if (match == ACCESS_ACCEPTED) {
+        conn->s_state.redir.user_time = user.user_time;
+        conn->s_state.redir.auth_mode = AUTH_SMS_USER;
+        strncpy(conn->s_state.redir.username, user.username, USER_RAND_USERNAME_LEN);
+        strlcpy(conn->s_state.redir.phone, user.phone, sizeof(conn->s_state.redir.phone));
+        session_params_dyn(&conn->s_params);
+
+        uint32_t timestamp = (uint32_t)mainclock_now();
+        usr_update_sms_user(db, &user, user.phone, conn->hismac, timestamp, NULL);
+      }
+    }
 	}
 
-	break;
+	if (_options.debug)
+		chilli_log(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+			   conn->s_state.redir.username, match ? "found" : "not found");
+
+	sqlclose(db);
+
+	return match;
+}
+
+int mac_user_authenticator(struct redir_t *redir, struct redir_conn_t *conn,
+                           MD5_CTX *context, uint8_t *user_password, uint8_t *chap_challenge) {
+  int match = ACCESS_DENIED;
+  char mac[MACSTRLEN+1];
+
+  snprintf(mac, sizeof(mac), MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  if (_options.macpass) {
+    if (_options.debug)
+      chilli_log(LOG_INFO, "%s(%d): looking for %s (%s)", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, _options.macpass);
+
+    if (conn->authdata.type == REDIR_AUTH_PAP) {
+      if (!strcmp((char *) user_password, _options.macpass))
+        match = ACCESS_ACCEPTED;
+    } else if (conn->authdata.type == REDIR_AUTH_CHAP) {
+      match = auth_chap(conn, context, chap_challenge, user_password, _options.macpass);
+    }
+
+    if (match == ACCESS_ACCEPTED) {
+      conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+      session_params_dyn(&conn->s_params);
+    }
+
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
+             conn->s_state.redir.username, match ? "found" : "not found");
+  }
+  else {
+    conn->s_state.redir.auth_mode = AUTH_MAC_USER;
+    session_params_dyn(&conn->s_params);
+    match = ACCESS_ACCEPTED;
+  }
+
+  return match;
+}
+
+int trial_user_authenticator(struct redir_conn_t *conn) {
+  char mac[MACSTRLEN+7];
+
+  snprintf(mac, sizeof(mac), "trial-"MAC_FMT, MAC_ARG(conn->hismac));
+  strlcpy(conn->s_state.redir.username, mac, USERNAMESIZE);
+
+  conn->s_state.redir.auth_mode = AUTH_TRIAL_USER;
+  session_params_trial(&conn->s_params);
+
+  return ACCESS_ACCEPTED;
+}
+
+#ifdef USING_CURL
+int sso_user_authenticator(struct redir_conn_t *conn) {
+  char callback_url[256];
+  _oauth2_session oauth2_session = { 0 };
+
+  if (_options.uamuissl && _options.uamuiport) {
+    if (_options.uamaliasname && _options.domain) {
+      if (_options.redirssl) {
+        sprintf(callback_url, "https://%s.%s/ssocallback",
+              _options.uamaliasname,
+              _options.domain);
+      } else {
+        sprintf(callback_url, "https://%s.%s:%d/ssocallback",
+              _options.uamaliasname,
+              _options.domain,
+              _options.uamuiport);
       }
+    } else {
+      sprintf(callback_url, "https://%s:%d/ssocallback", inet_ntoa(_options.uamlisten), _options.uamuiport);
     }
+  } else if (_options.uamaliasname && _options.domain) {
+    sprintf(callback_url, "http://%s.%s/ssocallback",
+                  _options.uamaliasname,
+                  _options.domain);
+  } else {
+    sprintf(callback_url, "%shttp://%s:%d/ssocallback", _options.oidcforcehttps ? "https://redirectmeto.com/" : "",
+      inet_ntoa(_options.uamlisten), _options.uamport);
   }
 
-  if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): user %s %s", __FUNCTION__, __LINE__,
-           conn->s_state.redir.username,
-           match ? "found" : "not found");
+  oauth2_set_parameter_list(&oauth2_session,
+    OAUTH2_OPT_RESPONSE_TYPE, OAUTH2_RESPONSE_TYPE_CODE,
+    OAUTH2_OPT_OIDC_ENDPOINT, _options.oidcdiscoveryurl,
+    OAUTH2_OPT_CLIENT_ID, _options.oidcclientid,
+    OAUTH2_OPT_CLIENT_SECRET, _options.oidcclientsecret,
+    OAUTH2_OPT_REDIRECT_URI, callback_url,
+    OAUTH2_OPT_CODE, conn->s_state.redir.code,
+    OAUTH2_OPT_NONE);
+
+  if (oauth2_get_openid_config(&oauth2_session) != OAUTH2_OK) {
+   if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Failed get oauth2 openid configuration",
+             __FUNCTION__, __LINE__);
+    return ACCESS_DENIED;
+  }
 
-  fclose(f);
-  free(line);
-  return match;
+  if (oauth2_exchange_token(&oauth2_session) != OAUTH2_OK) {
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Failed to validate oauth2 code exchange",
+             __FUNCTION__, __LINE__);
+    return ACCESS_DENIED;
+  }
+
+  if (oauth2_get_userinfo(&oauth2_session) != OAUTH2_OK) {
+    if (_options.debug)
+      chilli_log(LOG_DEBUG, "%s(%d): Failed to get oauth2 user information",
+             __FUNCTION__, __LINE__);
+    if (!oauth2_session.username || oauth2_session.username[0] == '\0')
+      return ACCESS_DENIED;
+  }
+
+  if (oauth2_session.username && oauth2_session.username[0] != '\0') {
+    strlcpy(conn->s_state.redir.username, oauth2_session.username, USERNAMESIZE);
+  } else {
+    char username[USER_USERNAMENAMESIZE + 1];
+    if (usr_random_hex(username, USER_RAND_USERNAME_LEN)) {
+      return ACCESS_DENIED;
+    }
+    strlcpy(conn->s_state.redir.username, username, USERNAMESIZE);
+  }
+
+  conn->s_state.redir.auth_mode = AUTH_SSO_USER;
+  session_params_dyn(&conn->s_params);
+
+  oauth2_clean_session(&oauth2_session);
+  return ACCESS_ACCEPTED;
+}
+#endif
+
+int authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int dynamic_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = dynamic_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int sms_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = sms_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
+}
+
+int mac_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password) {
+  struct redir_conn_t conn;
+  memset(&conn, 0, sizeof(conn));
+
+  struct redir_conn_t *conn_ptr = &conn;
+
+  memcpy(&conn_ptr->hismac, &appconn->hismac, sizeof(appconn->hismac));
+  memcpy(&conn_ptr->hisip, &appconn->hisip, sizeof(appconn->hisip));
+
+  memcpy(&conn_ptr->s_params, &appconn->s_params, sizeof(appconn->s_params));
+  memcpy(&conn_ptr->s_state, &appconn->s_state, sizeof(appconn->s_state));
+
+  conn_ptr->authdata.type = REDIR_AUTH_PAP;
+  
+  int ret = mac_user_authenticator(NULL, conn_ptr, NULL, user_password, NULL);
+
+  memcpy(&appconn->s_params, &conn_ptr->s_params, sizeof(conn_ptr->s_params));
+  memcpy(&appconn->s_state, &conn_ptr->s_state, sizeof(conn_ptr->s_state));
+
+  return ret;
 }
 
 /* redir_accept() does the following:
@@ -3135,14 +4117,14 @@
   if ((new_socket = safe_accept(redir->fd[idx],
 				(struct sockaddr *)&address, &addrlen)) < 0) {
     if (errno != ECONNABORTED)
-      syslog(LOG_ERR, "%s: accept() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: accept() failed!", strerror(errno));
     return 0;
   }
 
   addrlen = sizeof(struct sockaddr_in);
 
   if (getsockname(redir->fd[idx], (struct sockaddr *)&baddress, &addrlen) < 0) {
-    syslog(LOG_WARNING, "%s: getsockname() failed!", strerror(errno));
+    chilli_log(LOG_WARNING, "%s: getsockname() failed!", strerror(errno));
   }
 
   radius_packet_id++;
@@ -3153,7 +4135,7 @@
      care */
 
   if ((status = redir_fork(new_socket, new_socket)) < 0) {
-    syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
     safe_close(new_socket);
     return 0;
   }
@@ -3191,11 +4173,11 @@
     char b[128];
     int max = 1000;
     if (shutdown(outfd, SHUT_WR) != 0)
-    syslog(LOG_DEBUG, "shutdown socket for writing");
+    chilli_log(LOG_DEBUG, "shutdown socket for writing");
     if (!ndelay_on(infd))
     while(safe_read(infd, b, sizeof(b)) > 0 && max--);
     if (shutdown(infd, SHUT_RD) != 0)
-    syslog(LOG_DEBUG, "shutdown socket for reading");
+    chilli_log(LOG_DEBUG, "shutdown socket for reading");
   */
   safe_close(outfd);
   safe_close(infd);
@@ -3205,7 +4187,7 @@
 static int _redir_close_exit(int infd, int outfd) {
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): close_exit", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): close_exit", __FUNCTION__, __LINE__);
 #endif
   _redir_close(infd,outfd);
   chilli_freeconn();
@@ -3240,13 +4222,13 @@
   len = offsetof(struct sockaddr_un, sun_path) + strlen(remote.sun_path);
 
   if (safe_connect(s, (struct sockaddr *)&remote, len) == -1) {
-    syslog(LOG_ERR, "%s: could not connect to %s", strerror(errno), remote.sun_path);
+    chilli_log(LOG_ERR, "%s: could not connect to %s", strerror(errno), remote.sun_path);
     safe_close(s);
     return -1;
   }
 
   if (safe_write(s, msg, sizeof(*msg)) != sizeof(*msg)) {
-    syslog(LOG_ERR, "%s: could not write to %s", strerror(errno), remote.sun_path);
+    chilli_log(LOG_ERR, "%s: could not write to %s", strerror(errno), remote.sun_path);
     safe_close(s);
     return -1;
   }
@@ -3275,7 +4257,7 @@
     itval.it_value.tv_usec = 0;
 
     if (setitimer(ITIMER_REAL, &itval, NULL)) {
-      syslog(LOG_ERR, "%s: setitimer() failed!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: setitimer() failed!", strerror(errno));
     }
 
 #if defined(F_DUPFD)
@@ -3301,7 +4283,7 @@
   if (socket->sslcon) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): Shutting down SSL", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): Shutting down SSL", __FUNCTION__, __LINE__);
 #endif
     openssl_shutdown(socket->sslcon, 2);
     openssl_free(socket->sslcon);
@@ -3345,7 +4327,7 @@
 
   /* We are forked when the redir_request is null */
   int forked = (rreq == 0);
-  int err;
+  int err, ret;
 
 
   memset(&httpreq,0,sizeof(httpreq));
@@ -3362,7 +4344,7 @@
   redir_chartohex(challenge, hexchal, REDIR_MD5LEN);                    \
   msg.mtype = msgtype;                                                  \
   memcpy(conn.s_state.redir.uamchal, challenge, REDIR_MD5LEN);          \
-  if (_options.debug) syslog(LOG_DEBUG, "%s(%d): ---->>> resetting challenge: %s", __FUNCTION__, __LINE__, hexchal)
+  if (_options.debug) chilli_log(LOG_DEBUG, "%s(%d): ---->>> resetting challenge: %s", __FUNCTION__, __LINE__, hexchal)
 
 #ifdef USING_IPC_UNIX
 #define redir_msg_send(msgopt)                                          \
@@ -3372,7 +4354,7 @@
   memcpy(&msg.mdata.params, &conn.s_params, sizeof(msg.mdata.params));  \
   memcpy(&msg.mdata.redir, &conn.s_state.redir, sizeof(msg.mdata.redir)); \
   if (redir_send_msg(redir, &msg) < 0) {                                \
-    syslog(LOG_ERR, "%s: write() failed! msgfd=%d type=%ld len=%d",     \
+    chilli_log(LOG_ERR, "%s: write() failed! msgfd=%d type=%ld len=%d",     \
            strerror(errno), redir->msgfd, msg.mtype, (int)sizeof(msg.mdata)); \
     return redir_main_exit(&socket, forked, rreq);                      \
   }
@@ -3384,7 +4366,7 @@
   memcpy(&msg.mdata.params, &conn.s_params, sizeof(msg.mdata.params));  \
   memcpy(&msg.mdata.redir, &conn.s_state.redir, sizeof(msg.mdata.redir)); \
   if (msgsnd(redir->msgid, (void *)&msg, sizeof(msg.mdata), 0) < 0) {   \
-    syslog(LOG_ERR, "%s: msgsnd() failed! msgid=%d type=%ld len=%d",    \
+    chilli_log(LOG_ERR, "%s: msgsnd() failed! msgid=%d type=%ld len=%d",    \
            strerror(errno), redir->msgid, msg.mtype, (int)sizeof(msg.mdata)); \
     return redir_main_exit(&socket, forked, rreq);                      \
   }
@@ -3397,6 +4379,7 @@
   memset(hexchal, 0, sizeof(hexchal));
   memset(&conn, 0, sizeof(conn));
   memset(&msg, 0, sizeof(msg));
+  conn.s_state.redir.tos = 0;
 
   socket.fd[0] = infd;
   socket.fd[1] = outfd;
@@ -3405,14 +4388,14 @@
 
   /*
     if (ndelay_on(socket.fd[0])) {
-    syslog(LOG_ERR, "%s: fcntl() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fcntl() failed", strerror(errno));
     return redir_main_exit(&socket, forked, rreq);
     }
   */
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Calling redir_getstate()", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Calling redir_getstate()", __FUNCTION__, __LINE__);
 #endif
 
   /*
@@ -3422,7 +4405,7 @@
   termstate = REDIR_TERM_GETSTATE;
 
   if (!redir->cb_getstate) {
-    syslog(LOG_ERR, "No cb_getstate() defined!");
+    chilli_log(LOG_ERR, "No cb_getstate() defined!");
     return redir_main_exit(&socket, forked, rreq);
   }
 
@@ -3432,7 +4415,7 @@
   if (state == -1) {
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): getstate() session not found", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): getstate() session not found", __FUNCTION__, __LINE__);
 #endif
 
 #ifdef ENABLE_EWTAPI
@@ -3443,7 +4426,7 @@
        */
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): redir connection is SSL", __FUNCTION__, __LINE__);
 #endif
       conn.flags |= USING_SSL;
     } else
@@ -3460,7 +4443,7 @@
    */
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Receiving HTTP%s Request", __FUNCTION__, __LINE__, (conn.flags & USING_SSL) ? "S" : "");
+    chilli_log(LOG_DEBUG, "%s(%d): Receiving HTTP%s Request", __FUNCTION__, __LINE__, (conn.flags & USING_SSL) ? "S" : "");
 #endif
 
 #ifdef HAVE_SSL
@@ -3482,7 +4465,7 @@
 
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): SSL loop %d", __FUNCTION__, __LINE__, loop);
+      chilli_log(LOG_DEBUG, "%s(%d): SSL loop %d", __FUNCTION__, __LINE__, loop);
 #endif
 
     while (!done) {
@@ -3490,13 +4473,13 @@
         case -1:
 #if(_debug_ > 1)
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir error, redir_main_exit", __FUNCTION__, __LINE__);
+            chilli_log(LOG_DEBUG, "%s(%d): redir error, redir_main_exit", __FUNCTION__, __LINE__);
 #endif
           return redir_main_exit(&socket, forked, rreq);
         case 1:
           if (!loop) {
             if (_options.debug)
-              syslog(LOG_DEBUG, "%s(%d): Continue... SSL pending", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): Continue... SSL pending", __FUNCTION__, __LINE__);
             return 1;
           }
           break;
@@ -3508,7 +4491,7 @@
 
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "%s(%d): HTTPS Accepted", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): HTTPS Accepted", __FUNCTION__, __LINE__);
 #endif
   }
 #endif
@@ -3521,18 +4504,18 @@
     case 1:
 #if(_debug_ > 1)
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Continue...", __FUNCTION__, __LINE__);
+        chilli_log(LOG_DEBUG, "%s(%d): Continue...", __FUNCTION__, __LINE__);
 #endif
       return 1;
     default:
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): Error calling get_req. Terminating %d", __FUNCTION__, __LINE__, err);
+        chilli_log(LOG_DEBUG, "%s(%d): Error calling get_req. Terminating %d", __FUNCTION__, __LINE__, err);
       return redir_main_exit(&socket, forked, rreq);
   }
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Processing HTTP%s Request", __FUNCTION__, __LINE__, (conn.flags & USING_SSL) ? "S" : "");
+    chilli_log(LOG_DEBUG, "%s(%d): Processing HTTP%s Request", __FUNCTION__, __LINE__, (conn.flags & USING_SSL) ? "S" : "");
 #endif
 
   switch (conn.type) {
@@ -3561,8 +4544,8 @@
                                 || isWPAD
 #endif
                                 )) {
-          char *ctype = "text/plain";
-          char *filename = conn.wwwfile;
+          const char *ctype = "text/plain";
+          const char *filename = conn.wwwfile;
           size_t namelen = strlen(filename);
           int parse = 0;
 
@@ -3570,7 +4553,7 @@
 #ifdef ENABLE_EWTAPI
           if (isEWT) {
             if (!(conn.s_params.flags & ADMIN_LOGIN)) {
-              syslog(LOG_WARNING, "Permission denied to EWT API");
+              chilli_log(LOG_WARNING, "Permission denied to EWT API");
               return redir_main_exit(&socket, forked, rreq);
             }
           } else
@@ -3582,7 +4565,7 @@
             } else
 #endif
             {
-              char *p;
+              const char *p;
               int cnt = 0;
               for (p=filename; *p; p++) {
                 if (*p == '.' || *p == '_'|| *p == '-' || *p == '/') {
@@ -3596,7 +4579,7 @@
                 if (*p >= 'A' && *p <= 'Z') continue;
                 if (*p >= '0' && *p <= '9') continue;
                 /* invalid file name! */
-                syslog(LOG_ERR, "invalid www request [%s]!", filename);
+                chilli_log(LOG_ERR, "invalid www request [%s]!", filename);
                 return redir_main_exit(&socket, forked, rreq);
               }
             }
@@ -3631,7 +4614,7 @@
             }
             else {
               /* we do not serve it! */
-              syslog(LOG_ERR, "invalid file extension! [%s]", filename);
+              chilli_log(LOG_ERR, "invalid file extension! [%s]", filename);
               return redir_main_exit(&socket, forked, rreq);
             }
 
@@ -3649,12 +4632,12 @@
           if (parse) {
 
             if (!_options.wwwbin) {
-              syslog(LOG_ERR, "the 'wwwbin' setting must be configured for CGI use");
+              chilli_log(LOG_ERR, "the 'wwwbin' setting must be configured for CGI use");
               return redir_main_exit(&socket, forked, rreq);
             }
 
             if (ndelay_off(socket.fd[0])) {
-              syslog(LOG_ERR, "%s: fcntl() failed", strerror(errno));
+              chilli_log(LOG_ERR, "%s: fcntl() failed", strerror(errno));
             }
 
 #ifdef HAVE_SSL
@@ -3668,14 +4651,14 @@
               int ctop[2];
 
               if (pipe(ptoc) == -1 || pipe(ctop) == -1) {
-                syslog(LOG_ERR, "%s: pipe() failed", strerror(errno));
+                chilli_log(LOG_ERR, "%s: pipe() failed", strerror(errno));
                 return redir_main_exit(&socket, forked, rreq);
               }
 
               forkpid = redir_fork(ptoc[0], ctop[1]);
 
               if (forkpid < 0) {
-                syslog(LOG_ERR, "%s: fork() failed", strerror(errno));
+                chilli_log(LOG_ERR, "%s: fork() failed", strerror(errno));
                 return redir_main_exit(&socket, forked, rreq);
               }
 
@@ -3690,18 +4673,18 @@
 
 #if(_debug_ > 1)
                 if (_options.debug)
-                  syslog(LOG_DEBUG, "%s(%d): ssl_wrapper(%d)", __FUNCTION__, __LINE__, getpid());
+                  chilli_log(LOG_DEBUG, "%s(%d): ssl_wrapper(%d)", __FUNCTION__, __LINE__, getpid());
 #endif
 
                 while (clen > 0) {
                   rd = clen > bufsize ? bufsize : clen;
 #if(_debug_ > 1)
                   if (_options.debug)
-                    syslog(LOG_DEBUG, "%s(%d): reading(%d)", __FUNCTION__, __LINE__, rd);
+                    chilli_log(LOG_DEBUG, "%s(%d): reading(%d)", __FUNCTION__, __LINE__, rd);
 #endif
                   if ((buflen = openssl_read(socket.sslcon, buffer, rd, 0)) > 0) {
                     if (safe_write(ptoc[1], buffer, (size_t) buflen) < 0) {
-                      syslog(LOG_ERR, "%s: error", strerror(errno));
+                      chilli_log(LOG_ERR, "%s: error", strerror(errno));
                       return redir_main_exit(&socket, forked, rreq);
                     }
                     clen -= buflen;
@@ -3711,25 +4694,25 @@
                 while (1) {
 #if(_debug_ > 1)
                   if (_options.debug)
-                    syslog(LOG_DEBUG, "%s(%d): script_read", __FUNCTION__, __LINE__);
+                    chilli_log(LOG_DEBUG, "%s(%d): script_read", __FUNCTION__, __LINE__);
 #endif
                   if ((buflen = safe_read(ctop[0], buffer, bufsize)) > 0) {
 #if(_debug_ > 1)
                     if (_options.debug)
-                      syslog(LOG_DEBUG, "%s(%d): script_read(%zd)", __FUNCTION__, __LINE__, buflen);
+                      chilli_log(LOG_DEBUG, "%s(%d): script_read(%zd)", __FUNCTION__, __LINE__, buflen);
 #endif
                     if (redir_write(&socket, buffer, (size_t) buflen) < 0) {
-                      syslog(LOG_ERR, "%s: redir_write() failed!", strerror(errno));
+                      chilli_log(LOG_ERR, "%s: redir_write() failed!", strerror(errno));
                       break;
                     }
 #if(_debug_ > 1)
                     if (_options.debug)
-                      syslog(LOG_DEBUG, "%s(%d): ssl_write(%zd)", __FUNCTION__, __LINE__, buflen);
+                      chilli_log(LOG_DEBUG, "%s(%d): ssl_write(%zd)", __FUNCTION__, __LINE__, buflen);
 #endif
                   } else {
 #if(_debug_ > 1)
                     if (_options.debug)
-                      syslog(LOG_DEBUG, "%s(%d): done", __FUNCTION__, __LINE__);
+                      chilli_log(LOG_DEBUG, "%s(%d): done", __FUNCTION__, __LINE__);
 #endif
                     break;
                   }
@@ -3737,7 +4720,7 @@
 
 #if(_debug_ > 1)
                 if (_options.debug)
-                  syslog(LOG_DEBUG, "%s(%d): ssl_wrapper(%d) done", __FUNCTION__, __LINE__, getpid());
+                  chilli_log(LOG_DEBUG, "%s(%d): ssl_wrapper(%d) done", __FUNCTION__, __LINE__, getpid());
 #endif
 
                 safe_close(ptoc[1]);
@@ -3753,7 +4736,7 @@
 
 #if(_debug_ > 1)
                 if (_options.debug)
-                  syslog(LOG_DEBUG, "%s(%d): script(%d)", __FUNCTION__, __LINE__, getpid());
+                  chilli_log(LOG_DEBUG, "%s(%d): script(%d)", __FUNCTION__, __LINE__, getpid());
 #endif
               }
             }
@@ -3809,7 +4792,7 @@
                 if (isWPAD && _options.wpadpacfile) {
                   char *binqqargs[3] = { _options.wpadpacfile, 0 } ;
                   if (_options.debug)
-                    syslog(LOG_DEBUG, "%s(%d): Running: %s", __FUNCTION__, __LINE__, _options.wpadpacfile);
+                    chilli_log(LOG_DEBUG, "%s(%d): Running: %s", __FUNCTION__, __LINE__, _options.wpadpacfile);
                   execv(*binqqargs, binqqargs);
                   break;
                 }
@@ -3820,7 +4803,7 @@
                   char *binqqargs[3] = { _options.wwwbin, buffer, 0 } ;
 
                   if (_options.debug)
-                    syslog(LOG_DEBUG, "%s(%d): Running: %s %s/%s", __FUNCTION__, __LINE__, _options.wwwbin, _options.wwwdir, filename);
+                    chilli_log(LOG_DEBUG, "%s(%d): Running: %s %s/%s", __FUNCTION__, __LINE__, _options.wwwbin, _options.wwwdir, filename);
                   snprintf(buffer, sizeof(buffer), "%s/%s", _options.wwwdir, filename);
 
                   execv(*binqqargs, binqqargs);
@@ -3848,7 +4831,7 @@
             if (fd > 0) {
 
               if (ndelay_off(socket.fd[0])) {
-                syslog(LOG_ERR, "%s: fcntl() failed", strerror(errno));
+                chilli_log(LOG_ERR, "%s: fcntl() failed", strerror(errno));
               }
 
               snprintf(buffer, bufsize,
@@ -3859,22 +4842,22 @@
                             ctype);
 
               if (redir_write(&socket, buffer, strlen(buffer)) < 0) {
-                syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+                chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
               }
 
               while ((buflen = safe_read(fd, buffer, bufsize)) > 0)
                 if (redir_write(&socket, buffer, (size_t) buflen) < 0)
-                  syslog(LOG_ERR, "%s: redir_write()", strerror(errno));
+                  chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
 
               safe_close(fd);
             }
-            else syslog(LOG_ERR, "could not open local content file %s!", filename);
+            else chilli_log(LOG_ERR, "could not open local content file %s!", filename);
           }
-          else syslog(LOG_ERR, "chroot/chdir to %s was not successful\n", _options.wwwdir);
+          else chilli_log(LOG_ERR, "chroot/chdir to %s was not successful\n", _options.wwwdir);
 
           return _redir_close_exit(infd, outfd); /* which exits */
         }
-        else syslog(LOG_ERR, "Required: 'wwwdir' (in chilli.conf) and 'file' query-string param");
+        else chilli_log(LOG_ERR, "Required: 'wwwdir' (in chilli.conf) and 'file' query-string param");
 
         return redir_main_exit(&socket, forked, rreq);
       }
@@ -3884,11 +4867,23 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): Processing received request", __FUNCTION__, __LINE__);
+    chilli_log(LOG_DEBUG, "%s(%d): Processing received request", __FUNCTION__, __LINE__);
 #endif
 
   /* default hexchal for use in replies */
   redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
+  if (_options.smsusers && _options.usersdbpath){
+    sqlite3 *db;
+    conn.s_state.redir.otp_state = 0;
+    if ((db = sqlopen(_options.usersdbpath))) {
+      struct str_sms_user user = {0};
+      if (usr_sms_user_exists(db, NULL, conn.hismac) == USER_RET_ALREADY && \
+          !usr_get_sms_user_phone(db, &user, NULL, conn.hismac) && user.used == 0) {
+        conn.s_state.redir.otp_state = 1;
+      }
+      sqlclose(db);
+    }
+  }
 
   switch (conn.type) {
 
@@ -3897,21 +4892,17 @@
 
       /* Was client was already logged on? */
       if (state == 1) {
-
         if (splash) {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
           reauth = 1;
-
         } else {
-
           if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
 
           redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
                       NULL, NULL, conn.s_state.redir.userurl, NULL,
-                      (char *)conn.s_params.url, conn.hismac,
+                      (char *) conn.s_params.url, conn.hismac,
                       &conn.hisip, httpreq.qs);
 
           return redir_main_exit(&socket, forked, rreq);
@@ -3920,11 +4911,11 @@
 
       /* Did the challenge expire? */
       if (_options.challengetimeout2 &&
-          (conn.s_state.uamtime + _options.challengetimeout2) <
-          mainclock_now()) {
+        (conn.s_state.uamtime + _options.challengetimeout2) <
+        mainclock_now()) {
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
-                 (long) conn.s_state.uamtime, (long) mainclock_now());
+            chilli_log(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                   (long) conn.s_state.uamtime, (long) mainclock_now());
 
         redir_memcopy(REDIR_CHALLENGE);
         redir_msg_send(REDIR_MSG_OPT_REDIR);
@@ -3936,74 +4927,204 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
-      if (is_local_user(redir, &conn)) {
-        session_param_defaults(&conn.s_params);
-        conn.response = REDIR_SUCCESS;
-      }
-      else {
+	  if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		if (_options.localusers) {
+			if ((ret = is_local_user(redir, &conn, authenticator)) == ACCESS_ACCEPTED) {
+              session_param_defaults(&conn.s_params);
+            }
+			else if (_options.registerusers && conn.response == REDIR_FAILED_REJECT) {
+				ret = is_local_user(redir, &conn, dynamic_user_authenticator);
+			}
+
+		} else if (_options.smsusers) {
+		    if (is_local_user(redir, &conn, sms_user_authenticator) == ACCESS_ACCEPTED) {
+		      session_param_defaults(&conn.s_params);
+		    }
+    } else if (_options.macusers) {
+      is_local_user(redir, &conn, mac_user_authenticator);
+		} else {
 
 #ifdef ENABLE_MODULES
-        int i;
-        int flags = 0;
+			int i;
+			int flags = 0;
 #endif
 
-        if (!forked) {
-          /*
-           *  When waiting for RADIUS, we need to be forked.
-           *  TODO: make redir_radius asynchronous.
-           */
-          pid_t forkpid = redir_fork(infd, outfd);
-          if (forkpid) { /* parent or error */
-            return redir_main_exit(&socket, forked, rreq);
-          }
-        }
+			if (!forked) {
+				/*
+				 *  When waiting for RADIUS, we need to be forked.
+				 *  TODO: make redir_radius asynchronous.
+				 */
+				pid_t forkpid = redir_fork(infd, outfd);
+				if (forkpid) { /* parent or error */
+					return redir_main_exit(&socket, forked, rreq);
+				}
+			}
 
 #ifdef ENABLE_MODULES
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
-        for (i=0; i < MAX_MODULES; i++) {
-          if (!_options.modules[i].name[0]) break;
-          if (_options.modules[i].ctx) {
-            struct chilli_module *m =
-                (struct chilli_module *)_options.modules[i].ctx;
-            if (m->redir_login) {
-              int modresult = m->redir_login(redir, &conn, &socket);
-              flags |= modresult;
-              switch(chilli_mod_state(modresult)) {
-                case CHILLI_MOD_ERROR:
-                  return redir_main_exit(&socket, forked, rreq);
-                default:
-                  break;
+            if (_options.debug)
+              chilli_log(LOG_DEBUG, "%s(%d): checking modules...", __FUNCTION__, __LINE__);
+            for (i=0; i < MAX_MODULES; i++) {
+              if (!_options.modules[i].name[0]) break;
+              if (_options.modules[i].ctx) {
+                struct chilli_module *m =
+                    (struct chilli_module *)_options.modules[i].ctx;
+                if (m->redir_login) {
+                  int modresult = m->redir_login(redir, &conn, &socket);
+                  flags |= modresult;
+                  switch(chilli_mod_state(modresult)) {
+                    case CHILLI_MOD_ERROR:
+                      return redir_main_exit(&socket, forked, rreq);
+                    default:
+                      break;
+                  }
+                }
               }
             }
-          }
-        }
-        if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
-          if (_options.debug)
-            syslog(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
-        } else {
+			if (flags & CHILLI_MOD_REDIR_SKIP_RADIUS) {
+			  if (_options.debug)
+				chilli_log(LOG_DEBUG, "%s(%d): Skipping RADIUS authentication", __FUNCTION__, __LINE__);
+			} else {
 #endif
 
-          termstate = REDIR_TERM_RADIUS;
+			termstate = REDIR_TERM_RADIUS;
 
-          if (optionsdebug)
-            syslog(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
+			if (optionsdebug)
+				chilli_log(LOG_DEBUG, "%s(%d): redir_accept: Sending RADIUS request", __FUNCTION__, __LINE__);
 
-          redir_radius(redir, &address->sin_addr, &conn, reauth);
-          termstate = REDIR_TERM_REPLY;
+			redir_radius(redir, &address->sin_addr, &conn, reauth);
+			termstate = REDIR_TERM_REPLY;
+
+      if (conn.response != REDIR_SUCCESS) {
+        mac_block_invoke("push_mac", &conn);
+      }
 
 #ifdef ENABLE_MODULES
-        }
+			}
 #endif
 
 #if(_debug_ > 1)
-        if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
+			if (_options.debug)
+			  chilli_log(LOG_DEBUG, "%s(%d): Received RADIUS reply", __FUNCTION__, __LINE__);
 #endif
-      }
+		}
+    if (conn.response == REDIR_SUCCESS) {
+      mac_block_invoke("unblock_mac", &conn);
+    }
+	  }
 
       if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
+        conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
+
+        if (reauth) {
+          conn.s_params.flags |= IS_UAM_REAUTH;
+        }
+
+        msg.mtype = REDIR_LOGIN;
 
+        if (_options.debug)
+          chilli_log(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+//        if (_options.successuserurl || _options.successurlcustom){
+            bstring successurl;
+            successurl = bfromcstralloc(1024,"");
+            if (_options.successuserurl)
+                bcatcstr(successurl, conn.s_state.redir.userurl);
+            else if (_options.successurlcustom)
+                bcatcstr(successurl, _options.successurlcustom);
+            else
+                successurl = NULL;
+
+            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
+                        conn.s_params.sessiontimeout, NULL,
+                        conn.s_state.redir.username,
+                        conn.s_state.redir.userurl, conn.reply,
+                        (char *)conn.s_params.url,
+                        conn.hismac, &conn.hisip, httpreq.qs);
+            bdestroy(successurl);
+//        } else {
+//            redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+//                        conn.s_params.sessiontimeout, NULL,
+//                        conn.s_state.redir.username,
+//                        conn.s_state.redir.userurl, conn.reply,
+//                        (char *)conn.s_params.url,
+//                        conn.hismac, &conn.hisip, httpreq.qs);
+//        }
+
+        /* set params and redir data */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
+
+      } else { /* Access-Reject */
+        int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+        if (_options.debug)
+          chilli_log(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+
+        if (!hasnexturl) {
+          if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+        } else {
+          msg.mtype = REDIR_NOTYET;
+        }
+
+        redir_reply(redir, &socket, &conn, conn.response,
+                    NULL,
+                    0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                    (char *)conn.s_params.url, conn.hismac,
+                    &conn.hisip, httpreq.qs);
+
+        /* set params, redir data, and reset session-id */
+        redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                       (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+      }
+
+      if (_options.debug)
+        chilli_log(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+      return redir_main_exit(&socket, forked, rreq);
+    }
+
+    case REDIR_TRIAL: {
+      char reauth = 0;
+
+      /* Was client was already logged on? */
+      if (state == 1) {
+        if (splash) {
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+          reauth = 1;
+        } else {
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+          redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                      NULL, NULL, conn.s_state.redir.userurl, NULL,
+                      (char *) conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+      }
+
+      //Setting conn.response here.
+      if (!_options.tos || (_options.tos && conn.response != REDIR_FAILED_TOS)) {
+		  if (_options.trialusers && trial_user_authenticator(&conn)) {
+			  conn.response = REDIR_SUCCESS;
+#ifdef ENABLE_DATABASE
+			  if (conn.s_params.maxinputoctets || conn.s_params.maxoutputoctets ||
+					  conn.s_params.sessiontimeout) {
+				switch (dbcheck_session(&conn)){
+				  case ACCESS_DENIED_DATA:
+					conn.response = REDIR_TRIAL_FAILED_DATA;
+					break;
+				  case ACCESS_DENIED_TIME:
+					conn.response = REDIR_TRIAL_FAILED_TIME;
+					break;
+				}
+			  }
+#endif
+		  }
+	  }
+
+      if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
         conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
 
         if (reauth) {
@@ -4013,30 +5134,40 @@
         msg.mtype = REDIR_LOGIN;
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+//        if (_options.successuserurl || _options.successurlcustom){
+        bstring successurl;
+        successurl = bfromcstralloc(1024,"");
+        if (_options.successuserurl)
+          bcatcstr(successurl, conn.s_state.redir.userurl);
+        else if (_options.successurlcustom)
+          bcatcstr(successurl, _options.successurlcustom);
+        else
+          successurl = NULL;
 
-        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, NULL,
+        redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
                     conn.s_params.sessiontimeout, NULL,
                     conn.s_state.redir.username,
                     conn.s_state.redir.userurl, conn.reply,
                     (char *)conn.s_params.url,
                     conn.hismac, &conn.hisip, httpreq.qs);
+        bdestroy(successurl);
 
         /* set params and redir data */
         redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
 
       } else { /* Access-Reject */
-
         int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
 
         if (!hasnexturl) {
           if (_options.challengetimeout)
-            redir_memcopy(REDIR_CHALLENGE);
+          redir_memcopy(REDIR_CHALLENGE);
         } else {
-          msg.mtype = REDIR_NOTYET;
+          msg.mtype = REDIR_TRIALLOGIN_FAILED;
         }
 
         redir_reply(redir, &socket, &conn, conn.response,
@@ -4051,7 +5182,7 @@
       }
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+        chilli_log(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
       return redir_main_exit(&socket, forked, rreq);
     }
 
@@ -4148,6 +5279,316 @@
         return redir_main_exit(&socket, forked, rreq);
       }
 
+    case REDIR_SIGNUP:
+		if (_options.registerusers)
+			usr_add_user(&conn);
+
+		redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+			  hexchal, NULL, conn.s_state.redir.userurl, NULL,
+			  NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+      return redir_main_exit(&socket, forked, rreq);
+    case REDIR_SMSSIGNUP:
+    	{
+    		if (_options.smsusers) {
+				int ret;
+
+				if (strlen(conn.s_state.redir.phone) < USER_MIN_PHONE_LEN) {
+					conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else if ((ret = usr_add_sms_user(&conn, conn.s_state.redir.phone, hexchal))) {
+					if (ret == USER_RET_ALREADY)
+						conn.response = REDIR_SMSSIGNUP_ALREADY;
+					else if (ret == USER_RET_SMS_ERR)
+						conn.response = REDIR_SMSSIGNUP_SMS_FAIL;
+					else
+						conn.response = REDIR_SMSSIGNUP_FAILED;
+				} else {
+					conn.response = REDIR_SMSSIGNUP_SUCCESS;
+				}
+			}
+
+			redir_reply(redir, &socket, &conn, conn.response, NULL, 0,
+						hexchal, NULL, conn.s_state.redir.userurl, NULL,
+						NULL, conn.hismac, &conn.hisip, httpreq.qs);
+
+			return redir_main_exit(&socket, forked, rreq);
+		}
+#ifdef USING_CURL
+    case REDIR_SSOCALLBACK:
+      {
+        char reauth = 0;
+
+        /* Was client was already logged on? */
+        if (state == 1) {
+          if (splash) {
+            if (_options.debug)
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: SPLASH reauth", __FUNCTION__, __LINE__);
+            reauth = 1;
+          } else {
+            if (_options.debug)
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+            redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                        NULL, NULL, conn.s_state.redir.userurl, NULL,
+                        (char *) conn.s_params.url, conn.hismac,
+                        &conn.hisip, httpreq.qs);
+
+            return redir_main_exit(&socket, forked, rreq);
+          }
+        }
+
+        /* Did the challenge expire? */
+        if (_options.challengetimeout2 &&
+          (conn.s_state.uamtime + _options.challengetimeout2) <
+          mainclock_now()) {
+          if (_options.debug)
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                    (long) conn.s_state.uamtime, (long) mainclock_now());
+
+          redir_memcopy(REDIR_CHALLENGE);
+          redir_msg_send(REDIR_MSG_OPT_REDIR);
+
+          redir_reply(redir, &socket, &conn, REDIR_FAILED_OTHER, NULL,
+                      0, hexchal, NULL, NULL, NULL,
+                      0, conn.hismac, &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        if (_options.oidc) {
+          if (sso_user_authenticator(&conn)) {
+            conn.response = REDIR_SUCCESS;
+  #ifdef ENABLE_DATABASE
+            if (conn.s_params.maxinputoctets || conn.s_params.maxoutputoctets ||
+                    conn.s_params.sessiontimeout) {
+              switch (dbcheck_session(&conn)){
+                case ACCESS_DENIED_DATA:
+                  conn.response = REDIR_FAILED_DATA;
+                  break;
+                case ACCESS_DENIED_TIME:
+                  conn.response = REDIR_FAILED_TIME;
+                  break;
+              }
+            }
+  #endif
+          } else {
+            conn.response = REDIR_SSO_FAILED;
+            mac_block_invoke("push_mac", &conn);
+          }
+        } else {
+          conn.response = REDIR_SSO_DENIED;
+        }
+
+        if (conn.response == REDIR_SUCCESS) { /* Accept-Accept */
+          mac_block_invoke("unblock_mac", &conn);
+          conn.s_params.flags &= ~REQUIRE_UAM_SPLASH;
+
+          if (reauth) {
+            conn.s_params.flags |= IS_UAM_REAUTH;
+          }
+
+          msg.mtype = REDIR_LOGIN;
+
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): handling Access-Accept", __FUNCTION__, __LINE__);
+
+          bstring successurl;
+          successurl = bfromcstralloc(1024,"");
+          if (_options.successuserurl)
+            bcatcstr(successurl, conn.s_state.redir.userurl);
+          else if (_options.successurlcustom)
+            bcatcstr(successurl, _options.successurlcustom);
+          else
+            successurl = NULL;
+
+          redir_reply(redir, &socket, &conn, REDIR_SUCCESS, successurl,
+                      conn.s_params.sessiontimeout, NULL,
+                      conn.s_state.redir.username,
+                      conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url,
+                      conn.hismac, &conn.hisip, httpreq.qs);
+          bdestroy(successurl);
+
+          /* set params and redir data */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS);
+
+        } else { /* Access-Reject */
+          int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+
+          if (!hasnexturl) {
+            if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+          } else {
+            msg.mtype = REDIR_SSO_FAILED;
+          }
+
+          redir_reply(redir, &socket, &conn, conn.response,
+                      NULL,
+                      0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          /* set params, redir data, and reset session-id */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                        (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+        }
+
+        if (_options.debug)
+          chilli_log(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+        return redir_main_exit(&socket, forked, rreq);
+      }
+    case REDIR_SSOLOGIN:
+      {
+        if (!_options.oidc || !_options.oidcdiscoveryurl || !_options.oidcclientid ||
+            !_options.oidcclientsecret || (_options.tos && conn.response == REDIR_FAILED_TOS)) {
+          int hasnexturl = (strlen((char *)conn.s_params.url) > 5);
+
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): handling Access-Reject", __FUNCTION__, __LINE__);
+
+          if (!hasnexturl) {
+            if (_options.challengetimeout)
+            redir_memcopy(REDIR_CHALLENGE);
+          } else {
+            msg.mtype = REDIR_SSO_FAILED;
+          }
+
+          redir_reply(redir, &socket, &conn, conn.response,
+                      NULL,
+                      0, hexchal, NULL, conn.s_state.redir.userurl, conn.reply,
+                      (char *)conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          /* set params, redir data, and reset session-id */
+          redir_msg_send(REDIR_MSG_OPT_REDIR | REDIR_MSG_OPT_PARAMS |
+                        (conn.response == REDIR_CHALLENGE ? 0 : REDIR_MSG_NSESSIONID));
+
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): -->> Msg userurl=[%s]\n", __FUNCTION__, __LINE__, conn.s_state.redir.userurl);
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        if (state == 1 && !splash) {
+          if (_options.debug)
+            chilli_log(LOG_DEBUG, "%s(%d): redir_accept: already logged on", __FUNCTION__, __LINE__);
+
+          redir_reply(redir, &socket, &conn, REDIR_ALREADY, NULL, 0,
+                      NULL, NULL, conn.s_state.redir.userurl, NULL,
+                      (char *) conn.s_params.url, conn.hismac,
+                      &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        /* Did the challenge expire? */
+        if (_options.challengetimeout2 &&
+          (conn.s_state.uamtime + _options.challengetimeout2) <
+          mainclock_now()) {
+          if (_options.debug)
+              chilli_log(LOG_DEBUG, "%s(%d): redir_accept: challenge expired: %ld : %ld", __FUNCTION__, __LINE__,
+                    (long) conn.s_state.uamtime, (long) mainclock_now());
+
+          redir_memcopy(REDIR_CHALLENGE);
+          redir_msg_send(REDIR_MSG_OPT_REDIR);
+
+          redir_reply(redir, &socket, &conn, REDIR_FAILED_OTHER, NULL,
+                      0, hexchal, NULL, NULL, NULL,
+                      0, conn.hismac, &conn.hisip, httpreq.qs);
+
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        char callback_url[256];
+        char chal_buffer[64];
+        _oauth2_session oauth2_session = { 0 };
+
+        if (_options.uamuissl && _options.uamuiport) {
+          if (_options.uamaliasname && _options.domain) {
+            if (_options.redirssl) {
+              sprintf(callback_url, "https://%s.%s/ssocallback",
+                    _options.uamaliasname,
+                    _options.domain);
+            } else {
+              sprintf(callback_url, "https://%s.%s:%d/ssocallback",
+                    _options.uamaliasname,
+                    _options.domain,
+                    _options.uamuiport);
+            }
+          } else {
+            sprintf(callback_url, "https://%s:%d/ssocallback", inet_ntoa(_options.uamlisten), _options.uamuiport);
+          }
+        } else if (_options.uamaliasname && _options.domain) {
+          sprintf(callback_url, "http://%s.%s/ssocallback",
+                        _options.uamaliasname,
+                        _options.domain);
+        } else {
+          sprintf(callback_url, "%shttp://%s:%d/ssocallback", _options.oidcforcehttps ? "https://redirectmeto.com/" : "",
+            inet_ntoa(_options.uamlisten), _options.uamport);
+        }
+
+        redir_chartohex(conn.s_state.redir.uamchal, chal_buffer, REDIR_MD5LEN);
+
+        oauth2_set_parameter_list(&oauth2_session,
+          OAUTH2_OPT_RESPONSE_TYPE, OAUTH2_RESPONSE_TYPE_CODE,
+          OAUTH2_OPT_OIDC_ENDPOINT, _options.oidcdiscoveryurl,
+          OAUTH2_OPT_CLIENT_ID, _options.oidcclientid,
+          OAUTH2_OPT_CLIENT_SECRET, _options.oidcclientsecret,
+          OAUTH2_OPT_REDIRECT_URI, callback_url,
+          OAUTH2_OPT_SCOPE, "openid email profile",
+          OAUTH2_OPT_STATE, chal_buffer,
+          OAUTH2_OPT_NONE);
+
+        if (oauth2_get_openid_config(&oauth2_session) != OAUTH2_OK ||
+            oauth2_build_authorization_url(&oauth2_session) != OAUTH2_OK) {
+          oauth2_clean_session(&oauth2_session);
+          snprintf(buffer, bufsize, "HTTP/1.0 403 Forbidden\r\n\r\n");
+          redir_write(&socket, buffer, strlen(buffer));
+          return redir_main_exit(&socket, forked, rreq);
+        }
+
+        bstring buffer1 = bfromcstralloc(1024, "");
+        if (!buffer1) {
+          chilli_log(LOG_ERR, "%s: bfromcstralloc() memory allocation error.", __FUNCTION__);
+          return -1;
+        }
+
+        redir_http(buffer1, "302 Moved Temporarily");
+        bcatcstr(buffer1, "Location: ");
+
+        bconcat(buffer1, bfromcstr(oauth2_session.authorization_url));
+
+        bcatcstr(buffer1, "\r\nContent-Type: text/html; charset=UTF-8\r\n");
+
+        bstring bbody1 = bfromcstralloc(512, "<HTML><BODY><H2>Browser error!</H2>"
+                    "Browser does not support redirects!</BODY>\r\n");
+
+        bcatcstr(bbody1, "\r\n</HTML>\r\n");
+
+        bstring bt1 = bfromcstralloc(128, "");
+        bassignformat(bt1, "Content-Length: %d\r\n", blength(bbody1));
+        bconcat(buffer1, bt1);
+
+        bcatcstr(buffer1, "\r\n"); /* end of headers */
+        bconcat(buffer1, bbody1);
+
+        bdestroy(bbody1);
+        bdestroy(bt1);
+
+        if (redir_write(&socket, (char *)buffer1->data, buffer1->slen) < 0) {
+          chilli_log(LOG_ERR, "%s: redir_write()", strerror(errno));
+          bdestroy(buffer1);
+          oauth2_clean_session(&oauth2_session);
+          return -1;
+        }
+        bdestroy(buffer1);
+        oauth2_clean_session(&oauth2_session);
+
+        return redir_main_exit(&socket, forked, rreq);
+      }
+#endif
     case REDIR_MSDOWNLOAD:
       snprintf(buffer, bufsize, "HTTP/1.0 403 Forbidden\r\n\r\n");
       redir_write(&socket, buffer, strlen(buffer));
@@ -4184,7 +5625,7 @@
             "}\r\n";
 
         if (_options.debug)
-          syslog(LOG_DEBUG, "%s(%d): WPAD", __FUNCTION__, __LINE__);
+          chilli_log(LOG_DEBUG, "%s(%d): WPAD", __FUNCTION__, __LINE__);
 
         snprintf(buffer, bufsize, hdr, strlen(cnt));
         redir_write(&socket, buffer, strlen(buffer));
@@ -4202,7 +5643,7 @@
    *  It must be an original request
    */
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): redir_accept: Original request host=%s", __FUNCTION__, __LINE__, httpreq.host);
+    chilli_log(LOG_DEBUG, "%s(%d): redir_accept: Original request host=%s", __FUNCTION__, __LINE__, httpreq.host);
 
 #ifdef ENABLE_REDIRDNSREQ
   if (_options.redirdnsreq && tun) {
@@ -4314,15 +5755,12 @@
     redir_memcopy(REDIR_CHALLENGE);
     redir_msg_send(REDIR_MSG_OPT_REDIR);
   }
-  else {
-    redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
-    msg.mtype = splash ? REDIR_ALREADY : REDIR_NOTYET;
-    redir_msg_send(REDIR_MSG_OPT_REDIR);
-  }
+
+  redir_chartohex(conn.s_state.redir.uamchal, hexchal, REDIR_MD5LEN);
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "%s(%d): ---->>> challenge: %s", __FUNCTION__, __LINE__, hexchal);
+    chilli_log(LOG_DEBUG, "%s(%d): ---->>> challenge: %s", __FUNCTION__, __LINE__, hexchal);
 #endif
 
   if (_options.macreauth && !conn.s_state.authenticated) {
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/redir.h src/src/redir.h
--- upstream/src/redir.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/redir.h	2025-11-06 13:20:13.000000000 +0000
@@ -45,6 +45,11 @@
 #define REDIR_SPLASH          8
 #define REDIR_MACREAUTH       9
 #define REDIR_REQERROR       10  /* Used internally when the HTTP request parsing created an error */
+#define REDIR_SIGNUP		11
+#define REDIR_SMSSIGNUP		12
+#define REDIR_TRIAL			13
+#define REDIR_SSOLOGIN     14
+#define REDIR_SSOCALLBACK 15
 
 #define REDIR_WWW            20
 #ifdef ENABLE_EWTAPI
@@ -70,6 +75,25 @@
 #define REDIR_FAILED_NOROUTE 60 /* Reply to /logon - no route for NAI */
 #define REDIR_ERROR_PROTOCOL 61 /* Reply to /logon - the client software is not matching the protocol (e.g. WISPr 1.0 or WISPr 2.0) */
 #define REDIR_CHALLENGE      62 /* Reply to /logon - if Radius challenge received in EAP authentication */
+#define REDIR_FAILED_DATA	 63 /* Reply to /logon if data limit reached */
+#define REDIR_FAILED_TIME	 64 /* Reply to /logon if time limit reached */
+#define REDIR_SIGNUP_FAILED	 65 /* Reply to /signup if no username or password found */
+#define REDIR_SIGNUP_SUCCESS 66 /* Reply to /signup user registered successfully */
+#define REDIR_SIGNUP_ALREADY 67 /* Reply to /signup user registered unsuccessfully */
+#define REDIR_SIGNUP_DENIED 68 /* Reply to /signup if method is disabled */
+#define REDIR_SMSSIGNUP_FAILED 69 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_ALREADY 70 /* Reply to /smssignup user registered unsuccessfully */
+#define REDIR_SMSSIGNUP_SUCCESS 71 /* Reply to /smssignup user registered successfully */
+#define REDIR_SMSSIGNUP_SMS_FAIL 72 /* Reply to /smssignup user registered unsuccessfully (sms failure) */
+#define REDIR_SMSSIGNUP_DENIED 73 /* Reply to /smssignup if method is disabled */
+#define REDIR_FAILED_TOS 74 /* Reply to /logon - the client does not accepted TOS */
+#define REDIR_TRIALLOGIN_DENIED 75 /* Reply to /trial - method not allowed */
+#define REDIR_TRIALLOGIN_FAILED 76 /* Reply to /trial - login failed */
+#define REDIR_TRIAL_FAILED_DATA	 77 /* Reply to /trial if data limit reached */
+#define REDIR_TRIAL_FAILED_TIME	 78 /* Reply to /trial if time limit reached */
+#define REDIR_FAILED_USER_DUPLICATE	 79 /* Reply to /logon if user duplicates with other */
+#define REDIR_SSO_DENIED 80 /* Reply to /ssocallback - method not allowed */
+#define REDIR_SSO_FAILED 81 /* Reply to /ssocallback - login failed */
 
 /* If more than one format flag is set, it indicates that Coova advertises several
    protocols that can be used by the client. Once the client has choosen which protocol
@@ -92,6 +116,19 @@
 #define REDIR_MSG_OPT_PARAMS  2
 #define REDIR_MSG_NSESSIONID  4
 
+#define ACCESS_DENIED 0
+#define ACCESS_ACCEPTED 1
+#define ACCESS_DENIED_DATA 2
+#define ACCESS_DENIED_TIME 3
+#define ACCESS_DENIED_UDUPCLICATE 4
+
+#define AUTH_LOCAL_USER 0
+#define AUTH_DYN_USER 1
+#define AUTH_SMS_USER 2
+#define AUTH_MAC_USER 3
+#define AUTH_TRIAL_USER 4
+#define AUTH_SSO_USER 5
+
 struct eapmsg_t {
   uint16_t len;
   uint8_t data[MAX_EAP_LEN];
@@ -156,6 +193,10 @@
    */
   struct session_params s_params;
   struct session_state s_state;
+#ifdef ENABLE_DATABASE
+    struct session_history s_history;		/*Session history*/
+#endif
+
 } __attribute__((packed));
 
 /* HTTP request parsing context */
@@ -243,7 +284,7 @@
   int uiport;
 #endif
 
-  int starttime;
+  time_t starttime;
 
   char *url;
   char *homepage;
@@ -353,4 +394,9 @@
 
 ssize_t redir_write(struct redir_socket_t *sock, char *buf, size_t len);
 
+int authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int dynamic_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int sms_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+int mac_user_authenticator_chilli(struct app_conn_t *appconn, uint8_t *user_password);
+
 #endif	/* !_REDIR_H */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/rtmon.c src/src/rtmon.c
--- upstream/src/rtmon.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/rtmon.c	2025-11-06 13:20:13.000000000 +0000
@@ -58,7 +58,7 @@
   addr.nl_groups = MYMGRP;
 
   if (bind(sock,(struct sockaddr *)&addr,sizeof(addr)) < 0) {
-    syslog(LOG_ERR, "Binding on socket(%d) failed.", sock);
+    chilli_log(LOG_ERR, "Binding on socket(%d) failed.", sock);
     close(sock);
     return -1;
   }
@@ -178,7 +178,7 @@
 
   for (i=0; i < sz; i++) {
     if (!memcmp(&rtmon->_routes[i], rt, sizeof(struct rtmon_route))) {
-      syslog(LOG_DEBUG, "Already have this route for %s", inet_ntoa(rt->destination));
+      chilli_log(LOG_DEBUG, "Already have this route for %s", inet_ntoa(rt->destination));
       return 0;
     }
     if (!dst && !rtmon->_routes[i].has_data) {
@@ -387,7 +387,7 @@
     if (rtmon->_routes[i].has_data) {
       if (rtmon->_routes[i].destination.s_addr == 0) {
 
-	syslog(LOG_DEBUG, "Default Route %s", inet_ntoa(rtmon->_routes[i].gateway));
+	chilli_log(LOG_DEBUG, "Default Route %s", inet_ntoa(rtmon->_routes[i].gateway));
 
 	for (j=0; j < rtmon->_iface_sz; j++) {
 	  if (rtmon->_ifaces[j].has_data) {
@@ -396,7 +396,7 @@
 	      struct sockaddr_in *sin;
 	      int s, attempt=0, retries=3;
 
-	      syslog(LOG_DEBUG, "Route Interface %s", rtmon->_ifaces[j].devname);
+	      chilli_log(LOG_DEBUG, "Route Interface %s", rtmon->_ifaces[j].devname);
 
 	      if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
 		perror("socket");
@@ -428,7 +428,7 @@
 		if (ioctl(s, SIOCGARP, (caddr_t) &areq) == -1) {
 
 		  if (errno == ENXIO) {
-		    syslog(LOG_DEBUG, "%s -- no entry\n", inet_ntoa(sin->sin_addr));
+		    chilli_log(LOG_DEBUG, "%s -- no entry\n", inet_ntoa(sin->sin_addr));
 		    attempt++;
 		    sleep(1);
 		    continue;
@@ -437,11 +437,11 @@
 
 		} else {
 
-		  syslog(LOG_DEBUG, "MAC %s", mactoa((uint8_t *)&areq.arp_ha.sa_data));
+		  chilli_log(LOG_DEBUG, "MAC %s", mactoa((uint8_t *)&areq.arp_ha.sa_data));
 		  memcpy(rtmon->_routes[i].gwaddr, &areq.arp_ha.sa_data, sizeof(rtmon->_routes[i].gwaddr));
 
 		  if (rtmon->cb(rtmon, &rtmon->_ifaces[j], &rtmon->_routes[i]))
-		    syslog(LOG_ERR, "%s: callback failed", strerror(errno));
+		    chilli_log(LOG_ERR, "%s: callback failed", strerror(errno));
 
 		  break;
 		}
@@ -465,10 +465,10 @@
   ri->has_data = 1 | RTMON_REMOVE;
 
   for (i=0; i < sz; i++) {
-    syslog(LOG_DEBUG, "i=%d sz=%d",i,sz);
+    chilli_log(LOG_DEBUG, "i=%d sz=%d",i,sz);
     if (!memcmp(&rtmon->_ifaces[i], ri, sizeof(struct rtmon_iface))) {
       rtmon->_ifaces[i].has_data = 1;
-      syslog(LOG_DEBUG, "Already have this iface %s", ri->devname);
+      chilli_log(LOG_DEBUG, "Already have this iface %s", ri->devname);
       return 0;
     }
     if (!dst && !rtmon->_ifaces[i].has_data) {
@@ -664,7 +664,7 @@
     return ret;
   }
 
-  syslog(LOG_DEBUG, "Type: %i (%s)",(nlh.nlmsg_type),lookup_name(typenames,nlh.nlmsg_type));
+  chilli_log(LOG_DEBUG, "Type: %i (%s)",(nlh.nlmsg_type),lookup_name(typenames,nlh.nlmsg_type));
 
 #define FLAG(x) if (nlh.nlmsg_flags & x) printf(" %s",#x)
   FLAG(NLM_F_REQUEST);
@@ -677,7 +677,7 @@
   FLAG(NLM_F_APPEND);
 #undef FLAG
 
-  syslog(LOG_DEBUG, "Seq : %i Pid : %i",nlh.nlmsg_seq,nlh.nlmsg_pid);
+  chilli_log(LOG_DEBUG, "Seq : %i Pid : %i",nlh.nlmsg_seq,nlh.nlmsg_pid);
 
   rtmon_discover_ifaces(rtmon);
   rtmon_discover_routes(rtmon);
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/safe.c src/src/safe.c
--- upstream/src/safe.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/safe.c	2025-11-06 13:20:13.000000000 +0000
@@ -84,7 +84,7 @@
   } while (ret == -1 && errno == EINTR);
 #if(_debug_)
   if (ret < 0)
-    syslog(LOG_ERR, "%s: write(%d, %zd)", strerror(errno), s, blen);
+    chilli_log(LOG_ERR, "%s: write(%d, %zd)", strerror(errno), s, blen);
 #endif
   return ret;
 }
@@ -96,7 +96,7 @@
   } while (ret == -1 && errno == EINTR);
 #if(_debug_)
   if (ret < 0)
-    syslog(LOG_ERR, "%s: recv(%d, %zd)", strerror(errno), sockfd, len);
+    chilli_log(LOG_ERR, "%s: recv(%d, %zd)", strerror(errno), sockfd, len);
 #endif
   return ret;
 }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/sample-mod.c src/src/sample-mod.c
--- upstream/src/sample-mod.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/sample-mod.c	2025-11-06 13:20:13.000000000 +0000
@@ -12,11 +12,11 @@
   char req[512];
 
   if ((rlen = safe_read(fd, req, sizeof(req))) < 0) {
-    syslog(LOG_ERR, "%s: acc()/read()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: acc()/read()", strerror(errno));
     return -1;
   }
 
-  syslog(LOG_DEBUG, "Received echo %.*s", rlen, req);
+  chilli_log(LOG_DEBUG, "Received echo %.*s", rlen, req);
 
   return CHILLI_MOD_OK;
 }
@@ -24,11 +24,11 @@
 static int module_initialize(char *conf, char isReload) {
   struct sockaddr_un local;
 
-  syslog(LOG_DEBUG, "%s('%s', %d)", __FUNCTION__, conf, (int) isReload);
+  chilli_log(LOG_DEBUG, "%s('%s', %d)", __FUNCTION__, conf, (int) isReload);
 
   if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
 
-    syslog(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not allocate UNIX Socket!", strerror(errno));
 
   } else {
 
@@ -39,7 +39,7 @@
 
     if (bind(fd, (struct sockaddr *)&local,
 	     sizeof(struct sockaddr_un)) == -1) {
-      syslog(LOG_ERR, "%s: could bind UNIX Socket!", strerror(errno));
+      chilli_log(LOG_ERR, "%s: could bind UNIX Socket!", strerror(errno));
       close(fd);
       fd = 0;
     }
@@ -49,7 +49,7 @@
 }
 
 static int module_net_select(select_ctx *sctx) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   net_select_reg(sctx, fd, SELECT_READ, (select_callback) acc, 0, 0);
   return CHILLI_MOD_OK;
 }
@@ -57,47 +57,47 @@
 static int module_redir_login(struct redir_t *redir,
 			      struct redir_conn_t *conn,
 			      struct redir_socket_t *sock) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_dhcp_connect(struct app_conn_t *appconn,
 			       struct dhcp_conn_t *dhcpconn) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_dhcp_disconnect(struct app_conn_t *appconn,
 				  struct dhcp_conn_t *dhcpconn) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_session_start(struct app_conn_t *appconn) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_session_update(struct app_conn_t *appconn) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_session_stop(struct app_conn_t *appconn) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_MOD_OK;
 }
 
 static int module_dns_handler (struct app_conn_t *appconn,
 			       struct dhcp_conn_t *dhcpconn,
 			       uint8_t *pack, size_t *plen, int isReq) {
-  syslog(LOG_DEBUG, "%s", __FUNCTION__);
+  chilli_log(LOG_DEBUG, "%s", __FUNCTION__);
   return CHILLI_DNS_OK;
 }
 
 static int module_destroy(char isReload) {
 
-  syslog(LOG_DEBUG, "%s(%d)", __FUNCTION__, (int) isReload);
+  chilli_log(LOG_DEBUG, "%s(%d)", __FUNCTION__, (int) isReload);
 
   close(fd);
   return CHILLI_MOD_OK;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/session.c src/src/session.c
--- upstream/src/session.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.c	2025-11-06 13:20:13.000000000 +0000
@@ -68,16 +68,16 @@
   bcatcstr(json,"\",\"userName\":\"");
   bcatcstr(json,state->redir.username);
   bcatcstr(json, "\",\"startTime\":");
-  bassignformat(tmp, "%ld", (long) mainclock_towall(init ? mainclock_now() : starttime));
+  bassignformat(tmp, "%"PRId64, (uint64_t) mainclock_towall(init ? mainclock_now() : starttime));
   bconcat(json, tmp);
   bcatcstr(json,",\"sessionTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->sessiontimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessiontimeout);
   bconcat(json, tmp);
   bcatcstr(json,",\"terminateTime\":");
-  bassignformat(tmp, "%ld", (long) params->sessionterminatetime);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->sessionterminatetime);
   bconcat(json, tmp);
   bcatcstr(json,",\"idleTimeout\":");
-  bassignformat(tmp, "%ld", (long) params->idletimeout);
+  bassignformat(tmp, "%"PRId64, (uint64_t) params->idletimeout);
   bconcat(json, tmp);
 #ifdef ENABLE_IEEE8021Q
   if (_options.ieee8021q && state->tag8021q) {
@@ -101,6 +101,11 @@
     bassignformat(tmp, "%lld", params->maxtotaloctets);
     bconcat(json, tmp);
   }
+  if (params->warningoctets) {
+    bcatcstr(json,",\"warningOctets\":");
+    bassignformat(tmp, "%lld", params->warningoctets);
+    bconcat(json, tmp);
+  }
 
   bdestroy(tmp);
   return 0;
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/session.h src/src/session.h
--- upstream/src/session.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/session.h	2025-11-06 13:20:13.000000000 +0000
@@ -25,7 +25,6 @@
 #include "garden.h"
 
 struct session_params {
-  uint8_t url[REDIR_USERURLSIZE];
   uint8_t filteridbuf[256];
   uint8_t filteridlen;
   uint8_t routeidx;
@@ -34,10 +33,20 @@
   uint64_t maxinputoctets;
   uint64_t maxoutputoctets;
   uint64_t maxtotaloctets;
+  uint64_t warningoctets; /* Data amount over which an SMS warning is sent */
   uint64_t sessiontimeout;
   uint32_t idletimeout;
   uint16_t interim_interval;     /* Seconds. 0 = No interim accounting */
   time_t sessionterminatetime;
+  int period; /* Data limit period */
+  int start;  /* Data limit start point */
+  uint64_t expiration;  /* Expiration time for dynamically allocated users */
+  uint32_t padding;
+  uint8_t url[REDIR_USERURLSIZE];
+
+#define PERIOD_DAY 1
+#define PERIOD_WEEK 2
+#define PERIOD_MONTH 3
 
 #define REQUIRE_UAM_AUTH   (1<<0)
 #define REQUIRE_UAM_SPLASH (1<<1)
@@ -63,6 +72,9 @@
   struct in_addr dns1;
 #endif
 
+  struct in_addr tcp_reset_addr[MAX_PASS_THROUGHS * 2];
+  uint32_t num_tcp_reset_addr;
+
 #ifdef ENABLE_SESSGARDEN
   pass_through pass_throughs[SESSION_PASS_THROUGH_MAX];
   uint32_t pass_through_count;
@@ -74,27 +86,26 @@
 
   char username[REDIR_USERNAMESIZE];
   char userurl[REDIR_USERURLSIZE];
+  char phone[64];
+  char email[128];
+  char signup_password[128];
+#ifdef USING_CURL
+  char code[4096];
+#endif
 
   uint8_t uamchal[REDIR_MD5LEN];
 
-  /* To store the RADIUS CLASS attribute received in the Access Accept */
-  uint8_t classbuf[RADIUS_ATTR_VLEN];
-  size_t classlen;
-
-  /* To store the RADIUS CUI attribute received in the Access Accept */
-  uint8_t cuibuf[RADIUS_ATTR_VLEN];
-  size_t cuilen;
-
-  /* To store the RADIUS STATE attribute between Radius requests */
-  uint8_t statebuf[RADIUS_ATTR_VLEN];
-  uint8_t statelen;
-
   /*  EAP identity of the last request sent */
   uint8_t eap_identity;
 
   /* UAM protocol used */
   uint8_t uamprotocol;
 
+  uint8_t tos:1;
+  uint8_t otp_state:1;
+  int auth_mode; /* user authentication mode */
+  int user_time;
+
 #ifdef ENABLE_USERAGENT
   char useragent[REDIR_USERAGENTSIZE];
 #endif
@@ -113,6 +124,15 @@
   size_t vsalen;
 #endif
 
+  /* To store the RADIUS CLASS attribute received in the Access Accept */
+  uint8_t classbuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS CUI attribute received in the Access Accept */
+  uint8_t cuibuf[RADIUS_ATTR_VLEN];
+  /* To store the RADIUS STATE attribute between Radius requests */
+  uint8_t statebuf[RADIUS_ATTR_VLEN];
+  size_t classlen;
+  size_t cuilen;
+  uint8_t statelen;
 } __attribute__((packed));
 
 struct session_state {
@@ -133,16 +153,21 @@
 
   struct timespec last_bw_time;
 
+  time_t dhcp_last_time; /* Last time a dhcp packet was received */
   time_t last_up_time;
   time_t last_time; /* Last time a packet was received or sent */
   time_t uamtime;
 
+  int warning_sent_download;
+  int warning_sent_upload;
+
   uint64_t input_packets;
   uint64_t output_packets;
   uint64_t input_octets;
   uint64_t output_octets;
   uint32_t terminate_cause;
   uint32_t session_id;
+  uint32_t terminate_cause_ui;
 
 #ifdef ENABLE_GARDENACCOUNTING
   char garden_sessionid[REDIR_SESSIONID_LEN];
@@ -198,5 +223,14 @@
 #endif
 
 } __attribute__((packed));
+#ifdef ENABLE_DATABASE
+struct session_history {
+    uint64_t input_packets;
+    uint64_t output_packets;
+    uint64_t input_octets;
+    uint64_t output_octets;
+    uint32_t sessiontime;
+} __attribute__((packed));
+#endif
 
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/sqlite.c src/src/sqlite.c
--- upstream/src/sqlite.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,73 @@
+
+#include "sqlite.h"
+#include "system.h"
+
+sqlite3 *sqlopen(char *dbpath) {
+    sqlite3 *db;
+    int ret;
+
+    ret = sqlite3_open(dbpath, &db);
+    if (ret)
+        chilli_log(LOG_INFO, "[%s] Can't open database: %s", __FUNCTION__ , sqlite3_errmsg(db));
+
+    return db;
+}
+
+int sqlclose(sqlite3 *db){
+    return sqlite3_close(db);
+}
+
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**)){
+    int ret;
+    char *err = 0;
+
+    ret = sqlite3_exec(db, sql, callback, 0, &err);
+    if (ret){
+        chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+        sqlite3_free(err);
+    }
+
+    return ret;
+}
+
+int sqlprepare(sqlite3 *db, char *sql){
+    sqlite3_stmt *stmt;
+    int ret;
+
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
+    if (ret) {
+        chilli_log(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    ret = sqlite3_step(stmt);
+    if (ret){
+        chilli_log(LOG_INFO, "SQL error: %s\n", sqlite3_errmsg(db));
+        goto out;
+    }
+
+    out:
+    return ret;
+}
+
+int sqltable_exists(sqlite3 *db, char *table_name){
+    int ret;
+    int count = 0;
+    char *sql = NULL;
+    sqlite3_stmt *stmt;
+
+    asprintf(&sql, "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='%s';",
+			 table_name);
+    ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+    if (ret != SQLITE_OK) {
+        chilli_log(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__ , sqlite3_errmsg(db));
+        return SQL_FAIL;
+    }
+
+    if ((ret = sqlite3_step(stmt)) == SQLITE_ROW)
+        count = sqlite3_column_int(stmt, 0);
+
+    sqlite3_finalize(stmt);
+
+    return (count == 0) ? SQL_FAIL : SQL_SUCCESS;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/sqlite.h src/src/sqlite.h
--- upstream/src/sqlite.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/sqlite.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,19 @@
+//
+// Created by darius on 19.5.23.
+//
+
+#ifndef RUTX_SQLITE_H
+#define RUTX_SQLITE_H
+
+#include <sqlite3.h>
+
+#define SQL_SUCCESS 0
+#define SQL_FAIL 1
+
+sqlite3 *sqlopen(char *dbpath);
+int sqlclose(sqlite3 *db);
+int sqlexec(sqlite3 *db, char *sql, int (*callback)(void*,int,char**,char**));
+int sqlprepare(sqlite3 *db, char *sql);
+int sqltable_exists(sqlite3 *db, char *table_name);
+
+#endif //RUTX_SQLITE_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ssl.c src/src/ssl.c
--- upstream/src/ssl.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ssl.c	2025-11-06 13:20:13.000000000 +0000
@@ -35,14 +35,16 @@
     if (openssl_init == 0) {
       openssl_init = 1;
 #ifdef HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       if (_options.debug) {
 	SSL_load_error_strings();
       }
       SSL_library_init();
       OpenSSL_add_all_algorithms();
+#endif
 #else
       matrixSslOpen();
-      syslog(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
 #endif
     }
     openssl_env_init(sslenv_svr = calloc(1, sizeof(openssl_env)), 0, 1);
@@ -55,14 +57,16 @@
     if (openssl_init == 0) {
       openssl_init = 1;
 #ifdef HAVE_OPENSSL
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
       if (_options.debug) {
 	SSL_load_error_strings();
       }
       SSL_library_init();
       OpenSSL_add_all_algorithms();
+#endif
 #else
       matrixSslOpen();
-      syslog(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
+      chilli_log(LOG_DEBUG, "%s(%d): MatrixSslOpen()", __FUNCTION__, __LINE__);
 #endif
     }
     openssl_env_init(sslenv_cli = calloc(1, sizeof(openssl_env)), 0, 0);
@@ -75,7 +79,7 @@
 openssl_verify_peer_cb(int ok, X509_STORE_CTX *ctx) {
   int err = X509_STORE_CTX_get_error(ctx);
   if (err != X509_V_OK) {
-    syslog(LOG_ERR, "%d peer certificate error: #%d : %s\n",
+    chilli_log(LOG_ERR, "%d peer certificate error: #%d : %s\n",
            errno, err, X509_verify_cert_error_string(err));
     return 0;
   }
@@ -94,7 +98,7 @@
   if (file)
     if (SSL_CTX_use_certificate_chain_file(env->ctx, file) > 0)
       return 1;
-  syslog(LOG_ERR, "%s: could not load certificate file %s\n", strerror(errno), file);
+  chilli_log(LOG_ERR, "%s: could not load certificate file %s\n", strerror(errno), file);
   return 0;
 }
 
@@ -106,7 +110,7 @@
         (err2 = SSL_CTX_check_private_key(env->ctx)))
       return 1;
   }
-  syslog(LOG_ERR, "%s: could not load private key file %s (%d,%d)\n", strerror(errno), file, err1, err2);
+  chilli_log(LOG_ERR, "%s: could not load private key file %s (%d,%d)\n", strerror(errno), file, err1, err2);
   return 0;
 }
 
@@ -114,7 +118,7 @@
 openssl_cacert_location(openssl_env *env, char *file, char *dir) {
   int err = SSL_CTX_load_verify_locations(env->ctx, file, dir);
   if (!err)
-    syslog(LOG_ERR, "%s: unable to load CA certificates.\n", strerror(errno));
+    chilli_log(LOG_ERR, "%s: unable to load CA certificates.\n", strerror(errno));
   return err;
 }
 
@@ -132,7 +136,7 @@
   if (_options.sslciphers) {
     SSL_CTX_set_cipher_list(env->ctx, _options.sslciphers);
   }
-#ifdef HAVE_OPENSSL_ENGINE
+#ifndef OPENSSL_NO_ENGINE
   if (engine) {
  retry:
     if ((env->engine = ENGINE_by_id(engine)) == NULL) {
@@ -175,7 +179,7 @@
 openssl_env_init(openssl_env *env, char *engine, int server) {
 
   if (!_options.sslcertfile || !_options.sslkeyfile) {
-    syslog(LOG_ERR, "options sslcertfile and sslkeyfile are required");
+    chilli_log(LOG_ERR, "options sslcertfile and sslkeyfile are required");
     return 0;
   }
 
@@ -189,13 +193,13 @@
 
     if (!openssl_use_certificate(env, _options.sslcertfile) ||
 	!openssl_use_privatekey(env, _options.sslkeyfile)) {
-      syslog(LOG_ERR, "failed reading setup sslcertfile and/or sslkeyfile");
+      chilli_log(LOG_ERR, "failed reading setup sslcertfile and/or sslkeyfile");
       return 0;
     }
 
     if (_options.sslcafile) {
       if (!openssl_cacert_location(env, _options.sslcafile, 0)) {
-	syslog(LOG_ERR, "failed reading sslcafile");
+	chilli_log(LOG_ERR, "failed reading sslcafile");
 	return 0;
       }
     }
@@ -204,17 +208,17 @@
     return err;
   }
 #else
-  syslog(LOG_DEBUG, "%s(%d): MatrixSSL Setup:", __FUNCTION__, __LINE__);
-  syslog(LOG_DEBUG, "%s(%d): SSL cert: %s", __FUNCTION__, __LINE__, _options.sslcertfile);
-  syslog(LOG_DEBUG, "%s(%d): SSL key: %s", __FUNCTION__, __LINE__, _options.sslkeyfile);
-  syslog(LOG_DEBUG, "%s(%d): SSL pass: %s", __FUNCTION__, __LINE__, _options.sslkeypass?_options.sslkeypass:"null");
-  syslog(LOG_DEBUG, "%s(%d): SSL ca: %s", __FUNCTION__, __LINE__, _options.sslcafile?_options.sslcafile:"null");
+  chilli_log(LOG_DEBUG, "%s(%d): MatrixSSL Setup:", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): SSL cert: %s", __FUNCTION__, __LINE__, _options.sslcertfile);
+  chilli_log(LOG_DEBUG, "%s(%d): SSL key: %s", __FUNCTION__, __LINE__, _options.sslkeyfile);
+  chilli_log(LOG_DEBUG, "%s(%d): SSL pass: %s", __FUNCTION__, __LINE__, _options.sslkeypass?_options.sslkeypass:"null");
+  chilli_log(LOG_DEBUG, "%s(%d): SSL ca: %s", __FUNCTION__, __LINE__, _options.sslcafile?_options.sslcafile:"null");
   if ( matrixSslReadKeys( &env->keys,
 			  _options.sslcertfile,
 			  _options.sslkeyfile,
 			  _options.sslkeypass,
 			  _options.sslcafile ) < 0 ) {
-    syslog(LOG_ERR, "%s: could not load ssl certificate or and/or key file", strerror(errno));
+    chilli_log(LOG_ERR, "%s: could not load ssl certificate or and/or key file", strerror(errno));
     return 0;
   }
 
@@ -225,7 +229,7 @@
 
 #ifdef HAVE_MATRIXSSL
 static int certValidator(sslCertInfo_t *t, void *arg) {
-  syslog(LOG_DEBUG, "%s(%d): MatrixSSL: certValidator()", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): MatrixSSL: certValidator()", __FUNCTION__, __LINE__);
   return 1;
 }
 #endif
@@ -257,7 +261,7 @@
 #if(_debug_)
     unsigned long error;
     while ((error = ERR_get_error())) {
-      syslog(LOG_DEBUG, "%s(%d): TLS: %s", __FUNCTION__, __LINE__, ERR_error_string(error, NULL));
+      chilli_log(LOG_DEBUG, "%s(%d): TLS: %s", __FUNCTION__, __LINE__, ERR_error_string(error, NULL));
       is_error = 1;
     }
 #endif
@@ -268,7 +272,7 @@
   }
 #elif  HAVE_MATRIXSSL
   if (!SSL_connect(c->con, certValidator, c)) {
-    syslog(LOG_ERR, "%s: openssl_connect_fd", strerror(errno));
+    chilli_log(LOG_ERR, "%s: openssl_connect_fd", strerror(errno));
     openssl_free(c);
     return 0;
   }
@@ -300,10 +304,10 @@
           if (errno != EINTR) {
 #if(_debug_ > 1)
             if (errno > 0) {
-              syslog(LOG_DEBUG, "%s(%d): SSL handshake interrupted by system [Hint: Stop button pressed in browser?!]", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): SSL handshake interrupted by system [Hint: Stop button pressed in browser?!]", __FUNCTION__, __LINE__);
             }
             else {
-              syslog(LOG_DEBUG, "%s(%d): Spurious SSL handshake interrupt [Hint: Usually just one of those OpenSSL confusions!?]", __FUNCTION__, __LINE__);
+              chilli_log(LOG_DEBUG, "%s(%d): Spurious SSL handshake interrupt [Hint: Usually just one of those OpenSSL confusions!?]", __FUNCTION__, __LINE__);
             }
 #endif
           }
@@ -315,7 +319,11 @@
     } else {
 
 #ifdef HAVE_OPENSSL_ENGINE
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+      X509 *peer_cert = SSL_get1_peer_certificate(c->con);
+#else
       X509 *peer_cert = SSL_get_peer_certificate(c->con);
+#endif
 
       if (peer_cert) {
 	char subj[1024];
@@ -323,12 +331,12 @@
 	X509_NAME_oneline(X509_get_subject_name(peer_cert),subj,sizeof(subj));
 
 	if (SSL_get_verify_result(c->con) != X509_V_OK) {
-	  syslog(LOG_DEBUG, "%s(%d): auth_failed: %s", __FUNCTION__, __LINE__, subj);
+	  chilli_log(LOG_DEBUG, "%s(%d): auth_failed: %s", __FUNCTION__, __LINE__, subj);
 	  X509_free(peer_cert);
 	  return -1;
 	}
 
-	syslog(LOG_DEBUG, "%s(%d): auth_success: %s", __FUNCTION__, __LINE__, subj);
+	chilli_log(LOG_DEBUG, "%s(%d): auth_success: %s", __FUNCTION__, __LINE__, subj);
 	if (conn) conn->s_params.flags |= ADMIN_LOGIN;
 
 	if (_options.debug) {
@@ -338,21 +346,21 @@
 #endif
               SSL_CIPHER *cipher;
 	  char b[512];
-	  syslog(LOG_DEBUG, "%s(%d): Debugging: SSL Information:\n", __FUNCTION__, __LINE__);
+	  chilli_log(LOG_DEBUG, "%s(%d): Debugging: SSL Information:\n", __FUNCTION__, __LINE__);
 	  cipher = SSL_get_current_cipher(c->con);
-	  syslog(LOG_DEBUG, "%s(%d): Protocol: %s, %s with %.*s bit key\n", __FUNCTION__, __LINE__,
+	  chilli_log(LOG_DEBUG, "%s(%d): Protocol: %s, %s with %.*s bit key\n", __FUNCTION__, __LINE__,
                  SSL_CIPHER_get_version(cipher),
                  (char*)SSL_CIPHER_get_name(cipher),
                  sprintf(b, "%d", EVP_PKEY_bits(pktmp)), b);
-	  syslog(LOG_DEBUG, "%s(%d): Subject:  %s\n", __FUNCTION__, __LINE__, subj);
+	  chilli_log(LOG_DEBUG, "%s(%d): Subject:  %s\n", __FUNCTION__, __LINE__, subj);
 	  X509_NAME_oneline(X509_get_issuer_name(peer_cert),b,sizeof(b));
-	  syslog(LOG_DEBUG, "%s(%d): Issuer:   %s\n", __FUNCTION__, __LINE__, b);
+	  chilli_log(LOG_DEBUG, "%s(%d): Issuer:   %s\n", __FUNCTION__, __LINE__, b);
 	  EVP_PKEY_free(pktmp);
 	}
 
 	X509_free(peer_cert);
       } else {
-	syslog(LOG_DEBUG, "%s(%d): no SSL certificate", __FUNCTION__, __LINE__);
+	chilli_log(LOG_DEBUG, "%s(%d): no SSL certificate", __FUNCTION__, __LINE__);
       }
 #endif
     }
@@ -384,7 +392,7 @@
   if (!c) return 0;
 
   if (!env || !env->ready) {
-    syslog(LOG_ERR, "SSL not available!");
+    chilli_log(LOG_ERR, "SSL not available!");
     openssl_free(c);
     return 0;
   }
@@ -427,7 +435,7 @@
   matrixSslSetCertValidator(c->con->ssl, certValidator, c->con->keys);
 
   if ((rc = SSL_accept2(c->con)) < 0) {
-    syslog(LOG_ERR, "%s: SSL accept failure %s", strerror(errno), c->con->status);
+    chilli_log(LOG_ERR, "%s: SSL accept failure %s", strerror(errno), c->con->status);
     openssl_free(c);
     return 0;
   }
@@ -450,7 +458,7 @@
   if (con->con) {
     err = SSL_get_error(con->con, ret);
 #if(_debug_ > 1)
-    syslog(LOG_DEBUG, "%s(%d): SSL: (%s()) %s", __FUNCTION__, __LINE__, func,
+    chilli_log(LOG_DEBUG, "%s(%d): SSL: (%s()) %s", __FUNCTION__, __LINE__, func,
            err == SSL_ERROR_NONE ? "None":
            err == SSL_ERROR_ZERO_RETURN ? "Return!":
            err == SSL_ERROR_WANT_READ ? "Read (continue)":
@@ -480,7 +488,7 @@
   }
   return err;
 #else
-  syslog(LOG_ERR, "%s: ssl error in %s", strerror(errno), func);
+  chilli_log(LOG_ERR, "%s: ssl error in %s", strerror(errno), func);
   return 0;
 #endif
 }
@@ -533,7 +541,7 @@
 
   rbytes = SSL_read(con->con, b, l);
 
-  syslog(LOG_DEBUG, "%s(%d): --- SSL_read() = %d", __FUNCTION__, __LINE__, rbytes);
+  chilli_log(LOG_DEBUG, "%s(%d): --- SSL_read() = %d", __FUNCTION__, __LINE__, rbytes);
 
   if (rbytes <= 0) {
     err = openssl_error(con, rbytes, "openssl_read");
@@ -576,7 +584,7 @@
       if (err == -1) return err;
       else if (err > 0) {
 #if(_debug_)
-	//syslog(LOG_DEBUG, "ssl_repeat_write");
+	//chilli_log(LOG_DEBUG, "ssl_repeat_write");
 #endif
 	goto repeat_write;
       }
@@ -605,11 +613,11 @@
 void
 openssl_env_free(openssl_env *env) {
 #if(_debug_)
-  syslog(LOG_DEBUG, "%s(%d): Freeing SSL environemnt", __FUNCTION__, __LINE__);
+  chilli_log(LOG_DEBUG, "%s(%d): Freeing SSL environemnt", __FUNCTION__, __LINE__);
 #endif
 #ifdef HAVE_OPENSSL
   if (env->ctx) SSL_CTX_free(env->ctx);
-#ifdef HAVE_OPENSSL_ENGINE
+#ifndef OPENSSL_NO_ENGINE
   if (env->engine) ENGINE_free(env->engine);
 #endif
 #endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ssl.h src/src/ssl.h
--- upstream/src/ssl.h	2016-12-15 17:28:43.000000000 +0000
+++ src/src/ssl.h	2025-11-06 13:20:13.000000000 +0000
@@ -41,6 +41,7 @@
 #include <openssl/ssl.h>
 #include <openssl/pem.h>
 #include <openssl/engine.h>
+#include <openssl/err.h>
 #elif HAVE_CYASSL
 #include <stdio.h>
 #include <stdlib.h>
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/statusfile.c src/src/statusfile.c
--- upstream/src/statusfile.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/statusfile.c	2025-11-06 13:20:13.000000000 +0000
@@ -47,14 +47,14 @@
 
   statedir_file(filedest, sizeof(filedest), _options.usestatusfile, 0);
 
-  syslog(LOG_DEBUG, "%s(%d): Loading file %s", __FUNCTION__, __LINE__, filedest);
+  chilli_log(LOG_DEBUG, "%s(%d): Loading file %s", __FUNCTION__, __LINE__, filedest);
 
   file = fopen(filedest, "r");
-  if (!file) { syslog(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
+  if (!file) { chilli_log(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
 
   while ((c = fgetc(file)) != MARK_START) {
     if (c == EOF) {
-      syslog(LOG_ERR, "%s: end of file", strerror(errno));
+      chilli_log(LOG_ERR, "%s: end of file", strerror(errno));
       fclose(file);
       return -1;
     }
@@ -62,28 +62,28 @@
 
   time(&wall);
   if (fread(&r_wall, sizeof(time_t), 1, file) != 1) {
-    syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+    chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
     if (c == EOF) { fclose(file); return -1; }
   }
 
   rt = mainclock_tick();
   if (fread(&r_rt, sizeof(time_t), 1, file) != 1) {
-    syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+    chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
     if (c == EOF) { fclose(file); return -1; }
   }
 
   if ((c = fgetc(file)) != MARK_START) {
-    syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+    chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
     fclose(file);
     return -1;
   }
 
   rtoffset = wall - rt;
-  syslog(LOG_DEBUG, "%s(%d): now: wall = %d, rt = %d, wall at rt=0 %d", __FUNCTION__, __LINE__, 
+  chilli_log(LOG_DEBUG, "%s(%d): now: wall = %d, rt = %d, wall at rt=0 %d", __FUNCTION__, __LINE__, 
          (int)wall, (int)rt, (int)rtoffset);
 
   r_rtoffset = r_wall - r_rt;
-  syslog(LOG_DEBUG, "%s(%d): file: wall = %d, rt = %d, wall at rt=0 %d", __FUNCTION__, __LINE__,
+  chilli_log(LOG_DEBUG, "%s(%d): file: wall = %d, rt = %d, wall at rt=0 %d", __FUNCTION__, __LINE__,
          (int)r_wall, (int)r_rt, (int)r_rtoffset);
 
   while (fread(&dhcpconn, sizeof(struct dhcp_conn_t), 1, file) == 1) {
@@ -94,14 +94,14 @@
     /* todo: read a md5 checksum or magic token */
 
     if ((c = fgetc(file)) != MARK_NEXT) {
-      syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+      chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
       fclose(file);
       return -1;
     }
 
     if (dhcp_hashget(dhcp, &conn, dhcpconn.hismac)) {
 
-      syslog(LOG_INFO, "Loading dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
+      chilli_log(LOG_INFO, "Loading dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
              dhcpconn.hismac[0], dhcpconn.hismac[1],
              dhcpconn.hismac[2], dhcpconn.hismac[3],
              dhcpconn.hismac[4], dhcpconn.hismac[5]);
@@ -138,13 +138,13 @@
 	memset(conn->dnat[n].mac, 0, PKT_ETH_ALEN);
       }
 
-      syslog(LOG_DEBUG, "%s(%d): checking IP %s", __FUNCTION__, __LINE__, inet_ntoa(dhcpconn.hisip));
+      chilli_log(LOG_DEBUG, "%s(%d): checking IP %s", __FUNCTION__, __LINE__, inet_ntoa(dhcpconn.hisip));
 
       /* add into ippool */
       if (ippool_getip(ippool, &newipm, &dhcpconn.hisip)) {
 	if (ippool_newip(ippool, &newipm, &dhcpconn.hisip, 1)) {
 	  if (ippool_newip(ippool, &newipm, &dhcpconn.hisip, 0)) {
-	    syslog(LOG_ERR, "Failed to allocate either static or dynamic IP address");
+	    chilli_log(LOG_ERR, "Failed to allocate either static or dynamic IP address");
 	    conn->hisip.s_addr = 0;
 	  }
 	}
@@ -159,7 +159,7 @@
 	  struct app_conn_t *aconn = 0;
 
 	  if ((c = fgetc(file)) != MARK_NEXT) {
-	    syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+	    chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
 	    fclose(file);
 	    return -1;
 	  }
@@ -214,14 +214,14 @@
 	  /* todo: read a md5 checksum or magic token */
 	}
 	else {
-	  syslog(LOG_ERR, "%s: Problem loading state file %s", strerror(errno), filedest);
+	  chilli_log(LOG_ERR, "%s: Problem loading state file %s", strerror(errno), filedest);
 	  break;
 	}
       }
 
     } else {
 
-      syslog(LOG_INFO, "Known dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
+      chilli_log(LOG_INFO, "Known dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X",
              dhcpconn.hismac[0], dhcpconn.hismac[1],
              dhcpconn.hismac[2], dhcpconn.hismac[3],
              dhcpconn.hismac[4], dhcpconn.hismac[5]);
@@ -230,12 +230,12 @@
 
       if (dhcpconn.peer) {
 
-	syslog(LOG_INFO, "Reading appconn (peer)");
+	chilli_log(LOG_INFO, "Reading appconn (peer)");
 
 	if (fread(&appconn, sizeof(struct app_conn_t), 1, file) == 1) {
 
 	  if ((c = fgetc(file)) != MARK_NEXT) {
-	    syslog(LOG_ERR, "%s: bad binary file", strerror(errno));
+	    chilli_log(LOG_ERR, "%s: bad binary file", strerror(errno));
 	    fclose(file);
 	    return -1;
 	  }
@@ -246,7 +246,7 @@
 	     */
 	    struct app_conn_t *aconn = (struct app_conn_t*) conn->peer;
 
-	    syslog(LOG_INFO, "Overwriting existing appconn %d", appconn.s_state.authenticated);
+	    chilli_log(LOG_INFO, "Overwriting existing appconn %d", appconn.s_state.authenticated);
 
 	    memcpy(&aconn->s_params, &appconn.s_params, sizeof(struct session_params));
 	    memcpy(&aconn->s_state, &appconn.s_state, sizeof(struct session_state));
@@ -257,12 +257,12 @@
 	     */
 	    struct app_conn_t *aconn = 0;
 
-	    syslog(LOG_INFO, "Creating new appconn (peer)");
+	    chilli_log(LOG_INFO, "Creating new appconn (peer)");
 
 	    if (ippool_getip(ippool, &newipm, &conn->hisip)) {
 	      if (ippool_newip(ippool, &newipm, &conn->hisip, 1)) {
 		if (ippool_newip(ippool, &newipm, &conn->hisip, 0)) {
-		  syslog(LOG_ERR, "Failed to allocate either static or dynamic IP address");
+		  chilli_log(LOG_ERR, "Failed to allocate either static or dynamic IP address");
 		  fclose(file);
 		  return -1;
 		}
@@ -319,12 +319,12 @@
 
   statedir_file(filedest, sizeof(filedest), _options.usestatusfile, 0);
 
-  syslog(LOG_DEBUG, "%s(%d): Writing status file: %s", __FUNCTION__, __LINE__, filedest);
+  chilli_log(LOG_DEBUG, "%s(%d): Writing status file: %s", __FUNCTION__, __LINE__, filedest);
 
   file = fopen(filedest, "w");
-  if (!file) { syslog(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
+  if (!file) { chilli_log(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
   fprintf(file, "#CoovaChilli-Version: %s\n", VERSION);
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
 
   /* marker */
   fputc(MARK_START, file);
@@ -347,7 +347,7 @@
 #ifdef ENABLE_LAYER3
       case DHCP_AUTH_ROUTER:
 #endif
-        syslog(LOG_DEBUG, "%s(%d): Saving dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X %s", __FUNCTION__, __LINE__, 
+        chilli_log(LOG_DEBUG, "%s(%d): Saving dhcp connection %.2X-%.2X-%.2X-%.2X-%.2X-%.2X %s", __FUNCTION__, __LINE__, 
                dhcpconn->hismac[0], dhcpconn->hismac[1],
                dhcpconn->hismac[2], dhcpconn->hismac[3],
                dhcpconn->hismac[4], dhcpconn->hismac[5],
@@ -389,25 +389,25 @@
   statedir_file(filedest, sizeof(filedest), _options.usestatusfile, 0);
 
   file = fopen(filedest, "w");
-  if (!file) { syslog(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
+  if (!file) { chilli_log(LOG_ERR, "%s: could not open file %s", strerror(errno), filedest); return -1; }
 
   fprintf(file, "#Version:1.1\n");
   fprintf(file, "#SessionID = SID\n#Start-Time = ST\n");
   fprintf(file, "#SessionTimeOut = STO\n#SessionTerminateTime = STT\n");
-  fprintf(file, "#Timestamp: %d\n", (int) mainclock);
+  fprintf(file, "#Timestamp: %"PRId64"\n", (uint64_t) mainclock);
   fprintf(file, "#User, IP, MAC, SID, ST, STO, STT\n");
 
   while(dhcpconn) {
     appconn = (struct app_conn_t *)dhcpconn->peer;
     if (appconn && appconn->s_state.authenticated == 1) {
-      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %d, %d, %d\n",
+      fprintf(file, "%s, %s, %.2X-%.2X-%.2X-%.2X-%.2X-%.2X, %s, %"PRId64", %d, %d\n",
 	      appconn->s_state.redir.username,
 	      inet_ntoa(appconn->hisip),
 	      appconn->hismac[0], appconn->hismac[1],
 	      appconn->hismac[2], appconn->hismac[3],
 	      appconn->hismac[4], appconn->hismac[5],
 	      appconn->s_state.sessionid,
-	      appconn->s_state.start_time,
+	      (uint64_t)appconn->s_state.start_time,
 	      appconn->s_params.sessiontimeout,
 	      appconn->s_params.sessionterminatetime);
     }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/tun.c src/src/tun.c
--- upstream/src/tun.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/tun.c	2025-11-06 13:20:13.000000000 +0000
@@ -105,7 +105,7 @@
       net_interface *newif = 0;
       net_interface netif;
       if (_options.debug)
-        syslog(LOG_DEBUG, "Discoving TUN %s", name);
+        chilli_log(LOG_DEBUG, "Discoving TUN %s", name);
       memset(&netif, 0, sizeof(netif));
       strlcpy(netif.devname, rti->devname, sizeof(netif.devname));
       memcpy(netif.hwaddr, rti->hwaddr, sizeof(netif.hwaddr));
@@ -121,7 +121,7 @@
       if (newif) {
 
 	if (net_init(newif, 0, ETH_P_ALL, 1, 0) < 0) {
-	  syslog(LOG_ERR, "%s: net_init", strerror(errno));
+	  chilli_log(LOG_ERR, "%s: net_init", strerror(errno));
 	}
 	else {
 	  net_select_reg(tun->sctx,
@@ -144,7 +144,7 @@
   int fd, len, i;
 
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -152,19 +152,19 @@
   ic.ifc_len=0;
 
   if (ioctl(fd, SIOCGIFCONF, &ic) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCGIFCONF)", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFCONF)", strerror(errno));
     close(fd);
     return -1;
   }
 
   if (!(ic.ifc_buf = calloc((size_t)ic.ifc_len, 1))) {
-    syslog(LOG_ERR, "%s: calloc(ic.ifc_buf)", strerror(errno));
+    chilli_log(LOG_ERR, "%s: calloc(ic.ifc_buf)", strerror(errno));
     close(fd);
     return -1;
   }
 
   if (ioctl(fd, SIOCGIFCONF, &ic) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCGIFCONF)", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFCONF)", strerror(errno));
     free(ic.ifc_buf);
     close(fd);
     return -1;
@@ -182,22 +182,22 @@
     netif.address = inaddr(ifr_addr);
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "Interface: %s", ifr->ifr_name);
+      chilli_log(LOG_DEBUG, "Interface: %s", ifr->ifr_name);
 
     if (!strcmp(ifr->ifr_name, _options.dhcpif)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "skipping dhcpif %s", _options.dhcpif);
+        chilli_log(LOG_DEBUG, "skipping dhcpif %s", _options.dhcpif);
       continue;
     }
 
     if (!strncmp(ifr->ifr_name, "tun", 3) || !strncmp(ifr->ifr_name, "tap", 3)) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "skipping tun/tap %s", _options.dhcpif);
+        chilli_log(LOG_DEBUG, "skipping tun/tap %s", _options.dhcpif);
       continue;
     }
 
     if (_options.debug)
-      syslog(LOG_DEBUG, "\tIP Address:\t%s", inet_ntoa(inaddr(ifr_addr)));
+      chilli_log(LOG_DEBUG, "\tIP Address:\t%s", inet_ntoa(inaddr(ifr_addr)));
 
 
     /* netmask */
@@ -205,9 +205,9 @@
 
       netif.netmask = inaddr(ifr_addr);
       if (_options.debug)
-        syslog(LOG_DEBUG, "\tNetmask:\t%s", inet_ntoa(inaddr(ifr_addr)));
+        chilli_log(LOG_DEBUG, "\tNetmask:\t%s", inet_ntoa(inaddr(ifr_addr)));
 
-    } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFNETMASK)", strerror(errno));
+    } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFNETMASK)", strerror(errno));
 
     /* hardware address */
 #ifdef SIOCGIFHWADDR
@@ -226,12 +226,12 @@
             memcpy(netif.hwaddr, u, 6);
 
             if (_options.debug)
-              syslog(LOG_DEBUG, "\tHW Address:\t%2.2X-%2.2X-%2.2X-%2.2X-%2.2X-%2.2x",
+              chilli_log(LOG_DEBUG, "\tHW Address:\t%2.2X-%2.2X-%2.2X-%2.2X-%2.2X-%2.2x",
                      u[0], u[1], u[2], u[3], u[4], u[5]);
           }
           break;
       }
-    } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFHWADDR)", strerror(errno));
+    } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFHWADDR)", strerror(errno));
 #else
 #ifdef SIOCGENADDR
     if (-1 < ioctl(fd, SIOCGENADDR, (caddr_t)ifr)) {
@@ -240,9 +240,9 @@
       memcpy(netif.hwaddr, u, 6);
 
       if (_options.debug)
-        syslog(LOG_DEBUG, "\tHW Address:\t%2.2X-%2.2X-%2.2X-%2.2X-%2.2X-%2.2x",
+        chilli_log(LOG_DEBUG, "\tHW Address:\t%2.2X-%2.2X-%2.2X-%2.2X-%2.2X-%2.2x",
                u[0], u[1], u[2], u[3], u[4], u[5]);
-    } else syslog(LOG_ERR, "%s: ioctl(SIOCGENADDR)", strerror(errno));
+    } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGENADDR)", strerror(errno));
 #else
 #warning Do not know how to find interface hardware address
 #endif /* SIOCGENADDR */
@@ -253,7 +253,7 @@
 
       netif.devflags = ifr->ifr_flags;
 
-    } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFFLAGS)", strerror(errno));
+    } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFFLAGS)", strerror(errno));
 
     /* point-to-point gateway */
     if (netif.devflags & IFF_POINTOPOINT) {
@@ -262,9 +262,9 @@
 	netif.flags |= NET_PPPHDR;
 	netif.gateway = inaddr(ifr_addr);
         if (_options.debug)
-          syslog(LOG_DEBUG, "\tPoint-to-Point:\t%s", inet_ntoa(inaddr(ifr_dstaddr)));
+          chilli_log(LOG_DEBUG, "\tPoint-to-Point:\t%s", inet_ntoa(inaddr(ifr_dstaddr)));
 
-      } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFDSTADDR)", strerror(errno));
+      } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFDSTADDR)", strerror(errno));
     }
 
     /* broadcast address */
@@ -273,9 +273,9 @@
 
 	netif.broadcast = inaddr(ifr_addr);
         if (_options.debug)
-          syslog(LOG_DEBUG, "\tBroadcast:\t%s", inet_ntoa(inaddr(ifr_addr)));
+          chilli_log(LOG_DEBUG, "\tBroadcast:\t%s", inet_ntoa(inaddr(ifr_addr)));
 
-      } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFBRDADDR)", strerror(errno));
+      } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFBRDADDR)", strerror(errno));
     }
 
     /* mtu */
@@ -283,9 +283,9 @@
 
       netif.mtu = ifr->ifr_mtu;
       if (_options.debug)
-        syslog(LOG_DEBUG, "\tMTU:      \t%u",  ifr->ifr_mtu);
+        chilli_log(LOG_DEBUG, "\tMTU:      \t%u",  ifr->ifr_mtu);
 
-    } else syslog(LOG_ERR, "%s: ioctl(SIOCGIFMTU)", strerror(errno));
+    } else chilli_log(LOG_ERR, "%s: ioctl(SIOCGIFMTU)", strerror(errno));
 
     /* if (0 == ioctl(fd, SIOCGIFMETRIC, ifr)) */
 
@@ -300,7 +300,7 @@
       if (newif) {
 
 	if (net_init(newif, 0, ETH_P_ALL, 1, 0) < 0) {
-	  syslog(LOG_ERR, "%s: net_init", strerror(errno));
+	  chilli_log(LOG_ERR, "%s: net_init", strerror(errno));
 	}
 
 	if (!strcmp(_options.routeif, netif.devname))
@@ -308,7 +308,7 @@
 
       } else {
         if (_options.debug)
-          syslog(LOG_DEBUG, "no room for interface %s", netif.devname);
+          chilli_log(LOG_DEBUG, "no room for interface %s", netif.devname);
       }
     }
   }
@@ -345,10 +345,10 @@
   ifr.ifr_netmask.sa_family = AF_INET;
   strlcpy(ifr.ifr_name, tuntap(this).devname, IFNAMSIZ);
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
   }
   if (ioctl(fd, SIOCGIFINDEX, &ifr)) {
-    syslog(LOG_ERR, "%s: ioctl() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl() failed", strerror(errno));
     close(fd);
     return -1;
   }
@@ -391,7 +391,7 @@
   req.i.ifa_scope = RT_SCOPE_HOST; /* TODO or 0 */
 
   if (tun_gifindex(this, &idx)) {
-    syslog(LOG_ERR, "%s: tun_gifindex() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: tun_gifindex() failed", strerror(errno));
     return -1;
   }
 
@@ -401,7 +401,7 @@
   tun_nlattr(&req.n, sizeof(req), IFA_LOCAL, dstaddr, sizeof(dstaddr));
 
   if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -410,26 +410,26 @@
   local.nl_groups = 0;
 
   if (bind(fd, (struct sockaddr*)&local, sizeof(local)) < 0) {
-    syslog(LOG_ERR, "%s: bind() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: bind() failed", strerror(errno));
     close(fd);
     return -1;
   }
 
   addr_len = sizeof(local);
   if (getsockname(fd, (struct sockaddr*)&local, (socklen_t *) &addr_len) < 0) {
-    syslog(LOG_ERR, "%s: getsockname() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: getsockname() failed", strerror(errno));
     close(fd);
     return -1;
   }
 
   if (addr_len != sizeof(local)) {
-    syslog(LOG_ERR, "Wrong address length %zd", addr_len);
+    chilli_log(LOG_ERR, "Wrong address length %zd", addr_len);
     close(fd);
     return -1;
   }
 
   if (local.nl_family != AF_NETLINK) {
-    syslog(LOG_ERR, "Wrong address family %d", local.nl_family);
+    chilli_log(LOG_ERR, "Wrong address family %d", local.nl_family);
     close(fd);
     return -1;
   }
@@ -454,7 +454,7 @@
   req.n.nlmsg_flags |= NLM_F_ACK;
 
   if (sendmsg(fd, &msg, 0) < 0)
-    syslog(LOG_ERR, "%s: sendmsg()", strerror(errno));
+    chilli_log(LOG_ERR, "%s: sendmsg()", strerror(errno));
 
   dev_set_flags(tuntap(this).devname, IFF_UP | IFF_RUNNING);
 
@@ -492,12 +492,12 @@
 
   /* Create a channel to the NET kernel. */
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
   if (ioctl(fd, SIOCAIFADDR, (void *) &areq) < 0) {
-    syslog(LOG_ERR, "%s: ioctl(SIOCAIFADDR) failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl(SIOCAIFADDR) failed", strerror(errno));
     close(fd);
     return -1;
   }
@@ -511,7 +511,7 @@
   if (!this->addrs) /* Use ioctl for first addr to make ping work */
     return tun_setaddr(this, addr, dstaddr, netmask);
 
-  syslog(LOG_ERR, "%s: Setting multiple addresses not possible on Solaris", strerror(errno));
+  chilli_log(LOG_ERR, "%s: Setting multiple addresses not possible on Solaris", strerror(errno));
   return -1;
 
 #else
@@ -557,7 +557,7 @@
 #if defined(__linux__)
   /* Open the actual tun device */
   if ((netif->fd = open("/dev/net/tun", O_RDWR)) < 0) {
-    syslog(LOG_ERR, "%s: open() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: open() failed", strerror(errno));
     return -1;
   }
 
@@ -596,7 +596,7 @@
     strlcpy(ifr.ifr_name, _options.tundev, IFNAMSIZ);
 
   if (ioctl(netif->fd, TUNSETIFF, (void *) &ifr) < 0) {
-    syslog(LOG_ERR, "%s: ioctl() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: ioctl() failed", strerror(errno));
     close(netif->fd);
     return -1;
   }
@@ -611,13 +611,13 @@
       nifr.ifr_qlen = _options.txqlen;
 
       if (ioctl(nfd, SIOCSIFTXQLEN, (void *) &nifr) >= 0)
-	syslog(LOG_INFO, "TX queue length set to %d", _options.txqlen);
+	chilli_log(LOG_INFO, "TX queue length set to %d", _options.txqlen);
       else
-	syslog(LOG_ERR, "%s: Cannot set tx queue length on %s", strerror(errno), ifr.ifr_name);
+	chilli_log(LOG_ERR, "%s: Cannot set tx queue length on %s", strerror(errno), ifr.ifr_name);
 
       close (nfd);
     } else {
-      syslog(LOG_ERR, "%s: Cannot open socket on %s", strerror(errno), ifr.ifr_name);
+      chilli_log(LOG_ERR, "%s: Cannot open socket on %s", strerror(errno), ifr.ifr_name);
     }
   }
 #endif
@@ -635,11 +635,11 @@
       memset(&ifr, 0, sizeof(ifr));
       strlcpy(ifr.ifr_name, netif->devname, IFNAMSIZ);
       if (ioctl(fd, SIOCGIFHWADDR, &ifr) < 0) {
-	syslog(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), fd, SIOCGIFHWADDR);
+	chilli_log(LOG_ERR, "%s: ioctl(d=%d, request=%d) failed", strerror(errno), fd, SIOCGIFHWADDR);
       }
       memcpy(netif->hwaddr, ifr.ifr_hwaddr.sa_data, PKT_ETH_ALEN);
       if (_options.debug)
-        syslog(LOG_DEBUG, "tap-mac: %s %.2X-%.2X-%.2X-%.2X-%.2X-%.2X", ifr.ifr_name,
+        chilli_log(LOG_DEBUG, "tap-mac: %s %.2X-%.2X-%.2X-%.2X-%.2X-%.2X", ifr.ifr_name,
                netif->hwaddr[0],netif->hwaddr[1],netif->hwaddr[2],
                netif->hwaddr[3],netif->hwaddr[4],netif->hwaddr[5]);
       close(fd);
@@ -661,7 +661,7 @@
   }
 
   if (netif->fd < 0) {
-    syslog(LOG_ERR, "%s: Can't find tunnel device", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't find tunnel device", strerror(errno));
     return -1;
   }
 
@@ -677,7 +677,7 @@
 
   /* Create a channel to the NET kernel. */
   if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-    syslog(LOG_ERR, "%s: socket() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: socket() failed", strerror(errno));
     return -1;
   }
 
@@ -690,40 +690,40 @@
 #elif defined(__sun__)
 
   if ((ip_fd = open("/dev/udp", O_RDWR, 0)) < 0) {
-    syslog(LOG_ERR, "%s: Can't open /dev/udp", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't open /dev/udp", strerror(errno));
     return -1;
   }
 
   if ((netif->fd = open("/dev/tun", O_RDWR, 0)) < 0) {
-    syslog(LOG_ERR, "%s: Can't open /dev/tun", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't open /dev/tun", strerror(errno));
     return -1;
   }
 
   /* Assign a new PPA and get its unit number. */
   if ((ppa = ioctl(netif->fd, TUNNEWPPA, -1)) < 0) {
-    syslog(LOG_ERR, "%s: Can't assign new interface", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't assign new interface", strerror(errno));
     return -1;
   }
 
   if ((if_fd = open("/dev/tun", O_RDWR, 0)) < 0) {
-    syslog(LOG_ERR, "%s: Can't open /dev/tun (2)", strerror(errno));
+    chilli_log(LOG_ERR, "%s: Can't open /dev/tun (2)", strerror(errno));
     return -1;
   }
 
   if (ioctl(if_fd, I_PUSH, "ip") < 0){
-    syslog(LOG_ERR, "%d Can't push IP module");
+    chilli_log(LOG_ERR, "%d Can't push IP module");
     return -1;
   }
 
   /* Assign ppa according to the unit number returned by tun device */
   if (ioctl(if_fd, IF_UNITSEL, (char *)&ppa) < 0) {
-    syslog(LOG_ERR, "%d Can't set PPA %d", ppa);
+    chilli_log(LOG_ERR, "%d Can't set PPA %d", ppa);
     return -1;
   }
 
   /* Link the two streams */
   if ((muxid = ioctl(ip_fd, I_LINK, if_fd)) < 0) {
-    syslog(LOG_ERR, "%d Can't link TUN device to IP");
+    chilli_log(LOG_ERR, "%d Can't link TUN device to IP");
     return -1;
   }
 
@@ -738,7 +738,7 @@
 
   if (ioctl(ip_fd, SIOCSIFMUXID, &ifr) < 0) {
     ioctl(ip_fd, I_PUNLINK, muxid);
-    syslog(LOG_ERR, "%d Can't set multiplexor id");
+    chilli_log(LOG_ERR, "%d Can't set multiplexor id");
     return -1;
   }
 
@@ -756,7 +756,7 @@
   struct tun_t *tun;
 
   if (!(tun = *ptun = calloc(1, sizeof(struct tun_t)))) {
-    syslog(LOG_ERR, "%s: calloc() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: calloc() failed", strerror(errno));
     return EOF;
   }
 
@@ -812,7 +812,7 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "tun_decaps(idx=%d, len=%zd)", tun(c->this, c->idx).ifindex, length);
+    chilli_log(LOG_DEBUG, "tun_decaps(idx=%d, len=%zd)", tun(c->this, c->idx).ifindex, length);
 #endif
 
   if (length < PKT_IP_HLEN)
@@ -861,7 +861,7 @@
 #if(_debug_)
       struct in_addr addr;
       addr.s_addr = iph->daddr;
-      syslog(LOG_DEBUG, "pkt not for our network %s",inet_ntoa(addr));
+      chilli_log(LOG_DEBUG, "pkt not for our network %s",inet_ntoa(addr));
 #endif
       return -1;
     }
@@ -871,14 +871,14 @@
     if (iph->version_ihl != PKT_IP_VER_HLEN) {
 #if(_debug_)
       if (_options.debug)
-        syslog(LOG_DEBUG, "dropping non-IPv4");
+        chilli_log(LOG_DEBUG, "dropping non-IPv4");
 #endif
       return -1;
     }
 
     if ((int)ntohs(iph->tot_len) + ethsize > length) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "dropping ip packet; ip-len=%d + eth-hdr=%d > read-len=%d",
+        chilli_log(LOG_DEBUG, "dropping ip packet; ip-len=%d + eth-hdr=%d > read-len=%d",
                (int)ntohs(iph->tot_len),
                ethsize, (int)length);
       return -1;
@@ -921,7 +921,7 @@
   if ((length = safe_read(tun(this, idx).fd,
 			  pkt_buffer_head(&pb),
 			  pkt_buffer_size(&pb))) <= 0) {
-    syslog(LOG_ERR, "%s: read() failed", strerror(errno));
+    chilli_log(LOG_ERR, "%s: read() failed", strerror(errno));
     return -1;
   }
 
@@ -929,7 +929,7 @@
 
   /*
     if (_options.debug)
-    syslog(LOG_DEBUG, "tun_decaps(%d) %s",length,tun(tun,idx).devname);
+    chilli_log(LOG_DEBUG, "tun_decaps(%d) %s",length,tun(tun,idx).devname);
   */
 
   if (this->cb_ind) {
@@ -956,7 +956,7 @@
   sbuf.maxlen = pkt_buffer_size(&pb);
   sbuf.buf = pkt_buffer_head(&pb);
   if (getmsg(tun(this, idx).fd, NULL, &sbuf, &f) < 0) {
-    syslog(LOG_ERR, "%d getmsg() failed");
+    chilli_log(LOG_ERR, "%d getmsg() failed");
     return -1;
   }
 
@@ -993,7 +993,7 @@
     size_t ethlen = sizeofeth(pack);
 #if(_debug_)
     if (_options.debug)
-      syslog(LOG_DEBUG, "PPP Header");
+      chilli_log(LOG_DEBUG, "PPP Header");
 #endif
     memset(&addr,0,sizeof(addr));
     addr.sll_family = AF_PACKET;
@@ -1032,7 +1032,7 @@
     if ((iph->daddr & _options.mask.s_addr) == _options.net.s_addr ||
 	iph->daddr == dhcp->uamlisten.s_addr) {
       if (_options.debug)
-        syslog(LOG_DEBUG, "Using route idx == 0 (tun/tap)");
+        chilli_log(LOG_DEBUG, "Using route idx == 0 (tun/tap)");
       idx = 0;
     }
   }
@@ -1049,7 +1049,7 @@
 #ifdef ENABLE_NETNAT
   if (idx > 0) {
     if (nat_do(tun, idx, pack, len)) {
-      syslog(LOG_ERR, "unable to nat packet!");
+      chilli_log(LOG_ERR, "unable to nat packet!");
     }
   }
 #endif
@@ -1093,7 +1093,7 @@
 
 #if(_debug_ > 1)
     if (_options.debug)
-      syslog(LOG_DEBUG, "writing to tap src=%.2x:%.2x:%.2x:%.2x:%.2x:%.2x "
+      chilli_log(LOG_DEBUG, "writing to tap src=%.2x:%.2x:%.2x:%.2x:%.2x:%.2x "
              "dst=%.2x:%.2x:%.2x:%.2x:%.2x:%.2x len=%zd",
              ethh->src[0],ethh->src[1],ethh->src[2],
              ethh->src[3],ethh->src[4],ethh->src[5],
@@ -1109,13 +1109,13 @@
 
 #if(_debug_ > 1)
   if (_options.debug)
-    syslog(LOG_DEBUG, "tun_encaps(%s) len=%zd", tun(tun,idx).devname, len);
+    chilli_log(LOG_DEBUG, "tun_encaps(%s) len=%zd", tun(tun,idx).devname, len);
 #endif
 
   result = tun_write(tun, pack, len, idx);
 
   if (result < 0) {
-    syslog(LOG_ERR, "%s: tun_write(%zu) = %d", strerror(errno), len, result);
+    chilli_log(LOG_ERR, "%s: tun_write(%zu) = %d", strerror(errno), len, result);
   }
 
   return result;
@@ -1126,12 +1126,12 @@
   pid_t pid;
   char b[56];
 
-  syslog(LOG_DEBUG, "Running %s", script);
+  chilli_log(LOG_DEBUG, "Running %s", script);
 
   net.s_addr = tuntap(tun).address.s_addr & tuntap(tun).netmask.s_addr;
 
   if ((pid = fork()) < 0) {
-    syslog(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
+    chilli_log(LOG_ERR, "%s: fork() returned -1!", strerror(errno));
     return 0;
   }
 
@@ -1141,7 +1141,7 @@
    again:
       if (waitpid(pid, &status, 0) == -1) {
 	if (errno == EINTR) goto again;
-	syslog(LOG_ERR, "%s: waiting for %s", strerror(errno), script);
+	chilli_log(LOG_ERR, "%s: waiting for %s", strerror(errno), script);
       }
     }
     return 0;
@@ -1184,9 +1184,11 @@
 #endif
 
 #ifdef HAVE_NETFILTER_COOVA
-  if (_options.kname) {
-    set_env("KNAME", VAL_STRING, _options.kname, 0);
-  }
+  set_env("KNAME", VAL_STRING, _options.kname ? _options.kname : "", 0);
+#endif
+
+#ifdef ENABLE_MULTILAN
+  set_moreif_env();
 #endif
 
   if (execl(
@@ -1197,7 +1199,7 @@
 #endif
           script, tuntap(tun).devname, (char *) 0) != 0) {
 
-    syslog(LOG_ERR, "%s: execl(%s) did not return 0!", strerror(errno), script);
+    chilli_log(LOG_ERR, "%s: execl(%s) did not return 0!", strerror(errno), script);
     exit(0);
   }
 
@@ -1238,7 +1240,7 @@
    tun_nlattr(&req.n, sizeof(req), RTA_GATEWAY, gateway, 4);
 
    if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE)) < 0) {
-   syslog(LOG_ERR, "%s: %s %d socket() failed", strerror(errno), __FILE__, __LINE__);
+   chilli_log(LOG_ERR, "%s: %s %d socket() failed", strerror(errno), __FILE__, __LINE__);
    return -1;
    }
 
@@ -1247,26 +1249,26 @@
    local.nl_groups = 0;
 
    if (bind(fd, (struct sockaddr*)&local, sizeof(local)) < 0) {
-   syslog(LOG_ERR, "%s: %s %d  bind() failed", strerror(errno), __FILE__, __LINE__);
+   chilli_log(LOG_ERR, "%s: %s %d  bind() failed", strerror(errno), __FILE__, __LINE__);
    close(fd);
    return -1;
    }
 
    addr_len = sizeof(local);
    if (getsockname(fd, (struct sockaddr*)&local, &addr_len) < 0) {
-   syslog(LOG_ERR, "%s: %s %d getsockname() failed", strerror(errno), __FILE__, __LINE__);
+   chilli_log(LOG_ERR, "%s: %s %d getsockname() failed", strerror(errno), __FILE__, __LINE__);
    close(fd);
    return -1;
    }
 
    if (addr_len != sizeof(local)) {
-   syslog(LOG_ERR, "%s: %s %d Wrong address length %d", strerror(errno), __FILE__, __LINE__, addr_len);
+   chilli_log(LOG_ERR, "%s: %s %d Wrong address length %d", strerror(errno), __FILE__, __LINE__, addr_len);
    close(fd);
    return -1;
    }
 
    if (local.nl_family != AF_NETLINK) {
-   syslog(LOG_ERR, "%s: %s %d Wrong address family %d", strerror(errno), __FILE__, __LINE__, local.nl_family);
+   chilli_log(LOG_ERR, "%s: %s %d Wrong address family %d", strerror(errno), __FILE__, __LINE__, local.nl_family);
    close(fd);
    return -1;
    }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ubus.c src/src/ubus.c
--- upstream/src/ubus.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,625 @@
+
+#include "chilli.h"
+#include "options.h"
+
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+
+enum {
+	FORMAT_TABLE,
+	FORMAT_ARRAY
+};
+
+enum {
+	CHILLI_IP,
+	CHILLI_MAC,
+	CHILLI_SESSION_ID,
+	CHILLI_MAX
+};
+
+enum {
+	CHILLI_FORGET_MAC,
+	CHILLI_FORGET_MAX
+};
+
+static const struct blobmsg_policy chilli_default_policy[] = {
+		[CHILLI_IP]  = {.name = "ip", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+		[CHILLI_SESSION_ID]   = {.name = "sessionid", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct blobmsg_policy chilli_forget_policy[] = {
+		[CHILLI_FORGET_MAC] = {.name = "mac", .type = BLOBMSG_TYPE_STRING},
+};
+
+static const struct ubus_method chilli_methods[] = {
+		UBUS_METHOD("list", chilli_list_method, chilli_default_policy),
+		UBUS_METHOD("logout", chilli_logout_method, chilli_default_policy),
+		UBUS_METHOD("forget", chilli_forget_method, chilli_forget_policy),
+};
+
+static struct ubus_object_type chilli_object_type =
+		UBUS_OBJECT_TYPE("chilli_obj_type", chilli_methods);
+
+struct ubus_object chilli_object = {
+		.name      = "chilli",
+		.type      = &chilli_object_type,
+		.methods   = chilli_methods,
+		.n_methods = ARRAY_SIZE(chilli_methods),
+};
+
+static int parse_mac(uint8_t *mac, char *string) {
+	unsigned int temp[PKT_ETH_ALEN];
+	char macstr[RADIUS_ATTR_VLEN];
+	int macstrlen;
+	int i;
+
+	if ((macstrlen = strlen(string)) >= (RADIUS_ATTR_VLEN-1)) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	memcpy(macstr, string, macstrlen);
+	macstr[macstrlen] = 0;
+
+	for (i=0; i<macstrlen; i++)
+		if (!isxdigit((int) macstr[i]))
+			macstr[i] = 0x20;
+
+	if (sscanf(macstr, "%2x %2x %2x %2x %2x %2x",
+			   &temp[0], &temp[1], &temp[2],
+			   &temp[3], &temp[4], &temp[5]) != 6) {
+		fprintf(stderr, "%s: bad MAC address\n", string);
+		return -1;
+	}
+
+	for (i = 0; i < PKT_ETH_ALEN; i++)
+		mac[i] = temp[i];
+
+	return 0;
+}
+
+static void chilli_session_params(struct session_state *state, struct session_params *params,
+								  struct blob_buf *b)
+{
+	time_t starttime = state->start_time;
+
+	blobmsg_add_string(b, "sessionId", state->sessionid);
+	blobmsg_add_string(b, "userName", state->redir.username);
+	blobmsg_add_u64(b, "startTime", (uint64_t) mainclock_towall(starttime));
+	blobmsg_add_u64(b, "sessionTimeout", params->sessiontimeout);
+	blobmsg_add_u64(b, "terminateTime", params->sessionterminatetime);
+	blobmsg_add_u32(b, "idleTimeout", params->idletimeout);
+#ifdef ENABLE_IEEE8021Q
+	if (_options.ieee8021q && state->tag8021q) {
+		blobmsg_add_u16(b, "vlan", ntohs(state->tag8021q & PKT_8021Q_MASK_VID));
+	}
+#endif
+	if (params->maxinputoctets) {
+		blobmsg_add_u64(b, "maxInputOctets", params->maxinputoctets);
+	}
+	if (params->maxoutputoctets) {
+		blobmsg_add_u64(b, "maxOutputOctets", params->maxoutputoctets);
+	}
+	if (params->maxtotaloctets) {
+		blobmsg_add_u64(b, "maxTotalOctets", params->maxtotaloctets);
+	}
+	if (params->bandwidthmaxdown) {
+		blobmsg_add_u64(b, "maxDwBandwidth", params->bandwidthmaxdown);
+	}
+	if (params->bandwidthmaxup) {
+		blobmsg_add_u64(b, "maxUpBandwidth", params->bandwidthmaxup);
+	}
+}
+
+static void chilli_session_acct(struct session_state *state, struct blob_buf *b)
+{
+	uint32_t inoctets = state->input_octets;
+	uint32_t outoctets = state->output_octets;
+	uint32_t ingigawords = (state->input_octets >> 32);
+	uint32_t outgigawords = (state->output_octets >> 32);
+	uint32_t sessiontime;
+	uint32_t idletime;
+
+	sessiontime = mainclock_diffu(state->start_time);
+	idletime    = mainclock_diffu(state->last_up_time);
+
+	blobmsg_add_u32(b, "sessionTime", !state->authenticated ? 0 : sessiontime);
+	blobmsg_add_u32(b, "idleTime", !state->authenticated ? 0 : idletime);
+	blobmsg_add_u32(b, "inputOctets", !state->authenticated ? 0 : inoctets);
+	blobmsg_add_u32(b, "outputOctets", !state->authenticated ? 0 : outoctets);
+	blobmsg_add_u32(b, "inputGigawords", !state->authenticated ? 0 : ingigawords);
+	blobmsg_add_u32(b, "outputGigawords", !state->authenticated ? 0 : (long)outgigawords);
+	blobmsg_add_string(b, "viewPoint", _options.swapoctets ? "nas" : "client");
+}
+
+static void chilli_getinfo(struct app_conn_t *appconn, struct blob_buf *b, int format_array) {
+	if (appconn->s_state.authenticated) {
+		void *i = blobmsg_open_table(b, "session");
+		chilli_session_params(&appconn->s_state, &appconn->s_params, b);
+		blobmsg_close_table(b, i);
+
+		if (format_array) {
+			i = blobmsg_open_table(b, "accounting");
+			chilli_session_acct(&appconn->s_state, b);
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void chilli_form_blob(struct blob_buf *b, struct app_conn_t *appconn, struct dhcp_conn_t *conn, int format_array) {
+	char tmp_buff[64];
+	void *i;
+
+	if (!appconn && conn)
+		appconn = (struct app_conn_t *)conn->peer;
+
+	if ((!appconn || !appconn->inuse)) {
+		return;
+	} else if (conn && !conn->inuse) {
+		return;
+	} else {
+		if (format_array) {
+			i = blobmsg_open_table(b, NULL);
+		}
+		if (appconn) {
+			blobmsg_add_u32(b, "nasPort", appconn->unit);
+			blobmsg_add_u8(b, "clientState", appconn->s_state.authenticated);
+			blobmsg_add_string(b, "ipAddress", inet_ntoa(appconn->hisip));
+			if (appconn->s_state.redir.userurl[0]) {
+				blobmsg_add_string(b, "url", appconn->s_state.redir.userurl);
+			}
+		}
+
+		if (conn) {
+			sprintf(tmp_buff, MAC_FMT, MAC_ARG(conn->hismac));
+			blobmsg_add_string(b, "macAddress", tmp_buff);
+			blobmsg_add_string(b, "dhcpState", state2name(conn->authstate));
+		}
+
+		if (appconn) {
+			chilli_getinfo(appconn, b, format_array);
+		}
+
+		if (format_array) {
+			blobmsg_close_table(b, i);
+		}
+	}
+}
+
+void unused (void){
+	return;
+}
+
+static int chilli_list_method(struct ubus_context *ctx, struct ubus_object *obj,
+							  struct ubus_request_data *req, const char *method,
+							  struct blob_attr *msg)
+{
+	struct cmdsock_request req_params = { 0 };
+	struct app_conn_t *appconn = NULL;
+	struct dhcp_conn_t *dhcpconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	struct blob_buf b = { 0 };
+	int crt = 0;
+	void *ses;
+
+	blob_buf_init(&b, 0);
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		crt = 1;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		crt = 1;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		crt = 1;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	ses = blobmsg_open_array(&b, "sessions");
+	appconn = find_app_conn(&req_params, &crt);
+	if (appconn) {
+		dhcpconn = (struct dhcp_conn_t *)appconn->dnlink;
+		chilli_form_blob(&b, appconn, dhcpconn, FORMAT_ARRAY);
+	} else if (!crt) {
+		if (dhcp) {
+			dhcpconn = dhcp->firstusedconn;
+			while (dhcpconn) {
+				chilli_form_blob(&b, NULL, dhcpconn, FORMAT_ARRAY);
+				dhcpconn = dhcpconn->next;
+			}
+		}
+	}
+
+	blobmsg_close_array(&b, ses);
+	ubus_send_reply(ctx, req, b.head);
+	blob_buf_free(&b);
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_logout_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+	struct blob_attr *tb[CHILLI_MAX];
+	int count = 0;
+
+	memset(&req_params, 0, sizeof(req_params));
+	blobmsg_parse(chilli_default_policy, ARRAY_SIZE(chilli_default_policy),
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (tb[CHILLI_IP]) {
+		count++;
+		if (!inet_pton(AF_INET, blobmsg_data(tb[CHILLI_IP]), &req_params.ip)) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+	}
+
+	if (tb[CHILLI_MAC]) {
+		if (parse_mac(req_params.mac, blobmsg_data(tb[CHILLI_MAC]))) {
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		}
+
+		count++;
+	}
+
+	if (tb[CHILLI_SESSION_ID]) {
+		count++;
+		strlcpy(req_params.d.sess.sessionid, blobmsg_data(tb[CHILLI_SESSION_ID]),
+				sizeof(req_params.d.sess.sessionid));
+	}
+
+	if (count == 0) {
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	appconn = find_app_conn(&req_params, 0);
+	if (_options.debug) {
+		chilli_log(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+			   inet_ntoa(req_params.ip));
+	}
+
+	if (appconn) {
+		if (_options.debug) {
+			chilli_log(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_ADMIN_RESET);
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+static int chilli_forget_method(struct ubus_context *ctx, struct ubus_object *obj,
+								struct ubus_request_data *req, const char *method, struct blob_attr *msg)
+{
+	int ret = UBUS_STATUS_OK;
+	struct blob_attr *tb[CHILLI_FORGET_MAX];
+	uint8_t mac[6];
+
+	blobmsg_parse(chilli_forget_policy, CHILLI_FORGET_MAX,
+				  tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[CHILLI_FORGET_MAC] || parse_mac(mac, blobmsg_data(tb[CHILLI_FORGET_MAC]))) {
+		ret = UBUS_STATUS_INVALID_ARGUMENT;
+		goto end;
+	}
+
+	usr_rm_user(mac);
+	usr_rm_sms_user(mac);
+end:
+	return ret;
+}
+
+void ubus_disconnect_cb(struct ubus_context *ubus)
+{
+	int ret;
+
+	if ((ret = ubus_reconnect(ubus, NULL)))
+	{
+		chilli_log(LOG_ERR, "Cannot reconnect to UBus: %s", ubus_strerror(ret));
+		ubus_free(ubus);
+	}
+}
+
+void chilli_ubus_add_obj(struct ubus_context *ctx)
+{
+	int ret;
+
+	if ((ret = ubus_add_object(ctx, &chilli_object))) {
+		chilli_log(LOG_ERR, "Failed to add object: %s", ubus_strerror(ret));
+	}
+
+	ctx->connection_lost = ubus_disconnect_cb;
+}
+
+void chilli_ubus_remove_obj(struct ubus_context *ctx)
+{
+	int ret = ubus_remove_object(ctx, &chilli_object);
+	if (ret) {
+		chilli_log(LOG_ERR, "Failed to remove object: %s", ubus_strerror(ret));
+	}
+}
+
+// main hostapd event handler.
+// the general approach of using hostapd might be inefficient, as hostapd
+// is kind of a fire hose when it comes to the events it sends out.
+static int hostapd_event_handle(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+
+	// unused vars
+	UNUSED(ctx);
+	UNUSED(obj);
+	UNUSED(req);
+
+	// coova-chilli functionality related vars
+	struct cmdsock_request req_params;
+	struct app_conn_t *appconn = NULL;
+
+	// blobmsg parsing related vars
+	struct blob_attr *cur;
+	int rem;
+
+	// check to see if we're receiving a dissasoc call
+	// from hostapd
+	if (strcmp(method, CHILLI_UBUS_HAP_DISASSOC) != 0) {
+		return UBUS_STATUS_OK;
+	}
+
+	// at this point, we know that we are dealing with data that is
+	// related to a disconnect event
+
+	// this loop is only really concerned with
+	// the first blobvalue of *msg.
+	// which may or may not be our MAC addr
+	blobmsg_for_each_attr(cur, msg, rem) {
+
+		// check if we have field named 'address' (contains our mac addr).
+		// if not, break.
+		if (strcmp(blobmsg_name(cur), CHILLI_UBUS_HAP_ADDR)) {
+			continue;
+		}
+
+		// use the same methods as above to remove the disconnect from coova-chilli
+		// internally.
+		if (parse_mac(req_params.mac, blobmsg_get_string(cur))) {
+			chilli_log(LOG_ERR, "Unable to parse incoming mac address from hostapd");
+			break;
+		}
+
+		appconn = find_app_conn(&req_params, 0);
+
+		if (_options.debug) {
+			chilli_log(LOG_DEBUG, "%s(%d): looking to logout session %s", __FUNCTION__, __LINE__,
+				inet_ntoa(req_params.ip));
+		}
+
+		if (!appconn) {
+			break;
+		}
+
+		// at this point we have a valid appconn obj
+
+		if (_options.debug) {
+			chilli_log(LOG_DEBUG, "%s(%d): found %s %s", __FUNCTION__, __LINE__,
+				   inet_ntoa(appconn->hisip), appconn->s_state.sessionid);
+		}
+
+		terminate_appconn(appconn, RADIUS_TERMINATE_CAUSE_LOST_SERVICE);
+
+		// we can break here since we
+		// got everything we needed out of *msg.
+		break;
+	}
+
+	return UBUS_STATUS_OK;
+}
+
+// tries to subscribe a single *ubus_subscriber and an iface pair to hostapd
+static int chilli_ubus_singlesub_hostapd(struct ubus_context *ctx, struct ubus_subscriber *event, char *iface)
+{
+	// null-check
+	if (iface == NULL || iface[0] == '\0') {
+		chilli_log(LOG_DEBUG, "%s given null iface argument.", __FUNCTION__);
+		return 1;
+	}
+
+	uint32_t u_obj_id;
+
+	char obj_name_buf[CHILLI_UBUS_OBJ_BUFSIZ];
+
+	// set event handler for ubus_subscriber
+	event->cb = hostapd_event_handle;
+
+	// prepare ubus obj string. i,e take the iface we got and add the hostapd base ubus
+	// obj name and a dot before it
+	snprintf(obj_name_buf, CHILLI_UBUS_OBJ_BUFSIZ, "%s.%s", CHILLI_UBUS_HAP_OBJ, iface);
+
+	// try to look for ubus hostapd obj
+	if (ubus_lookup_id(ctx, obj_name_buf, &u_obj_id)) {
+		chilli_log(LOG_ERR, "Failed to find ubus object: %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to register ubus subscriber
+	if (ubus_register_subscriber(ctx, event)) {
+		chilli_log(LOG_ERR, "Failed to register ubus subscriber for %s", obj_name_buf);
+		return 1;
+	}
+
+	// try to subscribe
+	if (ubus_subscribe(ctx, event, u_obj_id) != UBUS_STATUS_OK) {
+		chilli_log(LOG_ERR, "Failed to subscribe to %s", obj_name_buf);
+		return 1;
+	}
+
+	chilli_log(LOG_INFO, "Successfully subscribed to %s", obj_name_buf);
+	return 0;
+
+}
+
+
+// function that subscribes to any relevant hostapd ubus objects. This is used to track 
+// Wifi connects/disconnects in order to be able to remove user from session list
+// if they disconnect from the wifi itself.
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options)
+{
+	// NOTE: i know there's the _options global, accessible from here, but having the options be passed
+	// as an argument is better practice, especially for maintainability
+
+
+	// null-check. Something has probably gone very wrong if this gets triggered.
+	if (options.dhcpif == NULL || options.dhcpif[0] == '\0') {
+		chilli_log(LOG_ERR, "Unable to add hostapd listeners. DHCP iface not set.");
+		return;
+	}
+
+	static struct ubus_subscriber hostapd_event; // ubus subscription object
+
+	// try to subscribe to the hostapd instance of the main iface.
+	// if this fails, move on.
+	chilli_ubus_singlesub_hostapd(ctx, &hostapd_event, options.dhcpif);
+
+	// basically do the same as above, but with the idea that all data of note is stored as arrays
+	#ifdef ENABLE_MULTILAN
+		static struct ubus_subscriber hostapd_multi_events[MAX_MOREIF]; // array of additional ubus sub objs
+
+		// for every additional interface that we got
+		for (int i = 0; i < MAX_MOREIF; i++) {
+			// try to subscribe to additinoal interface, move on if failed.
+			chilli_ubus_singlesub_hostapd(ctx, &hostapd_multi_events[i], options.moreif[i].dhcpif);
+		}
+	#endif
+}
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+			struct dhcp_conn_t *dhcpconn)
+{
+	if (!ctx) {
+		return;
+	}
+
+	struct blob_buf b = { 0 };
+	int err = 0;
+
+	blob_buf_init(&b, 0);
+
+	if (appconn) {
+		if (!strcmp(state, CHILLI_EVENT_CONNECT)) {
+			chilli_form_blob(&b, appconn, dhcpconn, FORMAT_TABLE);
+		} else {
+			blobmsg_add_string(&b, "sessionId", appconn->s_state.sessionid);
+		}
+	}
+
+	err = ubus_send_event(ctx, state, b.head);
+	if (err) {
+		chilli_log(LOG_ERR, "Failed to send ubus event '%s': %s", state, ubus_strerror(err));
+	}
+
+	blob_buf_free(&b);
+}
+
+static const char* find_ssid_in_iface(struct ubus_request *req, struct blob_attr *msg) {
+	struct ubus_ssid_request *request = (struct ubus_ssid_request *)req->priv;
+	const char *target_ifname = request->target_ifname;
+	const char *ssid = NULL;
+
+	struct blob_attr *cur, *cur2;
+	int rem = 0, rem2 = 0;
+
+	/* for every attribute of interface */
+	blobmsg_for_each_attr (cur, msg, rem) {
+		const char *attr_name = blobmsg_name(cur);
+
+		if (strcmp(attr_name, "ifname") == 0 && strcmp(blobmsg_get_string(cur), target_ifname)) {
+			return ssid;
+		}
+
+		if (strcmp(attr_name, "config") == 0) {
+			/* for every config sub-attribute of interface */
+			blobmsg_for_each_attr (cur2, cur, rem2) {
+				if (strcmp(blobmsg_name(cur2), "ssid")) continue;
+				ssid = blobmsg_get_string(cur2);
+				return ssid;
+			}
+		}
+	}
+
+	return ssid;
+}
+
+static void get_interfaces_cb(struct ubus_request *req, int type, struct blob_attr *msg) {
+	struct ubus_ssid_request *request = (struct ubus_ssid_request *)req->priv;
+	const char **ssid_ptr = request->ssid_ptr;
+
+	struct blob_attr *cur, *cur2, *cur3;
+	int rem = 0, rem2 = 0, rem3 = 0;
+
+	/* top-level, this loops over the "radio*" sub-objects */
+	blobmsg_for_each_attr (cur, blob_memdup(msg), rem) {
+		/* for every attribute within a radio* */
+		blobmsg_for_each_attr (cur2, blob_memdup(cur), rem2) {
+			if (strcmp(blobmsg_name(cur2), "interfaces"))
+				continue;
+
+			/* for every interface */
+			blobmsg_for_each_attr (cur3, blob_memdup(cur2), rem3) {
+				const char *ssid = find_ssid_in_iface(req, blob_memdup(cur3));
+				if (ssid == NULL) continue;
+				*ssid_ptr = ssid;
+				return;
+			}
+		}
+	}
+}
+
+const char* find_ssid_by_ifname(const char *ifname) {
+	uint32_t net_obj;
+	struct blob_buf buf = {0};
+	const char *ssid = NULL;
+	struct ubus_ssid_request request = { .target_ifname = ifname, .ssid_ptr = &ssid };
+
+	ubus_ctx = ubus_connect(NULL);
+	if (!ubus_ctx) {
+		chilli_log(LOG_ERR, "Failed to connect to ubus");
+		return ssid;
+	}
+
+	blob_buf_init(&buf, 0);
+	if (ubus_lookup_id(ubus_ctx, CHILLI_UBUS_WIRELESS_OBJ, &net_obj)) {
+		goto free;
+	}
+
+	if (ubus_invoke(ubus_ctx, net_obj, CHILLI_UBUS_WIRELESS_STATUS, buf.head, get_interfaces_cb, &request, CHILLI_UBUS_TIMEOUT)) {
+		goto free;
+	}
+
+free:
+	ubus_free(ubus_ctx);
+	blob_buf_free(&buf);
+	return ssid;
+}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/ubus.h src/src/ubus.h
--- upstream/src/ubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,39 @@
+
+#ifndef _CHILLI_UBUS_H
+#define _CHILLI_UBUS_H
+
+#include <libubus.h>
+
+#define CHILLI_UBUS_OBJ_BUFSIZ 50
+
+// various defines for parsing the incoming ubus obj
+#define CHILLI_UBUS_HAP_OBJ "hostapd"
+#define CHILLI_UBUS_HAP_DISASSOC "disassoc"
+#define CHILLI_UBUS_HAP_ADDR "address"
+
+#define CHILLI_UBUS_WIRELESS_OBJ "network.wireless"
+#define CHILLI_UBUS_WIRELESS_STATUS "status"
+
+#define CHILLI_UBUS_TIMEOUT 5000
+
+#define UNUSED(x) (void)(x)
+
+#define CHILLI_EVENT_CONNECT "chilli.connect"
+#define CHILLI_EVENT_DISCONNECT "chilli.disconnect"
+
+struct ubus_ssid_request {
+	const char *target_ifname;
+	const char **ssid_ptr;
+};
+
+void chilli_ubus_add_obj(struct ubus_context *ctx);
+void chilli_ubus_remove_obj(struct ubus_context *ctx);
+
+void chilli_ubus_subscribe_hostapd(struct ubus_context *ctx, struct options_t options);
+
+void send_ubus_event(struct ubus_context *ctx, char *state, struct app_conn_t *appconn,
+                        struct dhcp_conn_t *dhcpconn);
+
+const char* find_ssid_by_ifname(const char *ifname);
+
+#endif //_CHILLI_UBUS_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/users.c src/src/users.c
--- upstream/src/users.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.c	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,695 @@
+#include "chilli.h"
+#include <uci.h>
+#include <libtlt_uci.h>
+#ifdef ENABLE_GSM
+#include "gsm.h"
+#endif
+
+static int rm_user(char *table, uint8_t *mac);
+
+/*!
+ * Generate a n octet random string
+ * @param dst The memory area to copy to
+ * @param size The number of bytes to copy
+ * @return 0 on success, -1 on fail.
+ */
+
+int usr_random_hex(char *dst, size_t size)
+{
+	size_t i = 0;
+	int c;
+	char x[3];
+	FILE *file;
+
+	if ((file = fopen("/dev/urandom", "r")) == NULL) {
+		chilli_log(LOG_ERR, "%s: fopen(/dev/urandom)", strerror(errno));
+		return -1;
+	}
+
+	for (i = 0; i <= size - 2; i++) {
+		c = fgetc(file);
+		snprintf(x, 3, "%.2x", c);
+		dst[i++] = x[0];
+		dst[i]	 = x[1];
+	}
+
+	dst[size] = 0;
+
+	fclose(file);
+	return 0;
+}
+
+int usr_runscript(struct redir_conn_t *conn, char *script, char *username, char *password)
+{
+	int status;
+	uint32_t sessiontime;
+
+	if ((status = chilli_fork(CHILLI_PROC_SCRIPT, script)) < 0) {
+		chilli_log(LOG_ERR, "%s: forking %s", strerror(errno), script);
+		return 0;
+	}
+
+	if (status > 0) { /* Parent */
+		return 0;
+	}
+
+	set_env("DEV", VAL_STRING, tun(tun, 0).devname, 0);
+	set_env("ADDR", VAL_IN_ADDR, &conn->ourip, 0);
+	set_env("FRAMED_IP_ADDRESS", VAL_IN_ADDR, &conn->hisip, 0);
+	set_env("SESSION_TIMEOUT", VAL_ULONG64, &conn->s_params.sessiontimeout, 0);
+	set_env("IDLE_TIMEOUT", VAL_ULONG, &conn->s_params.idletimeout, 0);
+	set_env("CALLING_STATION_ID", VAL_MAC_ADDR, conn->hismac, 0);
+	set_env("CALLED_STATION_ID", VAL_MAC_ADDR, chilli_called_station(&conn->s_state), 0);
+	set_env("WISPR_BANDWIDTH_MAX_UP", VAL_ULONG, &conn->s_params.bandwidthmaxup, 0);
+	set_env("WISPR_BANDWIDTH_MAX_DOWN", VAL_ULONG, &conn->s_params.bandwidthmaxdown, 0);
+	set_env("COOVACHILLI_MAX_INPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxinputoctets, 0);
+	set_env("COOVACHILLI_MAX_OUTPUT_OCTETS", VAL_ULONG64, &conn->s_params.maxoutputoctets, 0);
+	set_env("COOVACHILLI_MAX_TOTAL_OCTETS", VAL_ULONG64, &conn->s_params.maxtotaloctets, 0);
+	set_env("COOVACHILLI_WARNING_OCTETS", VAL_ULONG64, &conn->s_params.warningoctets, 0);
+
+	sessiontime = mainclock_diffu(conn->s_state.start_time);
+	set_env("SESSION_TIME", VAL_ULONG, &sessiontime, 0);
+	sessiontime = mainclock_diffu(conn->s_state.last_up_time);
+	set_env("IDLE_TIME", VAL_ULONG, &sessiontime, 0);
+	set_env("USER_EXPIRATION_TIME", VAL_ULONG64, &conn->s_params.expiration, 0);
+	set_env("PHONE", VAL_STRING, &conn->s_state.redir.phone, 0);
+	set_env("EMAIL", VAL_STRING, &conn->s_state.redir.email, 0);
+
+	if (username) {
+		set_env("USER_NAME", VAL_STRING, username, 0);
+	}
+	if (_options.smsusers) {
+		if (password)
+			set_env("PASSWORD", VAL_STRING, password, 0);
+#ifdef ENABLE_GSM
+		if (_options.modemid)
+			set_env("MODEM_ID", VAL_STRING, _options.modemid, 0);
+#endif
+	}
+
+	if (execl(
+#ifdef ENABLE_CHILLISCRIPT
+		    SBINDIR "/chilli_script", SBINDIR "/chilli_script", _options.binconfig,
+#else
+		    script,
+#endif
+		    script, (char *)0) != 0) {
+		chilli_log(LOG_ERR, "%s: exec %s failed", strerror(errno), script);
+	}
+
+	exit(0);
+}
+
+int usr_gen_message(char *msg, char *password)
+{
+	time_t now;
+
+	if (_options.dynexpirationtime) {
+		time(&now);
+		now += _options.dynexpirationtime;
+	}
+
+	sprintf(msg, MSG_FMT, password, _options.dynexpirationtime ? ctime(&now) : "unlimited");
+
+	return 0;
+}
+
+int _select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_user *p_str_user = (struct str_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_USER_NAME], USER_USERNAMENAMESIZE);
+		p_str_user->username[USER_USERNAMENAMESIZE] = 0;
+		strncpy(p_str_user->email, argv[COL_USER_EMAIL], USER_EMAILSIZE);
+		p_str_user->email[USER_EMAILSIZE] = 0;
+		strncpy(p_str_user->password, argv[COL_USER_PASS], USER_PASSWORDSIZE);
+		p_str_user->password[USER_PASSWORDSIZE] = 0;
+		strncpy(p_str_user->phone, argv[COL_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration =
+			argv[COL_USER_EXPIRATION] ? strtol(argv[COL_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->user_time = argv[COL_USER_TIME] ? strtol(argv[COL_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int _lusr_select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_luser *p_str_user = (struct str_luser *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_LUSER_NAME], USER_USERNAMENAMESIZE);
+		p_str_user->username[USER_USERNAMENAMESIZE] = 0;
+		strncpy(p_str_user->password, argv[COL_LUSER_PASS], USER_PASSWORDSIZE);
+		p_str_user->password[USER_PASSWORDSIZE] = 0;
+		strncpy(p_str_user->group, argv[COL_LUSER_GROUP], USER_GROUPSIZE);
+		p_str_user->group[USER_GROUPSIZE] = 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_user_expired(sqlite3 *db, char *email, uint8_t *mac)
+{
+	int ret = USER_RET_SUCCESS;
+	char *sql = 0;
+	sqlite3_stmt *stmt;
+
+	asprintf(&sql, SELECT_NOT_EXPIRED_EMAIL_FMT, "users", email, MAC_ARG(mac));
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);
+	if (ret != SQLITE_OK) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__, sqlite3_errmsg(db));
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		if (sqlite3_column_int(stmt, 0) > 0)
+			ret = USER_RET_ALREADY;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+int usr_get_user(sqlite3 *db, struct str_user *user, char *email)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_USER_FMT, email);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int lusr_get_user(sqlite3 *db, struct str_luser *user, char *username)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_LUSER_FMT, username);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _lusr_select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_update_user_pwd(sqlite3 *db, struct str_user *user, char *email, char *new_passw)
+{
+#ifndef HAVE_OPENSSL
+	return SQL_FAIL;
+#endif
+	char *new_passw_hash = hash_sha512(new_passw);
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, UPDATE_USR_PWD, new_passw_hash, email);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		free(new_passw_hash);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	free(new_passw_hash);
+
+	return SQL_SUCCESS;
+}
+
+int lusr_update_user_pwd(sqlite3 *db, struct str_luser *user, char *username, char *new_passw)
+{
+#ifndef HAVE_OPENSSL
+	return SQL_FAIL;
+#endif
+	char *new_passw_hash = hash_sha512(new_passw);
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, UPDATE_LUSER_PWD, new_passw_hash, username);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _lusr_select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		free(new_passw_hash);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	free(new_passw_hash);
+
+	return SQL_SUCCESS;
+}
+
+int usr_add_user(struct redir_conn_t *conn)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_ERROR;
+	char username[USER_USERNAMENAMESIZE + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		conn->response = REDIR_SIGNUP_FAILED;
+		return USER_RET_ERROR;
+	}
+
+	if ((ret = usr_user_expired(db, conn->s_state.redir.email, conn->hismac)) != USER_RET_SUCCESS) {
+		if (ret == USER_RET_ALREADY)
+			conn->response = REDIR_SIGNUP_ALREADY;
+		else
+			conn->response = REDIR_SIGNUP_FAILED;
+
+		goto out;
+	}
+
+	if (usr_random_hex(username, USER_RAND_USERNAME_LEN)) {
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_USERS_FMT, username, conn->s_state.redir.email,
+		 conn->s_state.redir.signup_password, MAC_ARG(conn->hismac), conn->s_state.redir.phone,
+		 _options.dynexpirationtime);
+
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		conn->response = REDIR_SIGNUP_SUCCESS;
+		ret	       = USER_RET_SUCCESS;
+		if (_options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+			if (_options.debug)
+				chilli_log(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n", __FUNCTION__,
+				       __LINE__, _options.usersignup);
+
+			usr_runscript(conn, _options.usersignup, conn->s_state.redir.email, NULL);
+		}
+	} else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+static int lusr_add_user(sqlite3 *db, const char *username, const char *password, const char *group)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, INSERT_LUSER_FMT, username, password, group);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, 0, 0, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+		return SQL_FAIL;
+	}
+
+	free(sql);
+	return SQL_SUCCESS;
+}
+
+int _sms_select_callback(void *str_user, int argc, char **argv, char **azColName)
+{
+	struct str_sms_user *p_str_user = (struct str_sms_user *)str_user;
+
+	if (argc > 0) {
+		strncpy(p_str_user->username, argv[COL_SMS_USER_NAME], USER_RAND_USERNAME_LEN);
+		p_str_user->username[USER_RAND_USERNAME_LEN] = 0;
+		strncpy(p_str_user->password, argv[COL_SMS_USER_PASS], USER_RAND_PASSWORD_LEN);
+		p_str_user->password[USER_RAND_PASSWORD_LEN] = 0;
+		strncpy(p_str_user->phone, argv[COL_SMS_USER_PHONE], USER_PHONESIZE);
+		p_str_user->phone[USER_PHONESIZE] = 0;
+		p_str_user->expiration =
+			argv[COL_SMS_USER_EXPIRATION] ? strtol(argv[COL_SMS_USER_EXPIRATION], NULL, 0) : 0;
+		p_str_user->used = argv[COL_SMS_USER_USED] ? strtol(argv[COL_SMS_USER_USED], NULL, 0) : 0;
+		p_str_user->user_time =
+			argv[COL_SMS_USER_TIME] ? strtol(argv[COL_SMS_USER_TIME], NULL, 0) : 0;
+	}
+
+	return SQL_SUCCESS;
+}
+
+int usr_get_sms_user(sqlite3 *db, struct str_sms_user *user, char *password)
+{
+	int ret = 0;
+	char *sql = 0;
+	char *err = 0;
+
+	asprintf(&sql, SELECT_SMS_USER_FMT, password);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_sms_user_exists(sqlite3 *db, char *phone, uint8_t *mac)
+{
+	int ret = USER_RET_ERROR;
+	char *sql = 0;
+	sqlite3_stmt *stmt;
+
+	if (phone != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_FMT, "sms_users", phone);
+	else if (mac != NULL)
+		asprintf(&sql, SELECT_NOT_EXPIRED_MAC_FMT, "sms_users", MAC_ARG(mac));
+	else
+		goto out;
+
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (sqlite3_prepare_v2(db, sql, -1, &stmt, 0) != SQLITE_OK) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s", __FUNCTION__, sqlite3_errmsg(db));
+		goto out;
+	}
+
+	if (sqlite3_step(stmt) == SQLITE_ROW)
+		ret = sqlite3_column_int(stmt, 0) > 0 ? USER_RET_ALREADY : USER_RET_SUCCESS;
+
+	sqlite3_finalize(stmt);
+
+out:
+	free(sql);
+
+	return ret;
+}
+
+static int send_sms_created(struct redir_conn_t *conn, char *phone, char *password)
+{
+	int ret = USER_RET_SUCCESS;
+#ifdef ENABLE_GSM
+	char message[USER_MAX_MESSAGE_SIZE];
+
+	usr_gen_message(message, password);
+
+	if (chilli_send_sms(phone, message, _options.modemid) != CHILLI_GSM_OK) {
+		usr_rm_sms_user(conn->hismac);
+		ret = USER_RET_SMS_ERR;
+	}
+#endif
+	if (ret == USER_RET_SUCCESS && _options.usersignup && !(conn->s_params.flags & NO_SCRIPT)) {
+		if (_options.debug)
+			chilli_log(LOG_DEBUG, "%s(%d): Calling user signup script: %s\n", __FUNCTION__, __LINE__,
+			       _options.usersignup);
+
+		usr_runscript(conn, _options.usersignup, phone, password);
+	}
+	return ret;
+}
+
+int usr_get_sms_user_phone(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac)
+{
+	int ret = SQL_SUCCESS;
+	char *sql = NULL;
+	char *err = 0;
+
+	if (phone != NULL)
+		asprintf(&sql, SELECT_SMS_USER_PHONE_FMT, phone);
+	else if (mac != NULL)
+		asprintf(&sql, SELECT_SMS_USER_MAC_FMT, MAC_ARG(mac));
+	else
+		goto out;
+
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return SQL_FAIL;
+	}
+
+out:
+	free(sql);
+
+	return SQL_SUCCESS;
+}
+
+int usr_add_sms_user(struct redir_conn_t *conn, char *phone, char *hexchall)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_ERROR;
+	char password[USER_RAND_PASSWORD_LEN + 1];
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath)))
+		return USER_RET_ERROR;
+
+	if (usr_random_hex(password, USER_RAND_PASSWORD_LEN)) {
+		ret = USER_RET_ERROR;
+		goto out;
+	}
+
+	if ((ret = usr_sms_user_exists(db, phone, conn->hismac)) != USER_RET_SUCCESS) {
+		struct str_sms_user user = { 0 };
+		if (usr_get_sms_user_phone(db, &user, phone, conn->hismac) || user.used == 0) {
+			chilli_log(LOG_DEBUG, "user already exists: %d\n", ret);
+			goto out;
+		}
+		if ((ret = usr_update_sms_user(db, &user, phone, conn->hismac, 0, password)) !=
+		    USER_RET_SUCCESS) {
+			goto out;
+		}
+		ret = send_sms_created(conn, phone, password);
+		goto out;
+	}
+
+	asprintf(&sql, INSERT_SMS_USERS_FMT, phone, password, MAC_ARG(conn->hismac), phone,
+		 _options.dynexpirationtime);
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	if (!sqlexec(db, sql, NULL)) {
+		ret = send_sms_created(conn, phone, password);
+	} else {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+out:
+	sqlclose(db);
+
+	return ret;
+}
+
+int usr_update_sms_user(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac, uint32_t used,
+			char *new_passw)
+{
+	int ret = USER_RET_SUCCESS;
+	char *sql = NULL;
+	char *err = 0;
+
+	if (new_passw) {
+		asprintf(&sql, UPDATE_SMS_USERS_PWD_FMT, new_passw, used, MAC_ARG(mac), phone);
+	} else {
+		asprintf(&sql, UPDATE_SMS_USERS_USE_FMT, used, MAC_ARG(mac), phone);
+	}
+
+	if (_options.debug)
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+
+	ret = sqlite3_exec(db, sql, _sms_select_callback, user, &err);
+	if (ret) {
+		chilli_log(LOG_INFO, "[%s] SQL error: %s\n", __FUNCTION__, err);
+		sqlite3_free(err);
+		free(sql);
+
+		return USER_RET_ERROR;
+	}
+
+	free(sql);
+
+	return USER_RET_SUCCESS;
+}
+
+static int rm_user(char *table, uint8_t *mac)
+{
+	sqlite3 *db;
+	char *sql = NULL;
+	int ret	  = USER_RET_SUCCESS;
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath))) {
+		ret = USER_RET_ERROR;
+		goto end;
+	}
+
+	asprintf(&sql, DELETE_USER_FMT, table, MAC_ARG(mac));
+	if (_options.debug) {
+		chilli_log(LOG_INFO, "[%s] SQL: %s", __FUNCTION__, sql);
+	}
+
+	if (sqlexec(db, sql, NULL)) {
+		ret = USER_RET_ERROR;
+	}
+
+	free(sql);
+	sqlclose(db);
+end:
+	return ret;
+}
+
+int usr_rm_user(uint8_t *mac)
+{
+	return rm_user("users", mac);
+}
+
+int usr_rm_sms_user(uint8_t *mac)
+{
+	return rm_user("sms_users", mac);
+}
+
+int usr_get(char *username)
+{
+	return 0;
+}
+
+static int migrate_localusers(sqlite3 *db)
+{
+	struct uci_context *uci = uci_alloc_context();
+	if (!uci) {
+		return 1;
+	}
+
+	struct uci_package *uci_chilli = NULL;
+	if (uci_load(uci, CHILLI_CONFIG, &uci_chilli)) {
+		uci_free_context(uci);
+		return 1;
+	}
+
+	struct uci_element *e = NULL;
+	struct uci_element *tmp = NULL;
+	uci_foreach_element_safe (&uci_chilli->sections, e, tmp) {
+		struct uci_section *s = uci_to_section(e);
+		if (!s->type || strcmp(s->type, "user")) {
+			continue;
+		}
+
+		const char *username_uci = uci_lookup_option_string(uci, s, "username");
+		if (!username_uci) {
+			continue;
+		}
+
+		const char *password_uci = uci_lookup_option_string(uci, s, "password");
+		if (!password_uci) {
+			continue;
+		}
+
+		const char *group_uci = uci_lookup_option_string(uci, s, "group");
+		lusr_add_user(db, username_uci, password_uci, !group_uci ? "default" : group_uci);
+
+		struct uci_ptr ptr = {
+			.target	 = UCI_TYPE_SECTION,
+			.package = uci_chilli->e.name,
+			.section = s->e.name,
+		};
+		uci_delete(uci, &ptr);
+		uci_save(uci, ptr.p);
+	}
+
+	uci_commit(uci, &uci_chilli, false);
+	uci_unload(uci, uci_chilli);
+	uci_free_context(uci);
+	return 0;
+}
+
+static int alter_table_add_column(sqlite3 *db, const char *table_name, const char *column_definition)
+{
+	int ret		= USER_RET_ERROR;
+	char *sql_alter = NULL;
+
+	asprintf(&sql_alter, ALTER_TABLE_FMT, table_name, column_definition);
+
+	if (sqlite3_exec(db, sql_alter, 0, 0, 0) == SQLITE_OK) {
+		ret = USER_RET_SUCCESS;
+	}
+
+	free(sql_alter);
+
+	return ret;
+}
+
+int alter_tables()
+{
+	sqlite3 *db;
+	int ret = USER_RET_ERROR;
+
+	if (!_options.usersdbpath || !(db = sqlopen(_options.usersdbpath)))
+		return ret;
+
+	ret = alter_table_add_column(db, "sms_users", "used TIMESTAMP DEFAULT 0 NOT NULL");
+	ret = sqlite3_exec(db, CREATE_LUSER_TABLE, 0, 0, 0);
+	ret = migrate_localusers(db);
+
+	sqlclose(db);
+	return ret;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/users.h src/src/users.h
--- upstream/src/users.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/users.h	2025-11-06 13:20:13.000000000 +0000
@@ -0,0 +1,182 @@
+
+#ifndef RUTX_USERS_H
+#define RUTX_USERS_H
+
+#include <inttypes.h>
+
+#define USER_MIN_PHONE_LEN 6
+
+#define USER_USERNAMENAMESIZE 128
+#define USER_PASSWORDSIZE     128
+#define USER_PHONESIZE	      64
+#define USER_EMAILSIZE	      128
+#define USER_GROUPSIZE	      128
+
+#define USER_RAND_USERNAME_LEN 16
+#define USER_RAND_PASSWORD_LEN 6
+
+#define USER_RET_SUCCESS 0
+#define USER_RET_ERROR	 1
+#define USER_RET_ALREADY 2
+#define USER_RET_SMS_ERR 3
+
+#define USER_MAX_MESSAGE_SIZE 128
+
+#define CHILLI_CONFIG "chilli"
+
+enum {
+	COL_SMS_USER_ID = 0,
+	COL_SMS_USER_NAME,
+	COL_SMS_USER_PASS,
+	COL_SMS_USER_MAC,
+	COL_SMS_USER_PHONE,
+	COL_SMS_USER_CREATED,
+	COL_SMS_USER_EXPIRATION,
+	COL_SMS_USER_USED,
+	COL_SMS_USER_TIME,
+};
+
+enum {
+	COL_USER_ID = 0,
+	COL_USER_NAME,
+	COL_USER_EMAIL,
+	COL_USER_PASS,
+	COL_USER_MAC,
+	COL_USER_PHONE,
+	COL_USER_CREATED,
+	COL_USER_EXPIRATION,
+	COL_USER_TIME,
+};
+
+enum { COL_LUSER_ID = 0, COL_LUSER_NAME, COL_LUSER_PASS, COL_LUSER_GROUP };
+
+#define INSERT_SMS_USERS_FMT                                                                                 \
+	"INSERT INTO sms_users (username, password, mac, phone,"                                             \
+	" expiration) VALUES ('%s', '%s', '" MAC_FMT "', '%s', '%" PRIi64 "');"
+
+#define NOT_EXPIRED_FMT                                                                                      \
+	"((strftime('%%s','now') - strftime('%%s', created)) < expiration"                                   \
+	" OR expiration = '0')"
+
+#define LIMIT_FMT " ORDER BY id DESC limit 1"
+
+#define UPDATE_USR_PWD                                                                                       \
+	"UPDATE users SET password='%s' \
+			WHERE (" NOT_EXPIRED_FMT " AND email = '%s');"
+
+#define UPDATE_SMS_USERS_PWD_FMT                                                                             \
+	"UPDATE sms_users SET password='%s', \
+			used='%" PRIu32 "', mac='"MAC_FMT"' WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+#define UPDATE_SMS_USERS_USE_FMT                                                                             \
+	"UPDATE sms_users SET used='%" PRIu32 "', mac='"MAC_FMT"' \
+			WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+#define USER_TIME_FMT "(strftime('%%s','now') - strftime('%%s', created)) AS user_time"
+
+//Cont all unexpired users with corresponding phone number
+#define SELECT_NOT_EXPIRED_FMT                                                                               \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND phone = '%s');"
+
+//Cont all unexpired users with corresponding mac
+#define SELECT_NOT_EXPIRED_MAC_FMT                                                                           \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND mac = '" MAC_FMT "');"
+
+#define SELECT_NOT_EXPIRED_EMAIL_FMT                                                                         \
+	"SELECT COUNT(*) from %s"                                                                            \
+	" WHERE (" NOT_EXPIRED_FMT " AND (email = '%s' OR mac = '" MAC_FMT "'));"
+
+#define SELECT_SMS_USER_FMT                                                                                  \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND password = '%s')" LIMIT_FMT ";"
+
+#define SELECT_SMS_USER_PHONE_FMT                                                                            \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND phone = '%s')" LIMIT_FMT ";"
+
+#define SELECT_SMS_USER_MAC_FMT                                                                            \
+	"SELECT *, " USER_TIME_FMT "  FROM sms_users"                                                        \
+	" WHERE (" NOT_EXPIRED_FMT " AND mac = '" MAC_FMT "')" LIMIT_FMT ";"
+
+#define INSERT_USERS_FMT                                                                                     \
+	"INSERT INTO users (username, email, password, mac, phone,"                                          \
+	" expiration) VALUES ('%s', '%s', '%s', '" MAC_FMT "', '%s', '%" PRIi64 "');"
+
+#define SELECT_USER_FMT                                                                                      \
+	"SELECT *, " USER_TIME_FMT " FROM users "                                                            \
+	"WHERE (" NOT_EXPIRED_FMT " AND email = '%s')" LIMIT_FMT ";"
+
+#define DELETE_USER_FMT "DELETE FROM %s WHERE (mac = '" MAC_FMT "');"
+
+#define ALTER_TABLE_FMT "ALTER TABLE %s ADD COLUMN %s;"
+
+#define MSG_FMT "Password - %s, expiration time - %s"
+
+#define CREATE_LUSER_TABLE                                                                                   \
+	"CREATE TABLE IF NOT EXISTS local_users ("                                                           \
+	"id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,"                                              \
+	"username TEXT NOT NULL UNIQUE,"                                                                     \
+	"password TEXT NOT NULL,"                                                                            \
+	"user_group TEXT NOT NULL"                                                                           \
+	");"
+
+#define SELECT_LUSER_FMT                                                                                     \
+	"SELECT * FROM local_users "                                                                         \
+	"WHERE username = '%s'" LIMIT_FMT ";"
+
+#define UPDATE_LUSER_PWD                                                                                     \
+	"UPDATE local_users SET password='%s' \
+			WHERE username = '%s';"
+
+#define INSERT_LUSER_FMT                                                                                     \
+	"INSERT INTO local_users (username, password, user_group"                                            \
+	") VALUES ('%s', '%s', '%s');"
+
+struct str_sms_user {
+	char username[USER_RAND_USERNAME_LEN + 1];
+	char password[USER_RAND_PASSWORD_LEN + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t used;
+	uint32_t user_time;
+};
+
+struct str_user {
+	char username[USER_USERNAMENAMESIZE + 1];
+	char email[USER_EMAILSIZE + 1];
+	char password[USER_PASSWORDSIZE + 1];
+	char phone[USER_PHONESIZE + 1];
+	uint32_t expiration;
+	uint32_t user_time;
+};
+
+struct str_luser {
+	char username[USER_USERNAMENAMESIZE + 1];
+	char password[USER_PASSWORDSIZE + 1];
+	char group[USER_GROUPSIZE + 1];
+};
+
+int usr_get_user(sqlite3 *db, struct str_user *user, char *email);
+int usr_update_user_pwd(sqlite3 *db, struct str_user *user, char *email, char *new_passw);
+int usr_add_user(struct redir_conn_t *conn);
+
+int usr_get_sms_user(sqlite3 *db, struct str_sms_user *user, char *password);
+int usr_get_sms_user_phone(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac);
+int usr_update_sms_user(sqlite3 *db, struct str_sms_user *user, char *phone, uint8_t *mac, uint32_t used,
+			char *new_passw);
+int usr_add_sms_user(struct redir_conn_t *conn, char *phone, char *hexchall);
+int usr_sms_user_exists(sqlite3 *db, char *phone, uint8_t *mac);
+
+int usr_rm_user(uint8_t *mac);
+int usr_rm_sms_user(uint8_t *mac);
+
+int lusr_get_user(sqlite3 *db, struct str_luser *user, char *username);
+int lusr_update_user_pwd(sqlite3 *db, struct str_luser *user, char *username, char *new_passw);
+
+int usr_random_hex(char *dst, size_t size);
+
+int alter_tables();
+
+#endif //RUTX_USERS_H
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/util.c src/src/util.c
--- upstream/src/util.c	2016-12-15 17:28:43.000000000 +0000
+++ src/src/util.c	2025-11-06 13:20:13.000000000 +0000
@@ -75,7 +75,7 @@
     slashslash = src + 8;
   }
   else {
-    syslog(LOG_ERR, "URL must start with http:// or https:// [%s]!", src);
+    chilli_log(LOG_ERR, "URL must start with http:// or https:// [%s]!", src);
     return -1;
   }
 
@@ -94,7 +94,7 @@
     /* ...:port/... */
     hostlen = colon - slashslash;
     if (1 != sscanf(colon+1, "%d", port)) {
-      syslog(LOG_ERR, "Not able to parse URL port: %s!", src);
+      chilli_log(LOG_ERR, "Not able to parse URL port: %s!", src);
       return -1;
     }
   }
@@ -103,7 +103,7 @@
   }
 
   if (hostlen > (hostsize-1)) {
-    syslog(LOG_ERR, "URL hostname larger than %d: %s!", hostsize-1, src);
+    chilli_log(LOG_ERR, "URL hostname larger than %d: %s!", hostsize-1, src);
     return -1;
   }
 
@@ -116,6 +116,54 @@
 
   return 0;
 }
+
+int bstrtocstr(bstring src, char *dst, unsigned int len) {
+	if (!src || src->slen == 0) {
+		dst[0] = 0;
+		return 0;
+	}
+
+	strlcpy(dst, (char*)src->data, len);
+	return 0;
+}
+
+int bescape_str(bstring src, bstring dst) {
+  int n;
+
+  bassigncstr(dst, "");
+  for (n=0; n < src->slen; n++)
+    if ('\'' != src->data[n] && src->data[n] != '"' &&
+        '\\' != src->data[n]) {
+      bconchar(dst,src->data[n]);
+    }
+
+  return 0;
+}
+
+int escape_cstr(char *src, char *dst) {
+  int i = 0;
+  int n;
+
+  for (n = 0; n < strlen(src); n++)
+    if ('\'' != src[n] && src[n] != '"' &&
+        '\\' != src[n]) {
+      dst[i++] = src[n];
+    }
+
+  dst[i] = 0;
+
+  return 0;
+}
+
+int besc_strtocstr(bstring src, char *dst, unsigned int len) {
+  bstring dst_bt = bfromcstr("");
+
+  bescape_str(src, dst_bt);
+  bstrtocstr(dst_bt, dst, len);
+  bdestroy(dst_bt);
+
+  return 0;
+}
 
 
 /* This file is free software; you can redistribute it and/or modify */
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/www/Makefile.am src/www/Makefile.am
--- upstream/www/Makefile.am	2016-12-15 17:28:43.000000000 +0000
+++ src/www/Makefile.am	2025-11-06 13:20:13.000000000 +0000
@@ -17,7 +17,7 @@
 edit = sed \
 	-e 's,@SBINDIR\@,$(sbindir),g' \
 	-e 's,@INITDIR\@,$(sysconfdir)/init.d,g' \
-	-e 's,@VARRUN\@,$(localstatedir)/run,g' \
+	-e 's,@VARRUN\@,$(localstatedir),g' \
 	-e 's,@ETCCHILLI\@,$(sysconfdir)/chilli,g' \
 	-e 's,@SYSCONFDIR\@,$(sysconfdir),g' \
 	-e 's,@PREFIX\@,$(prefix),g'
