semgrep_errors:
  image: returntocorp/semgrep
  before_script:
    - 'git clone git@git.teltonika.lt:cybersecurity/SAST.git'
  script:
    - |
      semgrep ci --config=$SEMGREP_RULES --json > semgrep_output.json ||
      json=$(cat semgrep_output.json)
      elements=("path" "message" "lines")
      IFS=- read -r first <<< $(echo "$json" | awk -F 'results":' '{print $2}' | awk -F ', "version":' '{print $1}')
      results=$(awk '{split($0, array, "\"check_id\":");
      for (i = 1; i <= 5; i++){
        print array[i]
        }
      }' <<< "$first")

      readarray -t y <<<"$results"
      error_found=false
      for _ITEM in "${y[@]}"; do
        if [[ "$_ITEM" == *"ERROR"* ]]; then
          error_found=true
          check_id=$(awk '{sub(/,$/, "", $1); print $1}' <<< "$_ITEM")
          start=$(echo $_ITEM | grep -oE '"start": \{[^}]*"line": [0-9]*' | sed -E 's/.*"line": ([0-9]*).*/"start":"line":\1/')
          echo "RULE ID: $check_id"
          echo "| $start" | sed 's/\\n//g; s/\\t//g'
          for element in ${elements[@]}; do
            data=$(grep -oE '"'$element'": "[^"]*"' <<< $_ITEM | sed 's/\\n//g; s/\\t//g')
            echo "| $data "
          done;
        fi
      done
      echo "-------------------------------------------------------------------------------------------------------"
      if [[ "$error_found" = true ]]; then  # add this condition
        exit 1  # fail the pipeline if there are any errors found
      fi
  rules:
    - changes:
      - .gitlab-ci.yml
    - if: $CI_PIPELINE_SOURCE == "web"  # allow triggering a scan manually from the GitLab UI
    - if: $CI_MERGE_REQUEST_IID
  variables:
    SEMGREP_RULES: >- # more at semgrep.dev/r
      ./SAST/rules.yaml
  tags:
    - check

semgrep_info:
  image: returntocorp/semgrep
  before_script:
    - 'git clone git@git.teltonika.lt:cybersecurity/SAST.git'
  script:
    - |
      semgrep ci --config=$SEMGREP_RULES --json > semgrep_output.json ||
      json=$(cat semgrep_output.json)
      elements=("path" "message" "lines")
      elements=("path" "message" "lines")
      IFS=- read -r first <<< $(echo "$json" | awk -F 'results":' '{print $2}' | awk -F ', "version":' '{print $1}')
      results=$(awk '{split($0, array, "\"check_id\":");
      for (i = 1; i <= 5; i++){
        print array[i]
        }
      }' <<< "$first")

      readarray -t y <<<"$results"
      error_found=false
      for _ITEM in "${y[@]}"; do
        if [[ "$_ITEM" == *"INFO"* ]]; then
          error_found=true
          check_id=$(awk '{sub(/,$/, "", $1); print $1}' <<< "$_ITEM")
          start=$(echo $_ITEM | grep -oE '"start": \{[^}]*"line": [0-9]*' | sed -E 's/.*"line": ([0-9]*).*/"start":"line":\1/')
          echo "RULE ID: $check_id"
          echo "| $start" | sed 's/\\n//g; s/\\t//g'
          for element in ${elements[@]}; do
            data=$(grep -oE '"'$element'": "[^"]*"' <<< $_ITEM | sed 's/\\n//g; s/\\t//g')
            echo "| $data "
          done;
        fi
      done
      echo "-------------------------------------------------------------------------------------------------------"
      if [[ "$error_found" = true ]]; then  # add this condition
        exit 1  # fail the pipeline if there are any errors found
      fi
  allow_failure: true
  rules:
    - changes:
      - .gitlab-ci.yml
    - if: $CI_PIPELINE_SOURCE == "web"  # allow triggering a scan manually from the GitLab UI
    - if: $CI_MERGE_REQUEST_IID
  variables:
    SEMGREP_RULES: >- # more at semgrep.dev/r
      ./SAST/rules.yaml
  tags:
    - check
