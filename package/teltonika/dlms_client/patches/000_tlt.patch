diff --recursive --unified --new-file --no-dereference orig/.gitignore src/.gitignore
--- orig/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitignore	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+.vscode/
diff --recursive --unified --new-file --no-dereference orig/.gitlab-ci.yml src/.gitlab-ci.yml
--- orig/.gitlab-ci.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitlab-ci.yml	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,20 @@
+include:
+  - project: teltonika/ci-templates
+    file:
+      - /templates/semgrep.yml
+
+workflow:
+  rules:
+    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
+    - if: $CI_PIPELINE_SOURCE == "web"
+    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
+      when: never
+    - if: $CI_COMMIT_BRANCH
+
+semgrep_errors:
+  extends: .semgrep_errors
+
+semgrep_info:
+  extends: .semgrep_info
+  needs:
+    - job: semgrep_errors
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/.gitmodules src/.gitmodules
--- orig/.gitmodules	1970-01-01 00:00:00.000000000 +0000
+++ src/.gitmodules	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,3 @@
+[submodule "test/support"]
+	path = test/support
+	url = git@git.teltonika.lt:teltonika/packages/unit_test_stubs.git
diff --recursive --unified --new-file --no-dereference orig/Makefile src/Makefile
--- orig/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ src/Makefile	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,21 @@
+TARGET = dlms_client
+
+SRCDIR := ./src
+
+SOURCES := $(wildcard $(SRCDIR)/*.c)
+
+OBJS = $(SOURCES:.c=.o)
+
+CFLAGS += -D_GNU_SOURCE -DCONFIG_MACHINE_$(TLT_PLATFORM_NAME)
+CFLAGS += -Wall -Wextra -Werror -pedantic -fno-common -ffunction-sections -fdata-sections -Wundef
+
+LDFLAGS += -lubus -lubox -lsqlite3 -ltlt_uci -luci -lgurux_dlms_c -ltlt_logger -lpthread
+RM = rm -f
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $^ $(LDFLAGS)
+
+clean:
+	$(RM) $(OBJS) $(TARGET)
diff --recursive --unified --new-file --no-dereference orig/README.md src/README.md
--- orig/README.md	1970-01-01 00:00:00.000000000 +0000
+++ src/README.md	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,378 @@
+# DLMS Master
+
+Master type application for DLMS supported device (server) interval scanning. Application itself is more like a client since it connects to DLMS device(s) also known as server and collects data by given OBIS code.
+
+
+### DLMS Device
+
+Each **physical device** can contain one or more **logical devices**. Each **logical device** contains a number of **COSEM** objects, modeling the functionality of the **logical device**.
+
+COSEM objects are implemented from COSEM interface classes which describe attributes and methods of realised COSEM objects.
+Each COSEM objects is identified by it's OBIS code: A.B.C.D.E.F (0.0.1.0.0.254)
+
+```plantuml
+
+@startuml
+
+node "DLMS server" <<Physical device>> {
+    node "Management logical device" <<Logical device>> {
+        storage "LDN" as LDN1
+        storage "A" as A1
+        storage "Register "Total Energy"" as REG1 
+        note right: COSEM Object (OBIS: 0.0.1.0.0.254)
+        storage "ProfileGeneric "Energy Profile"" as REG2
+        note right: COSEM Object (OBIS: 0.1.0.39.0.254)
+    }
+
+    node "Logical Device 2" <<Logical device>> {
+        storage "LDN" as LDN2
+        storage "A" as A2
+        storage "Register "Total Water"" as REG3
+        note right: COSEM Object (OBIS: 0.0.1.0.0.254)
+        storage "ProfileGeneric "Water Profile"" as REG4
+        note right: COSEM Object (OBIS: 1.1.0.39.0.254)
+    }
+}
+
+@enduml
+```
+
+### Deployment diagram
+
+```plantuml
+@startuml
+
+node "TRB255" <<Device>> {
+    node "RutOS" <<ExecutionEnvironment>> {
+        component "Data to Server" as DTS
+        component "DLMS Master" as Master
+        database "/tmp/dlms_master.db" as db
+    }
+}
+
+cloud "Remote\nServer" as Remote
+
+node "DLMS Device 1" as S1
+node "DLMS Device 2" as S2
+node "DLMS Device 3" as S3
+
+S1 -up-> Master
+S2 -up-> Master
+S3 -up-> Master
+Master -> db
+db -> DTS
+DTS -> Remote
+
+@enduml`
+```
+
+### Overview what DLMS Master application reads and connects to
+
+
+```plantuml
+@startuml
+
+Title Reading
+
+node Physical_Device {
+ node Logical_Device_Address_1 {
+    storage Data_Name
+    note right
+    COSEM Class ID: 1
+    Attribute 1: Logical Name (OBIS code)
+    Attribute 2: Value
+    end note
+
+    storage Register_Total_Energy
+    note right
+    COSEM Class ID: 3
+    Attribute 1: Logical Name (OBIS code)
+    Attribute 2: Value
+    Attribute 3: Scaler and unit
+    end note
+
+    storage Association_LN_Object
+    note right
+    COSEM Class ID: 15
+    Attribute 1: Logical Name (OBIS code)
+    Attribute 2: Object list
+    Attribute 3: Associated partners ID
+    Attribute 4: Application context name
+    Attribute 5: xDLMS context info
+    Attribute 6: Authentication mechanism name
+    Attribute 7: Secret
+    Attribute 8: Association status
+    Attribute 9: Security setup reference
+    Attribute 10: User list
+    Attribute 11: Current user
+
+    end note
+ }
+}
+
+node Teltonika_Router {
+ node DLMS_Master
+}
+
+DLMS_Master --> Logical_Device_Address_1 : Connects to
+DLMS_Master --> Data_Name : Reads attributes
+DLMS_Master --> Register_Total_Energy : Reads attributes
+DLMS_Master --> Association_LN_Object : Reads attributes
+
+@enduml
+
+```
+
+### Class diagram
+
+```plantuml
+@startuml
+skinparam nodesep 80
+
+class Master
+class Device
+class ValueGroup
+class Value
+
+
+Master "1"  --> "0..*" Device
+Master "1" --> "0..* "ValueGroup
+ValueGroup "1" --> "0..*" Value
+Value "0..*" -left->  "1" Device
+
+@enduml
+```
+
+### Main function activity diagram
+
+```plantuml
+@startuml
+Title Main function
+
+start
+
+:utl_parse_args();
+note right
+Parse -D <level> argument
+end note
+
+:logger_init();
+note right
+Initiate logger. Zero is the most powerful level.
+end note
+
+:init_ubus_test_functions();
+
+:uloop_init();
+
+:cfg_get_master();
+note right
+Read configuration and create master struct
+If failing (most likely configuration is empty), just start UBUS methods for testing.
+end note
+
+:mstr_create_db();
+
+:mstr_initialize_cosem_groups();
+note right
+Start groups. Every group has separate thread.
+end note
+
+:uloop_run();
+
+:mstr_db_free();
+
+:cfg_free_master();
+
+:ubus_exit();
+
+stop
+@enduml
+```
+
+#### Thread routine
+
+```plantuml
+@startuml
+
+Title mstr_thread_routine
+
+start
+
+while (forever)
+
+:data = cg_read_group_codes(value_group, &rc);
+note right
+Read all COSEM objects that are in COSEM group.
+end note
+
+:mstr_write_group_data_to_db(value_group, data);
+note right
+Write returned data to DB.
+end note
+
+:free(data);
+note right
+Free returned data.
+end note
+
+:utl_smart_sleep(timeout, value_group->interval);
+note right
+Calculates how much time you need to sleep (because reading consumes some time)
+end note
+
+endwhile
+
+end
+
+@enduml
+```
+
+### DLMS/COSEM message types
+
+| Frame | Description |
+| ------ | ------ |
+| SNRM | Set Normal Response Mode, is used to bring the server (meter) into the normal response mode. The SNRM is used to negotiate parameters such as the maximum length of the data that can be received and transmitted by either party |
+| UA | On reception of an SNRM, the server examines the values of these parameter (if sent by the client) and chooses a value which both the client and server will be compliant to. This information is conveyed by the server to the client using a UA Frame. |
+| AARQ | Application Association Request, is sent by the client to establish an association with the server. The AARQ PDU (Protocol Data Unit) communicates the Application Context used and the Authentication Value (Secret Password to authenticate Client and/or Server) if any to the Server. |
+| AARE | Application Association Response, is the response sent by the server to an AARQ. |
+| GET | A GET request is used by the client to fetch data from the meter. |
+| SET | The SET Request is used by the client to set a data at the meter. |
+| DISC | Disconnect – command is used to disconnect the logical link layer of the client from the server. On reception of a DISC command, the server responds with a UA, similar to the one sent on response to the SNRM. The server is said to be in NDM (Normal Disconnected Mode) on reception of this command. No data exchange can be carried out in this state, except Unnumbered Information and Mode Setting Command such as the SNRM. |
+
+### Connecting and reading 
+
+In order to connect to DLMS device, we need: 
+- server address 
+- client address 
+- TCP IP/PORT or serial port. 
+
+DLMS devices have multiple levels of authentications which grant different permissions to physical device. 
+Different authentications use different client address (default: no authentication 16, low (password only) - 17, high (password + encryption) - 18)
+
+
+## Test button
+
+Test button should be working **after** you enable master section.
+
+We can test:
+1. Physical device;
+2. COSEM group. If we want to test COSEM group, **at least** one physical device must be created.
+
+Test buttons can be tested through UBUS calls:
+
+* TCP device:
+`ubus call dlms test_device '{"type":0, "tcp_address":"192.168.1.156", "tcp_port":4068,"client_addr":16,"logical_server_addr":0, "server_addr":1, "security":0}'`
+
+* Serial device:
+`ubus call dlms test_device '{"type":1, "serial_dev":"/dev/rs232", "serial_baudrate":9600, "serial_databits":8, "serial_stopbits":1, "serial_parity":"none", "serial_flowcontrol":"none", "client_addr":16,"logical_server_addr":0, "server_addr":1, "security":0}'`
+
+* COSEM group:
+`ubus call dlms test_cosem_group '{"objects":[{"id":5, "enabled":1, "name":"type_data", "devices":["4","3","6","10"], "obis":"0.0.42.0.0.255", "cosem_id":1}]}'`
+
+## Configurations 
+
+**Config**: dlms_master
+**Config Section**: connection
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ |
+| Name |  Name of DLMS connection configuration | - | - | name | - | Yes |
+| Connection type  | DLMS connection type | - | drowdown selection TCP or SERIAL | type | TCP | Yes |
+
+**Connection type: TCP**
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ | 
+| Address | DLMS device IP address for TCP connection | - | IP address validation | address | - | Yes |
+| Port | DLMS device IP port for TCP connection | - | 0-65535 | port | - | Yes |
+
+**Connection type: TCP**
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ | 
+| Serial device | DLMS device serial device | - | drowdown selection from /dev/* | device | - | Yes |
+| Baudrate | Serial port baudrate | - | 300/600/1200/1800/2400/4800/9600/19200/38400 | baudrate | 9600 | Yes |
+| Databits | Serial port databits | - | 5/6/7/8 | databits | 8 | Yes |
+| Stopbits | Serial port stopbits | - | 1/2 | stopbits | 1 | Yes |
+| Parity | Serial port parity | - | None/Even/Odd/Mark/Space | parity | None | Yes |
+| Flow control | Serial port parity | - | None, RTS/CTS, Xon/Xoff | flowcontrol | None | Yes |
+
+**Config**: dlms_master
+**Config Section**: physical_device
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ | 
+| Enabled | Physical device state | - | 1/0 | enabled | 0 | Yes |
+| Name | Physical device name | - | - | name | 9600 | Yes |
+| Server address | DLMS device server address | - | Numbers only | server_addr | None | Yes |
+| Logical server address | DLMS device logical server address | - | Numbers only | server_addr | None | Yes |
+| Client address | DLMS device client address | - | Numbers only | client_addr | 8 | Yes |
+| Access security | DLMS device authentication type | - | (0) NONE / LOW (1) / HIGH (2) / HIGH MD5 (3) / HIGH SHA1 (4) / HIGH GMAC (5) | authentication | 0 | Yes |
+| Interface type | DLMS device interface type | - | (0) HDLC / WRAPPER (1) | interface | 0 | Yes |
+| Transport security | DLMS device security | - | 0 (NONE) / Authentication (16) / Security encryption (32) / Authentication encryption (48) | security | 0 | Yes |
+| Password | DLMS device password if authentication is used | - | - | password | - | No |
+| Authentication key | DLMS device authentication key | - | - | authentication_key | - | No |
+| Block cipher key | DLMS device block cipher key | - | - | block_cipher_key | - | No |
+| Dedicated key | DLMS device dedicated key | - | - | dedicated_key | - | No |
+| Invocation counter OBIS code | DLMS device invocation counter OBIS | - | - | dedicated_key | - | No |
+
+**Config**: dlms_master
+**Config Section**: cosem_group
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ | 
+| Enabled | Value group state | - | 1/0 | enabled | - | Yes |
+| Name | OBIS code group name | - | - | name | - | Yes |
+| Interval | Interval for OBIS code reading | - | Numbers only | interval | - | Yes |
+
+
+**Config**: dlms_master
+**Config Section**: cosem
+
+| Option label | Option hint |  Placeholder | Option validation | Option name in config | Default values | Required |
+| ------ | ------ | ------ | ------ | ------ |------ | ------ | 
+| Enabled | OBIS state | - | 1/0 | enabled | - | Yes |
+| Name | OBIS option name | - | - | name | - | Yes |
+| Physical devices | Physical device to read from | - | select physical devices from dropdown and write it's section id | dev_config | - | Yes |
+| OBIS Code | OBIS code value | - | - | code | - | Yes |
+| COSEM class id | Object type for OBIS code | - | check 1. below | type | - | No (only if physical device option scanAllObjs is selected) |
+
+1. Available COSEM class id
+
+| Class name | class ID |
+| ------ | ------ | 
+| DATA | 1 |
+| REGISTER | 3 |
+| EXTENDED REGISTER | 4 |
+| DEMAND REGISTER | 5 |
+| REGISTER ACTIVATION | 6 |
+| PROFILE GENERIC | 7 |
+| CLOCK | 8 |
+| SCRIPT TABLE | 9 |
+| SPECIAL DAYS TABLE | 11 |
+| ASSOCIATION SHORT NAME | 12 |
+| ASSOCIATION LOGICAL NAME | 15 |
+| SAP ASSIGNMENT | 17 |
+| IMAGE TRANSFER | 18 |
+| IEC LOCAL PORT SETUP | 19 |
+| ACTIVITY CALENDAR | 20 |
+| REGISTER MONITOR | 21 |
+| ACTION SCHEDULE | 22 |
+| IEC HDLC SETUP | 23 |
+| IEC TWISTED PAIR SETUP | 24 |
+| UTILITY TABLES | 26 |
+| MODEM CONFIGURATION | 27 |
+| AUTO ANSWER | 28 |
+| AUTO CONNECT | 29 |
+| PUSH SETUP | 40 |
+| TCP UDP SETUP | 41 |
+| IP4 SETUP | 42 |
+| MAC ADDRESS SETUP | 43 |
+| GPRS SETUP | 45 |
+| GSM DIAGNOSTIC | 47 |
+| IP6 SETUP | 48 |
+| COMPACT DATA | 62 |
+| SECURITY SETUP | 64 |
+| DISCONNECT CONTROL | 70 |
+| LIMITER | 71 |
diff --recursive --unified --new-file --no-dereference orig/VS/GuruxDLMSClientExample.sln src/VS/GuruxDLMSClientExample.sln
--- orig/VS/GuruxDLMSClientExample.sln	2023-11-10 10:15:18.000000000 +0000
+++ src/VS/GuruxDLMSClientExample.sln	1970-01-01 00:00:00.000000000 +0000
@@ -1,41 +0,0 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 14
-VisualStudioVersion = 14.0.25420.1
-MinimumVisualStudioVersion = 10.0.40219.1
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GuruxDLMSClientExample", "GuruxDLMSClientExample.vcxproj", "{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}"
-	ProjectSection(ProjectDependencies) = postProject
-		{14659927-283A-4C68-952C-7FBBBEA1F55B} = {14659927-283A-4C68-952C-7FBBBEA1F55B}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GuruxDLMS.c", "..\..\development\VS\GuruxDLMS.c.vcxproj", "{14659927-283A-4C68-952C-7FBBBEA1F55B}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Debug|x64 = Debug|x64
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Debug|Win32.ActiveCfg = Debug|Win32
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Debug|Win32.Build.0 = Debug|Win32
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Debug|x64.ActiveCfg = Debug|x64
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Debug|x64.Build.0 = Debug|x64
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Release|Win32.ActiveCfg = Release|Win32
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Release|Win32.Build.0 = Release|Win32
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Release|x64.ActiveCfg = Release|x64
-		{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}.Release|x64.Build.0 = Release|x64
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Debug|Win32.Build.0 = Debug|Win32
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Debug|x64.ActiveCfg = Debug|x64
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Debug|x64.Build.0 = Debug|x64
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Release|Win32.ActiveCfg = Release|Win32
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Release|Win32.Build.0 = Release|Win32
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Release|x64.ActiveCfg = Release|x64
-		{14659927-283A-4C68-952C-7FBBBEA1F55B}.Release|x64.Build.0 = Release|x64
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff --recursive --unified --new-file --no-dereference orig/VS/GuruxDLMSClientExample.vcxproj src/VS/GuruxDLMSClientExample.vcxproj
--- orig/VS/GuruxDLMSClientExample.vcxproj	2023-11-10 10:15:18.000000000 +0000
+++ src/VS/GuruxDLMSClientExample.vcxproj	1970-01-01 00:00:00.000000000 +0000
@@ -1,164 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\src\communication.c" />
-    <ClCompile Include="..\src\connection.c" />
-    <ClCompile Include="..\src\getopt.c" />
-    <ClCompile Include="..\src\main.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\include\communication.h" />
-    <ClInclude Include="..\include\connection.h" />
-    <ClInclude Include="..\include\getopt.h" />
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{9BA40B4C-40CB-4FC0-B120-0D4DF7B7F121}</ProjectGuid>
-    <Keyword>Win32Proj</Keyword>
-    <RootNamespace>GuruxDLMSClientExample</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <CharacterSet>NotSet</CharacterSet>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <CharacterSet>NotSet</CharacterSet>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>NotSet</CharacterSet>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>NotSet</CharacterSet>
-    <PlatformToolset>v142</PlatformToolset>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <LinkIncremental>true</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <LinkIncremental>true</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAs>CompileAsC</CompileAs>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>Ws2_32.lib;Debug\GuruxDLMS.c.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <PreprocessorDefinitions>WIN64;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAs>CompileAsC</CompileAs>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <AdditionalDependencies>Ws2_32.lib;x64\Debug\GuruxDLMS.c.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <Optimization>MaxSpeed</Optimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAs>CompileAsC</CompileAs>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <AdditionalDependencies>Ws2_32.lib;Release\GuruxDLMS.c.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <Optimization>MaxSpeed</Optimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <PreprocessorDefinitions>WIN64;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <CompileAs>CompileAsC</CompileAs>
-    </ClCompile>
-    <Link>
-      <SubSystem>Console</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <AdditionalDependencies>Ws2_32.lib;x64\Release\GuruxDLMS.c.lib;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/VS/GuruxDLMSClientExample.vcxproj.filters src/VS/GuruxDLMSClientExample.vcxproj.filters
--- orig/VS/GuruxDLMSClientExample.vcxproj.filters	2023-11-10 10:15:18.000000000 +0000
+++ src/VS/GuruxDLMSClientExample.vcxproj.filters	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\src\communication.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\connection.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\main.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\getopt.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\include\communication.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\connection.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\include\getopt.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/files/dlms_client.conf src/files/dlms_client.conf
--- orig/files/dlms_client.conf	1970-01-01 00:00:00.000000000 +0000
+++ src/files/dlms_client.conf	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,2 @@
+config main 'main'
+	option enabled '0'
diff --recursive --unified --new-file --no-dereference orig/files/dlms_client.init src/files/dlms_client.init
--- orig/files/dlms_client.init	1970-01-01 00:00:00.000000000 +0000
+++ src/files/dlms_client.init	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,42 @@
+#!/bin/sh /etc/rc.common
+
+APP=/usr/sbin/dlms_client
+CONFIG="dlms_client"
+
+USE_PROCD=1
+START=99
+STOP=99
+
+GROUPS_ENABLED=0
+
+check_for_enabled_groups() {
+	config_get ENABLED "$1" "enabled" "0"
+
+	[ "$ENABLED" = "0" ] && return
+
+	GROUPS_ENABLED=1
+}
+
+start_service() {
+	config_load $CONFIG
+
+	config_get enabled "main" "enabled" "0"
+	config_foreach check_for_enabled_groups cosem_group
+
+	[ "$GROUPS_ENABLED" = "0" ] && [ "$enabled" = "0" ] && return
+
+	procd_open_instance
+	procd_set_param command "$APP"
+	procd_set_param respawn ${respawn_threshold:-0} ${respawn_timeout:-60} ${respawn_retry:-0}
+	procd_close_instance
+}
+
+reload_service() {
+	procd_set_param file /etc/config/modbus_client
+	stop
+	start
+}
+
+service_triggers() {
+	procd_add_reload_trigger "$CONFIG"
+}
diff --recursive --unified --new-file --no-dereference orig/include/communication.h src/include/communication.h
--- orig/include/communication.h	2023-11-10 10:15:18.000000000 +0000
+++ src/include/communication.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,151 +0,0 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-
-#ifndef COMMUNICATION_H
-#define COMMUNICATION_H
-
-#include <stdio.h>
-#include <string.h>
-#include "../../development/include/client.h"
-#include "../../development/include/cosem.h"
-#include "connection.h"
-
-//Make connection using TCP/IP connection.
-int com_makeConnect(
-    connection *connection,
-    const char* address,
-    int port,
-    int waitTime);
-
-//Make connection serial port connection.
-int com_open(
-    connection *connection,
-    const char* port);
-
-//Start server.
-int com_startServer(
-    connection *connection,
-    unsigned char trace,
-    int port);
-
-// Read DLMS Data frame from the device.
-int readDLMSPacket(
-    connection *connection,
-    gxByteBuffer* data,
-    gxReplyData* reply);
-
-int com_readDataBlock(
-    connection *connection,
-    message* messages,
-    gxReplyData* reply);
-
-//Close connection to the meter.
-int com_disconnect(
-    connection* connection);
-
-//Close connection to the meter and close the communcation channel.
-int com_close(
-    connection *connection);
-
-//Initialize optical head.
-int com_initializeOpticalHead(
-    connection* connection);
-
-
-//Read Invocation counter (frame counter) from the meter and update it.
-int com_updateInvocationCounter(
-    connection* connection,
-    const char* invocationCounter);
-
-//Initialize connection to the meter.
-int com_initializeConnection(
-    connection *connection);
-
-//Get Association view.
-int com_getAssociationView(
-    connection *connection,
-    const char* outputFile);
-
-//Read object.
-int com_read(
-    connection *connection,
-    gxObject* object,
-    unsigned char attributeOrdinal);
-
-//Send keepalive message.
-int com_getKeepAlive(
-    connection* connection);
-
-//Write object.
-int com_write(
-    connection *connection,
-    gxObject* object,
-    unsigned char attributeOrdinal);
-
-int com_method(
-    connection *connection,
-    gxObject* object,
-    unsigned char attributeOrdinal,
-    dlmsVARIANT* params);
-
-/**
-* Read objects.
-*/
-int com_readList(
-    connection *connection,
-    gxArray* list);
-
-int com_readRowsByEntry(
-    connection *connection,
-    gxProfileGeneric* object,
-    unsigned long index,
-    unsigned long count);
-
-int com_readRowsByEntry2(
-    connection *connection,
-    gxProfileGeneric* object,
-    unsigned long index,
-    unsigned long count,
-    unsigned short colStartIndex,
-    unsigned short colEndIndex);
-
-int com_readRowsByRange(
-    connection *connection,
-    gxProfileGeneric* object,
-    struct tm* start,
-    struct tm* end);
-
-int com_readRowsByRange2(
-    connection* connection,
-    gxProfileGeneric* object,
-    gxtime* start,
-    gxtime* end);
-
-int com_readValue(
-    connection *connection,
-    gxObject* object,
-    unsigned char index);
-
-//This function reads ALL objects that meter have. It will loop all object's attributes.
-int com_readAllObjects(
-    connection *connection,
-    const char* outputFile);
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --recursive --unified --new-file --no-dereference orig/include/connection.h src/include/connection.h
--- orig/include/connection.h	2023-11-10 10:15:18.000000000 +0000
+++ src/include/connection.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,75 +0,0 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-
-#ifndef MEDIA_H
-#define MEDIA_H
-
-#include "../../development/include/bytebuffer.h"
-#include "../../development/include/dlmssettings.h"
-
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-#include <Winsock2.h> //Add support for sockets
-#include <Windows.h> //Add support for serial port functions.
-#endif
-
-static const unsigned int RECEIVE_BUFFER_SIZE = 200;
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-    typedef struct
-    {
-        //Is trace used.
-        GX_TRACE_LEVEL trace;
-        //Socked handle.
-        int socket;
-        //Serial port handle.
-#if defined(_WIN32) || defined(_WIN64)// If Windows
-        HANDLE comPort;
-        OVERLAPPED		osWrite;
-        OVERLAPPED		osReader;
-#else //If Linux
-        int comPort;
-#endif
-        unsigned long   waitTime;
-        //Received data.
-        gxByteBuffer data;
-        //Receiver thread handle.
-        int receiverThread;
-        //If receiver thread is closing.
-        unsigned char closing;
-
-        dlmsSettings settings;
-    } connection;
-
-    void con_initializeBuffers(
-        connection* connection,
-        int size);
-
-    //Initialize connection settings.
-    void con_init(
-        connection* con,
-        GX_TRACE_LEVEL trace);
-
-    //Close connection..
-    void con_close(connection* con);
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif //MEDIA_H
diff --recursive --unified --new-file --no-dereference orig/include/getopt.h src/include/getopt.h
--- orig/include/getopt.h	2023-11-10 10:15:18.000000000 +0000
+++ src/include/getopt.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,36 +0,0 @@
-/* *****************************************************************
-*
-* Copyright 2016 Microsoft
-*
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*
-******************************************************************/
-
-#ifndef GETOPT_H__
-#define GETOPT_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    extern char *optarg;
-    extern int optind;
-
-    int getopt(int argc, char *const argv[], const char *optstring);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --recursive --unified --new-file --no-dereference orig/makefile src/makefile
--- orig/makefile	2023-11-10 10:15:18.000000000 +0000
+++ src/makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-# project name (generate executable with this name)
-TARGET   = gurux.dlms.client.bin
-
-CC       = gcc
-
-# compiling flags here
-CFLAGS   = -std=gnu99 -Wall -I.
-
-LINKER   = gcc -o
-
-# linking flags here
-LFLAGS   = -L../development/lib
-
-# change these to set the proper directories where each files should be
-
-SRCDIR   = src
-OBJDIR   = obj
-BINDIR   = bin
-
-SOURCES  := $(wildcard $(SRCDIR)/*.c)
-INCLUDES := $(wildcard $(SRCDIR)/*.h)
-OBJECTS  := $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)
-rm       = rm -f
-
-$(BINDIR)/$(TARGET): $(OBJECTS)
-	@$(LINKER) $@ $(LFLAGS) $(OBJECTS) -lgurux_dlms_c -lm
-	@echo "Linking complete!"
-
-$(OBJECTS): $(OBJDIR)/%.o : $(SRCDIR)/%.c
-	@$(CC) $(CFLAGS) -c $< -o $@
-	@echo "Compiled "$<" successfully!"
-
-.PHONEY: clean
-clean:
-	@$(rm) $(OBJECTS)
-	@echo "Cleanup complete!" 
-	@echo $(OBJECTS)
-
-.PHONEY: remove
-remove: clean
-	@$(rm) $(BINDIR)/$(TARGET)
-	@echo "Executable removed!"
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/project.yml src/project.yml
--- orig/project.yml	1970-01-01 00:00:00.000000000 +0000
+++ src/project.yml	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,150 @@
+---
+# This sample demonstrates running a collection of unit tests.
+
+:project:
+  :use_exceptions: FALSE
+  :use_test_preprocessor: TRUE
+  :use_auxiliary_dependencies: TRUE
+  :build_root: build
+  :release_build: FALSE
+  :test_file_prefix: test_
+  :which_ceedling: gem
+  :ceedling_version: 0.31.1
+  :default_tasks:
+    - test:all
+
+:environment:
+  - :path:
+      - "#{ENV['PATH']}"
+  - :gcov_prefix_strip: 100
+  - :gcov_prefix: "/tmp/gcov/"
+  - :gcov_run: 1
+
+:extension:
+  :executable: .out
+
+:paths:
+  :libraries: []
+  :test:
+    - +:test/**
+    - -:test/support
+  :support:
+    - test/support
+  :source:
+    - src/**
+  :include:
+    - test/include
+    - "#{ENV['STAGING_DIR']}/usr/include/"
+    - "#{ENV['STAGING_DIR']}/usr/include/libubox/*"
+    - "#{ENV['TOOLCHAIN_DIR']}/include/"
+
+:tools:
+  :gcov_compiler:
+    :executable: "#{ENV['CC']}"
+    :name: "OpenWRT gcc"
+    :arguments:
+      - -I"$": COLLECTION_PATHS_TEST_SUPPORT_SOURCE_INCLUDE_VENDOR
+      - -I"$": COLLECTION_PATHS_TEST_TOOLCHAIN_INCLUDE
+      - "#{ENV['CFLAGS']}"
+      - "#{ENV['CPPFLAGS']}"
+      - "#{ENV['LDFLAGS']}"
+      - -DTEST
+      - --coverage
+      - -lpthread
+      - -luci
+      - -ltlt_uci
+      - -lsqlite3
+      - -lubus
+      - -lubox
+      - -lubus
+      - -c
+      - -Werror=incompatible-pointer-types
+      - -O0 -ggdb3 # for debugging
+      - -o ${2}
+      - ${1}
+  :gcov_linker:
+    :executable: "#{ENV['CC']}"
+    :name: "OpenWRT gcc linker"
+    :arguments:
+      - -I"$": COLLECTION_PATHS_TEST_SUPPORT_SOURCE_INCLUDE_VENDOR
+      - "#{ENV['CFLAGS']}"
+      - "#{ENV['CPPFLAGS']}"
+      - "#{ENV['LDFLAGS']}"
+      - -DTEST
+      - -lpthread
+      - -luci
+      - -ltlt_uci
+      - -lsqlite3
+      - -lubus
+      - -lubox
+      - -O0 -ggdb3 # for debugging
+      - --coverage
+      - -o ${2}
+      - ${1}
+  :gcov_fixture:
+    :executable: "#{ENV['TOPDIR']}/scripts/tests_upload_and_run.sh"
+    :name: "Test uploader and runner script"
+    :arguments:
+      - "#{ENV['TARGET_IP']}"
+      - "#{ENV['TARGET_PORT']}"
+      - "${1}"
+  :gcov_report:
+    :executable: "#{ENV['GCOV']}"
+    :name: "gcov report"
+    :arguments:
+      - -n
+      - -p
+      - -b
+      - -o "$": GCOV_BUILD_OUTPUT_PATH
+      - ${1}
+  :gcov_gcovr_post_report:
+    :executable: "gcovr"
+    :name: "gcovr post report"
+    :arguments:
+      - --exclude-throw-branches
+      - --exclude-unreachable-branches
+      - ${1}
+
+:cmock:
+  :mock_prefix: mock_
+  :when_no_prototypes: :error
+  # :when_ptr: :compare_ptr
+  :enforce_strict_ordering: TRUE
+  :plugins:
+    - :array
+    - :callback
+    - :expect_any_args
+    - :ignore
+    - :ignore_arg
+    # - :ignore_stateless
+    - :return_thru_ptr
+  :treat_as:
+    int8: INT8
+    uint8: HEX8
+    uint16: HEX16
+    uint32: UINT32
+    bool: UINT8
+  :treat_externs: :include
+  :treat_inlines: :exclude
+
+:plugins:
+  :load_paths:
+    - "#{Ceedling.load_path}"
+  :enabled:
+    - stdout_pretty_tests_report
+    - module_generator
+    - gcov
+
+# Add -gcov to the plugins list to make sure of the gcov plugin
+# You will need to have gcov and gcovr both installed to make it work.
+# For more information on these options, see docs in plugins/gcov
+:gcov:
+  :utilities:
+    - gcovr # Use gcovr to create the specified reports (default).
+  :html_report: true
+  :html_report_type: detailed
+  :reports:
+    - HtmlDetailed
+  :gcovr:
+    :html_artifact_filename: coverage_report.html
+    :html_title: "REPORT"
diff --recursive --unified --new-file --no-dereference orig/src/attribute_converter.c src/src/attribute_converter.c
--- orig/src/attribute_converter.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/attribute_converter.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,2634 @@
+#include "master.h"
+
+/*
+	Original: https://github.com/Gurux/GuruxDLMS.c/blob/master/development/src/converters.c
+	Rewritten to match JSON format.
+*/
+
+PRIVATE void parse_scaler(char **json, char *value);
+
+PUBLIC void attr_init(object_attributes *attributes, gxObject *object)
+{
+	attributes->values = calloc(obj_attributeCount(object), sizeof(char *));
+	if (!attributes->values) {
+		log(L_ERROR, "Failed to initiate COSEM attribute values");
+		exit(1);
+	}
+}
+
+PUBLIC void attr_free(object_attributes *attributes)
+{
+	if (!attributes) {
+		return;
+	}
+
+	for (int i = 0; i < attributes->count; i++) {
+		free(attributes->values[i]);
+	}
+
+	free(attributes->values);
+	attributes->count = 0;
+}
+
+PUBLIC char *attr_to_json(object_attributes *attributes)
+{
+	char *json = NULL;
+	for (int i = 0; i < attributes->count && attributes->values[i]; i++) {
+		char attr_no[16] = { 0 };
+		snprintf(attr_no, sizeof(attr_no), "\"%d\": ", i + 1);
+		utl_append_to_str(&json, attr_no);
+		if (strstr(attributes->values[i], "Scaler") || strstr(attributes->values[i], "Cell ID")) {
+			parse_scaler(&json, attributes->values[i]);
+			utl_append_if_needed(&json, i, attributes->count - 1, ",");
+			continue;
+		}
+
+		utl_append_to_str(&json, "\"");
+		utl_append_to_str(&json, attributes->values[i]);
+		utl_append_to_str(&json, "\"");
+		utl_append_if_needed(&json, i, attributes->count - 1, ", ");
+	}
+
+	return json;
+}
+
+PRIVATE void parse_scaler(char **json, char *value)
+{
+	utl_append_to_str(json, "{");
+	utl_append_to_str(json, value);
+	utl_append_to_str(json, "}");
+}
+
+PRIVATE void add_obis(void *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxObject *obj = (gxObject *)object;
+
+	if (use_ln_ref) {
+		attributes->values[attributes->count++] = calloc(25, sizeof(char));
+		hlp_getLogicalNameToString(obj->logicalName, attributes->values[0]);
+	} else {
+		attributes->values[attributes->count] = calloc(10, sizeof(char));
+		snprintf(attributes->values[attributes->count++], 10, "%d", obj->shortName);
+	}
+}
+
+PRIVATE int obj_timeWindowToString(gxArray* arr, gxByteBuffer* bb)
+{
+    gxKey* it;
+    int ret = 0;
+    uint16_t pos;
+    for (pos = 0; pos != arr->size; ++pos)
+    {
+        if ((ret = arr_getByIndex(arr, pos, (void**)&it)) != 0)
+        {
+            break;
+        }
+        if (pos != 0)
+        {
+            bb_addString(bb, ", ");
+        }
+        if ((ret = time_toString((gxtime*)it->key, bb)) != 0 ||
+            (ret = bb_addString(bb, " ")) != 0 ||
+            (ret = time_toString((gxtime*)it->value, bb)) != 0)
+        {
+            break;
+        }
+    }
+    return ret;
+}
+
+PRIVATE int obj_CaptureObjectsToString(gxByteBuffer* ba, gxArray* objects)
+{
+    uint16_t pos;
+    int ret = DLMS_ERROR_CODE_OK;
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    gxTarget* it;
+#else
+    gxKey* it;
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    for (pos = 0; pos != objects->size; ++pos)
+    {
+        if ((ret = arr_getByIndex(objects, pos, (void**)&it)) != DLMS_ERROR_CODE_OK)
+        {
+            break;
+        }
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+        if ((ret = bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->target->objectType))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = hlp_appendLogicalName(ba, it->target->logicalName)) != 0)
+        {
+            break;
+        }
+#else
+        if ((ret = bb_addString(ba, obj_typeToString2(((gxObject*)it->key)->objectType))) != 0 ||
+            (ret = bb_addString(ba, " ")) != 0 ||
+            (ret = hlp_appendLogicalName(ba, ((gxObject*)it->key)->logicalName)) != 0)
+        {
+            break;
+        }
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+    }
+    return ret;
+}
+
+#ifndef DLMS_IGNORE_ACTIVITY_CALENDAR
+PRIVATE int obj_seasonProfileToString(gxArray* arr, gxByteBuffer* ba)
+{
+    gxSeasonProfile* it;
+    int ret;
+    uint16_t pos;
+    bb_addString(ba, "[");
+    for (pos = 0; pos != arr->size; ++pos)
+    {
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+        ret = arr_getByIndex(arr, pos, (void**)&it);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        bb_addString(ba, "{");
+        bb_attachString(ba, bb_toHexString(&it->name));
+        bb_addString(ba, ", ");
+        time_toString(&it->start, ba);
+        bb_addString(ba, ", ");
+        bb_attachString(ba, bb_toHexString(&it->weekName));
+        bb_addString(ba, "}");
+    }
+    bb_addString(ba, "]");
+    return 0;
+}
+
+PRIVATE int obj_weekProfileToString(gxArray* arr, gxByteBuffer* ba)
+{
+    gxWeekProfile* it;
+    int ret;
+    uint16_t pos;
+    bb_addString(ba, "[");
+    for (pos = 0; pos != arr->size; ++pos)
+    {
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+        ret = arr_getByIndex(arr, pos, (void**)&it);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        bb_attachString(ba, bb_toString(&it->name));
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->monday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->tuesday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->wednesday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->thursday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->friday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->saturday);
+        bb_addString(ba, " ");
+        bb_addIntAsString(ba, it->sunday);
+    }
+    bb_addString(ba, "]");
+    return 0;
+}
+
+PRIVATE int obj_dayProfileToString(gxArray *arr, gxByteBuffer *ba)
+{
+	gxDayProfile *dp = NULL;
+	gxDayProfileAction *it = NULL;
+	int ret;
+	uint16_t pos, pos2;
+	bb_addString(ba, "[");
+
+	for (pos = 0; pos != arr->size; ++pos) {
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+		ret = arr_getByIndex(arr, pos, (void **)&dp);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		bb_addIntAsString(ba, dp->dayId);
+		bb_addString(ba, "[");
+		for (pos2 = 0; pos2 != dp->daySchedules.size; ++pos2) {
+			if (pos2 != 0) {
+				bb_addString(ba, ", ");
+			}
+
+			ret = arr_getByIndex(&dp->daySchedules, pos2, (void **)&it);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				return ret;
+			}
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+		if (!it || !it->script) {
+			hlp_appendLogicalName(ba, EMPTY_LN);
+		} else {
+			hlp_appendLogicalName(ba, it->script->logicalName);
+		}
+#else
+	    	hlp_appendLogicalName(ba, it->scriptLogicalName);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->scriptSelector);
+		bb_addString(ba, " ");
+		time_toString(&it->startTime, ba);
+		}
+	bb_addString(ba, "]");
+    }
+    bb_addString(ba, "]");
+    return 0;
+}
+#endif //DLMS_IGNORE_ACTIVITY_CALENDAR
+
+PRIVATE int obj_objectsToString(gxByteBuffer* ba, objectArray* objects)
+{
+    uint16_t pos;
+    int ret = DLMS_ERROR_CODE_OK;
+    gxObject* it;
+    for (pos = 0; pos != objects->size; ++pos)
+    {
+        ret = oa_getByIndex(objects, pos, &it);
+        if (ret != DLMS_ERROR_CODE_OK)
+        {
+            return ret;
+        }
+        if (pos != 0)
+        {
+            bb_addString(ba, ", ");
+        }
+        bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->objectType));
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+        assert(ret == 0);
+#endif
+        bb_addString(ba, " ");
+        hlp_appendLogicalName(ba, it->logicalName);
+        }
+    return ret;
+}
+
+PRIVATE int obj_getIPAddress(gxByteBuffer* ba, gxArray* arr)
+{
+    char tmp[64];
+    int ret;
+    uint16_t pos;
+    IN6_ADDR* ip;
+    if ((ret = bb_addString(ba, "{")) == 0)
+    {
+        for (pos = 0; pos != arr->size; ++pos)
+        {
+            if ((ret = arr_getByIndex(arr, pos, (void**)&ip)) != 0)
+            {
+                break;
+            }
+            if (pos != 0)
+            {
+                bb_addString(ba, ", ");
+            }
+            //Add Ws2_32.lib for LabWindows/CVI.
+            inet_ntop(AF_INET6, &ip, tmp, sizeof(tmp));
+            bb_addString(ba, tmp);
+        }
+        if (ret == 0)
+        {
+            ret = bb_addString(ba, "}");
+        }
+    }
+    return ret;
+}
+
+#ifndef DLMS_IGNORE_REGISTER_MONITOR
+PRIVATE void actionItemToString(gxActionItem* item, gxByteBuffer* ba)
+{
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+    if (item->script == NULL)
+    {
+        hlp_appendLogicalName(ba, EMPTY_LN);
+    }
+    else
+    {
+        hlp_appendLogicalName(ba, item->script->base.logicalName);
+    }
+#else
+    hlp_appendLogicalName(ba, item->logicalName);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, item->scriptSelector);
+}
+
+#endif
+
+PRIVATE int obj_getNeighborDiscoverySetupAsString(gxByteBuffer* ba, gxArray* arr)
+{
+    int ret;
+    uint16_t pos;
+    gxNeighborDiscoverySetup* it;
+    if ((ret = bb_addString(ba, "{")) == 0)
+    {
+        for (pos = 0; pos != arr->size; ++pos)
+        {
+            if ((ret = arr_getByIndex(arr, pos, (void**)&it)) != 0)
+            {
+                break;
+            }
+            if (pos != 0)
+            {
+                bb_addString(ba, ", ");
+            }
+            if ((ret = bb_addString(ba, "[")) != 0 ||
+                (ret = bb_addIntAsString(ba, it->maxRetry)) != 0 ||
+                (ret = bb_addString(ba, ", ")) != 0 ||
+                (ret = bb_addIntAsString(ba, it->retryWaitTime)) != 0 ||
+                (ret = bb_addString(ba, ", ")) != 0 ||
+                (ret = bb_addIntAsString(ba, it->sendPeriod)) != 0 ||
+                (ret = bb_addString(ba, "]")) != 0)
+            {
+                break;
+            }
+        }
+        if (ret == 0)
+        {
+            ret = bb_addString(ba, "}");
+        }
+    }
+    return ret;
+}
+
+#ifndef DLMS_IGNORE_DATA
+PUBLIC int attr_DataToString(gxData *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	ret					= var_toString(&object->value, &ba);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_DATA
+
+#ifndef DLMS_IGNORE_REGISTER
+PUBLIC int attr_RegisterToString(gxRegister *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	ret					= var_toString(&object->value, &ba);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	// TODO: probably needs better formatting
+	bb_addString(&ba, "\"Scaler\": \"");
+	bb_addDoubleAsString(&ba, hlp_getScaler(object->scaler));
+	bb_addString(&ba, "\", \"Unit\": \"");
+	bb_addString(&ba, obj_getUnitAsString(object->unit));
+	bb_addString(&ba, "\"");
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_REGISTER
+#ifndef DLMS_IGNORE_CLOCK
+PUBLIC int attr_clockToString(gxClock *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	ret = time_toString(&object->time, &ba);
+	if (ret != 0) {
+		return ret;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->timeZone);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->status);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = time_toString(&object->begin, &ba);
+	if (ret != 0) {
+		return ret;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = time_toString(&object->end, &ba);
+	if (ret != 0) {
+		return ret;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->deviation);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->enabled);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->clockBase);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_CLOCK
+#ifndef DLMS_IGNORE_SCRIPT_TABLE
+PUBLIC int attr_ScriptTableToString(gxScriptTable *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos, pos2;
+	gxByteBuffer ba;
+	gxScript *s;
+	gxScriptAction *sa;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->scripts.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		ret = arr_getByIndex(&object->scripts, pos, (void **)&s);
+		if (ret != 0) {
+			return ret;
+		}
+		bb_addIntAsString(&ba, s->id);
+		// bb_addString(&ba, "\n");
+		for (pos2 = 0; pos2 != s->actions.size; ++pos2) {
+			ret = arr_getByIndex(&s->actions, pos2, (void **)&sa);
+			if (ret != 0) {
+				return ret;
+			}
+			if (pos2 != 0) {
+				bb_addString(&ba, ", ");
+			}
+			bb_addIntAsString(&ba, sa->type);
+			bb_addString(&ba, " ");
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+			if (sa->target == NULL) {
+				bb_addIntAsString(&ba, 0);
+				bb_addString(&ba, " ");
+				hlp_appendLogicalName(&ba, EMPTY_LN);
+			} else {
+				bb_addIntAsString(&ba, sa->target->objectType);
+				bb_addString(&ba, " ");
+				hlp_appendLogicalName(&ba, sa->target->logicalName);
+			}
+#else
+			bb_addIntAsString(&ba, sa->objectType);
+			bb_addString(&ba, " ");
+			hlp_appendLogicalName(&ba, sa->logicalName);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+
+			bb_addString(&ba, " ");
+			bb_addIntAsString(&ba, sa->index);
+			bb_addString(&ba, " ");
+			ret = var_toString(&sa->parameter, &ba);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+	}
+	// bb_addString(&ba, "]\n");
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_SCRIPT_TABLE
+#ifndef DLMS_IGNORE_SPECIAL_DAYS_TABLE
+PUBLIC int attr_specialDaysTableToString(gxSpecialDaysTable *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos;
+	gxSpecialDay *sd;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->entries.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		ret = arr_getByIndex(&object->entries, pos, (void **)&sd);
+		if (ret != 0) {
+			return ret;
+		}
+		bb_addIntAsString(&ba, sd->index);
+		bb_addString(&ba, " ");
+		ret = time_toString(&sd->date, &ba);
+		if (ret != 0) {
+			return ret;
+		}
+		bb_addString(&ba, " ");
+		bb_addIntAsString(&ba, sd->dayId);
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_SPECIAL_DAYS_TABLE
+#ifndef DLMS_IGNORE_TCP_UDP_SETUP
+PUBLIC int attr_TcpUdpSetupToString(gxTcpUdpSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->port);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+	bb_addLogicalName(&ba, obj_getLogicalName((gxObject *)object->ipSetup));
+#else
+	bb_addLogicalName(&ba, object->ipReference);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->maximumSegmentSize);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->maximumSimultaneousConnections);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->inactivityTimeout);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_TCP_UDP_SETUP
+
+PUBLIC int attr_timeWindowToString(gxArray *arr, gxByteBuffer *bb)
+{
+	gxKey *it;
+	int ret = 0;
+	uint16_t pos;
+	for (pos = 0; pos != arr->size; ++pos) {
+		if ((ret = arr_getByIndex(arr, pos, (void **)&it)) != 0) {
+			break;
+		}
+		if (pos != 0) {
+			bb_addString(bb, ", ");
+		}
+		if ((ret = time_toString((gxtime *)it->key, bb)) != 0 || (ret = bb_addString(bb, " ")) != 0 ||
+		    (ret = time_toString((gxtime *)it->value, bb)) != 0) {
+			break;
+		}
+	}
+	return ret;
+}
+
+PUBLIC int attr_CaptureObjectsToString(gxByteBuffer *ba, gxArray *objects)
+{
+	uint16_t pos;
+	int ret = DLMS_ERROR_CODE_OK;
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	gxTarget *it;
+#else
+	gxKey *it;
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	for (pos = 0; pos != objects->size; ++pos) {
+		if ((ret = arr_getByIndex(objects, pos, (void **)&it)) != DLMS_ERROR_CODE_OK) {
+			break;
+		}
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+		if ((ret = bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->target->objectType))) !=
+			    0 ||
+		    (ret = bb_addString(ba, " ")) != 0 ||
+		    (ret = hlp_appendLogicalName(ba, it->target->logicalName)) != 0) {
+			break;
+		}
+#else
+		if ((ret = bb_addString(ba, obj_typeToString2(((gxObject *)it->key)->objectType))) != 0 ||
+		    (ret = bb_addString(ba, " ")) != 0 ||
+		    (ret = hlp_appendLogicalName(ba, ((gxObject *)it->key)->logicalName)) != 0) {
+			break;
+		}
+#endif //#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	}
+	return ret;
+}
+
+#ifndef DLMS_IGNORE_PUSH_SETUP
+PUBLIC int attr_pushSetupToString(gxPushSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+
+	if ((ret = BYTE_BUFFER_INIT(&ba)) != 0) {
+		goto end;
+	}
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if ((ret = obj_CaptureObjectsToString(&ba, &object->pushObjectList)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	// čia parsint reik list'ą.
+	printf("%s\n", attributes->values[1]);
+	bb_empty(&ba);
+
+	if ((ret = bb_set(&ba, object->destination.data, object->destination.size)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, " ")) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addIntAsString(&ba, object->message)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_timeWindowToString(&object->communicationWindow, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->randomisationStartInterval)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->numberOfRetries)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->repetitionDelay)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_PUSH_SETUP
+#ifndef DLMS_IGNORE_AUTO_CONNECT
+PUBLIC int attr_autoConnectToString(gxAutoConnect *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxKey *k;
+	int ret;
+	uint16_t pos;
+	gxByteBuffer ba, *dest;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->mode);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->repetitions);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->repetitionDelay);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->callingWindow.size; ++pos) {
+		// bb_addString(&ba, "\"");
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		ret = arr_getByIndex(&object->callingWindow, pos, (void **)&k);
+		if (ret != 0) {
+			return ret;
+		}
+		time_toString((gxtime *)k->key, &ba);
+		bb_addString(&ba, " ");
+		time_toString((gxtime *)k->value, &ba);
+		// bb_addString(&ba, "\"");
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	for (pos = 0; pos != object->destinations.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		ret = arr_getByIndex(&object->destinations, pos, (void **)&dest);
+		if (ret != 0) {
+			return ret;
+		}
+		bb_set2(&ba, dest, 0, bb_size(dest));
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_AUTO_CONNECT
+#ifndef DLMS_IGNORE_ACTIVITY_CALENDAR
+PUBLIC int attr_seasonProfileToString(gxArray *arr, gxByteBuffer *ba)
+{
+	gxSeasonProfile *it;
+	int ret;
+	uint16_t pos;
+	bb_addString(ba, "[");
+	for (pos = 0; pos != arr->size; ++pos) {
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+		ret = arr_getByIndex(arr, pos, (void **)&it);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		bb_addString(ba, "{");
+		bb_attachString(ba, bb_toHexString(&it->name));
+		bb_addString(ba, ", ");
+		time_toString(&it->start, ba);
+		bb_addString(ba, ", ");
+		bb_attachString(ba, bb_toHexString(&it->weekName));
+		bb_addString(ba, "}");
+	}
+	bb_addString(ba, "]");
+	return 0;
+}
+PUBLIC int attr_weekProfileToString(gxArray *arr, gxByteBuffer *ba)
+{
+	gxWeekProfile *it;
+	int ret;
+	uint16_t pos;
+	bb_addString(ba, "[");
+	for (pos = 0; pos != arr->size; ++pos) {
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+		ret = arr_getByIndex(arr, pos, (void **)&it);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		bb_attachString(ba, bb_toString(&it->name));
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->monday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->tuesday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->wednesday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->thursday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->friday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->saturday);
+		bb_addString(ba, " ");
+		bb_addIntAsString(ba, it->sunday);
+	}
+	bb_addString(ba, "]");
+	return 0;
+}
+
+PUBLIC int attr_dayProfileToString(gxArray *arr, gxByteBuffer *ba)
+{
+	gxDayProfile *dp;
+	gxDayProfileAction *it;
+	int ret;
+	uint16_t pos, pos2;
+	bb_addString(ba, "[");
+	for (pos = 0; pos != arr->size; ++pos) {
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+		ret = arr_getByIndex(arr, pos, (void **)&dp);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		bb_addIntAsString(ba, dp->dayId);
+		bb_addString(ba, "[");
+		for (pos2 = 0; pos2 != dp->daySchedules.size; ++pos2) {
+			if (pos2 != 0) {
+				bb_addString(ba, ", ");
+			}
+			ret = arr_getByIndex(&dp->daySchedules, pos2, (void **)&it);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				return ret;
+			}
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+			if (it->script == NULL) {
+				hlp_appendLogicalName(ba, EMPTY_LN);
+			} else {
+				hlp_appendLogicalName(ba, it->script->logicalName);
+			}
+#else
+			hlp_appendLogicalName(ba, it->scriptLogicalName);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+			bb_addString(ba, " ");
+			bb_addIntAsString(ba, it->scriptSelector);
+			bb_addString(ba, " ");
+			time_toString(&it->startTime, ba);
+		}
+		bb_addString(ba, "]");
+	}
+	bb_addString(ba, "]");
+	return 0;
+}
+
+PUBLIC int attr_activityCalendarToString(gxActivityCalendar *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba = { 0 };
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if ((ret = bb_attachString(&ba, bb_toString(&object->calendarNameActive))) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_seasonProfileToString(&object->seasonProfileActive, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_weekProfileToString(&object->weekProfileTableActive, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_dayProfileToString(&object->dayProfileTableActive, &ba)) != 0) {
+		goto end;
+	}
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_attachString(&ba, bb_toString(&object->calendarNamePassive))) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_seasonProfileToString(&object->seasonProfilePassive, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_weekProfileToString(&object->weekProfileTablePassive, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = obj_dayProfileToString(&object->dayProfileTablePassive, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = time_toString(&object->time, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_ACTIVITY_CALENDAR
+
+#ifndef DLMS_IGNORE_SECURITY_SETUP
+PUBLIC int attr_securitySetupToString(gxSecuritySetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->securityPolicy);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->securitySuite);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toHexString(&object->serverSystemTitle));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toHexString(&object->clientSystemTitle));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_SECURITY_SETUP
+
+#ifndef DLMS_IGNORE_IEC_HDLC_SETUP
+PUBLIC int attr_hdlcSetupToString(gxIecHdlcSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->communicationSpeed);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->windowSizeTransmit);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->windowSizeReceive);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->maximumInfoLengthTransmit);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->maximumInfoLengthReceive);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->interCharachterTimeout);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->inactivityTimeout);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->deviceAddress);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+
+	return 0;
+}
+#endif //DLMS_IGNORE_IEC_HDLC_SETUP
+
+#ifndef DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+PUBLIC int attr_localPortSetupToString(gxLocalPortSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->defaultMode);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->defaultBaudrate);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->proposedBaudrate);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->responseTime);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toString(&object->deviceAddress));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toString(&object->password1));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toString(&object->password2));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toString(&object->password5));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+
+#ifndef DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+PUBLIC int attr_IecTwistedPairSetupToString(gxIecTwistedPairSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret = 0;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if ((ret = bb_addIntAsString(&ba, object->mode)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, (int)object->speed)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (long unsigned pos = 0; pos != object->primaryAddresses.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		if ((ret = bb_addIntAsString(&ba, object->primaryAddresses.data[pos])) != 0) {
+			break;
+		}
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (long unsigned pos = 0; pos != object->tabis.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		if ((ret = bb_addIntAsString(&ba, object->tabis.data[pos])) != 0) {
+			break;
+		}
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+
+#ifndef DLMS_IGNORE_DEMAND_REGISTER
+PUBLIC int attr_demandRegisterToString(gxDemandRegister *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if ((ret = var_toString(&object->currentAverageValue, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = var_toString(&object->lastAverageValue, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	// TODO: probably needs better formatting
+	bb_addString(&ba, "\"Scaler\": \"");
+	bb_addDoubleAsString(&ba, hlp_getScaler(object->scaler));
+	bb_addString(&ba, "\", \"Unit\": \"");
+	bb_addString(&ba, obj_getUnitAsString(object->unit));
+	bb_addString(&ba, "\"");
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = var_toString(&object->status, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = time_toString(&object->captureTime, &ba)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->period)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->numberOfPeriods)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_DEMAND_REGISTER
+
+#ifndef DLMS_IGNORE_REGISTER_ACTIVATION
+PUBLIC int attr_registerActivationToString(gxRegisterActivation *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret = 0;
+	uint16_t pos;
+#ifdef DLMS_IGNORE_OBJECT_POINTERS
+	gxObjectDefinition *od;
+	gxKey *it;
+#else
+	gxObject *od;
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	gxRegisterActivationMask *it;
+#else
+	gxKey *it;
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->registerAssignment.size; ++pos) {
+#if !defined(DLMS_IGNORE_OBJECT_POINTERS) && !defined(DLMS_IGNORE_MALLOC) &&                                 \
+	!defined(DLMS_COSEM_EXACT_DATA_TYPES)
+		ret = oa_getByIndex(&object->registerAssignment, pos, &od);
+#else
+		ret = arr_getByIndex(&object->registerAssignment, pos, (void **)&od);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+		if (ret != 0) {
+			break;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		if ((ret = bb_addIntAsString(&ba, od->objectType)) != 0 ||
+		    (ret = bb_addString(&ba, " ")) != 0 ||
+		    (ret = hlp_appendLogicalName(&ba, od->logicalName)) != 0) {
+			break;
+		}
+	}
+	if (ret == 0) {
+		bb_addString(&ba, "]");
+		attributes->values[attributes->count++] = bb_toString(&ba);
+		bb_empty(&ba);
+
+		if ((ret = bb_addString(&ba, "[")) == 0) {
+			for (pos = 0; pos != object->maskList.size; ++pos) {
+				ret = arr_getByIndex(&object->maskList, pos, (void **)&it);
+				if (ret != 0) {
+					break;
+				}
+				if (pos != 0) {
+					bb_addString(&ba, ", ");
+				}
+#if !defined(DLMS_IGNORE_OBJECT_POINTERS) && !defined(DLMS_IGNORE_MALLOC) &&                                 \
+	!defined(DLMS_COSEM_EXACT_DATA_TYPES)
+				bb_attachString(&ba, bb_toString((gxByteBuffer *)it->key));
+				bb_addString(&ba, " ");
+				bb_attachString(&ba, bb_toString((gxByteBuffer *)it->value));
+#else
+				if ((ret = bb_attachString(&ba, bb_toHexString(&it->name))) != 0 ||
+				    (ret = bb_addString(&ba, ": ")) != 0 ||
+				    (ret = bb_attachString(&ba, bb_toHexString(&it->indexes))) != 0) {
+					break;
+				}
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+			}
+			bb_addString(&ba, "]");
+			attributes->values[attributes->count++] = bb_toString(&ba);
+		}
+	}
+
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_REGISTER_ACTIVATION
+
+#ifndef DLMS_IGNORE_REGISTER_MONITOR
+PUBLIC int attr_registerMonitorToString(gxRegisterMonitor *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos;
+	dlmsVARIANT *tmp;
+	gxByteBuffer ba;
+	gxActionSet *as;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->thresholds.size; ++pos) {
+		ret = va_getByIndex(&object->thresholds, pos, &tmp);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		ret = var_toString(tmp, &ba);
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+		if (ret != 0) {
+			return DLMS_ERROR_CODE_INVALID_RESPONSE;
+		}
+#endif
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+	if (object->monitoredValue.target == NULL) {
+		hlp_appendLogicalName(&ba, EMPTY_LN);
+		bb_addString(&ba, " ");
+		bb_addString(&ba, obj_typeToString2(0));
+	} else {
+		hlp_appendLogicalName(&ba, object->monitoredValue.target->logicalName);
+		bb_addString(&ba, " ");
+		bb_addString(&ba, obj_typeToString2(object->monitoredValue.target->objectType));
+	}
+#else
+	hlp_appendLogicalName(&ba, object->monitoredValue.logicalName);
+	bb_addString(&ba, " ");
+	bb_addString(&ba, obj_typeToString2(object->monitoredValue.objectType));
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+	bb_addString(&ba, " ");
+	bb_addIntAsString(&ba, object->monitoredValue.attributeIndex);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->actions.size; ++pos) {
+		ret = arr_getByIndex(&object->actions, pos, (void **)&as);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		actionItemToString(&as->actionUp, &ba);
+		bb_addString(&ba, " ");
+		actionItemToString(&as->actionDown, &ba);
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_REGISTER_MONITOR
+
+#ifndef DLMS_IGNORE_ACTION_SCHEDULE
+PUBLIC int attr_actionScheduleToString(gxActionSchedule *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos;
+	gxtime *tm;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+	if (object->executedScript == NULL) {
+		hlp_appendLogicalName(&ba, EMPTY_LN);
+	} else {
+		hlp_appendLogicalName(&ba, object->executedScript->base.logicalName);
+	}
+#else
+	hlp_appendLogicalName(&ba, object->executedScriptLogicalName);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+
+	bb_addString(&ba, " ");
+	bb_addIntAsString(&ba, object->executedScriptSelector);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->type);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->executionTime.size; ++pos) {
+		ret = arr_getByIndex(&object->executionTime, pos, (void **)&tm);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			goto end;
+		} else {
+			if (pos != 0) {
+				bb_addString(&ba, ", ");
+			}
+			ret = time_toString(tm, &ba);
+			if (ret != 0) {
+				goto end;
+			}
+		}
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return DLMS_ERROR_CODE_OK;
+}
+#endif //DLMS_IGNORE_ACTION_SCHEDULE
+
+#ifndef DLMS_IGNORE_SAP_ASSIGNMENT
+PUBLIC int attr_sapAssignmentToString(gxSapAssignment *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos;
+	gxSapItem *it;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->sapAssignmentList.size; ++pos) {
+		ret = arr_getByIndex(&object->sapAssignmentList, pos, (void **)&it);
+		if (ret != 0) {
+			return ret;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_addIntAsString(&ba, it->id);
+		bb_addString(&ba, ": ");
+		bb_set2(&ba, &it->name, 0, bb_size(&it->name));
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_SAP_ASSIGNMENT
+
+#ifndef DLMS_IGNORE_AUTO_ANSWER
+PUBLIC int attr_autoAnswerToString(gxAutoAnswer *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if ((ret = bb_addIntAsString(&ba, object->mode)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addString(&ba, "[")) != 0) {
+		goto end;
+	}
+
+	if ((ret = obj_timeWindowToString(&object->listeningWindow, &ba)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, "]")) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->status)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->numberOfCalls)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->numberOfRingsInListeningWindow)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, " ")) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addIntAsString(&ba, object->numberOfRingsOutListeningWindow)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_AUTO_ANSWER
+
+#ifndef DLMS_IGNORE_IP4_SETUP
+PUBLIC int attr_ip4SetupToString(gxIp4Setup *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	uint16_t pos;
+#if !defined(DLMS_IGNORE_OBJECT_POINTERS) && !defined(DLMS_IGNORE_MALLOC) &&                                 \
+	!defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	dlmsVARIANT *tmp;
+#else
+	uint32_t *tmp;
+#endif
+	gxip4SetupIpOption *ip;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+	if (object->dataLinkLayer != NULL) {
+		char ln[12] = { 0 };
+		hlp_getLogicalNameToString(object->dataLinkLayer->logicalName, ln);
+		bb_addString(&ba, ln);
+		free(object->dataLinkLayer);
+	}
+#else
+	bb_addLogicalName(&ba, object->dataLinkLayerReference);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->ipAddress);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->multicastIPAddress.size; ++pos) {
+#if !defined(DLMS_IGNORE_OBJECT_POINTERS) && !defined(DLMS_IGNORE_MALLOC) &&                                 \
+	!defined(DLMS_COSEM_EXACT_DATA_TYPES)
+		ret = va_getByIndex(&object->multicastIPAddress, pos, &tmp);
+#else
+		ret = arr_getByIndex2(&object->multicastIPAddress, pos, (void **)&tmp, sizeof(uint32_t));
+#endif
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+		ret = bb_addIntAsString(&ba, *tmp);
+#else
+		ret = var_toString(tmp, &ba);
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+		if (ret != 0) {
+			goto end;
+		}
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->ipOptions.size; ++pos) {
+		ret = arr_getByIndex(&object->ipOptions, pos, (void **)&ip);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_addIntAsString(&ba, ip->type);
+		bb_addString(&ba, " ");
+		bb_attachString(&ba, bb_toString(&ip->data));
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->subnetMask);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->gatewayIPAddress);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->useDHCP);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->primaryDNSAddress);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->secondaryDNSAddress);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	// var_toString(&object->value, &ba);
+	// attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_IP4_SETUP
+
+#ifndef DLMS_IGNORE_IP6_SETUP
+PUBLIC int attr_getIPAddress(gxByteBuffer *ba, gxArray *arr)
+{
+	char tmp[64];
+	int ret;
+	uint16_t pos;
+	IN6_ADDR *ip;
+	if ((ret = bb_addString(ba, "{")) == 0) {
+		for (pos = 0; pos != arr->size; ++pos) {
+			if ((ret = arr_getByIndex(arr, pos, (void **)&ip)) != 0) {
+				break;
+			}
+			if (pos != 0) {
+				bb_addString(ba, ", ");
+			}
+			//Add Ws2_32.lib for LabWindows/CVI.
+			inet_ntop(AF_INET6, &ip, tmp, sizeof(tmp));
+			bb_addString(ba, tmp);
+		}
+		if (ret == 0) {
+			ret = bb_addString(ba, "}");
+		}
+	}
+	return ret;
+}
+
+PUBLIC int attr_getNeighborDiscoverySetupAsString(gxByteBuffer *ba, gxArray *arr)
+{
+	int ret;
+	uint16_t pos;
+	gxNeighborDiscoverySetup *it;
+	if ((ret = bb_addString(ba, "{")) == 0) {
+		for (pos = 0; pos != arr->size; ++pos) {
+			if ((ret = arr_getByIndex(arr, pos, (void **)&it)) != 0) {
+				break;
+			}
+			if (pos != 0) {
+				bb_addString(ba, ", ");
+			}
+			if ((ret = bb_addString(ba, "[")) != 0 ||
+			    (ret = bb_addIntAsString(ba, it->maxRetry)) != 0 ||
+			    (ret = bb_addString(ba, ", ")) != 0 ||
+			    (ret = bb_addIntAsString(ba, it->retryWaitTime)) != 0 ||
+			    (ret = bb_addString(ba, ", ")) != 0 ||
+			    (ret = bb_addIntAsString(ba, it->sendPeriod)) != 0 ||
+			    (ret = bb_addString(ba, "]")) != 0) {
+				break;
+			}
+		}
+		if (ret == 0) {
+			ret = bb_addString(ba, "}");
+		}
+	}
+	return ret;
+}
+
+PUBLIC int attr_ip6SetupToString(gxIp6Setup *object, object_attributes *attributes, int use_ln_ref)
+{
+	char tmp[64];
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+	if (object->dataLinkLayer != NULL) {
+		char ln[12] = { 0 };
+		hlp_getLogicalNameToString(object->dataLinkLayer->logicalName, ln);
+		bb_addString(&ba, ln);
+		free(object->dataLinkLayer);
+	}
+#else
+	bb_addLogicalName(&ba, object->dataLinkLayerReference);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addIntAsString(&ba, object->addressConfigMode)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addString(&ba, "[")) != 0) {
+		goto end;
+	}
+
+	if ((ret = obj_getIPAddress(&ba, &object->unicastIPAddress)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, "]")) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addString(&ba, "[")) != 0) {
+		goto end;
+	}
+
+	if ((ret = obj_getIPAddress(&ba, &object->multicastIPAddress)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, "]")) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if ((ret = bb_addString(&ba, "[")) != 0) {
+		goto end;
+	}
+
+	if ((ret = obj_getIPAddress(&ba, &object->gatewayIPAddress)) != 0) {
+		goto end;
+	}
+
+	if ((ret = bb_addString(&ba, "]")) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	inet_ntop(AF_INET6, &object->primaryDNSAddress, tmp, sizeof(tmp));
+	bb_addString(&ba, tmp);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+	inet_ntop(AF_INET6, &object->secondaryDNSAddress, tmp, sizeof(tmp));
+	bb_addString(&ba, tmp);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+	if ((ret = bb_addIntAsString(&ba, object->trafficClass)) != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = obj_getNeighborDiscoverySetupAsString(&ba, &object->neighborDiscoverySetup);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_IP6_SETUP
+
+#ifndef DLMS_IGNORE_UTILITY_TABLES
+PUBLIC int attr_UtilityTablesToString(gxUtilityTables *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->tableId);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, bb_size(&object->buffer));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, bb_toHexString(&object->buffer));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_UTILITY_TABLES
+
+#ifndef DLMS_IGNORE_IMAGE_TRANSFER
+PUBLIC int attr_imageTransferToString(gxImageTransfer *object, object_attributes *attributes, int use_ln_ref)
+{
+	uint16_t pos;
+	int ret;
+	gxImageActivateInfo *it;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->imageBlockSize);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_attachString(&ba, ba_toString(&object->imageTransferredBlocksStatus));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->imageFirstNotTransferredBlockNumber);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->imageTransferEnabled);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->imageTransferStatus);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->imageActivateInfo.size; ++pos) {
+		ret = arr_getByIndex(&object->imageActivateInfo, pos, (void **)&it);
+		if (ret != 0) {
+			return ret;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_addIntAsString(&ba, it->size);
+		bb_addString(&ba, " ");
+		bb_attachString(&ba, bb_toHexString(&it->identification));
+		bb_addString(&ba, " ");
+		bb_attachString(&ba, bb_toHexString(&it->signature));
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_IMAGE_TRANSFER
+#ifndef DLMS_IGNORE_DISCONNECT_CONTROL
+PUBLIC int attr_disconnectControlToString(gxDisconnectControl *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->outputState);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->controlState);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->controlMode);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_DISCONNECT_CONTROL
+#ifndef DLMS_IGNORE_LIMITER
+PUBLIC int attr_limiterToString(gxLimiter *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	if (object->monitoredValue != NULL) {
+		hlp_appendLogicalName(&ba, object->monitoredValue->logicalName);
+		bb_addString(&ba, ": ");
+		bb_addIntAsString(&ba, object->selectedAttributeIndex);
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = var_toString(&object->thresholdActive, &ba);
+	if (ret != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = var_toString(&object->thresholdNormal, &ba);
+	if (ret != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = var_toString(&object->thresholdEmergency, &ba);
+	if (ret != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->minOverThresholdDuration);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->minUnderThresholdDuration);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->emergencyProfile.id);
+	bb_addString(&ba, " ");
+	time_toString(&object->emergencyProfile.activationTime, &ba);
+	bb_addString(&ba, " ");
+	bb_addIntAsString(&ba, object->emergencyProfile.duration);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	if ((ret = obj_UInt16ArrayToString(&ba, &object->emergencyProfileGroupIDs)) != 0) {
+		goto end;
+	}
+#else
+	if ((ret = va_toString(&object->emergencyProfileGroupIDs, &ba)) != 0) {
+		goto end;
+	}
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->emergencyProfileActive);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	actionItemToString(&object->actionOverThreshold, &ba);
+	bb_addString(&ba, " ");
+	actionItemToString(&object->actionUnderThreshold, &ba);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_LIMITER
+
+#ifndef DLMS_IGNORE_MODEM_CONFIGURATION
+PUBLIC int attr_modemConfigurationToString(gxModemConfiguration *object, object_attributes *attributes, int use_ln_ref)
+{
+	uint16_t pos;
+	int ret;
+	gxModemInitialisation *mi;
+	gxByteBuffer ba, *it;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addIntAsString(&ba, object->communicationSpeed);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->initialisationStrings.size; ++pos) {
+		ret = arr_getByIndex(&object->initialisationStrings, pos, (void **)&mi);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_attachString(&ba, bb_toString(&mi->request));
+		bb_addString(&ba, " ");
+		bb_attachString(&ba, bb_toString(&mi->response));
+		bb_addString(&ba, " ");
+		bb_addIntAsString(&ba, mi->delay);
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->modemProfile.size; ++pos) {
+		ret = arr_getByIndex(&object->modemProfile, pos, (void **)&it);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_attachString(&ba, bb_toString(it));
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_MODEM_CONFIGURATION
+char *parse_mac_address(char *str);
+#ifndef DLMS_IGNORE_MAC_ADDRESS_SETUP
+PUBLIC int attr_macAddressSetupToString(gxMacAddressSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba = { 0 };
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_attachString(&ba, bb_toHexString(&object->macAddress));
+	attributes->values[attributes->count++] = parse_mac_address(bb_toString(&ba));
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_MAC_ADDRESS_SETUP
+
+char *parse_mac_address(char *str)
+{
+	int i = 0;
+	while(str[i]) {
+		if (str[i] == ' ') {
+			str[i] = ':';
+		}
+		i++;
+	}
+
+	return str;
+}
+
+#ifndef DLMS_IGNORE_GPRS_SETUP
+PRIVATE void qualityOfServiceToString(gxQualityOfService* target, gxByteBuffer* ba)
+{
+    bb_addIntAsString(ba, target->precedence);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, target->delay);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, target->reliability);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, target->peakThroughput);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, target->meanThroughput);
+    bb_addString(ba, " ");
+}
+
+PUBLIC int attr_GPRSSetupToString(gxGPRSSetup *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_attachString(&ba, bb_toString(&object->apn));
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->pinCode);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	qualityOfServiceToString(&object->defaultQualityOfService, &ba);
+	bb_addString(&ba, ", ");
+	qualityOfServiceToString(&object->requestedQualityOfService, &ba);
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_GPRS_SETUP
+
+#ifndef DLMS_IGNORE_EXTENDED_REGISTER
+PUBLIC int attr_extendedRegisterToString(gxExtendedRegister *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	ret = var_toString(&object->value, &ba);
+	if (ret != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	// TODO: probably needs better formatting
+	bb_addString(&ba, "\"Scaler\": \"");
+	bb_addIntAsString(&ba, object->scaler);
+	bb_addString(&ba, "\", \"Unit\": \"");
+	bb_addString(&ba, obj_getUnitAsString(object->unit));
+	bb_addString(&ba, "\"");
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	ret = var_toString(&object->status, &ba);
+	if (ret != 0) {
+		goto end;
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	time_toString(&object->captureTime, &ba);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_EXTENDED_REGISTER
+
+PUBLIC int attr_objectsToString(gxByteBuffer *ba, objectArray *objects)
+{
+	uint16_t pos;
+	int ret = DLMS_ERROR_CODE_OK;
+	gxObject *it;
+	for (pos = 0; pos != objects->size; ++pos) {
+		ret = oa_getByIndex(objects, pos, &it);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		if (pos != 0) {
+			bb_addString(ba, ", ");
+		}
+		bb_addString(ba, obj_typeToString2((DLMS_OBJECT_TYPE)it->objectType));
+#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)
+		if (ret != 0) {
+			return DLMS_ERROR_CODE_INVALID_RESPONSE;
+		}
+#endif
+		bb_addString(ba, " ");
+		hlp_appendLogicalName(ba, it->logicalName);
+	}
+	return ret;
+}
+
+PUBLIC int attr_rowsToString(gxByteBuffer *ba, gxArray *buffer)
+{
+	dlmsVARIANT *tmp;
+	variantArray *va;
+	int ret;
+	uint16_t r, c;
+	for (r = 0; r != buffer->size; ++r) {
+		ret = arr_getByIndex(buffer, r, (void **)&va);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			return ret;
+		}
+		for (c = 0; c != va->size; ++c) {
+			if (c != 0) {
+				bb_addString(ba, ",");
+			}
+			ret = va_getByIndex(va, c, &tmp);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				return ret;
+			}
+			ret = var_toString(tmp, ba);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				return ret;
+			}
+		}
+		bb_addString(ba, ";");
+	}
+	return 0;
+}
+
+#ifndef DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+PRIVATE void obj_applicationContextNameToString(gxByteBuffer* ba, gxApplicationContextName* object)
+{
+    hlp_appendLogicalName(ba, object->logicalName);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->jointIsoCtt);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->country);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->countryName);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->identifiedOrganization);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->dlmsUA);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->applicationContext);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->contextId);
+}
+
+PRIVATE void obj_xDLMSContextTypeToString(gxByteBuffer* ba, gxXDLMSContextType* object)
+{
+    bb_addIntAsString(ba, object->conformance);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->maxReceivePduSize);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->maxSendPduSize);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->qualityOfService);
+    bb_addString(ba, " ");
+    bb_attachString(ba, bb_toString(&object->cypheringInfo));
+}
+
+PRIVATE void obj_authenticationMechanismNameToString(gxByteBuffer* ba, gxAuthenticationMechanismName* object)
+{
+    bb_addIntAsString(ba, object->jointIsoCtt);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->country);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->countryName);
+    bb_addIntAsString(ba, object->identifiedOrganization);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->dlmsUA);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->authenticationMechanismName);
+    bb_addString(ba, " ");
+    bb_addIntAsString(ba, object->mechanismId);
+}
+
+PUBLIC int attr_associationLogicalNameToString(gxAssociationLogicalName *object, object_attributes *attributes, int use_ln_ref)
+{
+	uint16_t pos;
+	int ret = 0;
+	gxKey2 *it;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&ba, "[");
+	obj_objectsToString(&ba, &object->objectList);
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->clientSAP);
+	bb_addString(&ba, "/");
+	bb_addIntAsString(&ba, object->serverSAP);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	obj_applicationContextNameToString(&ba, &object->applicationContextName);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	obj_xDLMSContextTypeToString(&ba, &object->xDLMSContextInfo);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	obj_authenticationMechanismNameToString(&ba, &object->authenticationMechanismName);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+
+	if (object->secret.data) {
+		bb_attachString(&ba, bb_toString(&object->secret));
+	} else {
+		char* buff = calloc(12 + 1, sizeof(char));
+		strlcpy(buff, "Access error", 13);
+		bb_attachString(&ba, buff);
+	}
+
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->associationStatus);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	//Security Setup Reference is from version 1.
+	if (object->base.version > 0) {
+		// bb_addString(&ba, "\nIndex: 9 Value: ");
+#ifndef DLMS_IGNORE_SECURITY_SETUP
+#ifndef DLMS_IGNORE_OBJECT_POINTERS
+		bb_addLogicalName(&ba, obj_getLogicalName((gxObject *)object->securitySetup));
+#else
+		bb_addLogicalName(&ba, object->securitySetupReference);
+#endif //DLMS_IGNORE_OBJECT_POINTERS
+		attributes->values[attributes->count++] = bb_toString(&ba);
+		bb_empty(&ba);
+
+#endif //DLMS_IGNORE_SECURITY_SETUP
+	}
+	if (object->base.version > 1) {
+		bb_addString(&ba, "[");
+		for (pos = 0; pos != object->userList.size; ++pos) {
+			if ((ret = arr_getByIndex(&object->userList, pos, (void **)&it)) != 0) {
+				goto end;
+			}
+			bb_addString(&ba, "ID: ");
+			bb_addIntAsString(&ba, it->key);
+			bb_addString(&ba, " Name: ");
+			bb_addString(&ba, (char *)it->value);
+		}
+		bb_addString(&ba, "]");
+		attributes->values[attributes->count++] = bb_toString(&ba);
+	}
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+
+#ifndef DLMS_IGNORE_PROFILE_GENERIC
+PUBLIC int attr_ProfileGenericToString(gxProfileGeneric *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret;
+	gxByteBuffer ba;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_empty(&ba);
+	bb_addString(&ba, "[");
+	attr_rowsToString(&ba, &object->buffer);
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	obj_CaptureObjectsToString(&ba, &object->captureObjects);
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->capturePeriod);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->sortMethod);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	if (object->sortObject != NULL) {
+		ret = hlp_appendLogicalName(&ba, object->sortObject->logicalName);
+		if (ret != 0) {
+			goto end;
+		}
+	}
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->entriesInUse);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->profileEntries);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_PROFILE_GENERIC
+
+#ifndef DLMS_IGNORE_GSM_DIAGNOSTIC
+PUBLIC int attr_GsmDiagnosticToString(gxGsmDiagnostic *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret = 0;
+	uint16_t pos;
+	gxAdjacentCell *it;
+	gxByteBuffer ba = { 0 };
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+#if defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	bb_set(&ba, object->operatorName.data, object->operatorName.size);
+#else
+	bb_addString(&ba, object->operatorName);
+#endif //defined(DLMS_IGNORE_MALLOC) || defined(DLMS_COSEM_EXACT_DATA_TYPES)
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->status);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->circuitSwitchStatus);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->packetSwitchStatus);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "\"Cell ID\": \"");
+	bb_addIntAsString(&ba, object->cellInfo.cellId);
+	bb_addString(&ba, "\", \"Location ID\": \"");
+	bb_addIntAsString(&ba, object->cellInfo.locationId);
+	bb_addString(&ba, "\", \"Signal Quality\": \"");
+	bb_addIntAsString(&ba, object->cellInfo.signalQuality);
+	bb_addString(&ba, "\", \"BER\": \"");
+	bb_addIntAsString(&ba, object->cellInfo.ber);
+	bb_addString(&ba, "\"");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addString(&ba, "[");
+	for (pos = 0; pos != object->adjacentCells.size; ++pos) {
+		ret = arr_getByIndex(&object->adjacentCells, pos, (void **)&it);
+		if (ret != 0) {
+			goto end;
+		}
+		if (pos != 0) {
+			bb_addString(&ba, ", ");
+		}
+		bb_addIntAsString(&ba, it->cellId);
+		bb_addString(&ba, ":");
+		bb_addIntAsString(&ba, it->signalQuality);
+	}
+	bb_addString(&ba, "]");
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	time_toString(&object->captureTime, &ba);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+end:
+	bb_clear(&ba);
+	return ret;
+}
+#endif //DLMS_IGNORE_GSM_DIAGNOSTIC
+
+#ifndef DLMS_IGNORE_COMPACT_DATA
+PUBLIC int attr_CompactDataToString(gxCompactData *object, object_attributes *attributes, int use_ln_ref)
+{
+	gxByteBuffer ba;
+	char *tmp;
+	BYTE_BUFFER_INIT(&ba);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	tmp = bb_toHexString(&object->buffer);
+	bb_addString(&ba, tmp);
+	free(tmp);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	obj_CaptureObjectsToString(&ba, &object->captureObjects);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->templateId);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	tmp = bb_toHexString(&object->templateDescription);
+	bb_addString(&ba, tmp);
+	free(tmp);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+	bb_empty(&ba);
+
+	bb_addIntAsString(&ba, object->captureMethod);
+	attributes->values[attributes->count++] = bb_toString(&ba);
+
+	bb_clear(&ba);
+	return 0;
+}
+#endif //DLMS_IGNORE_COMPACT_DATA
+
+#ifndef DLMS_IGNORE_ARBITRATOR
+PUBLIC int attr_ArbitratorToString(gxArbitrator *object, object_attributes *attributes, int use_ln_ref)
+{
+	uint16_t pos;
+	int ret = 0;
+	gxByteBuffer bb;
+	gxActionItem *it;
+	bitArray *ba;
+	BYTE_BUFFER_INIT(&bb);
+
+	add_obis(object, attributes, use_ln_ref);
+
+	bb_addString(&bb, "{");
+	for (pos = 0; pos != object->actions.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&bb, ", ");
+		}
+		if ((ret = arr_getByIndex(&object->actions, pos, (void **)&it)) != 0) {
+			break;
+		}
+		bb_addString(&bb, "[");
+		hlp_appendLogicalName(&bb, it->script->base.logicalName);
+		bb_addString(&bb, ", ");
+		bb_addIntAsString(&bb, it->scriptSelector);
+		bb_addString(&bb, "]");
+	}
+	bb_addString(&bb, "}");
+	attributes->values[attributes->count++] = bb_toString(&bb);
+	bb_empty(&bb);
+
+	bb_addString(&bb, "{");
+	for (pos = 0; pos != object->permissionsTable.size; ++pos) {
+		if (pos != 0) {
+			bb_addString(&bb, ", ");
+		}
+		if ((ret = arr_getByIndex(&object->permissionsTable, pos, (void **)&ba)) != 0 ||
+		    (ret = ba_toString2(&bb, ba)) != 0) {
+			break;
+		}
+	}
+	ret					= bb_addString(&bb, "}");
+	attributes->values[attributes->count++] = bb_toString(&bb);
+
+	bb_clear(&bb);
+	return 0;
+}
+#endif //DLMS_IGNORE_ARBITRATOR
+
+PUBLIC int attr_to_string(gxObject *object, object_attributes *attributes, int use_ln_ref)
+{
+	int ret = 1;
+	switch (object->objectType) {
+#ifndef DLMS_IGNORE_DATA
+	case DLMS_OBJECT_TYPE_DATA:
+		ret = attr_DataToString((gxData *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_DATA
+#ifndef DLMS_IGNORE_REGISTER
+	case DLMS_OBJECT_TYPE_REGISTER:
+		ret = attr_RegisterToString((gxRegister *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_REGISTER
+#ifndef DLMS_IGNORE_CLOCK
+	case DLMS_OBJECT_TYPE_CLOCK:
+		ret = attr_clockToString((gxClock *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_CLOCK
+#ifndef DLMS_IGNORE_ACTION_SCHEDULE
+	case DLMS_OBJECT_TYPE_ACTION_SCHEDULE:
+		ret = attr_actionScheduleToString((gxActionSchedule *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_ACTION_SCHEDULE
+#ifndef DLMS_IGNORE_ACTIVITY_CALENDAR
+	case DLMS_OBJECT_TYPE_ACTIVITY_CALENDAR:
+		ret = attr_activityCalendarToString((gxActivityCalendar *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_ACTIVITY_CALENDAR
+#ifndef DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+	case DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME:
+		ret = attr_associationLogicalNameToString((gxAssociationLogicalName *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_ASSOCIATION_LOGICAL_NAME
+#ifndef DLMS_IGNORE_AUTO_ANSWER
+	case DLMS_OBJECT_TYPE_AUTO_ANSWER:
+		ret = attr_autoAnswerToString((gxAutoAnswer *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_AUTO_ANSWER
+#ifndef DLMS_IGNORE_AUTO_CONNECT
+	case DLMS_OBJECT_TYPE_AUTO_CONNECT:
+		ret = attr_autoConnectToString((gxAutoConnect *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_AUTO_CONNECT
+#ifndef DLMS_IGNORE_DEMAND_REGISTER
+	case DLMS_OBJECT_TYPE_DEMAND_REGISTER:
+		ret = attr_demandRegisterToString((gxDemandRegister *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_DEMAND_REGISTER
+#ifndef DLMS_IGNORE_MAC_ADDRESS_SETUP
+	case DLMS_OBJECT_TYPE_MAC_ADDRESS_SETUP:
+		ret = attr_macAddressSetupToString((gxMacAddressSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_MAC_ADDRESS_SETUP
+#ifndef DLMS_IGNORE_EXTENDED_REGISTER
+	case DLMS_OBJECT_TYPE_EXTENDED_REGISTER:
+		ret = attr_extendedRegisterToString((gxExtendedRegister *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_EXTENDED_REGISTER
+#ifndef DLMS_IGNORE_GPRS_SETUP
+	case DLMS_OBJECT_TYPE_GPRS_SETUP:
+		ret = attr_GPRSSetupToString((gxGPRSSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_GPRS_SETUP
+#ifndef DLMS_IGNORE_SECURITY_SETUP
+	case DLMS_OBJECT_TYPE_SECURITY_SETUP:
+		ret = attr_securitySetupToString((gxSecuritySetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_SECURITY_SETUP
+#ifndef DLMS_IGNORE_IEC_HDLC_SETUP
+	case DLMS_OBJECT_TYPE_IEC_HDLC_SETUP:
+		ret = attr_hdlcSetupToString((gxIecHdlcSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IEC_HDLC_SETUP
+#ifndef DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+	case DLMS_OBJECT_TYPE_IEC_LOCAL_PORT_SETUP:
+		ret = attr_localPortSetupToString((gxLocalPortSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IEC_LOCAL_PORT_SETUP
+#ifndef DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+	case DLMS_OBJECT_TYPE_IEC_TWISTED_PAIR_SETUP:
+		ret = attr_IecTwistedPairSetupToString((gxIecTwistedPairSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IEC_TWISTED_PAIR_SETUP
+#ifndef DLMS_IGNORE_IP4_SETUP
+	case DLMS_OBJECT_TYPE_IP4_SETUP:
+		ret = attr_ip4SetupToString((gxIp4Setup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IP4_SETUP
+#ifndef DLMS_IGNORE_IP6_SETUP
+	case DLMS_OBJECT_TYPE_IP6_SETUP:
+		ret = attr_ip6SetupToString((gxIp6Setup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IP4_SETUP
+#ifndef DLMS_IGNORE_IMAGE_TRANSFER
+	case DLMS_OBJECT_TYPE_IMAGE_TRANSFER:
+		ret = attr_imageTransferToString((gxImageTransfer *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_IMAGE_TRANSFER
+#ifndef DLMS_IGNORE_DISCONNECT_CONTROL
+	case DLMS_OBJECT_TYPE_DISCONNECT_CONTROL:
+		ret = attr_disconnectControlToString((gxDisconnectControl *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_DISCONNECT_CONTROL
+#ifndef DLMS_IGNORE_LIMITER
+	case DLMS_OBJECT_TYPE_LIMITER:
+		ret = attr_limiterToString((gxLimiter *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_LIMITER
+#ifndef DLMS_IGNORE_MODEM_CONFIGURATION
+	case DLMS_OBJECT_TYPE_MODEM_CONFIGURATION:
+		ret = attr_modemConfigurationToString((gxModemConfiguration *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_MODEM_CONFIGURATION
+#ifndef DLMS_IGNORE_PROFILE_GENERIC
+	case DLMS_OBJECT_TYPE_PROFILE_GENERIC:
+		ret = attr_ProfileGenericToString((gxProfileGeneric *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_PROFILE_GENERIC
+#ifndef DLMS_IGNORE_REGISTER_ACTIVATION
+	case DLMS_OBJECT_TYPE_REGISTER_ACTIVATION:
+		ret = attr_registerActivationToString((gxRegisterActivation *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_REGISTER_ACTIVATION
+#ifndef DLMS_IGNORE_REGISTER_MONITOR
+	case DLMS_OBJECT_TYPE_REGISTER_MONITOR:
+		ret = attr_registerMonitorToString((gxRegisterMonitor *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_REGISTER_MONITOR
+#ifndef DLMS_IGNORE_SAP_ASSIGNMENT
+	case DLMS_OBJECT_TYPE_SAP_ASSIGNMENT:
+		ret = attr_sapAssignmentToString((gxSapAssignment *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_SAP_ASSIGNMENT
+#ifndef DLMS_IGNORE_SCRIPT_TABLE
+	case DLMS_OBJECT_TYPE_SCRIPT_TABLE:
+		ret = attr_ScriptTableToString((gxScriptTable *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_SCRIPT_TABLE
+#ifndef DLMS_IGNORE_SPECIAL_DAYS_TABLE
+	case DLMS_OBJECT_TYPE_SPECIAL_DAYS_TABLE:
+		ret = attr_specialDaysTableToString((gxSpecialDaysTable *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_SPECIAL_DAYS_TABLE
+#ifndef DLMS_IGNORE_TCP_UDP_SETUP
+	case DLMS_OBJECT_TYPE_TCP_UDP_SETUP:
+		ret = attr_TcpUdpSetupToString((gxTcpUdpSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_TCP_UDP_SETUP
+#ifndef DLMS_IGNORE_UTILITY_TABLES
+	case DLMS_OBJECT_TYPE_UTILITY_TABLES:
+		ret = attr_UtilityTablesToString((gxUtilityTables *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_UTILITY_TABLES
+#ifndef DLMS_IGNORE_PUSH_SETUP
+	case DLMS_OBJECT_TYPE_PUSH_SETUP:
+		ret = attr_pushSetupToString((gxPushSetup *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_PUSH_SETUP
+#ifndef DLMS_IGNORE_GSM_DIAGNOSTIC
+	case DLMS_OBJECT_TYPE_GSM_DIAGNOSTIC:
+		ret = attr_GsmDiagnosticToString((gxGsmDiagnostic *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_GSM_DIAGNOSTIC
+#ifndef DLMS_IGNORE_COMPACT_DATA
+	case DLMS_OBJECT_TYPE_COMPACT_DATA:
+		ret = attr_CompactDataToString((gxCompactData *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_COMPACT_DATA
+#ifndef DLMS_IGNORE_ARBITRATOR
+	case DLMS_OBJECT_TYPE_ARBITRATOR:
+		ret = attr_ArbitratorToString((gxArbitrator *)object, attributes, use_ln_ref);
+		break;
+#endif //DLMS_IGNORE_ARBITRATOR
+	default: //Unknown type.
+		ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+	}
+	return ret;
+}
diff --recursive --unified --new-file --no-dereference orig/src/communication.c src/src/communication.c
--- orig/src/communication.c	2023-11-10 10:15:18.000000000 +0000
+++ src/src/communication.c	2024-01-10 07:48:57.000000000 +0000
@@ -1,1179 +1,951 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-#include <ws2tcpip.h>
-#include <Windows.h> //Add support for serial port functions.
-#else
-#define INVALID_HANDLE_VALUE -1
-#include <unistd.h>
-#include <stdlib.h>
-#include <errno.h> //Add support for sockets
+#include "master.h"
+
+/*
+	Original: https://github.com/Gurux/GuruxDLMS.c/blob/master/GuruxDLMSClientExample/src/communication.c
+	Adjusted to our needs
+*/
+
 #include <netdb.h> //Add support for sockets
-#include <sys/types.h> //Add support for sockets
-#include <sys/socket.h> //Add support for sockets
-#include <netinet/in.h> //Add support for sockets
-#include <arpa/inet.h> //Add support for sockets
-#include <termios.h>
 #include <sys/ioctl.h>
-#include <sys/stat.h>
 #include <fcntl.h>
-#endif
-
-#include "../include/communication.h"
-#include "../../development/include/gxkey.h"
-#include "../../development/include/converters.h"
-#include "../../development/include/cosem.h"
-#include "../../development/include/gxserializer.h"
-
-//Returns current time.
-//If you are not using operating system you have to implement this by yourself.
-//Reason for this is that all compilers's or HWs don't support time at all.
-void time_now(gxtime* value)
-{
-    time_initUnix(value, (unsigned long)time(NULL));
-}
-
-//Check is IP address IPv6 or IPv4 address.
-unsigned char com_isIPv6Address(const char* pAddress)
-{
-    return strstr(pAddress, ":") != NULL;
-}
-
-//Make connection using TCP/IP connection.
-int com_makeConnect(connection* connection, const char* address, int port, int waitTime)
-{
-    int ret;
-    //create socket.
-    int family = com_isIPv6Address(address) ? AF_INET6 : AF_INET;
-    connection->socket = socket(family, SOCK_STREAM, IPPROTO_IP);
-    if (connection->socket == -1)
-    {
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-        int err = WSAGetLastError();
-        printf("Socket creation failed: %d\r\n", err);
-#else
-        int err = errno;
-        printf("Socket creation failed: %d, %s\r\n", err, strerror(err));
-#endif
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-
-    struct sockaddr* add;
-    int addSize;
-    struct sockaddr_in6 addrIP6;
-    struct sockaddr_in addIP4;
-    if (family == AF_INET)
-    {
-        addIP4.sin_port = htons(port);
-        addIP4.sin_family = AF_INET;
-        addIP4.sin_addr.s_addr = inet_addr(address);
-        addSize = sizeof(struct sockaddr_in);
-        add = (struct sockaddr*)&addIP4;
-        //If address is give as name
-        if (addIP4.sin_addr.s_addr == INADDR_NONE)
-        {
-            struct hostent* Hostent = gethostbyname(address);
-            if (Hostent == NULL)
-            {
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-                ret = WSAGetLastError();
-                closesocket(connection->socket);
-#else
-                ret = errno;
-                close(connection->socket);
-#endif
-                connection->socket = -1;
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-            };
-            addIP4.sin_addr = *(struct in_addr*)(void*)Hostent->h_addr_list[0];
-        };
-    }
-    else
-    {
-        memset(&addrIP6, 0, sizeof(struct sockaddr_in6));
-        addrIP6.sin6_port = htons(port);
-        addrIP6.sin6_family = AF_INET6;
-        ret = inet_pton(family, address, &(addrIP6.sin6_addr));
-        if (ret == -1)
-        {
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-            ret = WSAGetLastError();
-            closesocket(connection->socket);
-#else
-            ret = errno;
-            close(connection->socket);
-#endif
-            connection->socket = -1;
-            return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-        };
-        add = (struct sockaddr*)&addrIP6;
-        addSize = sizeof(struct sockaddr_in6);
-    }
-
-    //Set timeout.
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-    setsockopt(connection->socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&waitTime, sizeof(waitTime));
-#else
-    struct timeval tv;
-    tv.tv_sec = waitTime / 1000;
-    tv.tv_usec = 0;
-    setsockopt(connection->socket, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv));
-#endif //
-    //Connect to the meter.
-    ret = connect(connection->socket, add, addSize);
-    if (ret == -1)
-    {
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-        ret = WSAGetLastError();
-        closesocket(connection->socket);
-        printf("Connection failed: %d\n", ret);
-#else
-        ret = errno;
-        close(connection->socket);
-        printf("Connection failed: %d, %s\n", ret, strerror(ret));
-#endif
-        connection->socket = -1;
-        return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    };
-    return DLMS_ERROR_CODE_OK;
-}
-
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-int com_setCommState(HANDLE hWnd, LPDCB DCB)
-{
-    if (!SetCommState(hWnd, DCB))
-    {
-        DWORD err = GetLastError(); //Save occured error.
-        if (err == 995)
-        {
-            COMSTAT comstat;
-            unsigned long RecieveErrors;
-            if (!ClearCommError(hWnd, &RecieveErrors, &comstat))
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | GetLastError();
-            }
-            if (!SetCommState(hWnd, DCB))
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | GetLastError();
-            }
-        }
-        else
-        {
-            //If USB to serial port converters do not implement this.
-            if (err != ERROR_INVALID_FUNCTION)
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | err;
-            }
-        }
-    }
-    return DLMS_ERROR_CODE_OK;
-}
-#endif
-
-int com_readSerialPort(
-    connection* connection,
-    unsigned char eop)
-{
-    //Read reply data.
-    int ret, cnt = 1, pos;
-    unsigned char eopFound = 0;
-    int lastReadIndex = 0;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-    unsigned long RecieveErrors;
-    COMSTAT comstat;
-    DWORD bytesRead = 0;
-#else
-    unsigned short bytesRead = 0;
-    unsigned short readTime = 0;
-#endif
-    do
-    {
-#if defined(_WIN32) || defined(_WIN64)//Windows
-        //We do not want to read byte at the time.
-        if (!ClearCommError(connection->comPort, &RecieveErrors, &comstat))
-        {
-            ret = GetLastError();
-            return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-        }
-        bytesRead = 0;
-        cnt = 1;
-        //Try to read at least one byte.
-        if (comstat.cbInQue > 0)
-        {
-            cnt = comstat.cbInQue;
-        }
-        if (!ReadFile(connection->comPort, connection->data.data + connection->data.size, cnt, &bytesRead, &connection->osReader))
-        {
-            ret = GetLastError();
-            if (ret != ERROR_IO_PENDING)
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-            }
-            //Wait until data is actually read
-            if (WaitForSingleObject(connection->osReader.hEvent, connection->waitTime) != WAIT_OBJECT_0)
-            {
-                return DLMS_ERROR_CODE_RECEIVE_FAILED;
-            }
-            if (!GetOverlappedResult(connection->comPort, &connection->osReader, &bytesRead, TRUE))
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | GetLastError();
-            }
-        }
-#else
-        //Get bytes available.
-        ret = ioctl(connection->comPort, FIONREAD, &cnt);
-        //If driver is not supporting this functionality.
-        if (ret < 0)
-        {
-            cnt = RECEIVE_BUFFER_SIZE;
-        }
-        else if (cnt == 0)
-        {
-            //Try to read at least one byte.
-            cnt = 1;
-        }
-        //If there is more data than can fit to buffer.
-        if (cnt > RECEIVE_BUFFER_SIZE)
-        {
-            cnt = RECEIVE_BUFFER_SIZE;
-        }
-        bytesRead = read(connection->comPort, connection->data.data + connection->data.size, cnt);
-        if (bytesRead == 0xFFFF)
-        {
-            //If there is no data on the read buffer.
-            if (errno == EAGAIN)
-            {
-                if (readTime > connection->waitTime)
-                {
-                    return DLMS_ERROR_CODE_RECEIVE_FAILED;
-                }
-                readTime += 100;
-                bytesRead = 0;
-            }
-            else
-            {
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | errno;
-            }
-        }
-#endif
-        connection->data.size += (unsigned short)bytesRead;
-        //Note! Some USB converters can return true for ReadFile and Zero as bytesRead.
-        //In that case wait for a while and read again.
-        if (bytesRead == 0)
-        {
-#if defined(_WIN32) || defined(_WIN64)//Windows
-            Sleep(100);
-#else
-            usleep(100000);
-#endif
-            continue;
-        }
-        //Search eop.
-        if (connection->data.size > 5)
-        {
-            //Some optical strobes can return extra bytes.
-            for (pos = connection->data.size - 1; pos != lastReadIndex; --pos)
-            {
-                if (connection->data.data[pos] == eop)
-                {
-                    eopFound = 1;
-                    break;
-                }
-            }
-            lastReadIndex = pos;
-        }
-    } while (eopFound == 0);
-    return DLMS_ERROR_CODE_OK;
-}
-
-int com_initializeOpticalHead(
-    connection* connection)
-{
-    unsigned short baudRate;
-    int ret = 0, len, pos;
-    unsigned char ch;
-    //In Linux serial port name might be very long.
-    char buff[50];
-#if defined(_WIN32) || defined(_WIN64)
-    DCB dcb = { 0 };
-    unsigned long sendSize = 0;
-    if (connection->comPort == INVALID_HANDLE_VALUE)
-    {
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-    dcb.DCBlength = sizeof(DCB);
-    if (!GetCommState(connection->comPort, &dcb))
-    {
-        ret = GetLastError();
-        return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    }
-    dcb.fBinary = 1;
-    dcb.fOutX = dcb.fInX = 0;
-    //Abort all reads and writes on Error.
-    dcb.fAbortOnError = 1;
-    if (connection->settings.interfaceType == DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E)
-    {
-        dcb.BaudRate = 300;
-        dcb.ByteSize = 7;
-        dcb.StopBits = ONESTOPBIT;
-        dcb.Parity = EVENPARITY;
-    }
-    else
-    {
-        dcb.BaudRate = 9600;
-        dcb.ByteSize = 8;
-        dcb.StopBits = ONESTOPBIT;
-        dcb.Parity = NOPARITY;
-    }
-    if ((ret = com_setCommState(connection->comPort, &dcb)) != 0)
-    {
-        return ret;
-    }
-#else
-    struct termios options;
-    memset(&options, 0, sizeof(options));
-    options.c_iflag = 0;
-    options.c_oflag = 0;
-    if (connection->settings.interfaceType == DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E)
-    {
-        options.c_cflag |= PARENB;
-        options.c_cflag &= ~PARODD;
-        options.c_cflag &= ~CSTOPB;
-        options.c_cflag &= ~CSIZE;
-        options.c_cflag |= CS7;
-        //Set Baud Rates
-        cfsetospeed(&options, B300);
-        cfsetispeed(&options, B300);
-    }
-    else
-    {
-        // 8n1, see termios.h for more information
-        options.c_cflag = CS8 | CREAD | CLOCAL;
-        /*
-        options.c_cflag &= ~PARENB
-        options.c_cflag &= ~CSTOPB
-        options.c_cflag &= ~CSIZE;
-        options.c_cflag |= CS8;
-        */
-        //Set Baud Rates
-        cfsetospeed(&options, B9600);
-        cfsetispeed(&options, B9600);
-    }
-    options.c_lflag = 0;
-    options.c_cc[VMIN] = 1;
-    //How long we are waiting reply charachter from serial port.
-    options.c_cc[VTIME] = 5;
-
-    //hardware flow control is used as default.
-    //options.c_cflag |= CRTSCTS;
-    if (tcsetattr(connection->comPort, TCSAFLUSH, &options) != 0)
-    {
-        printf("Failed to Open port. tcsetattr failed.\r");
-        return DLMS_ERROR_CODE_INVALID_PARAMETER;
-    }
-#endif
-    if (connection->settings.interfaceType == DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E)
-    {
-#if _MSC_VER > 1000
-        strcpy_s(buff, 50, "/?!\r\n");
-#else
-        strcpy(buff, "/?!\r\n");
-#endif
-        len = strlen(buff);
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("\nTX:\t");
-            for (pos = 0; pos != len; ++pos)
-            {
-                printf("%.2X ", buff[pos]);
-            }
-            printf("\n");
-        }
-#if defined(_WIN32) || defined(_WIN64)
-        ret = WriteFile(connection->comPort, buff, len, &sendSize, &connection->osWrite);
-        if (ret == 0)
-        {
-            DWORD err = GetLastError();
-            //If error occurs...
-            if (err != ERROR_IO_PENDING)
-            {
-                return DLMS_ERROR_CODE_SEND_FAILED;
-            }
-            //Wait until data is actually sent
-            WaitForSingleObject(connection->osWrite.hEvent, INFINITE);
-        }
-#else //#if defined(__LINUX__)
-        ret = write(connection->comPort, buff, len);
-        if (ret != len)
-        {
-            return DLMS_ERROR_CODE_SEND_FAILED;
-        }
-#endif
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("\nRX:\t");
-        }
-        //Read reply data.
-        if (com_readSerialPort(connection, '\n') != 0)
-        {
-            return DLMS_ERROR_CODE_INVALID_PARAMETER;
-        }
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("\r\n");
-        }
-        if (bb_getUInt8(&connection->data, &ch) != 0 || ch != '/')
-        {
-            return DLMS_ERROR_CODE_SEND_FAILED;
-        }
-        //Get used baud rate.
-        if ((ret = bb_getUInt8ByIndex(&connection->data, 4, &ch)) != 0)
-        {
-            return DLMS_ERROR_CODE_SEND_FAILED;
-        }
-        switch (ch)
-        {
-        case '0':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 300;
-#else
-            baudRate = B300;
-#endif
-            break;
-        case '1':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 600;
-#else
-            baudRate = B600;
-#endif
-            break;
-        case '2':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 1200;
-#else
-            baudRate = B1200;
-#endif
-            break;
-        case '3':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 2400;
-#else
-            baudRate = B2400;
-#endif
-            break;
-        case '4':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 4800;
-#else
-            baudRate = B4800;
-#endif
-            break;
-        case '5':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 9600;
-#else
-            baudRate = B9600;
-#endif
-            break;
-        case '6':
-#if defined(_WIN32) || defined(_WIN64)
-            baudRate = 19200;
-#else
-            baudRate = B19200;
-#endif
-            break;
-        default:
-            return DLMS_ERROR_CODE_INVALID_PARAMETER;
-        }
-        //Send ACK
-        buff[0] = 0x06;
-        //Send Protocol control character
-        buff[1] = '2';// "2" HDLC protocol procedure (Mode E)
-        buff[2] = (char)ch;
-        buff[3] = '2';
-        buff[4] = (char)0x0D;
-        buff[5] = 0x0A;
-        len = 6;
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("\nTX:\t");
-            for (pos = 0; pos != len; ++pos)
-            {
-                printf("%.2X ", buff[pos]);
-            }
-            printf("\n");
-        }
-#if defined(_WIN32) || defined(_WIN64)//Windows
-        ret = WriteFile(connection->comPort, buff, len, &sendSize, &connection->osWrite);
-        if (ret == 0)
-        {
-            int err = GetLastError();
-            //If error occurs...
-            if (err != ERROR_IO_PENDING)
-            {
-                printf("WriteFile %d\r\n", err);
-                return DLMS_ERROR_CODE_SEND_FAILED;
-            }
-            //Wait until data is actually sent
-            WaitForSingleObject(connection->osWrite.hEvent, INFINITE);
-        }
-#else //#if defined(__LINUX__)
-        ret = write(connection->comPort, buff, len);
-        if (ret != len)
-        {
-            return DLMS_ERROR_CODE_SEND_FAILED;
-        }
-#endif
-#if defined(_WIN32) || defined(_WIN64)//Windows
-        //This sleep is in standard. Do not remove.
-        Sleep(1000);
-        dcb.BaudRate = baudRate;
-        if ((ret = com_setCommState(connection->comPort, &dcb)) != 0)
-        {
-            return ret;
-        }
-        printf("New baudrate %d\r\n", dcb.BaudRate);
-        len = 6;
-        if ((ret = com_readSerialPort(connection, '\n')) != 0)
-        {
-            printf("Read %d\r\n", ret);
-            return ret;
-        }
-        dcb.ByteSize = 8;
-        dcb.StopBits = ONESTOPBIT;
-        dcb.Parity = NOPARITY;
-        if ((ret = com_setCommState(connection->comPort, &dcb)) != 0)
-        {
-            return ret;
-        }
-#else
-        //This sleep is in standard. Do not remove.
-        usleep(1000000);
-        // 8n1, see termios.h for more information
-        options.c_cflag = CS8 | CREAD | CLOCAL;
-        //Set Baud Rates
-        cfsetospeed(&options, baudRate);
-        cfsetispeed(&options, baudRate);
-        if (tcsetattr(connection->comPort, TCSAFLUSH, &options) != 0)
-        {
-            printf("Failed to Open port. tcsetattr failed.\r");
-            return DLMS_ERROR_CODE_INVALID_PARAMETER;
-        }
-#endif
-    }
-    return ret;
-}
-
-int com_open(
-    connection* connection,
-    const char* port)
-{
-    int ret;
-    //In Linux serial port name might be very long.
-#if defined(_WIN32) || defined(_WIN64)
-    char buff[50];
-#if _MSC_VER > 1000
-    sprintf_s(buff, 50, "\\\\.\\%s", port);
-#else
-    sprintf(buff, "\\\\.\\%s", port);
-#endif
-    //Open serial port for read / write. Port can't share.
-    connection->comPort = CreateFileA(buff,
-        GENERIC_READ | GENERIC_WRITE, 0, NULL,
-        OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
-    if (connection->comPort == INVALID_HANDLE_VALUE)
-    {
-        ret = GetLastError();
-        printf("Failed to open serial port: \"%s\"\n", buff);
-        return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    }
-#else //#if defined(__LINUX__)
-    // read/write | not controlling term | don't wait for DCD line signal.
-    connection->comPort = open(port, O_RDWR | O_NOCTTY | O_NONBLOCK);
-    if (connection->comPort == -1) // if open is unsuccessful.
-    {
-        ret = errno;
-        printf("Failed to open serial port: %s\n", port);
-        return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    }
-    if (!isatty(connection->comPort))
-    {
-        ret = errno;
-        printf("Failed to Open port %s. This is not a serial port.\n", port);
-        return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-    }
-#endif
-    return com_initializeOpticalHead(connection);
-}
-
-int sendData(connection* connection, gxByteBuffer* data)
-{
-    int ret = 0;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-    unsigned long sendSize = 0;
-#endif
-    if (connection->comPort != INVALID_HANDLE_VALUE)
-    {
-#if defined(_WIN32) || defined(_WIN64)//Windows
-        ret = WriteFile(connection->comPort, data->data, data->size, &sendSize, &connection->osWrite);
-        if (ret == 0)
-        {
-            COMSTAT comstat;
-            unsigned long RecieveErrors;
-            DWORD err = GetLastError();
-            //If error occurs...
-            if (err != ERROR_IO_PENDING)
-            {
-                ret = GetLastError();
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-            }
-            //Wait until data is actually sent
-            ret = WaitForSingleObject(connection->osWrite.hEvent, connection->waitTime);
-            if (ret != 0)
-            {
-                ret = GetLastError();
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-            }
-            //Read bytes in output buffer. Some USB converts require this.
-            if (!ClearCommError(connection->comPort, &RecieveErrors, &comstat))
-            {
-                ret = GetLastError();
-                return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-            }
-        }
-#else
-        ret = write(connection->comPort, data->data, data->size);
-        if (ret != data->size)
-        {
-            ret = errno;
-            return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-        }
-#endif
-    }
-    else
-    {
-        if (send(connection->socket, (const char*)data->data, data->size, 0) == -1)
-        {
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-            ret = WSAGetLastError();
-#else
-            ret = errno;
-#endif
-            return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | ret;
-        }
-    }
-    return 0;
-}
-
-int readData(connection* connection, gxByteBuffer* data, int* index)
-{
-    int ret = 0;
-    if (connection->comPort != INVALID_HANDLE_VALUE)
-    {
-        if ((ret = com_readSerialPort(connection, 0x7E)) != 0)
-        {
-            return ret;
-        }
-    }
-    else
-    {
-        uint32_t cnt = connection->data.capacity - connection->data.size;
-        if (cnt < 1)
-        {
-            return DLMS_ERROR_CODE_OUTOFMEMORY;
-        }
-        if ((ret = recv(connection->socket, (char*)connection->data.data + connection->data.size, cnt, 0)) == -1)
-        {
-            return DLMS_ERROR_CODE_RECEIVE_FAILED;
-        }
-        connection->data.size += ret;
-    }
-    if (connection->trace > GX_TRACE_LEVEL_INFO)
-    {
-        char* hex = hlp_bytesToHex(connection->data.data + *index, connection->data.size - *index);
-        if (*index == 0)
-        {
-            printf("\nRX:\t %s", hex);
-        }
-        else
-        {
-            printf(" %s", hex);
-        }
-        free(hex);
-        *index = connection->data.size;
-    }
-    return 0;
-}
-
-// Read DLMS Data frame from the device.
-int readDLMSPacket(
-    connection* connection,
-    gxByteBuffer* data,
-    gxReplyData* reply)
-{
-    char* hex;
-    int index = 0, ret;
-    if (data->size == 0)
-    {
-        return DLMS_ERROR_CODE_OK;
-    }
-    reply->complete = 0;
-    connection->data.size = 0;
-    connection->data.position = 0;
-    if (connection->trace == GX_TRACE_LEVEL_VERBOSE)
-    {
-        hex = bb_toHexString(data);
-        printf("\nTX:\t%s\n", hex);
-        free(hex);
-    }
-    if ((ret = sendData(connection, data)) != 0)
-    {
-        return ret;
-    }
-    //Loop until packet is complete.
-    unsigned char pos = 0;
-    do
-    {
-        if ((ret = readData(connection, &connection->data, &index)) != 0)
-        {
-            if (ret != DLMS_ERROR_CODE_RECEIVE_FAILED || pos == 3)
-            {
-                break;
-            }
-            ++pos;
-            printf("\nData send failed. Try to resend %d/3\n", pos);
-            if ((ret = sendData(connection, data)) != 0)
-            {
-                break;
-            }
-        }
-        else
-        {
-            ret = cl_getData(&connection->settings, &connection->data, reply);
-            if (ret != 0 && ret != DLMS_ERROR_CODE_FALSE)
-            {
-                break;
-            }
-        }
-    } while (reply->complete == 0);
-    if (connection->trace == GX_TRACE_LEVEL_VERBOSE)
-    {
-        printf("\n");
-    }
-    return ret;
-}
-
-int com_readDataBlock(
-    connection* connection,
-    message* messages,
-    gxReplyData* reply)
-{
-    gxByteBuffer rr;
-    int pos, ret = DLMS_ERROR_CODE_OK;
-    //If there is no data to send.
-    if (messages->size == 0)
-    {
-        return DLMS_ERROR_CODE_OK;
-    }
-    bb_init(&rr);
-    //Send data.
-    for (pos = 0; pos != messages->size; ++pos)
-    {
-        //Send data.
-        if ((ret = readDLMSPacket(connection, messages->data[pos], reply)) != DLMS_ERROR_CODE_OK)
-        {
-            return ret;
-        }
-        //Check is there errors or more data from server
-        while (reply_isMoreData(reply))
-        {
-            if ((ret = cl_receiverReady(&connection->settings, reply->moreData, &rr)) != DLMS_ERROR_CODE_OK)
-            {
-                bb_clear(&rr);
-                return ret;
-            }
-            if ((ret = readDLMSPacket(connection, &rr, reply)) != DLMS_ERROR_CODE_OK)
-            {
-                bb_clear(&rr);
-                return ret;
-            }
-            bb_clear(&rr);
-        }
-    }
-    return ret;
-}
-
-
-//Close connection to the meter.
-int com_disconnect(
-    connection* connection)
-{
-    int ret = DLMS_ERROR_CODE_OK;
-    gxReplyData reply;
-    message msg;
-    reply_init(&reply);
-    mes_init(&msg);
-    if ((ret = cl_disconnectRequest(&connection->settings, &msg)) != 0 ||
-        (ret = com_readDataBlock(connection, &msg, &reply)) != 0)
-    {
-        //Show error but continue close.
-        printf("Close failed.");
-    }
-    reply_clear(&reply);
-    mes_clear(&msg);
-    return ret;
-}
-
-//Close connection to the meter.
-int com_close(
-    connection* connection)
-{
-    int ret = DLMS_ERROR_CODE_OK;
-    gxReplyData reply;
-    message msg;
-    //If client is closed.
-    if (!connection->settings.server)
-    {
-        reply_init(&reply);
-        mes_init(&msg);
-        if ((ret = cl_releaseRequest(&connection->settings, &msg)) != 0 ||
-            (ret = com_readDataBlock(connection, &msg, &reply)) != 0)
-        {
-            //Show error but continue close.
-            printf("Release failed.");
-        }
-        reply_clear(&reply);
-        mes_clear(&msg);
-
-        if ((ret = cl_disconnectRequest(&connection->settings, &msg)) != 0 ||
-            (ret = com_readDataBlock(connection, &msg, &reply)) != 0)
-        {
-            //Show error but continue close.
-            printf("Close failed.");
-        }
-        reply_clear(&reply);
-        mes_clear(&msg);
-    }
-    if (connection->socket != -1)
-    {
-        connection->closing = 1;
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-        closesocket(connection->socket);
-#else
-        close(connection->socket);
-#endif
-        connection->socket = -1;
-    }
-    else if (connection->comPort != INVALID_HANDLE_VALUE)
-    {
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-        CloseHandle(connection->comPort);
-        connection->comPort = INVALID_HANDLE_VALUE;
-        CloseHandle(connection->osReader.hEvent);
-        CloseHandle(connection->osWrite.hEvent);
-#else
-        close(connection->comPort);
-#endif
-        connection->comPort = INVALID_HANDLE_VALUE;
-    }
-    cl_clear(&connection->settings);
-    return ret;
-}
-
-//Read Invocation counter (frame counter) from the meter and update it.
-int com_updateInvocationCounter(
-    connection* connection,
-    const char* invocationCounter)
-{
-    int ret = DLMS_ERROR_CODE_OK;
-    //Read frame counter if GeneralProtection is used.
-    if (invocationCounter != NULL && connection->settings.cipher.security != DLMS_SECURITY_NONE)
-    {
-        message messages;
-        gxReplyData reply;
-        unsigned short add = connection->settings.clientAddress;
-        DLMS_AUTHENTICATION auth = connection->settings.authentication;
-        DLMS_SECURITY security = connection->settings.cipher.security;
-        gxByteBuffer challenge;
-        bb_init(&challenge);
-        bb_set(&challenge, connection->settings.ctoSChallenge.data, connection->settings.ctoSChallenge.size);
-        connection->settings.clientAddress = 16;
-        connection->settings.authentication = DLMS_AUTHENTICATION_NONE;
-        connection->settings.cipher.security = DLMS_SECURITY_NONE;
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("updateInvocationCounter\r\n");
-        }
-        mes_init(&messages);
-        reply_init(&reply);
-        //Get meter's send and receive buffers size.
-        if ((ret = cl_snrmRequest(&connection->settings, &messages)) != 0 ||
-            (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
-            (ret = cl_parseUAResponse(&connection->settings, &reply.data)) != 0)
-        {
-            bb_clear(&challenge);
-            mes_clear(&messages);
-            reply_clear(&reply);
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("SNRMRequest failed %s\r\n", hlp_getErrorMessage(ret));
-            }
-            return ret;
-        }
-        mes_clear(&messages);
-        reply_clear(&reply);
-        if ((ret = cl_aarqRequest(&connection->settings, &messages)) != 0 ||
-            (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
-            (ret = cl_parseAAREResponse(&connection->settings, &reply.data)) != 0)
-        {
-            bb_clear(&challenge);
-            mes_clear(&messages);
-            reply_clear(&reply);
-            if (ret == DLMS_ERROR_CODE_APPLICATION_CONTEXT_NAME_NOT_SUPPORTED)
-            {
-                if (connection->trace > GX_TRACE_LEVEL_OFF)
-                {
-                    printf("Use Logical Name referencing is wrong. Change it!\r\n");
-                }
-                return ret;
-            }
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("AARQRequest failed %s\r\n", hlp_getErrorMessage(ret));
-            }
-            return ret;
-        }
-        mes_clear(&messages);
-        reply_clear(&reply);
-        if (connection->settings.maxPduSize == 0xFFFF)
-        {
-            con_initializeBuffers(connection, connection->settings.maxPduSize);
-        }
-        else
-        {
-            //Allocate 50 bytes more because some meters count this wrong and send few bytes too many.
-            con_initializeBuffers(connection, 50 + connection->settings.maxPduSize);
-        }
-        gxData d;
-        cosem_init(BASE(d), DLMS_OBJECT_TYPE_DATA, invocationCounter);
-        if ((ret = com_read(connection, BASE(d), 2)) == 0)
-        {
-            connection->settings.cipher.invocationCounter = 1 + var_toInteger(&d.value);
-            if (connection->trace > GX_TRACE_LEVEL_WARNING)
-            {
-                printf("Invocation counter: %u (0x%lX)\r\n",
-                    connection->settings.cipher.invocationCounter,
-                    connection->settings.cipher.invocationCounter);
-            }
-            //It's OK if this fails.
-            com_disconnect(connection);
-            connection->settings.clientAddress = add;
-            connection->settings.authentication = auth;
-            connection->settings.cipher.security = security;
-            bb_clear(&connection->settings.ctoSChallenge);
-            bb_set(&connection->settings.ctoSChallenge, challenge.data, challenge.size);
-            bb_clear(&challenge);
-        }
-    }
-    return ret;
-}
-
-//Initialize connection to the meter.
-int com_initializeConnection(
-    connection* connection)
-{
-    message messages;
-    gxReplyData reply;
-    int ret = 0;
-    if (connection->trace > GX_TRACE_LEVEL_WARNING)
-    {
-        printf("InitializeConnection\r\n");
-    }
-
-    mes_init(&messages);
-    reply_init(&reply);
-    //Get meter's send and receive buffers size.
-    if ((ret = cl_snrmRequest(&connection->settings, &messages)) != 0 ||
-        (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
-        (ret = cl_parseUAResponse(&connection->settings, &reply.data)) != 0)
-    {
-        mes_clear(&messages);
-        reply_clear(&reply);
-        if (connection->trace > GX_TRACE_LEVEL_OFF)
-        {
-            printf("SNRMRequest failed %s\r\n", hlp_getErrorMessage(ret));
-        }
-        return ret;
-    }
-    mes_clear(&messages);
-    reply_clear(&reply);
-    if ((ret = cl_aarqRequest(&connection->settings, &messages)) != 0 ||
-        (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
-        (ret = cl_parseAAREResponse(&connection->settings, &reply.data)) != 0)
-    {
-        mes_clear(&messages);
-        reply_clear(&reply);
-        if (ret == DLMS_ERROR_CODE_APPLICATION_CONTEXT_NAME_NOT_SUPPORTED)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Use Logical Name referencing is wrong. Change it!\r\n");
-            }
-            return ret;
-        }
-        if (connection->trace > GX_TRACE_LEVEL_OFF)
-        {
-            printf("AARQRequest failed %s\r\n", hlp_getErrorMessage(ret));
-        }
-        return ret;
-    }
-    mes_clear(&messages);
-    reply_clear(&reply);
-    if (connection->settings.maxPduSize == 0xFFFF)
-    {
-        con_initializeBuffers(connection, connection->settings.maxPduSize);
-    }
-    else
-    {
-        //Allocate 50 bytes more because some meters count this wrong and send few bytes too many.
-        con_initializeBuffers(connection, 50 + connection->settings.maxPduSize);
-    }
+#include <sys/stat.h>
+#include <termios.h>
+#include <poll.h>
 
-    // Get challenge Is HLS authentication is used.
-    if (connection->settings.authentication > DLMS_AUTHENTICATION_LOW)
-    {
-        if ((ret = cl_getApplicationAssociationRequest(&connection->settings, &messages)) != 0 ||
-            (ret = com_readDataBlock(connection, &messages, &reply)) != 0 ||
-            (ret = cl_parseApplicationAssociationResponse(&connection->settings, &reply.data)) != 0)
-        {
-            mes_clear(&messages);
-            reply_clear(&reply);
-            return ret;
-        }
-        mes_clear(&messages);
-        reply_clear(&reply);
-    }
-    return DLMS_ERROR_CODE_OK;
-}
+#define IO_TIMEOUT	    3 // timeout in seconds for reading/writing
+#define RECEIVE_BUFFER_SIZE 200
 
-//Report error on output;
-void com_reportError(const char* description,
-    gxObject* object,
-    unsigned char attributeOrdinal, int ret)
-{
-    char ln[25];
-    hlp_getLogicalNameToString(object->logicalName, ln);
-    printf("%s %s %s:%d %s\r\n", description, obj_typeToString2(object->objectType), ln, attributeOrdinal, hlp_getErrorMessage(ret));
+PRIVATE int com_open_tcp_connection(connection *c);
+PRIVATE uint8_t com_is_IPv6_address(const char *pAddress);
+PRIVATE int com_check_if_connected_to_server(int fd);
+PRIVATE int com_open_serial_connection(physical_device *dev);
+PRIVATE int com_initialize_serial_settings(connection *c);
+
+PRIVATE int com_read_data_block(connection *c, dlmsSettings *s, message *m, gxReplyData *reply);
+PRIVATE int read_dlms_packet(connection *c, dlmsSettings *s, gxByteBuffer *data, gxReplyData *reply);
+PRIVATE int read_data(connection *c, int *index);
+PRIVATE int com_read_serial_port(connection *c, unsigned char eop);
+PRIVATE int send_data(connection *c, gxByteBuffer *data);
+PRIVATE int com_disconnect(connection *c, dlmsSettings *s);
+
+//!< challenge can be NULL if request is not ciphered.
+PRIVATE int com_handle_aarq_request(connection *c, dlmsSettings *s, message *m, gxReplyData *reply, gxByteBuffer *challenge);
+PRIVATE int com_handle_snrm_request(connection *c, dlmsSettings *s, message *m, gxReplyData *reply, gxByteBuffer *challenge);
+PRIVATE void com_handle_init_buffers(connection *c, dlmsSettings *s);
+PRIVATE void com_initialize_buffers(connection *c, int size);
+
+struct baudrate {
+	int bps;
+	uint32_t baud;
+};
+
+PRIVATE struct baudrate baudrates[] = {
+	{ 300, B300 },	       { 600, B600 },	      { 1200, B1200 },	     { 1800, B1800 },
+	{ 2400, B2400 },       { 4800, B4800 },	      { 9600, B9600 },	     { 19200, B19200 },
+	{ 38400, B38400 },     { 57600, B57600 },     { 115200, B115200 },   { 230400, B230400 },
+	{ 460800, B460800 },   { 500000, B500000 },   { 576000, B576000 },   { 921600, B921600 },
+	{ 1000000, B1000000 }, { 1152000, B1152000 }, { 1500000, B1500000 }, { 2000000, B2000000 },
+	{ 2500000, B2500000 }, { 3000000, B3000000 }, { 3500000, B3500000 }, { 4000000, B4000000 },
+};
+
+PUBLIC int com_open_connection(physical_device *dev)
+{
+	return (dev->connection->type == TCP) ? com_open_tcp_connection(dev->connection) :
+						com_open_serial_connection(dev);
+}
+
+PRIVATE int com_open_tcp_connection(connection *c)
+{
+	int ret			    = 0;
+	int addSize		    = 0;
+	int flags		    = 0;
+	struct sockaddr *add	    = NULL;
+	struct sockaddr_in6 addrIP6 = { 0 };
+	struct sockaddr_in addIP4   = { 0 };
+	char *address		    = c->parameters.tcp.host;
+	int port		    = c->parameters.tcp.port;
+	int family		    = com_is_IPv6_address(address) ? AF_INET6 : AF_INET;
+
+	c->socket  = socket(family, SOCK_STREAM, IPPROTO_IP);
+	if (c->socket == -1) {
+		log(L_ERROR, "Socket creation failed: %s\n", strerror(errno));
+		return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+	}
+
+	if (family == AF_INET) {
+		addIP4.sin_port	       = htons(port);
+		addIP4.sin_family      = AF_INET;
+		addIP4.sin_addr.s_addr = inet_addr(address);
+		addSize		       = sizeof(struct sockaddr_in);
+		add		       = (struct sockaddr *)&addIP4;
+
+		if (addIP4.sin_addr.s_addr == INADDR_NONE) {
+			struct hostent *Hostent = gethostbyname(address);
+			if (Hostent == NULL) {
+				log(L_ERROR, "Failed to get host by name: %s\n", strerror(errno));
+				return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+			};
+			addIP4.sin_addr = *(struct in_addr *)(void *)Hostent->h_addr_list[0];
+		};
+	} else {
+		addrIP6.sin6_port   = htons(port);
+		addrIP6.sin6_family = AF_INET6;
+		ret		    = inet_pton(family, address, &(addrIP6.sin6_addr));
+		if (ret == -1) {
+			log(L_ERROR, "Failed to get host by name: %s\n", strerror(errno));
+			return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+		};
+		add	= (struct sockaddr *)&addrIP6;
+		addSize = sizeof(struct sockaddr_in6);
+	}
+
+	struct timeval tv = { IO_TIMEOUT, 0 };
+	setsockopt(c->socket, SOL_SOCKET, SO_RCVTIMEO, (const char *)&tv, sizeof(tv));
+	setsockopt(c->socket, SOL_SOCKET, SO_SNDTIMEO, (const char *)&tv, sizeof(tv));
+
+	flags = fcntl(c->socket, F_GETFL, 0);
+	fcntl(c->socket, F_SETFL, O_NONBLOCK);
+	//Connect to the meter.
+	if (connect(c->socket, add, addSize) == -1) {
+		if (errno == EINPROGRESS && com_check_if_connected_to_server(c->socket)) {
+			log(L_ERROR, "Failed to connect to server: %s", strerror(errno));
+			return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+		}
+	}
+
+	fcntl(c->socket, F_SETFL, flags);
+	return DLMS_ERROR_CODE_OK;
+}
+
+PRIVATE uint8_t com_is_IPv6_address(const char *pAddress)
+{
+	return (strstr(pAddress, ":") != NULL);
+}
+
+PRIVATE int com_check_if_connected_to_server(int fd)
+{
+	struct pollfd fds[1] = { [0] = { .fd = fd, .events = POLLOUT } };
+	int tries	     = 0;
+	while (tries < 10) {
+		int rc = poll(fds, 1, 100);
+
+		if (rc < 0) {
+			log(L_ERROR,, "Poll error while trying to connect: %s\n", strerror(errno));
+			break;
+		}
+
+		if ((fds[0].revents & POLLERR) || !fds[0].revents) {
+			usleep(10000);
+			tries++;
+			continue;
+		}
+
+		if (fds[0].revents & POLLOUT) {
+			int err = -1;
+			socklen_t err_size = sizeof(int);
+			getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &err_size);
+			return err;
+		}
+	}
+
+	return 1;
+}
+
+PRIVATE int com_initialize_mode_e(connection *c)
+{
+	struct termios options = { 0 };
+	int baudrate = B9600;
+
+	bb_clear(&c->data);
+	bb_init(&c->data);
+	bb_capacity(&c->data, 500);
+
+	for (size_t i = 0; i < ARRAY_SIZE(baudrates); i++) {
+		if (c->parameters.serial.baudrate == baudrates[i].bps) {
+			baudrate = baudrates[i].baud;
+			break;
+		}
+	}
+
+	options.c_cflag |= PARENB;
+	options.c_cflag &= ~PARODD;
+	options.c_cflag &= ~CSTOPB;
+	options.c_cflag &= ~CSIZE;
+	options.c_cflag |= CS7;
+
+	cfsetospeed(&options, B300);
+	cfsetispeed(&options, B300);
+
+	options.c_lflag = 0;
+	options.c_cc[VMIN] = 1;
+	options.c_cc[VTIME] = 5;
+
+	if (tcsetattr(c->socket, TCSAFLUSH, &options) != 0) {
+		log(L_ERROR, "Failed to set termios settings");
+		return DLMS_ERROR_CODE_INVALID_PARAMETER;
+	}
+
+	char buff[16] = "/?!\r\n";
+	int len = strlen(buff);
+	if (write(c->socket, buff, len) != len) {
+		log(L_ERROR, "Failed to write initialisation message");
+		return DLMS_ERROR_CODE_SEND_FAILED;
+	}
+
+	if (com_read_serial_port(c, '\n') != 0) {
+		// this might fail if device was already initiated with /?!\r\n.
+		log(L_ERROR, "Failed to read from serial port");
+		goto err;
+	}
+
+	unsigned char ch = 0;
+	if (bb_getUInt8(&c->data, &ch) != 0 || ch != '/') {
+		return DLMS_ERROR_CODE_SEND_FAILED;
+	}
+
+	//Get used baud rate.
+	if (bb_getUInt8ByIndex(&c->data, 4, &ch) != 0) {
+		return DLMS_ERROR_CODE_SEND_FAILED;
+	}
+
+	switch (ch) {
+	case '0':
+		baudrate = B300;
+		break;
+	case '1':
+		baudrate = B600;
+		break;
+	case '2':
+		baudrate = B1200;
+		break;
+	case '3':
+		baudrate = B2400;
+		break;
+	case '4':
+		baudrate = B4800;
+		break;
+	case '5':
+		baudrate = B9600;
+		break;
+	case '6':
+		baudrate = B19200;
+		break;
+	default:
+		log(L_ERROR, "Could not parse baudrate");
+		return DLMS_ERROR_CODE_INVALID_PARAMETER;
+	}
+
+err:
+	buff[0] = 0x06;     // ACK
+	buff[1] = '2'; 	    // "2" HDLC protocol procedure (Mode E)
+	buff[2] = (char)ch; // baud rate
+	buff[3] = '2';      // binary mode
+	buff[4] = 0x0D;
+	buff[5] = 0x0A;
+	len = 6;
+
+	if (write(c->socket, buff, 6) != len) {
+		log(L_ERROR, "Failed to write acknowledgment message");
+		return DLMS_ERROR_CODE_SEND_FAILED;
+	}
+
+	usleep(1000000); // This sleep is in standard. Do not remove.
+	options.c_cflag = CS8 | CREAD | CLOCAL;
+	cfsetospeed(&options, baudrate);
+	cfsetispeed(&options, baudrate);
+
+	if (tcsetattr(c->socket, TCSAFLUSH, &options) != 0) {
+		log(L_ERROR, "Failed to set termios settings");
+		return DLMS_ERROR_CODE_INVALID_PARAMETER;
+	}
+
+	return 0;
+}
+
+PRIVATE int com_open_serial_connection(physical_device *dev)
+{
+	char *device = dev->connection->parameters.serial.device;
+	dev->connection->socket = open(device, O_RDWR | O_NOCTTY | O_NONBLOCK);
+	if (dev->connection->socket == -1) {
+		log(L_DEBUG, "Failed to open serial port: %s\n", device);
+		return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+	}
+
+	if (!isatty(dev->connection->socket)) {
+		log(L_DEBUG, "'%s' is not a serial port\n", device);
+		return DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+	}
+
+	return (dev->settings.interfaceType != DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E) ?
+		       com_initialize_serial_settings(dev->connection) :
+		       com_initialize_mode_e(dev->connection);
+}
+
+PRIVATE int com_initialize_serial_settings(connection *c)
+{
+	int ret		       = 1;
+	struct termios options = { 0 };
+	int baudrate	       = 0;
+	int databits	       = 0;
+
+	for (size_t i = 0; i < ARRAY_SIZE(baudrates); i++) {
+		if (c->parameters.serial.baudrate == baudrates[i].bps) {
+			baudrate = baudrates[i].baud;
+			break;
+		}
+	}
+
+	switch (c->parameters.serial.databits) {
+	case 5:
+		databits = CS5;
+		break;
+	case 6:
+		databits = CS6;
+		break;
+	case 7:
+		databits = CS7;
+		break;
+	case 8:
+		databits = CS8;
+		break;
+	default:
+		log(L_ERROR, "Invalid databits\n");
+		goto err;
+	}
+
+	char p = *c->parameters.serial.parity;
+	switch (p) {
+	case 'n':
+		options.c_cflag &= ~PARENB;
+		break;
+	case 'o':
+		options.c_cflag |= (PARENB | PARODD);
+		break;
+	case 'e':
+		options.c_cflag |= PARENB;
+		options.c_cflag &= ~PARODD;
+		break;
+	case 'm':
+		options.c_cflag |= (PARENB | CMSPAR | PARODD);
+		break;
+	case 's':
+		options.c_cflag |= (PARENB | CMSPAR);
+		options.c_cflag &= ~PARODD;
+		break;
+	default:
+		log(L_ERROR, "Invalid parity\n");
+		goto err;
+	}
+
+	if (c->parameters.serial.stopbits == 1) {
+		options.c_cflag &= ~CSTOPB;
+	} else {
+		options.c_cflag |= CSTOPB;
+	}
+
+	options.c_cflag = databits | CREAD | CLOCAL;
+
+	cfsetospeed(&options, baudrate);
+	cfsetispeed(&options, baudrate);
+
+	if (!strncmp("rts/cts", c->parameters.serial.flow_control, strlen("rts/cts"))) {
+		options.c_cflag |= CRTSCTS;
+	} else if (!strncmp("xon/xoff", c->parameters.serial.flow_control, strlen("xon/xoff"))) {
+		options.c_iflag |= (IXON | IXOFF);
+	}
+
+	// How long we are waiting reply charachter from serial port.
+	options.c_cc[VMIN]  = 1;
+	options.c_cc[VTIME] = 5;
+
+	if (tcsetattr(c->socket, TCSANOW, &options) != 0) {
+		log(L_ERROR, "Failed to set STTY settings");
+		goto err;
+	}
+
+	ret = 0;
+err:
+	return ret;
+}
+
+PRIVATE int send_data(connection *c, gxByteBuffer *data)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	switch (c->type) {
+	case TCP:
+		if (send(c->socket, (const char *)data->data, data->size, 0) == -1) {
+			log(L_ERROR, "Failed to send data: %s\n", strerror(errno));
+			ret = DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+		}
+		break;
+	case SERIAL:
+		if (write(c->socket, data->data, data->size) != (ssize_t)data->size) {
+			log(L_ERROR, "Failed to write data: %s\n", strerror(errno));
+			ret = DLMS_ERROR_TYPE_COMMUNICATION_ERROR;
+		}
+		break;
+	default:
+		log(L_ERROR, "Invalid connection type");
+		ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
+	}
+
+	return ret;
+}
+
+PRIVATE int read_data(connection *c, int *index)
+{
+	int ret = 0;
+	if (c->type == SERIAL) {
+		if ((ret = com_read_serial_port(c, 0x7E)) != 0) {
+			log(L_ERROR, "com_read_serial_port has failed");
+			return ret;
+		}
+	} else if (c->type == TCP) {
+		uint32_t cnt = c->data.capacity - c->data.size;
+		if (cnt < 1) {
+			log(L_ERROR, "data.size is bigger than data.capacity");
+			return DLMS_ERROR_CODE_OUTOFMEMORY;
+		}
+
+		ret = recv(c->socket, (char *)c->data.data + c->data.size, cnt, 0);
+		if (ret == -1 || (ret == 0 && cnt != 0)) {
+			log(L_ERROR, "read_data(): recv failure");
+			return DLMS_ERROR_CODE_RECEIVE_FAILED;
+		}
+		c->data.size += ret;
+	}
+
+	if (g_debug_level <= L_DEBUG) {
+		char *hex = hlp_bytesToHex(c->data.data + *index, c->data.size - *index);
+		if (*index == 0) {
+			log(L_DEBUG, "RX:\t%s\n", hex);
+		} else {
+			log(L_DEBUG, " %s", hex);
+		}
+		free(hex);
+		*index = c->data.size;
+	}
+
+	return 0;
+}
+
+PRIVATE int com_read_serial_port(connection *c, unsigned char eop)
+{
+	//Read reply data.
+	int ret, pos;
+	uint cnt		 = 1;
+	unsigned char eopFound	 = 0;
+	int lastReadIndex	 = 0;
+	unsigned short bytesRead = 0;
+	unsigned short readTime	 = 0;
+	do {
+		//Get bytes available.
+		ret = ioctl(c->socket, FIONREAD, &cnt);
+		//If driver is not supporting this functionality.
+		if (ret < 0) {
+			cnt = RECEIVE_BUFFER_SIZE;
+		} else if (cnt == 0) {
+			//Try to read at least one byte.
+			cnt = 1;
+		}
+		//If there is more data than can fit to buffer.
+		if (cnt > RECEIVE_BUFFER_SIZE) {
+			cnt = RECEIVE_BUFFER_SIZE;
+		}
+		bytesRead = read(c->socket, c->data.data + c->data.size, cnt);
+		if (bytesRead == 0xFFFF) {
+			//If there is no data on the read buffer.
+			if (errno == EAGAIN) {
+				if (readTime > c->wait_time) {
+					log(L_ERROR, "Wait time is longer than read time");
+					return DLMS_ERROR_CODE_RECEIVE_FAILED;
+				}
+				readTime += 100;
+				bytesRead = 0;
+			} else {
+				log(L_ERROR, "com_read_serial_port() read failed");
+				return DLMS_ERROR_TYPE_COMMUNICATION_ERROR | errno;
+			}
+		}
+		c->data.size += (unsigned short)bytesRead;
+		//Note! Some USB converters can return true for ReadFile and Zero as bytesRead.
+		//In that case wait for a while and read again.
+		if (bytesRead == 0) {
+			usleep(40000);
+			continue;
+		}
+		//Search eop.
+		if (c->data.size > 5) {
+			//Some optical strobes can return extra bytes.
+			for (pos = c->data.size - 1; pos != lastReadIndex; --pos) {
+				if (c->data.data[pos] == eop) {
+					eopFound = 1;
+					break;
+				}
+			}
+			lastReadIndex = pos;
+		}
+	} while (eopFound == 0);
+	return DLMS_ERROR_CODE_OK;
+}
+
+PRIVATE int read_dlms_packet(connection *c, dlmsSettings *s, gxByteBuffer *data, gxReplyData *reply)
+{
+	int ret		 = DLMS_ERROR_CODE_OK;
+	int index	 = 0;
+	reply->complete	 = 0;
+	c->data.size	 = 0;
+	c->data.position = 0;
+
+	if (data->size == 0) {
+		log(L_ERROR, "Message is empty");
+		return DLMS_ERROR_CODE_OK;
+	}
+
+	if (g_debug_level <= L_DEBUG) {
+		char *hex = bb_toHexString(data);
+		log(L_DEBUG, "TX:\t%s", hex);
+		free(hex);
+	}
+
+	ret = send_data(c, data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to send data: %s\n", hlp_getErrorMessage(ret));
+		return ret;
+	}
+
+	//Loop until packet is complete.
+	unsigned char pos = 0;
+	do {
+		if ((ret = read_data(c, &index)) != 0) {
+			if (ret != DLMS_ERROR_CODE_RECEIVE_FAILED || pos >= 3) {
+				break;
+			}
+			log(L_DEBUG, "Data send failed. Try to resend %d/3", ++pos);
+			if ((ret = send_data(c, data)) != DLMS_ERROR_CODE_OK) {
+				break;
+			}
+		} else {
+			ret = cl_getData(s, &c->data, reply);
+			if (ret != 0 && ret != DLMS_ERROR_CODE_FALSE) {
+				break;
+			}
+		}
+	} while (reply->complete == 0);
+
+	return ret;
+}
+
+PRIVATE int com_read_data_block(connection *c, dlmsSettings *s, message *m, gxReplyData *reply)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	if (m->size == 0) {
+		// log(L_ERROR, "There is no data to send");
+		return ret;
+	}
+
+	gxByteBuffer rr;
+	bb_init(&rr);
+	for (int pos = 0; pos != m->size; ++pos) {
+		//Send data.
+		ret = read_dlms_packet(c, s, m->data[pos], reply);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			log(L_ERROR, "Failed to read_dlms_packet: %s", hlp_getErrorMessage(ret));
+			goto end;
+		}
+		//Check is there errors or more data from server
+		while (reply_isMoreData(reply)) {
+			ret = cl_receiverReady(s, reply->moreData, &rr);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				log(L_ERROR, "Failed to cl_receiverReady: %s", hlp_getErrorMessage(ret));
+				goto end;
+			}
+
+			ret = read_dlms_packet(c, s, &rr, reply);
+			if (ret != DLMS_ERROR_CODE_OK) {
+				log(L_ERROR, "[while] Failed to read_dlms_packet: %s", hlp_getErrorMessage(ret));
+				goto end;
+			}
+			bb_clear(&rr);
+		}
+	}
+
+end:
+	bb_clear(&rr);
+	return ret;
+}
+
+PUBLIC int com_update_invocation_counter(connection *c, dlmsSettings *s, const char *invocationCounter)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	if (invocationCounter == NULL || s->cipher.security == DLMS_SECURITY_NONE) {
+		return ret;
+	}
+
+	gxByteBuffer challenge	 = { 0 };
+	message messages	 = { 0 };
+	gxReplyData reply	 = { 0 };
+	unsigned short add	 = s->clientAddress;
+	DLMS_AUTHENTICATION auth = s->authentication;
+	DLMS_SECURITY security	 = s->cipher.security;
+
+	bb_init(&challenge);
+	bb_set(&challenge, s->ctoSChallenge.data, s->ctoSChallenge.size);
+	s->clientAddress   = 16;
+	s->authentication  = DLMS_AUTHENTICATION_NONE;
+	s->cipher.security = DLMS_SECURITY_NONE;
+
+	log(L_DEBUG, "Updating invocation counter\n");
+
+	//Get meter's send and receive buffers size.
+	ret = com_handle_snrm_request(c, s, &messages, &reply, &challenge);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "handle_snrm_request failed: %s\r\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_handle_aarq_request(c, s, &messages, &reply, &challenge);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "handle_aarq_request failed: %s\r\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	com_handle_init_buffers(c, s);
+
+	gxData d = { 0 };
+	cosem_init(BASE(d), DLMS_OBJECT_TYPE_DATA, invocationCounter);
+	if ((ret = com_read(c, s, BASE(d), 2)) == 0) {
+		s->cipher.invocationCounter = 1 + var_toInteger(&d.value);
+
+		log(L_DEBUG, "Invocation counter: %lu (0x%lX)\r\n", s->cipher.invocationCounter,
+		    s->cipher.invocationCounter);
+
+		com_disconnect(c, s);
+		bb_clear(&s->ctoSChallenge);
+		bb_set(&s->ctoSChallenge, challenge.data, challenge.size);
+	}
+
+err:
+	s->clientAddress   = add;
+	s->authentication  = auth;
+	s->cipher.security = security;
+
+	bb_clear(&challenge);
+	return ret;
+}
+
+PRIVATE int com_disconnect(connection *c, dlmsSettings *s)
+{
+	int ret		  = DLMS_ERROR_CODE_OK;
+	gxReplyData reply = { 0 };
+	message msg	  = { 0 };
+
+	log(L_INFO, "Disconnecting");
+	reply_init(&reply);
+	mes_init(&msg);
+
+	if ((ret = cl_disconnectRequest(s, &msg)) != 0 ||
+	    (ret = com_read_data_block(c, s, &msg, &reply)) != 0) {
+		log(L_DEBUG, "Disconnect failed");
+	}
+
+	reply_clear(&reply);
+	mes_clear(&msg);
+	return ret;
+}
+
+PUBLIC int com_initialize_connection(connection *c, dlmsSettings *s)
+{
+
+	int ret		  = DLMS_ERROR_CODE_OK;
+	message messages  = { 0 };
+	gxReplyData reply = { 0 };
+
+	log(L_INFO, "Initialising connection ('%d') ('%s')\n", c->id, UTL_SAFE_STR(c->name));
+
+	//Get meter's send and receive buffers size.
+	ret = com_handle_snrm_request(c, s, &messages, &reply, NULL);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to handle SNRM request: %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_handle_aarq_request(c, s, &messages, &reply, NULL);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to handle AARQ request: %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	com_handle_init_buffers(c, s);
+
+	if (s->authentication <= DLMS_AUTHENTICATION_LOW) {
+		goto err;
+	}
+
+	// Get challenge Is HLS authentication is used.
+	ret = cl_getApplicationAssociationRequest(s, &messages);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to get AA request: %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_read_data_block(c, s, &messages, &reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to read data block: %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = cl_parseApplicationAssociationResponse(s, &reply.data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to parse AA response: %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+err:
+	mes_clear(&messages);
+	reply_clear(&reply);
+	return ret;
+}
+
+PUBLIC int com_read(connection *c, dlmsSettings *s, gxObject *object, unsigned char attributeOrdinal)
+{
+	int ret		  = DLMS_ERROR_CODE_OK;
+	message data	  = { 0 };
+	gxReplyData reply = { 0 };
+
+	mes_init(&data);
+	reply_init(&reply);
+
+	ret = cl_read(s, object, attributeOrdinal, &data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to read object: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_read_data_block(c, s, &data, &reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to read COSEM object data block: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = cl_updateValue(s, object, attributeOrdinal, &reply.dataValue);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to update value: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+err:
+	mes_clear(&data);
+	reply_clear(&reply);
+	return ret;
+}
+
+PUBLIC void com_close(connection *c, dlmsSettings *s)
+{
+	log(L_INFO, "Closing connection ('%d') ('%s')", c->id, UTL_SAFE_STR(c->name));
+
+	if (!s->server) {
+		gxReplyData reply = { 0 };
+		message msg	  = { 0 };
+		reply_init(&reply);
+		mes_init(&msg);
+		if (cl_releaseRequest(s, &msg) != 0 || com_read_data_block(c, s, &msg, &reply) != 0) {
+			//Show error but continue close.
+			log(L_DEBUG, "Release failed");
+		}
+		reply_clear(&reply);
+		mes_clear(&msg);
+
+		if (cl_disconnectRequest(s, &msg) != 0 || com_read_data_block(c, s, &msg, &reply) != 0) {
+			//Show error but continue close.
+			log(L_DEBUG, "Close failed");
+		}
+		reply_clear(&reply);
+		mes_clear(&msg);
+	}
+
+	com_close_socket(c);
+}
+
+int com_getKeepAlive(connection *c, dlmsSettings *s)
+{
+	int ret		  = DLMS_ERROR_CODE_OK;
+	message data	  = { 0 };
+	gxReplyData reply = { 0 };
+
+	mes_init(&data);
+	reply_init(&reply);
+
+	ret = cl_getKeepAlive(s, &data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to get keepalive: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_read_data_block(c, s, &data, &reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "com_getKeepAlive(): failed to read data block: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+err:
+	mes_clear(&data);
+	reply_clear(&reply);
+	return ret;
+}
+
+PUBLIC int com_readRowsByEntry(connection *c, dlmsSettings *s, gxProfileGeneric *obj, int index, int count)
+{
+	int ret		  = DLMS_ERROR_CODE_OK;
+	message data	  = { 0 };
+	gxReplyData reply = { 0 };
+
+	mes_init(&data);
+	reply_init(&reply);
+
+	ret = cl_readRowsByEntry(s, obj, index, count, &data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to read rows by entry %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = com_read_data_block(c, s, &data, &reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to read data block %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	ret = cl_updateValue(s, (gxObject *)obj, 2, &reply.dataValue);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to update value %s\n", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+err:
+	mes_clear(&data);
+	reply_clear(&reply);
+	return ret;
+}
+
+PRIVATE int com_handle_snrm_request(connection *c, dlmsSettings *s, message *m, gxReplyData *reply, gxByteBuffer *challenge)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	mes_init(m);
+	reply_init(reply);
+
+	ret = cl_snrmRequest(s, m);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to send SNRM request: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+	ret = com_read_data_block(c, s, m, reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to read SNRM data block: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+	ret = cl_parseUAResponse(s, &reply->data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_DEBUG, "Failed to parse UA response: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+end:
+	mes_clear(m);
+	reply_clear(reply);
+	if (challenge) {
+		bb_clear(challenge);
+	}
+
+	return ret;
+}
+
+PRIVATE int com_handle_aarq_request(connection *c, dlmsSettings *s, message *m, gxReplyData *reply, gxByteBuffer *challenge)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	ret = cl_aarqRequest(s, m);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to send AARQ request: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+	ret = com_read_data_block(c, s, m, reply);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to read AARQ data block: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+	ret = cl_parseAAREResponse(s, &reply->data);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to parse AARE response: %s\n", hlp_getErrorMessage(ret));
+		goto end;
+	}
+
+end:
+	mes_clear(m);
+	reply_clear(reply);
+	if (challenge) {
+		bb_clear(challenge);
+	}
+
+	return ret;
+}
+
+PRIVATE void com_handle_init_buffers(connection *c, dlmsSettings *s)
+{
+	if (s->maxPduSize == 0xFFFF) {
+		com_initialize_buffers(c, s->maxPduSize);
+	} else {
+		//!< Allocate 50 bytes more because some meters count this wrong and send few bytes too many.
+		com_initialize_buffers(c, 50 + s->maxPduSize);
+	}
+}
+
+PRIVATE void com_initialize_buffers(connection *c, int size)
+{
+	if (size == 0) {
+		bb_clear(&c->data);
+	} else {
+		bb_capacity(&c->data, size);
+	}
+}
+
+PUBLIC void com_close_socket(connection *c)
+{
+	if (c->socket != -1) {
+		close(c->socket);
+		c->socket = -1;
+	}
 }
 
-static unsigned char CURRENT_LN[] = { 0, 0, 40, 0, 0, 0xFF };
-
-//Association view is read from association logical name object.
-int com_loadAssociationView(connection* connection, const char* outputFile)
-{
-    int ret = 0;
-    if (outputFile != NULL)
-    {
-        //Load settings.
-#if _MSC_VER > 1400
-        FILE* f = NULL;
-        fopen_s(&f, outputFile, "rb");
-#else
-        FILE* f = fopen(fileName, "rb");
-#endif
-        if (f != NULL)
-        {
-            gxObject* CURRENT_ASSOCIATION[1] = { NULL };
-            gxAssociationLogicalName ln;
-            gxAssociationShortName sn;
-            gxSerializerSettings serializerSettings;
-            ser_init(&serializerSettings);
-            serializerSettings.stream = f;
-            gxSerializerIgnore NON_SERIALIZED_OBJECTS[] = { IGNORE_ATTRIBUTE_BY_TYPE(DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, GET_ATTRIBUTE_EXCEPT(2)) };
-            serializerSettings.ignoredAttributes = NON_SERIALIZED_OBJECTS;
-            serializerSettings.count = sizeof(NON_SERIALIZED_OBJECTS) / sizeof(NON_SERIALIZED_OBJECTS[0]);
-            if (connection->settings.useLogicalNameReferencing)
-            {
-                INIT_OBJECT(ln, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, CURRENT_LN);
-                CURRENT_ASSOCIATION[0] = BASE(ln);
-            }
-            else
-            {
-                NON_SERIALIZED_OBJECTS[0].objectType = DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME;
-                INIT_OBJECT(sn, DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME, CURRENT_LN);
-                CURRENT_ASSOCIATION[0] = BASE(sn);
-            }
-            oa_clear(&connection->settings.objects, 1);
-            ret = ser_loadObjects(&connection->settings, &serializerSettings, CURRENT_ASSOCIATION, sizeof(CURRENT_ASSOCIATION) / sizeof(CURRENT_ASSOCIATION[0]));
-            fclose(f);
-            if (ret == 0)
-            {
-                if (connection->settings.useLogicalNameReferencing)
-                {
-                    oa_move(&connection->settings.objects, &ln.objectList);
-                    obj_clear(BASE(ln));
-                }
-                else
-                {
-                    oa_move(&connection->settings.objects, &sn.objectList);
-                    obj_clear(BASE(sn));
-                }
-            }
-        }
-    }
-    return ret;
-}
-
-//Get Association view.
-int com_getAssociationView(connection* connection, const char* outputFile)
+// TODO: read association view, remove association logical name COSEM class from group values.
+PUBLIC int com_get_association_view(connection *c, dlmsSettings *s)
 {
     //If association view is already read.
-    if (connection->settings.objects.size != 0)
-    {
+    if (s->objects.size != 0) {
         return 0;
     }
+
     int ret;
     message data;
     gxReplyData reply;
-    if (outputFile != NULL)
-    {
-        //Load settings.
-        return com_loadAssociationView(connection, outputFile);
-    }
     printf("GetAssociationView\r\n");
     mes_init(&data);
     reply_init(&reply);
-    /*
-    if ((ret = cl_getObjectsRequest(&connection->settings, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0 ||
-        (ret = cl_parseObjects(&connection->settings, &reply.data)) != 0)
-    {
-        printf("GetObjects failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    */
-    // Parse object one at the time. This can be used if there is a limited amount of the memory available.
-    // Only needed object can be created.
-    if ((ret = cl_getObjectsRequest(&connection->settings, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0)
+    if ((ret = cl_getObjectsRequest(s, &data)) != 0 ||
+        (ret = com_read_data_block(c, s, &data, &reply)) != 0)
     {
         printf("cl_getObjectsRequest failed %s\r\n", hlp_getErrorMessage(ret));
     }
     else
     {
-        gxObject* CURRENT_ASSOCIATION[1] = { NULL };
+        // gxObject* CURRENT_ASSOCIATION[1] = { NULL };
         uint16_t pos, count;
         if ((ret = cl_parseObjectCount(&reply.data, &count)) != 0)
         {
@@ -1183,721 +955,60 @@
         for (pos = 0; pos != count; ++pos)
         {
             memset(&obj, 0, sizeof(gxObject));
-            if ((ret = cl_parseNextObject(&connection->settings, &reply.data, &obj)) != 0)
+            if ((ret = cl_parseNextObject(s, &reply.data, &obj)) != 0)
             {
                 break;
             }
-            if (connection->settings.useLogicalNameReferencing && obj.objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME && memcmp(obj.logicalName, CURRENT_LN, sizeof(CURRENT_LN)) == 0)
-            {
-                gxAssociationLogicalName* ln = (gxAssociationLogicalName*)malloc(sizeof(gxAssociationLogicalName));
-                INIT_OBJECT((*ln), obj.objectType, obj.logicalName);
-                ln->base.shortName = obj.shortName;
-                oa_push(&connection->settings.objects, (gxObject*) ln);
-                CURRENT_ASSOCIATION[0] = (gxObject*)ln;
-            }
-            else if (!connection->settings.useLogicalNameReferencing && obj.objectType == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME && memcmp(obj.logicalName, CURRENT_LN, sizeof(CURRENT_LN)) == 0)
+            if (s->useLogicalNameReferencing && obj.objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
             {
-                gxAssociationShortName* sn = (gxAssociationShortName*)malloc(sizeof(gxAssociationShortName));
-                INIT_OBJECT((*sn), obj.objectType, obj.logicalName);
-                sn->base.shortName = obj.shortName;
-                oa_push(&connection->settings.objects, (gxObject*)sn);
-                CURRENT_ASSOCIATION[0] = (gxObject*)sn;
+        //         gxAssociationLogicalName* ln = (gxAssociationLogicalName*)malloc(sizeof(gxAssociationLogicalName));
+        //         INIT_OBJECT((*ln), obj.objectType, obj.logicalName);
+        //         ln->base.shortName = obj.shortName;
+        //         oa_push(&s->objects, (gxObject*) ln);
+        //         CURRENT_ASSOCIATION[0] = (gxObject*)ln;
+            }
+            else if (!s->useLogicalNameReferencing && obj.objectType == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME)
+            {
+        //         gxAssociationShortName* sn = (gxAssociationShortName*)malloc(sizeof(gxAssociationShortName));
+        //         INIT_OBJECT((*sn), obj.objectType, obj.logicalName);
+        //         sn->base.shortName = obj.shortName;
+        //         oa_push(&s->objects, (gxObject*)sn);
+        //         CURRENT_ASSOCIATION[0] = (gxObject*)sn;
             }
             else if (obj.objectType == DLMS_OBJECT_TYPE_DATA)
             {
-                gxData* data = (gxData*)malloc(sizeof(gxData));
-                INIT_OBJECT((*data), obj.objectType, obj.logicalName);
-                data->base.shortName = obj.shortName;
-                oa_push(&connection->settings.objects, (gxObject*)data);
+        //         gxData* data = (gxData*)malloc(sizeof(gxData));
+        //         INIT_OBJECT((*data), obj.objectType, obj.logicalName);
+        //         data->base.shortName = obj.shortName;
+        //         oa_push(&s->objects, (gxObject*)data);
             }
-            else
-            {
+            else {
                 gxObject* pObj = NULL;
-                if ((ret = cosem_createObject(obj.objectType, &pObj)) == 0 &&
-                    (ret = cosem_init2(pObj, obj.objectType, obj.logicalName)) == 0)
-                {
-                    pObj->shortName = obj.shortName;
-                    oa_push(&connection->settings.objects, pObj);
-                }
-            }
-        }
-        if (outputFile != NULL && CURRENT_ASSOCIATION[0] != NULL)
-        {
-            //Write settings.
-#if _MSC_VER > 1400
-            FILE* f = NULL;
-            fopen_s(&f, outputFile, "wb");
-#else
-            FILE* f = fopen(fileName, "wb");
-#endif
-            if (f != NULL)
-            {
-                gxSerializerSettings serializerSettings;
-                ser_init(&serializerSettings);
-                serializerSettings.stream = f;
-                gxSerializerIgnore NON_SERIALIZED_OBJECTS[] = { IGNORE_ATTRIBUTE_BY_TYPE(DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, GET_ATTRIBUTE_EXCEPT(2)) };
-                serializerSettings.ignoredAttributes = NON_SERIALIZED_OBJECTS;
-                serializerSettings.count = sizeof(NON_SERIALIZED_OBJECTS) / sizeof(NON_SERIALIZED_OBJECTS[0]);
-                if (connection->settings.useLogicalNameReferencing)
-                {
-                    oa_copy(&((gxAssociationLogicalName*)CURRENT_ASSOCIATION[0])->objectList, &connection->settings.objects);
-                }
-                else
-                {
-                    NON_SERIALIZED_OBJECTS[0].objectType = DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME;
-                    oa_copy(&((gxAssociationShortName*)CURRENT_ASSOCIATION[0])->objectList, &connection->settings.objects);
-                }
-                ret = ser_saveObjects(&serializerSettings, CURRENT_ASSOCIATION, sizeof(CURRENT_ASSOCIATION) / sizeof(CURRENT_ASSOCIATION[0]));
-                fclose(f);
-            }
-        }
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-
-//Read object.
-int com_read(
-    connection* connection,
-    gxObject* object,
-    unsigned char attributeOrdinal)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_read(&connection->settings, object, attributeOrdinal, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0 ||
-        (ret = cl_updateValue(&connection->settings, object, attributeOrdinal, &reply.dataValue)) != 0)
-    {
-        com_reportError("ReadObject failed", object, attributeOrdinal, ret);
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-int com_getKeepAlive(
-    connection* connection)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_getKeepAlive(&connection->settings, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0)
-    {
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-int com_write(
-    connection* connection,
-    gxObject* object,
-    unsigned char attributeOrdinal)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_write(&connection->settings, object, attributeOrdinal, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0)
-    {
-        com_reportError("Write failed", object, attributeOrdinal, ret);
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-int com_method(
-    connection* connection,
-    gxObject* object,
-    unsigned char attributeOrdinal,
-    dlmsVARIANT* params)
-{
-    int ret;
-    message messages;
-    gxReplyData reply;
-    mes_init(&messages);
-    reply_init(&reply);
-    if ((ret = cl_method(&connection->settings, object, attributeOrdinal, params, &messages)) != 0 ||
-        (ret = com_readDataBlock(connection, &messages, &reply)) != 0)
-    {
-        printf("Method failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    mes_clear(&messages);
-    reply_clear(&reply);
-    return ret;
-}
-
-//Read objects.
-int com_readList(
-    connection* connection,
-    gxArray* list)
-{
-    int pos, ret = DLMS_ERROR_CODE_OK;
-    gxByteBuffer bb, rr;
-    message messages;
-    gxReplyData reply;
-    if (list->size != 0)
-    {
-        mes_init(&messages);
-        if ((ret = cl_readList(&connection->settings, list, &messages)) != 0)
-        {
-            printf("ReadList failed %s\r\n", hlp_getErrorMessage(ret));
-        }
-        else
-        {
-            reply_init(&reply);
-            //NOTE! Set ignore value to true because list is parsed differently than normal read.
-            reply.ignoreValue = 1;
-            bb_init(&rr);
-            bb_init(&bb);
-            //Send data.
-            for (pos = 0; pos != messages.size; ++pos)
-            {
-                //Send data.
-                reply_clear(&reply);
-                if ((ret = readDLMSPacket(connection, messages.data[pos], &reply)) != DLMS_ERROR_CODE_OK)
-                {
-                    break;
-                }
-                //Check is there errors or more data from server
-                while (reply_isMoreData(&reply))
-                {
-                    //NOTE! Set ignore value to true because list is parsed differently than normal read.
-                    reply.ignoreValue = 1;
-                    if ((ret = cl_receiverReady(&connection->settings, reply.moreData, &rr)) != DLMS_ERROR_CODE_OK ||
-                        (ret = readDLMSPacket(connection, &rr, &reply)) != DLMS_ERROR_CODE_OK)
-                    {
-                        break;
-                    }
-                    bb_clear(&rr);
-                }
-                bb_set2(&bb, &reply.data, reply.data.position, -1);
-            }
-            if (ret == 0)
-            {
-                ret = cl_updateValues(&connection->settings, list, &bb);
-            }
-            bb_clear(&bb);
-            bb_clear(&rr);
-            reply_clear(&reply);
-        }
-        mes_clear(&messages);
-    }
-    return ret;
+		ret = cosem_createObject(obj.objectType, &pObj);
+		if (ret) {
+			printf("cosem_createObject failina:  %d type: %d\n", ret, obj.objectType);
+			continue;
+		}
+		ret = cosem_init2(pObj, obj.objectType, obj.logicalName);
+		if (ret) {
+			printf("cosem_init failina:  %d\n", ret);
+			continue;
+		}
+		pObj->shortName = obj.shortName;
+		oa_push(&s->objects, pObj);
+		printf("aš čia: %d\n", ret);
+		if (pObj) {
+			printf("short: %d\n", pObj->shortName);
+		char LN[32] = { 0 };
+		hlp_getLogicalNameToString(obj.logicalName, LN);
+		printf("logical: '%s'\n", LN);
+		} else {
+			printf("ne\n");
+		}
+	    }
+        }
+    }
+	mes_clear(&data);
+	reply_clear(&reply);
+	return ret;
 }
-
-int com_readRowsByEntry(
-    connection* connection,
-    gxProfileGeneric* object,
-    unsigned long index,
-    unsigned long count)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_readRowsByEntry(&connection->settings, object, index, count, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0 ||
-        (ret = cl_updateValue(&connection->settings, (gxObject*)object, 2, &reply.dataValue)) != 0)
-    {
-        printf("ReadObject failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-int com_readRowsByEntry2(
-    connection* connection,
-    gxProfileGeneric* object,
-    unsigned long index,
-    unsigned long count,
-    unsigned short colStartIndex,
-    unsigned short colEndIndex)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    gxByteBuffer bb;
-    char* str;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_readRowsByEntry2(&connection->settings, object, index, count, colStartIndex, colEndIndex, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0)
-    {
-        printf("ReadObject failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    else
-    {
-        bb_init(&bb);
-        var_toString(&reply.dataValue, &bb);
-        str = bb_toString(&bb);
-        printf(str);
-        bb_clear(&bb);
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////////////////
-int com_readRowsByRange(
-    connection* connection,
-    gxProfileGeneric* object,
-    struct tm* start,
-    struct tm* end)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_readRowsByRange(&connection->settings, object, start, end, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0 ||
-        (ret = cl_updateValue(&connection->settings, (gxObject*)object, 2, &reply.dataValue)) != 0)
-    {
-        printf("ReadObject failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////////////////
-int com_readRowsByRange2(
-    connection* connection,
-    gxProfileGeneric* object,
-    gxtime* start,
-    gxtime* end)
-{
-    int ret;
-    message data;
-    gxReplyData reply;
-    mes_init(&data);
-    reply_init(&reply);
-    if ((ret = cl_readRowsByRange2(&connection->settings, object, start, end, &data)) != 0 ||
-        (ret = com_readDataBlock(connection, &data, &reply)) != 0 ||
-        (ret = cl_updateValue(&connection->settings, (gxObject*)object, 2, &reply.dataValue)) != 0)
-    {
-        printf("ReadObject failed %s\r\n", hlp_getErrorMessage(ret));
-    }
-    mes_clear(&data);
-    reply_clear(&reply);
-    return ret;
-}
-
-
-///////////////////////////////////////////////////////////////////////////////////
-//Read scalers and units. They are static so they are read only once.
-int com_readScalerAndUnits(
-    connection* connection)
-{
-    gxObject* obj;
-    int ret, pos;
-    objectArray objects;
-    gxArray list;
-    gxObject* object;
-    DLMS_OBJECT_TYPE types[] = { DLMS_OBJECT_TYPE_EXTENDED_REGISTER, DLMS_OBJECT_TYPE_REGISTER, DLMS_OBJECT_TYPE_DEMAND_REGISTER };
-    oa_init(&objects);
-    //Find registers and demand registers and read them.
-    ret = oa_getObjects2(&connection->settings.objects, types, 3, &objects);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    if ((connection->settings.negotiatedConformance & DLMS_CONFORMANCE_MULTIPLE_REFERENCES) != 0)
-    {
-        arr_init(&list);
-        //Try to read with list first. All meters do not support it.
-        for (pos = 0; pos != connection->settings.objects.size; ++pos)
-        {
-            ret = oa_getByIndex(&connection->settings.objects, pos, &obj);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                oa_empty(&objects);
-                arr_clear(&list);
-                return ret;
-            }
-            if (obj->objectType == DLMS_OBJECT_TYPE_REGISTER ||
-                obj->objectType == DLMS_OBJECT_TYPE_EXTENDED_REGISTER)
-            {
-                arr_push(&list, key_init(obj, (void*)3));
-            }
-            else if (obj->objectType == DLMS_OBJECT_TYPE_DEMAND_REGISTER)
-            {
-                arr_push(&list, key_init(obj, (void*)4));
-            }
-        }
-        ret = com_readList(connection, &list);
-        arr_clear(&list);
-    }
-    //If read list failed read items one by one.
-    if (ret != 0)
-    {
-        for (pos = 0; pos != objects.size; ++pos)
-        {
-            ret = oa_getByIndex(&objects, pos, &object);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                oa_empty(&objects);
-                return ret;
-            }
-            ret = com_read(connection, object, object->objectType == DLMS_OBJECT_TYPE_DEMAND_REGISTER ? 4 : 3);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                oa_empty(&objects);
-                return ret;
-            }
-        }
-    }
-    //Do not clear objects list because it will free also objects from association view list.
-    oa_empty(&objects);
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////////////////
-//Read profile generic columns. They are static so they are read only once.
-int com_readProfileGenericColumns(
-    connection* connection)
-{
-    int ret, pos;
-    objectArray objects;
-    gxObject* object;
-    oa_init(&objects);
-    ret = oa_getObjects(&connection->settings.objects, DLMS_OBJECT_TYPE_PROFILE_GENERIC, &objects);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        oa_empty(&objects);
-        return ret;
-    }
-    for (pos = 0; pos != objects.size; ++pos)
-    {
-        ret = oa_getByIndex(&objects, pos, &object);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            break;
-        }
-        ret = com_read(connection, object, 3);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            break;
-        }
-    }
-    //Do not clear objects list because it will free also objects from association view list.
-    oa_empty(&objects);
-    return ret;
-}
-
-///////////////////////////////////////////////////////////////////////////////////
-//Read profile generics rows.
-int com_readProfileGenerics(
-    connection* connection)
-{
-    gxtime startTime, endTime;
-    int ret, pos;
-    char str[50];
-    char ln[25];
-    char* data = NULL;
-    gxByteBuffer ba;
-    objectArray objects;
-    gxProfileGeneric* pg;
-    oa_init(&objects);
-    ret = oa_getObjects(&connection->settings.objects, DLMS_OBJECT_TYPE_PROFILE_GENERIC, &objects);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        //Do not clear objects list because it will free also objects from association view list.
-        oa_empty(&objects);
-        return ret;
-    }
-    bb_init(&ba);
-    for (pos = 0; pos != objects.size; ++pos)
-    {
-        ret = oa_getByIndex(&objects, pos, (gxObject**)&pg);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            //Do not clear objects list because it will free also objects from association view list.
-            oa_empty(&objects);
-            return ret;
-        }
-        //Read entries in use.
-        ret = com_read(connection, (gxObject*)pg, 7);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s attribute index %d\r\n", str, ln, 7);
-            }
-            //Do not clear objects list because it will free also objects from association view list.
-            oa_empty(&objects);
-            return ret;
-        }
-        //Read entries.
-        ret = com_read(connection, (gxObject*)pg, 8);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s attribute index %d\r\n", str, ln, 8);
-            }
-            //Do not clear objects list because it will free also objects from association view list.
-            oa_empty(&objects);
-            return ret;
-        }
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("Entries: %ld/%ld\r\n", pg->entriesInUse, pg->profileEntries);
-        }
-        //If there are no columns or rows.
-        if (pg->entriesInUse == 0 || pg->captureObjects.size == 0)
-        {
-            continue;
-        }
-        //Read capture period.
-        ret = com_read(connection, (gxObject*)pg, 4);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s attribute index %d\r\n", str, ln, 8);
-            }
-            //Do not clear objects list because it will free also objects from association view list.
-            oa_empty(&objects);
-            return ret;
-        }
-        //Read Sort method.
-        ret = com_read(connection, (gxObject*)pg, 5);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s attribute index %d\r\n", str, ln, 8);
-            }
-            //Do not clear objects list because it will free also objects from association view list.
-            oa_empty(&objects);
-            return ret;
-        }
-        //Read first row from Profile Generic.
-        ret = com_readRowsByEntry(connection, pg, 1, 1);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s rows by entry\r\n", str, ln);
-            }
-        }
-        else
-        {
-            if (connection->trace > GX_TRACE_LEVEL_WARNING)
-            {
-                bb_init(&ba);
-                obj_rowsToString(&ba, &pg->buffer);
-                data = bb_toString(&ba);
-                bb_clear(&ba);
-                printf("%s\r\n", data);
-                free(data);
-            }
-        }
-        //Read last day from Profile Generic.
-        time_now(&startTime);
-        endTime = startTime;
-        time_clearTime(&startTime);
-        ret = com_readRowsByRange2(connection, pg, &startTime, &endTime);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            if (connection->trace > GX_TRACE_LEVEL_OFF)
-            {
-                printf("Failed to read object %s %s rows by entry\r\n", str, ln);
-            }
-        }
-        else
-        {
-            if (connection->trace > GX_TRACE_LEVEL_WARNING)
-            {
-                bb_init(&ba);
-                obj_rowsToString(&ba, &pg->buffer);
-                data = bb_toString(&ba);
-                bb_clear(&ba);
-                printf("%s\r\n", data);
-                free(data);
-            }
-        }
-    }
-    //Do not clear objects list because it will free also objects from association view list.
-    oa_empty(&objects);
-    return ret;
-}
-
-int com_readValue(connection* connection, gxObject* object, unsigned char index)
-{
-    int ret;
-    char* data = NULL;
-    char ln[25];
-    ret = hlp_getLogicalNameToString(object->logicalName, ln);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    if (connection->trace > GX_TRACE_LEVEL_WARNING)
-    {
-        printf("-------- Reading Object %s %s\r\n", obj_typeToString2(object->objectType), ln);
-    }
-    ret = com_read(connection, object, index);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        if (connection->trace > GX_TRACE_LEVEL_OFF)
-        {
-            printf("Failed to read object %s %s attribute index %d\r\n", obj_typeToString2(object->objectType), ln, index);
-        }
-        //Return error if not DLMS error.
-        if (ret != DLMS_ERROR_CODE_READ_WRITE_DENIED)
-        {
-            return ret;
-        }
-    }
-    if (connection->trace > GX_TRACE_LEVEL_WARNING)
-    {
-        ret = obj_toString(object, &data);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            return ret;
-        }
-        if (data != NULL)
-        {
-            printf("%s", data);
-            free(data);
-            data = NULL;
-        }
-    }
-    return 0;
-}
-
-// This function reads ALL objects that meter have excluded profile generic objects.
-// It will loop all object's attributes.
-int com_readValues(connection* connection)
-{
-    gxByteBuffer attributes;
-    unsigned char ch;
-    char* data = NULL;
-    char ln[25];
-    gxObject* object;
-    unsigned long index;
-    int ret = 0, pos;
-    bb_init(&attributes);
-    for (pos = 0; pos != connection->settings.objects.size; ++pos)
-    {
-        ret = oa_getByIndex(&connection->settings.objects, pos, &object);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            break;
-        }
-        ///////////////////////////////////////////////////////////////////////////////////
-        // Profile generics are read later because they are special cases.
-        // (There might be so lots of data and we so not want waste time to read all the data.)
-        if (object->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC)
-        {
-            continue;
-        }
-        ret = hlp_getLogicalNameToString(object->logicalName, ln);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            break;
-        }
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            printf("-------- Reading Object %s %s\n", obj_typeToString2(object->objectType), ln);
-        }
-        ret = obj_getAttributeIndexToRead(object, &attributes);
-        if (ret != DLMS_ERROR_CODE_OK)
-        {
-            break;
-        }
-        for (index = 0; index < attributes.size; ++index)
-        {
-            ret = bb_getUInt8ByIndex(&attributes, index, &ch);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                break;
-            }
-            ret = com_read(connection, object, ch);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                if (connection->trace > GX_TRACE_LEVEL_OFF)
-                {
-                    printf("Failed to read object %s %s attribute index %d\r\n", obj_typeToString2(object->objectType), ln, ch);
-                }
-                //Return error if not DLMS error.
-                if (ret != DLMS_ERROR_CODE_READ_WRITE_DENIED)
-                {
-                    continue;
-                }
-                ret = 0;
-            }
-        }
-        if (ret != 0)
-        {
-            break;
-        }
-        bb_clear(&attributes);
-        if (connection->trace > GX_TRACE_LEVEL_WARNING)
-        {
-            ret = obj_toString(object, &data);
-            if (ret != DLMS_ERROR_CODE_OK)
-            {
-                break;
-            }
-            if (data != NULL)
-            {
-                printf("%s", data);
-                free(data);
-                data = NULL;
-            }
-        }
-    }
-    bb_clear(&attributes);
-    return ret;
-}
-
-int com_readAllObjects(connection* connection, const char* outputFile)
-{
-    //Get objects from the meter and read them.
-    int ret = com_getAssociationView(connection, outputFile);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    ret = com_readScalerAndUnits(connection);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    ///////////////////////////////////////////////////////////////////////////////////
-    //Read Profile Generic columns.
-    ret = com_readProfileGenericColumns(connection);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    ret = com_readValues(connection);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    ret = com_readProfileGenerics(connection);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    return ret;
-}
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/src/config.c src/src/config.c
--- orig/src/config.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/config.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,1168 @@
+#include "master.h"
+
+#include <libtlt_uci.h>
+
+// TODO: check all reallocs
+// TODO: check all strdups
+// TODO: make terminal settings validator
+// TODO: validate auth keys.
+
+#define CFG_NAME "dlms_client"
+#define SEPARATOR log(L_INFO, "----------------------------");
+
+typedef struct connection_params_cfg {
+	int enabled;
+	int id;
+	char *name;
+	enum { TCP_CFG, SERIAL_CFG } type;
+	union {
+		struct {
+			char *host;
+			int port;
+		} tcp;
+		struct {
+			char *device;
+			int baudrate;
+			char *parity;
+			int databits;
+			int stopbits;
+			char *flow_control;
+		} serial;
+	} parameters;
+	int wait_time;
+} connection_params_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	int server_address;
+	int logical_server_address;
+	int client_address;
+	int access_security;
+	int interface_type;
+	int logical_name_ref;
+	char *password;
+	int transport_security;
+	int connection;
+	char *authentication_key;
+	char *block_cipher_key;
+	char *dedicated_key;
+	char *invocation_counter;
+} physical_device_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	uint32_t interval;
+} cosem_group_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	char *obis;
+	int cosem_id;
+	int entries;
+	char *physical_devices;
+	int cosem_group;
+} cosem_object_cfg;
+
+typedef struct {
+	size_t connection_cfg_count;
+	size_t physical_device_cfg_count;
+	size_t cosem_object_cfg_count;
+	size_t cosem_group_cfg_count;
+
+	connection_params_cfg **connections;
+	physical_device_cfg **physical_devices;
+	cosem_object_cfg **cosem_objects;
+	cosem_group_cfg **cosem_groups;
+} dlms_cfg;
+
+PRIVATE dlms_cfg *cfg_read_dlms_cfg();
+PRIVATE master *cfg_read_master(dlms_cfg *cfg);
+
+PRIVATE connection_params_cfg *cfg_read_connection(struct uci_context *uci, struct uci_section *section);
+PRIVATE physical_device_cfg *cfg_read_physical_device(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_object_cfg *cfg_read_cosem_object(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_group_cfg *cfg_read_cosem_group(struct uci_context *uci, struct uci_section *section);
+
+PRIVATE connection **cfg_get_connections(dlms_cfg *cfg, size_t *connection_count);
+PRIVATE connection *cfg_get_connection(connection_params_cfg *cfg);
+PRIVATE physical_device **cfg_get_physical_devices(dlms_cfg *cfg, connection **connections, size_t connection_count, size_t *physical_dev_count);
+PRIVATE physical_device *cfg_get_physical_device(physical_device_cfg *cfg, connection **connections, size_t connection_count);
+PRIVATE cosem_object **cfg_get_cosem_objects(dlms_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count, size_t *cosem_object_count);
+PRIVATE cosem_object *cfg_get_cosem_object(cosem_object_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count);
+PRIVATE cosem_group **cfg_get_cosem_groups(dlms_cfg *cfg, cosem_object **cosem_objects, size_t cosem_object_count, size_t *cosem_group_count);
+PRIVATE cosem_group *cfg_get_cosem_group(dlms_cfg *cfg, cosem_group_cfg *cosem_group_cfg, cosem_object **cosem_objects, size_t cosem_object_count);
+
+PRIVATE int cfg_init_mutexes(master *m);
+PRIVATE int cfg_init_mutex(pthread_mutex_t **mutex);
+
+PRIVATE void cfg_free_dlms_cfg(dlms_cfg *dlms);
+PRIVATE void cfg_free_connection_cfg(connection_params_cfg *conn);
+PRIVATE void cfg_free_physical_device_cfg(physical_device_cfg *dev);
+PRIVATE void cfg_free_cosem_object_cfg(cosem_object_cfg *cosem);
+PRIVATE void cfg_free_cosem_group_cfg(cosem_group_cfg *group);
+
+PRIVATE void cfg_free_connection(connection *c);
+PRIVATE void cfg_free_physical_device(physical_device *d);
+PRIVATE void cfg_free_cosem_object(cosem_object *o);
+PRIVATE void cfg_free_cosem_group(cosem_group *g);
+
+PUBLIC master *cfg_get_master()
+{
+	dlms_cfg *cfg = NULL;
+	master *m     = NULL;
+
+	cfg = cfg_read_dlms_cfg();
+	if (!cfg) {
+		log(L_ERROR, "Failed to read configuration file");
+		return NULL;
+	}
+
+	SEPARATOR
+	log(L_INFO, "Configuration read successfully, transfering data to main struct");
+
+	m = cfg_read_master(cfg);
+	if (!m) {
+		log(L_ERROR, "Failed to initiate main struct");
+		goto err;
+	}
+
+	log(L_INFO, "Data transfer to main struct is complete");
+
+	if (cfg_init_mutexes(m)) {
+		log(L_ERROR, "Failed to initiate mutexes");
+		goto err;
+	}
+
+	cfg_free_dlms_cfg(cfg);
+	return m;
+err:
+	cfg_free_dlms_cfg(cfg);
+	cfg_free_master(m);
+	return NULL;
+}
+
+PRIVATE dlms_cfg *cfg_read_dlms_cfg()
+{
+	struct uci_context *uci	 = NULL;
+	struct uci_package *pkg	 = NULL;
+	struct uci_element *elem = NULL;
+	dlms_cfg *cfg		 = NULL;
+
+	cfg = calloc(1, sizeof(dlms_cfg));
+	if (!cfg) {
+		log(L_ERROR, "Failed to allocate memory for dlms_cfg struct");
+		return NULL;
+	}
+
+	uci = uci_alloc_context();
+	if (!uci) {
+		log(L_ERROR, "Failed to allocate uci context");
+		goto err;
+	}
+
+	uci_load(uci, CFG_NAME, &pkg);
+	if (!pkg) {
+		log(L_ERROR, "Failed to find uci package %s", CFG_NAME);
+		goto err;
+	}
+
+	uci_foreach_element (&pkg->sections, elem) {
+		struct uci_section *section = uci_to_section(elem);
+		if (strcmp(section->type, "connection")) {
+			continue;
+		}
+
+		connection_params_cfg *conn = cfg_read_connection(uci, section);
+		if (conn) {
+			cfg->connections = realloc(cfg->connections, (cfg->connection_cfg_count + 1) * sizeof(connection_params_cfg));
+			cfg->connections[cfg->connection_cfg_count++] = conn;
+		}
+
+		if (cfg->connection_cfg_count >= MAX_CONNECTIONS_COUNT) {
+			log(L_NOTICE, "Reached connections limit, breaking");
+			break;
+		}
+	}
+
+	if(!cfg->connection_cfg_count) {
+		log(L_ERROR, "Failed to find any 'connections' sections");
+		goto err;
+	}
+
+	uci_foreach_element (&pkg->sections, elem) {
+		struct uci_section *section = uci_to_section(elem);
+		if (strcmp(section->type, "physical_device")) {
+			continue;
+		}
+
+		physical_device_cfg *dev = cfg_read_physical_device(uci, section);
+		if (dev) {
+			cfg->physical_devices = realloc(cfg->physical_devices, (cfg->physical_device_cfg_count + 1) * sizeof(physical_device_cfg));
+			cfg->physical_devices[cfg->physical_device_cfg_count++] = dev;
+		}
+
+		if (cfg->physical_device_cfg_count >= MAX_PHYSICAL_DEVICES_COUNT) {
+			log(L_NOTICE, "Reached physical devices limit, breaking");
+			break;
+		}
+	}
+
+	if(!cfg->physical_device_cfg_count) {
+		log(L_ERROR, "Failed to find any physical device sections");
+		goto err;
+	}
+
+	uci_foreach_element (&pkg->sections, elem) {
+		struct uci_section *section = uci_to_section(elem);
+		if (strcmp(section->type, "cosem")) {
+			continue;
+		}
+
+		cosem_object_cfg *cosem = cfg_read_cosem_object(uci, section);
+		if (cosem) {
+			cfg->cosem_objects = realloc(cfg->cosem_objects, (cfg->cosem_object_cfg_count + 1) * sizeof(cosem_object_cfg));
+			cfg->cosem_objects[cfg->cosem_object_cfg_count++] = cosem;
+		}
+	}
+
+	uci_foreach_element (&pkg->sections, elem) {
+		struct uci_section *section = uci_to_section(elem);
+		if (strcmp(section->type, "cosem_group")) {
+			continue;
+		}
+
+		cosem_group_cfg *cosem_group = cfg_read_cosem_group(uci, section);
+		if (cosem_group) {
+			cfg->cosem_groups = realloc(cfg->cosem_groups, (cfg->cosem_group_cfg_count + 1) * sizeof(cosem_group_cfg));
+			cfg->cosem_groups[cfg->cosem_group_cfg_count++] = cosem_group;
+		}
+
+		if (cfg->cosem_group_cfg_count >= MAX_COSEM_GROUPS_COUNT) {
+			log(L_NOTICE, "Reached COSEM group limit, breaking");
+			break;
+		}
+	}
+
+	uci_free_context(uci);
+	return cfg;
+err:
+	cfg_free_dlms_cfg(cfg);
+	uci_free_context(uci);
+	return NULL;
+}
+
+PRIVATE connection_params_cfg *cfg_read_connection(struct uci_context *uci, struct uci_section *section)
+{
+	SEPARATOR
+	connection_params_cfg *connection_params = NULL;
+	const char *section_id			 = NULL;
+
+	connection_params = calloc(1, sizeof(connection_params_cfg));
+	if (!connection_params) {
+		log(L_ERROR, "Failed to allocate memory for connection_params struct");
+		return NULL;
+	}
+
+	if (!section->e.name) {
+		log(L_ERROR, "Failed to find section name");
+		goto err;
+	}
+
+	section_id = section->e.name;
+	log(L_NOTICE, "Reading connection ('%s')", section_id);
+
+	connection_params->id = strtol(section->e.name, NULL, 10);
+	if (!connection_params->id) {
+		log(L_ERROR, "Section ID can not be 0");
+		goto err;
+	}
+
+	connection_params->enabled = ucix_get_option_int(uci, CFG_NAME, section_id, "enabled", 0);
+	if (!connection_params->enabled) {
+		log(L_ERROR, "Connection object ('%d') is disabled", connection_params->id);
+		goto err;
+	}
+
+	connection_params->name = ucix_get_option_cfg(uci, CFG_NAME, section_id, "name");
+	if (!connection_params->name) {
+		log(L_ERROR, "Option 'name' cannot be empty");
+		goto err;
+	}
+
+	connection_params->type = ucix_get_option_int(uci, CFG_NAME, section_id, "connection_type", 0);
+	if (connection_params->type < 0 || connection_params->type > 1) {
+		log(L_ERROR, "Option 'type' (%d) is outside range [0;1]", connection_params->type);
+		goto err;
+	}
+
+	if (connection_params->type == TCP_CFG) {
+		connection_params->parameters.tcp.host =
+			ucix_get_option_cfg(uci, CFG_NAME, section_id, "address");
+		if (!connection_params->parameters.tcp.host) {
+			log(L_ERROR, "Option 'host' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.tcp.port =
+			ucix_get_option_int(uci, CFG_NAME, section_id, "port", 0);
+		if ((connection_params->parameters.tcp.port < 1 ||
+		     connection_params->parameters.tcp.port > 65535)) {
+			log(L_ERROR, "Option 'port' cannot be empty [1;65535]");
+			goto err;
+		}
+	} else if (connection_params->type == SERIAL_CFG) {
+		connection_params->parameters.serial.device =
+			ucix_get_option_cfg(uci, CFG_NAME, section_id, "device");
+		if (!connection_params->parameters.serial.device) {
+			log(L_ERROR, "Option 'device' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.serial.baudrate =
+			ucix_get_option_int(uci, CFG_NAME, section_id, "baudrate", 0);
+		if (!connection_params->parameters.serial.baudrate) {
+			log(L_ERROR, "Option 'baudrate' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.serial.databits =
+			ucix_get_option_int(uci, CFG_NAME, section_id, "databits", 0);
+		if (connection_params->parameters.serial.databits < 5 ||
+		    connection_params->parameters.serial.databits > 8) {
+			log(L_ERROR, "Option 'databits' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.serial.stopbits =
+			ucix_get_option_int(uci, CFG_NAME, section_id, "stopbits", 0);
+		if (connection_params->parameters.serial.stopbits < 1 ||
+		    connection_params->parameters.serial.stopbits > 2) {
+			log(L_ERROR, "Option 'stopbits' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.serial.parity =
+			ucix_get_option_cfg(uci, CFG_NAME, section_id, "parity");
+		if (!connection_params->parameters.serial.parity) {
+			log(L_ERROR, "Option 'parity' cannot be empty");
+			goto err;
+		}
+
+		connection_params->parameters.serial.flow_control =
+			ucix_get_option_cfg(uci, CFG_NAME, section_id, "flowcontrol");
+		if (!connection_params->parameters.serial.flow_control) {
+			log(L_ERROR, "Option 'flowcontrol' cannot be empty");
+			goto err;
+		}
+	}
+
+	connection_params->wait_time = 5000;
+
+	log(L_NOTICE, "Connection ('%s', '%s') successfully added", section_id, UTL_SAFE_STR(connection_params->name));
+	return connection_params;
+err:
+	log(L_NOTICE, "Failed to add connection ('%s', '%s')", section_id, UTL_SAFE_STR(connection_params->name));
+	cfg_free_connection_cfg(connection_params);
+	return NULL;
+}
+
+PRIVATE physical_device_cfg *cfg_read_physical_device(struct uci_context *uci, struct uci_section *section)
+{
+	SEPARATOR
+	physical_device_cfg *dev   = NULL;
+	const char *section_id	   = NULL;
+
+	dev = calloc(1, sizeof(physical_device_cfg));
+	if (!dev) {
+		log(L_ERROR, "Failed to allocate memory for physical device struct");
+		return NULL;
+	}
+
+	if (!section->e.name) {
+		log(L_ERROR, "Failed to find section name");
+		goto err;
+	}
+
+	section_id = section->e.name;
+	log(L_NOTICE, "Reading physical device ('%s')", section_id);
+
+	dev->id = strtol(section->e.name, NULL, 10);
+	if (!dev->id) {
+		log(L_ERROR, "Section ID can not be 0");
+		goto err;
+	}
+
+	dev->enabled = ucix_get_option_int(uci, CFG_NAME, section_id, "enabled", 0);
+	dev->name = ucix_get_option_cfg(uci, CFG_NAME, section_id, "name");
+	if (!dev->name) {
+		log(L_ERROR, "Option 'name' cannot be empty");
+		goto err;
+	}
+
+	dev->server_address = ucix_get_option_int(uci, CFG_NAME, section_id, "server_addr", 0);
+	if (dev->server_address < 0) {
+		log(L_ERROR, "Option 'server_addr' cannot be < 0");
+		goto err;
+	}
+
+	dev->logical_server_address = ucix_get_option_int(uci, CFG_NAME, section_id, "log_server_addr", 0);
+	if (dev->logical_server_address < 0) {
+		log(L_ERROR, "Option 'server_addr' cannot be < 0");
+		goto err;
+	}
+
+	dev->client_address = ucix_get_option_int(uci, CFG_NAME, section_id, "client_addr", 0);
+	if (dev->client_address < 0) {
+		log(L_ERROR, "Option 'client_addr' cannot be < 0");
+		goto err;
+	}
+
+	// TODO: this won't be visible for now;
+	// by default use logical name referencing
+	dev->logical_name_ref = ucix_get_option_int(uci, CFG_NAME, section_id, "use_ln_ref", 1);
+	if (dev->logical_name_ref < 0 || dev->logical_name_ref > 1) {
+		log(L_ERROR, "Option 'logical_name_ref' (%d) is outside range [0;1]", dev->logical_name_ref);
+		goto err;
+	}
+
+	dev->connection = ucix_get_option_int(uci, CFG_NAME, section_id, "connection", 0);
+	if (!dev->connection) {
+		log(L_ERROR, "Option 'connection' can not be 0");
+		goto err;
+	}
+
+	dev->access_security = ucix_get_option_int(uci, CFG_NAME, section_id, "access_security", 0);
+	if (!dev->access_security) {
+		log(L_NOTICE, "Option 'access_security'is NONE");
+	}
+
+	dev->interface_type = ucix_get_option_int(uci, CFG_NAME, section_id, "interface", 0);
+	if (!dev->interface_type) {
+		log(L_NOTICE, "Option 'interface_type' is HDLC");
+	}
+
+	dev->password = ucix_get_option_cfg(uci, CFG_NAME, section_id, "password");
+	if (!dev->password) {
+		log(L_NOTICE, "Option 'password' is empty");
+	}
+
+	dev->transport_security = ucix_get_option_int(uci, CFG_NAME, section_id, "transport_security", 0);
+	if (!dev->transport_security) {
+		log(L_NOTICE, "Option 'transport_security' is NONE");
+	}
+
+	dev->authentication_key = ucix_get_option_cfg(uci, CFG_NAME, section_id, "authentication_key");
+	if (!dev->authentication_key) {
+		log(L_NOTICE, "Option 'authentication_key' is empty or value is invalid");
+	}
+
+	dev->block_cipher_key = ucix_get_option_cfg(uci, CFG_NAME, section_id, "block_cipher_key");
+	if (!dev->block_cipher_key) {
+		log(L_NOTICE, "Option 'block_cipher_key' is empty or value is invalid");
+	}
+
+	dev->dedicated_key = ucix_get_option_cfg(uci, CFG_NAME, section_id, "dedicated_key");
+	if (!dev->dedicated_key) {
+		log(L_NOTICE, "Option 'dedicated_key' is empty or value is invalid");
+	}
+
+	dev->invocation_counter = ucix_get_option_cfg(uci, CFG_NAME, section_id, "invocation_counter");
+	if (!dev->invocation_counter) {
+		log(L_NOTICE, "Option 'invocation_counter' is empty");
+	}
+
+	log(L_NOTICE, "Physical device ('%s', '%s') is successfully added", section_id, UTL_SAFE_STR(dev->name));
+	return dev;
+err:
+	log(L_NOTICE, "Failed to add physical device ('%s', '%s')", section_id, UTL_SAFE_STR(dev->name));
+	cfg_free_physical_device_cfg(dev);
+	return NULL;
+}
+
+PRIVATE cosem_object_cfg *cfg_read_cosem_object(struct uci_context *uci, struct uci_section *section)
+{
+	SEPARATOR
+	cosem_object_cfg *cosem = NULL;
+	const char *section_id	= NULL;
+
+	cosem = calloc(1, sizeof(cosem_object_cfg));
+	if (!cosem) {
+		log(L_ERROR, "Failed to allocate memory for cosem struct");
+		return NULL;
+	}
+
+	if (!section->e.name) {
+		log(L_ERROR, "Failed to find section name");
+		goto err;
+	}
+
+	section_id = section->e.name;
+	log(L_NOTICE, "Reading COSEM object ('%s')", section_id);
+
+	cosem->id = strtol(section->e.name, NULL, 10);
+	if (!cosem->id) {
+		log(L_ERROR, "Section ID can not be 0");
+		goto err;
+	}
+
+	cosem->enabled = ucix_get_option_int(uci, CFG_NAME, section_id, "enabled", 0);
+	if (!cosem->enabled) {
+		log(L_ERROR, "COSEM object ('%d') is disabled", cosem->id);
+		goto err;
+	}
+
+	cosem->name = ucix_get_option_cfg(uci, CFG_NAME, section_id, "name");
+	if (!cosem->name) {
+		log(L_ERROR, "Option 'name' can not be empty");
+		goto err;
+	}
+
+	cosem->obis = ucix_get_option_cfg(uci, CFG_NAME, section_id, "obis");
+	if (!cosem->obis) {
+		log(L_ERROR, "Option 'OBIS' can not be empty");
+		goto err;
+	}
+
+	cosem->cosem_id = ucix_get_option_int(uci, CFG_NAME, section_id, "cosem_id", 0);
+	if (!utl_validate_cosem_id(cosem->cosem_id)) {
+		log(L_ERROR, "Option 'cosem_id' (%d) is not supported", cosem->cosem_id);
+		goto err;
+	}
+
+	if (cosem->cosem_id == DLMS_OBJECT_TYPE_PROFILE_GENERIC) {
+		cosem->entries = ucix_get_option_int(uci, CFG_NAME, section_id, "entries", 0);
+		if (cosem->entries < 1) {
+			log(L_ERROR, "Option 'entries' (%d) can not be < 1", cosem->entries);
+			goto err;
+		}
+	}
+
+	cosem->physical_devices = ucix_get_list_option(uci, CFG_NAME, section_id, "physical_device");
+	if (!cosem->physical_devices) {
+		log(L_ERROR, "Option 'physical_devices' (%s) can not be empty", cosem->physical_devices);
+		goto err;
+	}
+
+	cosem->cosem_group = ucix_get_option_int(uci, CFG_NAME, section_id, "cosem_group", 0);
+	if (!cosem->cosem_group) {
+		log(L_ERROR, "Option 'cosem_group' (%d) can not be 0", cosem->cosem_group);
+		goto err;
+	}
+
+	log(L_NOTICE, "COSEM object ('%s', '%s') successfully added", section_id, UTL_SAFE_STR(cosem->name));
+	return cosem;
+err:
+	log(L_NOTICE, "Failed to add COSEM object ('%s', '%s')", section_id, UTL_SAFE_STR(cosem->name));
+	cfg_free_cosem_object_cfg(cosem);
+	return NULL;
+}
+
+PRIVATE cosem_group_cfg *cfg_read_cosem_group(struct uci_context *uci, struct uci_section *section)
+{
+	SEPARATOR
+	cosem_group_cfg *cosem_group = NULL;
+	const char *section_id	     = NULL;
+
+	cosem_group = calloc(1, sizeof(cosem_group_cfg));
+	if (!cosem_group) {
+		log(L_ERROR, "Failed to allocate memory for cosem_group struct");
+		return NULL;
+	}
+
+	if (!section->e.name) {
+		log(L_ERROR, "Failed to find section name");
+		goto err;
+	}
+
+	section_id = section->e.name;
+	log(L_NOTICE, "Reading COSEM group ('%s')", section_id);
+
+	cosem_group->id = strtol(section->e.name, NULL, 10);
+	if (!cosem_group->id) {
+		log(L_ERROR, "Section ID can not be 0");
+		goto err;
+	}
+
+	cosem_group->enabled = ucix_get_option_int(uci, CFG_NAME, section_id, "enabled", 0);
+	if (!cosem_group->enabled) {
+		log(L_ERROR, "COSEM group ('%d') is disabled", cosem_group->id);
+		goto err;
+	}
+
+	cosem_group->name = ucix_get_option_cfg(uci, CFG_NAME, section_id, "name");
+	if (!cosem_group->name) {
+		log(L_ERROR, "Option 'name' can not be empty");
+		goto err;
+	}
+
+	cosem_group->interval = ucix_get_option_int(uci, CFG_NAME, section_id, "interval", 1);
+	if (cosem_group->interval < 1) {
+		log(L_ERROR, "Option 'interval' (%ld) can not be < 1", cosem_group->interval);
+		goto err;
+	}
+
+	log(L_NOTICE, "COSEM group ('%s', '%s') is successfully added", section_id, UTL_SAFE_STR(cosem_group->name));
+	return cosem_group;
+err:
+	log(L_NOTICE, "Failed to add COSEM group ('%s', '%s')", section_id, UTL_SAFE_STR(cosem_group->name));
+	cfg_free_cosem_group_cfg(cosem_group);
+	return NULL;
+}
+
+PRIVATE master *cfg_read_master(dlms_cfg *cfg)
+{
+	master *m		  = NULL;
+	size_t connection_count	  = 0;
+	size_t physical_dev_count = 0;
+	size_t cosem_object_count = 0;
+	size_t cosem_group_count  = 0;
+
+	m = calloc(1, sizeof(master));
+	if (!m) {
+		log(L_ERROR, "Failed to allocate memory for main struct");
+		return NULL;
+	}
+
+	connection **connections = cfg_get_connections(cfg, &connection_count);
+	if (!connections) {
+		log(L_ERROR, "Failed to transfer connections from dlms_cfg to main");
+		return NULL;
+	}
+
+	physical_device **physical_devices =
+		cfg_get_physical_devices(cfg, connections, connection_count, &physical_dev_count);
+	if (!physical_devices) {
+		log(L_ERROR, "Failed to transfer physical devices from dlms_cfg to main");
+		return NULL;
+	}
+
+	cosem_object **cosem_objects =
+		cfg_get_cosem_objects(cfg, physical_devices, physical_dev_count, &cosem_object_count);
+	cosem_group **cosem_groups =
+		cfg_get_cosem_groups(cfg, cosem_objects, cosem_object_count, &cosem_group_count);
+
+	m->connections	      = connections;
+	m->connection_count   = connection_count;
+
+	m->physical_devices   = physical_devices;
+	m->physical_dev_count = physical_dev_count;
+
+	m->cosem_groups	      = cosem_groups;
+	m->cosem_group_count  = cosem_group_count;
+
+	m->cosem_object_count = cosem_object_count;
+	m->cosem_objects      = cosem_objects;
+
+	return m;
+}
+
+PRIVATE connection **cfg_get_connections(dlms_cfg *cfg, size_t *connection_count)
+{
+	connection **connections = calloc(cfg->connection_cfg_count, sizeof(connection *));
+	if (!connections) {
+		log(L_ERROR, "Failed to allocate memory for connections struct");
+		return NULL;
+	}
+
+	for (size_t i = 0; i < cfg->connection_cfg_count; i++) {
+		connection *conn = cfg_get_connection(cfg->connections[i]);
+		if (conn) {
+			connections[(*connection_count)++] = conn;
+		}
+	}
+
+	if (!(*connection_count)) {
+		free(connections);
+		return NULL;
+	}
+
+	return connections;
+}
+
+PRIVATE connection *cfg_get_connection(connection_params_cfg *cfg)
+{
+	connection *conn = calloc(1, sizeof(connection));
+	if (!conn) {
+		log(L_ERROR, "Failed to allocate memory for connection struct");
+		return NULL;
+	}
+
+	conn->enabled = conn->enabled;
+	conn->type    = cfg->type;
+	conn->id      = cfg->id;
+	conn->name    = strdup(cfg->name);
+
+	if (cfg->type == TCP_CFG) {
+		conn->parameters.tcp.host = strdup(cfg->parameters.tcp.host);
+		conn->parameters.tcp.port = cfg->parameters.tcp.port;
+	} else if (cfg->type == SERIAL_CFG) {
+		conn->parameters.serial.device	     = strdup(cfg->parameters.serial.device);
+		conn->parameters.serial.baudrate     = cfg->parameters.serial.baudrate;
+		conn->parameters.serial.parity	     = strdup(cfg->parameters.serial.parity);
+		conn->parameters.serial.flow_control = strdup(cfg->parameters.serial.flow_control);
+		conn->parameters.serial.databits     = cfg->parameters.serial.databits;
+		conn->parameters.serial.stopbits     = cfg->parameters.serial.stopbits;
+	} else {
+		log(L_ERROR, "Connection ('%d', '%s') has invalid connection type", conn->id, UTL_SAFE_STR(conn->name));
+		goto err;
+	}
+
+	conn->socket	= -1;
+	conn->wait_time = cfg->wait_time;
+
+	bb_init(&conn->data);
+	bb_capacity(&conn->data, 500);
+
+	return conn;
+err:
+	free(conn->name);
+	free(conn);
+	return NULL;
+}
+
+PRIVATE physical_device **cfg_get_physical_devices(dlms_cfg *cfg, connection **connections, size_t connection_count, size_t *physical_dev_count)
+{
+	physical_device **devices = calloc(cfg->physical_device_cfg_count, sizeof(physical_device *));
+	if (!devices) {
+		log(L_ERROR, "Failed to allocate memory for devices struct");
+		return NULL;
+	}
+
+	for (size_t i = 0; i < cfg->physical_device_cfg_count; i++) {
+		physical_device *dev = cfg_get_physical_device(cfg->physical_devices[i], connections, connection_count);
+		if (dev) {
+			devices[(*physical_dev_count)++] = dev;
+		}
+	}
+
+	if (!(*physical_dev_count)) {
+		free(devices);
+		return NULL;
+	}
+
+	return devices;
+}
+
+PRIVATE physical_device *cfg_get_physical_device(physical_device_cfg *cfg, connection **connections, size_t connection_count)
+{
+	physical_device *dev = calloc(1, sizeof(physical_device));
+	if (!dev) {
+		log(L_ERROR, "Failed to allocate memory for device struct");
+		return NULL;
+	}
+
+	dev->enabled = cfg->enabled;
+	dev->id	     = cfg->id;
+	dev->name    = strdup(cfg->name);
+	if (cfg->invocation_counter) {
+		dev->invocation_counter = strdup(cfg->invocation_counter);
+	}
+
+	// find connection for device
+	for (size_t i = 0; i < connection_count; i++) {
+		if (connections[i]->id == cfg->connection) {
+			dev->connection = connections[i];
+			break;
+		}
+	}
+
+	if (!dev->connection) {
+		log(L_ERROR, "Physical device does not contain connection");
+		goto err;
+	}
+
+	cfg->server_address = cl_getServerAddress(cfg->logical_server_address, cfg->server_address, 0);
+	cl_init(&dev->settings, cfg->logical_name_ref, cfg->client_address, cfg->server_address,
+		cfg->access_security, cfg->password, cfg->interface_type);
+
+	dev->settings.cipher.security = cfg->transport_security;
+
+	if (cfg->authentication_key) {
+		bb_clear(&dev->settings.cipher.authenticationKey);
+		bb_addHexString(&dev->settings.cipher.authenticationKey, cfg->authentication_key);
+	}
+
+	if (cfg->block_cipher_key) {
+		bb_clear(&dev->settings.cipher.blockCipherKey);
+		bb_addHexString(&dev->settings.cipher.blockCipherKey, cfg->block_cipher_key);
+	}
+
+	if (cfg->dedicated_key) {
+		dev->settings.cipher.dedicatedKey = (gxByteBuffer *)calloc(1, sizeof(gxByteBuffer));
+		bb_init(dev->settings.cipher.dedicatedKey);
+		bb_addHexString(dev->settings.cipher.dedicatedKey, cfg->dedicated_key);
+	}
+
+	return dev;
+err:
+	free(dev->name);
+	free(dev->invocation_counter);
+	free(dev);
+	return NULL;
+}
+
+PRIVATE cosem_object **cfg_get_cosem_objects(dlms_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count, size_t *cosem_object_count)
+{
+	cosem_object **cosem_objects = calloc(cfg->cosem_object_cfg_count, sizeof(cosem_object *));
+	if (!cosem_objects) {
+		log(L_ERROR, "Failed to allocate memory for COSEM objects struct");
+		return NULL;
+	}
+
+	for (size_t i = 0; i < cfg->cosem_object_cfg_count; i++) {
+		cosem_object *obj = cfg_get_cosem_object(cfg->cosem_objects[i], physical_devices, physical_dev_count);
+		if (obj) {
+			cosem_objects[(*cosem_object_count)++] = obj;
+		}
+	}
+
+	if (!(*cosem_object_count)) {
+		free(cosem_objects);
+		return NULL;
+	}
+
+	return cosem_objects;
+}
+
+PRIVATE cosem_object *cfg_get_cosem_object(cosem_object_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count)
+{
+	cosem_object *obj = calloc(1, sizeof(cosem_object));
+	if (!obj) {
+		log(L_ERROR, "Failed to allocate memory for COSEM object struct");
+		return NULL;
+	}
+
+	obj->enabled = cfg->enabled;
+	obj->id	     = cfg->id;
+	obj->name    = strdup(cfg->name);
+	obj->entries = cfg->entries;
+
+	// find devices for COSEM object
+	char *tok_save = NULL;
+	for (char *tok = strtok_r(cfg->physical_devices, " ", &tok_save); tok; tok = strtok_r(NULL, " ", &tok_save)) {
+		int physical_dev_id = strtol(tok, NULL, 10);
+		for (size_t i = 0; i < physical_dev_count; i++) {
+			if (physical_devices[i]->id == physical_dev_id) {
+				obj->devices = realloc(obj->devices, (obj->device_count + 1) * sizeof(physical_device *));
+				obj->devices[obj->device_count++] = physical_devices[i];
+			}
+		}
+	}
+
+	if (!obj->devices) {
+		log(L_ERROR, "COSEM object ('%d', '%s') does not contain any physical devices", obj->id, UTL_SAFE_STR(obj->name));
+		goto err;
+	}
+
+	if (cosem_createObject2(cfg->cosem_id, cfg->obis, &obj->object)) {
+		log(L_ERROR, "Failed to create COSEM object ('%d', '%s')", obj->id, UTL_SAFE_STR(obj->name));
+		goto err;
+	}
+
+	if (utl_is_logical_name(cfg->obis)) {
+		if (cosem_init(obj->object, cfg->cosem_id, cfg->obis)) {
+			log(L_ERROR, "Failed to init COSEM object ('%d', '%s')", obj->id, UTL_SAFE_STR(obj->name));
+			goto err;
+		}
+	} else {
+		obj->object->shortName = strtol(cfg->obis, NULL, 10);
+	}
+
+	return obj;
+err:
+	free(obj->name);
+	free(obj);
+	return NULL;
+}
+
+PRIVATE cosem_group **cfg_get_cosem_groups(dlms_cfg *cfg, cosem_object **cosem_objects, size_t cosem_object_count, size_t *cosem_group_count)
+{
+	cosem_group **cosem_groups = calloc(cfg->cosem_group_cfg_count, sizeof(cosem_group *));
+	if (!cosem_groups) {
+		log(L_ERROR, "Failed to allocate memory for COSEM groups struct");
+		return NULL;
+	}
+
+	for (size_t i = 0; i < cfg->cosem_group_cfg_count; i++) {
+		cosem_group *group = cfg_get_cosem_group(cfg, cfg->cosem_groups[i], cosem_objects, cosem_object_count);
+		if (group) {
+			cosem_groups[(*cosem_group_count)++] = group;
+		}
+	}
+
+	if (!(*cosem_group_count)) {
+		free(cosem_groups);
+		return NULL;
+	}
+
+	return cosem_groups;
+}
+
+PRIVATE cosem_group *cfg_get_cosem_group(dlms_cfg *cfg, cosem_group_cfg *cosem_group_cfg,
+					cosem_object **cosem_objects, size_t cosem_object_count)
+{
+	cosem_group *group = calloc(1, sizeof(cosem_group));
+	if (!group) {
+		log(L_ERROR, "Failed to allocate memory for COSEM group struct");
+		return NULL;
+	}
+
+	group->enabled	= cosem_group_cfg->enabled;
+	group->id	= cosem_group_cfg->id;
+	group->name	= strdup(cosem_group_cfg->name);
+	group->interval = cosem_group_cfg->interval;
+
+	// find COSEM objects for cosem_group
+	for (size_t i = 0; i < cosem_object_count; i++) {
+		for (size_t j = 0; j < cfg->cosem_object_cfg_count; j++) {
+			if ((cosem_objects[i]->id == cfg->cosem_objects[j]->id) &&
+			    (cfg->cosem_objects[i]->cosem_group == group->id)) {
+				group->cosem_objects = realloc(group->cosem_objects, (group->cosem_object_count + 1) * sizeof(cosem_object *));
+				group->cosem_objects[group->cosem_object_count++] = cosem_objects[i];
+			}
+		}
+
+		if (group->cosem_object_count >= MAX_COSEM_OBJECTS_COUNT) {
+			log(L_NOTICE, "Reached COSEM object limit for a group ('%d'), breaking", group->id);
+			break;
+		}
+	}
+
+	if (!group->cosem_objects) {
+		log(L_ERROR, "COSEM group ('%d', '%s') does not contain any COSEM objects", group->id, UTL_SAFE_STR(group->name));
+		goto err;
+	}
+
+	return group;
+err:
+	free(group->name);
+	free(group);
+	return NULL;
+}
+
+PRIVATE int cfg_init_mutexes(master *m)
+{
+	for (size_t i = 0; i < m->connection_count; i++) {
+		connection *c		       = m->connections[i];
+		pthread_mutex_t **mutex_target = NULL;
+		if (c->type == TCP) {
+			mutex_target = &c->mutex;
+		} else {
+			mutex_target = (strstr(c->parameters.serial.device, "rs485")) ? &m->mutex_rs485 : &m->mutex_rs232;
+		}
+
+		if (cfg_init_mutex(mutex_target)) {
+			log(L_ERROR, "Failed to initialize connection ('%d') mutex", c->id);
+			return 1;
+		}
+		c->mutex = *mutex_target;
+	}
+
+	return 0;
+}
+
+PRIVATE int cfg_init_mutex(pthread_mutex_t **mutex)
+{
+	if (*mutex) {
+		return 0;
+	}
+
+	*mutex = calloc(1, sizeof(pthread_mutex_t));
+	if (!*mutex) {
+		log(L_ERROR, "Failed to allocate memory for mutex");
+		return 1;
+	}
+
+	if (pthread_mutex_init(*mutex, NULL)) {
+		free(*mutex);
+		*mutex = NULL;
+		return 1;
+	}
+
+	return 0;
+}
+
+PRIVATE void cfg_free_dlms_cfg(dlms_cfg *dlms)
+{
+	if (!dlms) {
+		return;
+	}
+
+	for (size_t i = 0; i < dlms->connection_cfg_count; i++) {
+		cfg_free_connection_cfg(dlms->connections[i]);
+	}
+
+	for (size_t i = 0; i < dlms->physical_device_cfg_count; i++) {
+		cfg_free_physical_device_cfg(dlms->physical_devices[i]);
+	}
+
+	for (size_t i = 0; i < dlms->cosem_object_cfg_count; i++) {
+		cfg_free_cosem_object_cfg(dlms->cosem_objects[i]);
+	}
+
+	for (size_t i = 0; i < dlms->cosem_group_cfg_count; i++) {
+		cfg_free_cosem_group_cfg(dlms->cosem_groups[i]);
+	}
+
+	free(dlms->connections);
+	free(dlms->physical_devices);
+	free(dlms->cosem_objects);
+	free(dlms->cosem_groups);
+	free(dlms);
+}
+
+PRIVATE void cfg_free_connection_cfg(connection_params_cfg *c)
+{
+	if (!c) {
+		return;
+	}
+
+	free(c->name);
+
+	if (c->type == TCP_CFG) {
+		free(c->parameters.tcp.host);
+	} else if (c->type == SERIAL_CFG) {
+		free(c->parameters.serial.device);
+		free(c->parameters.serial.parity);
+		free(c->parameters.serial.flow_control);
+	}
+
+	free(c);
+}
+
+PRIVATE void cfg_free_physical_device_cfg(physical_device_cfg *d)
+{
+	if (!d) {
+		return;
+	}
+
+	free(d->name);
+	free(d->password);
+	free(d->authentication_key);
+	free(d->block_cipher_key);
+	free(d->dedicated_key);
+	free(d->invocation_counter);
+	free(d);
+}
+
+PRIVATE void cfg_free_cosem_object_cfg(cosem_object_cfg *o)
+{
+	if (!o) {
+		return;
+	}
+
+	free(o->name);
+	free(o->physical_devices);
+	free(o->obis);
+	free(o);
+}
+
+PRIVATE void cfg_free_cosem_group_cfg(cosem_group_cfg *g)
+{
+	if (!g) {
+		return;
+	}
+
+	free(g->name);
+	free(g);
+}
+
+PUBLIC void cfg_free_master(master *m)
+{
+	if (!m) {
+		return;
+	}
+
+	for (size_t i = 0; i < m->connection_count; i++) {
+		cfg_free_connection(m->connections[i]);
+	}
+
+	for (size_t i = 0; i < m->physical_dev_count; i++) {
+		cfg_free_physical_device(m->physical_devices[i]);
+	}
+
+	for (size_t i = 0; i < m->cosem_object_count; i++) {
+		cfg_free_cosem_object(m->cosem_objects[i]);
+	}
+	
+	for (size_t i = 0; i < m->cosem_group_count; i++) {
+		cfg_free_cosem_group(m->cosem_groups[i]);
+	}
+
+	pthread_mutex_destroy(m->mutex_rs232);
+	free(m->mutex_rs232);
+	pthread_mutex_destroy(m->mutex_rs485);
+	free(m->mutex_rs485);
+
+	free(m->connections);
+	free(m->physical_devices);
+	free(m->cosem_objects);
+	free(m->cosem_groups);
+	free(m);
+}
+
+PRIVATE void cfg_free_connection(connection *c)
+{
+	if (!c) {
+		return;
+	}
+
+	free(c->name);
+	bb_clear(&c->data);
+
+	if (c->type == TCP) {
+		free(c->parameters.tcp.host);
+		pthread_mutex_destroy(c->mutex);
+		free(c->mutex);
+	} else {
+		free(c->parameters.serial.device);
+		free(c->parameters.serial.parity);
+		free(c->parameters.serial.flow_control);
+	}
+
+	free(c);
+}
+
+PRIVATE void cfg_free_physical_device(physical_device *d)
+{
+	if (!d) {
+		return;
+	}
+
+	cip_clear(&d->settings.cipher);
+	cl_clear(&d->settings);
+
+	free(d->name);
+	free(d->invocation_counter);
+	free(d);
+}
+
+PRIVATE void cfg_free_cosem_object(cosem_object *o)
+{
+	if (!o) {
+		return;
+	}
+
+	obj_clear(o->object);
+	free(o->name);
+	free(o->object);
+	free(o->devices);
+	free(o);
+}
+
+PRIVATE void cfg_free_cosem_group(cosem_group *g)
+{
+	if (!g) {
+		return;
+	}
+
+	free(g->name);
+	free(g->cosem_objects);
+	free(g);
+}
diff --recursive --unified --new-file --no-dereference orig/src/connection.c src/src/connection.c
--- orig/src/connection.c	2023-11-10 10:15:18.000000000 +0000
+++ src/src/connection.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,85 +0,0 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-
-#include "../include/connection.h"
-#include <stdlib.h> // malloc and free needs this or error is generated.
-#include <stdio.h>
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-#else
-#include <string.h> // string function definitions
-#include <unistd.h> // UNIX standard function definitions
-#include <fcntl.h> // File control definitions
-#include <errno.h> // Error number definitions
-#include <termios.h> // POSIX terminal control definitions
-#include <time.h>   // time calls
-#endif
-
-//Initialize connection buffers.
-void con_initializeBuffers(connection* connection, int size)
-{
-    if (size == 0)
-    {
-        bb_clear(&connection->data);
-    }
-    else
-    {
-        bb_capacity(&connection->data, size);
-    }
-}
-
-//Initialize connection settings.
-void con_init(connection* con, GX_TRACE_LEVEL trace)
-{
-    con->trace = trace;
-    //Reply wait time is 5 seconds.
-    con->waitTime = 5000;
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-    con->comPort = INVALID_HANDLE_VALUE;
-    memset(&con->osReader, 0, sizeof(OVERLAPPED));
-    memset(&con->osWrite, 0, sizeof(OVERLAPPED));
-    con->osReader.hEvent = CreateEvent(NULL, 1, FALSE, NULL);
-    con->osWrite.hEvent = CreateEvent(NULL, 1, FALSE, NULL);
-#else
-    con->comPort = -1;
-#endif
-    con->socket = -1;
-    con->receiverThread = -1;
-    con->closing = 0;
-    bb_init(&con->data);
-    bb_capacity(&con->data, 500);
-}
-
-//Close connection..
-void con_close(connection* con)
-{
-#if defined(_WIN32) || defined(_WIN64)//If Windows
-    con->comPort = INVALID_HANDLE_VALUE;
-#else
-    if (con->comPort != -1)
-    {
-        int ret = close(con->comPort);
-        if (ret < 0)
-        {
-            printf("Failed to close port.\r\n");
-        }
-        con->comPort = -1;
-    }
-#endif
-    con->socket = -1;
-    bb_clear(&con->data);
-    con->closing = 0;
-    con_initializeBuffers(con, 0);
-}
diff --recursive --unified --new-file --no-dereference orig/src/cosem_group.c src/src/cosem_group.c
--- orig/src/cosem_group.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/cosem_group.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,210 @@
+#include "master.h"
+
+#define BUFFER_ATTRIBUTE_INDEX 2
+
+PRIVATE int cg_read_cosem_object(cosem_object *cosem_object, physical_device *dev);
+PRIVATE int cg_format_group_data(char **data, object_attributes *attr, char *device_name);
+PRIVATE int cg_read_profile_generic_data(cosem_object *obj, gxProfileGeneric *pg, physical_device *dev);
+
+PUBLIC char *cg_read_group_codes(cosem_group *group, int *rc)
+{
+	*rc = 1;
+	char *data = NULL;
+
+	utl_append_to_str(&data, "{");
+	for (size_t i = 0; i < group->cosem_object_count; i++) {
+		cosem_object *cosem_object = group->cosem_objects[i];
+
+		log(L_DEBUG, "Reading object %zu/%zu", i + 1, group->cosem_object_count);
+
+		utl_append_obj_name(&data, cosem_object->name);
+		utl_append_to_str(&data, "{");
+		for (size_t j = 0; j < cosem_object->device_count; j++) {
+			physical_device *dev	= cosem_object->devices[j];
+			object_attributes attrs = { 0 };
+			int err			= 0;
+
+			utl_lock_mutex_if_required(dev);
+
+			err = !dev->enabled;
+			if (err) {
+				utl_add_error_message(&data, dev->name, "Physical device is disabled", err);
+				log(L_WARNING, "Physical device ('%d') is disabled!", dev->id);
+				goto loopend_without_close;
+			}
+
+			err = cg_make_connection(dev);
+			if (err != DLMS_ERROR_CODE_OK) {
+				utl_add_error_message(&data, dev->name, "Failed to make connection with device", err);
+				log(L_ERROR, "Failed to make connection with device ('%d', '%s')", dev->id, dev->name);
+				goto loopend_without_close;
+			}
+
+			err = cg_read_cosem_object(cosem_object, dev);
+			if (err != DLMS_ERROR_CODE_OK) {
+				utl_add_error_message(&data, dev->name, hlp_getErrorMessage(err), err);
+				log(L_ERROR, "Failed to read COSEM object");
+				goto loopend;
+			}
+
+			attr_init(&attrs, cosem_object->object);
+			err = attr_to_string(cosem_object->object, &attrs, dev->settings.useLogicalNameReferencing);
+			if (err != DLMS_ERROR_CODE_OK) {
+				utl_add_error_message(&data, dev->name, "Failed to get COSEM object attributes", err);
+				log(L_ERROR, "Failed to get COSEM object attributes");
+				goto loopend;
+			}
+
+			err = cg_format_group_data(&data, &attrs, dev->name);
+			if (err != DLMS_ERROR_CODE_OK) {
+				utl_add_error_message(&data, dev->name, "Failed to format read attributes", err);
+				log(L_ERROR, "Failed to format read attributes\n");
+				goto loopend;
+			}
+
+			*rc = 0;
+		loopend:
+			com_close(dev->connection, &dev->settings);
+		loopend_without_close:
+			utl_unlock_mutex_if_required(dev);
+			utl_append_if_needed(&data, j, cosem_object->device_count - 1, ",");
+			attr_free(&attrs);
+			oa_clear(&dev->settings.releasedObjects, 1);
+		}
+		utl_append_to_str(&data, "}");
+		utl_append_if_needed(&data, i, group->cosem_object_count - 1, ",");
+	}
+	utl_append_to_str(&data, "}");
+
+	return data;
+}
+
+PUBLIC int cg_make_connection(physical_device *dev)
+{
+	int ret = DLMS_ERROR_CODE_OK;
+
+	if (!dev) {
+		log(L_ERROR, "Device is null!");
+		return 1;
+	}
+
+	if (dev->connection->socket != -1) {
+		log(L_INFO, "Already connected: %d", dev->connection->socket);
+		return ret;
+	}
+
+	ret = com_open_connection(dev);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to open connection ('%d', '%s')", dev->connection->id, dev->connection->name);
+		com_close_socket(dev->connection);
+		return ret;
+	}
+
+	ret = com_update_invocation_counter(dev->connection, &dev->settings, dev->invocation_counter);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to update invocation_counter");
+		goto err;
+	}
+
+	ret = com_initialize_connection(dev->connection, &dev->settings);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to initialize connection");
+		goto err;
+	}
+
+	return ret;
+err:
+	com_close(dev->connection, &dev->settings);
+	return ret;
+}
+
+PRIVATE int cg_read_cosem_object(cosem_object *cosem_object, physical_device *dev)
+{
+	gxObject *object	= cosem_object->object;
+	gxByteBuffer attributes = { 0 };
+	unsigned char ch	= 0;
+	int ret			= DLMS_ERROR_CODE_OK;
+
+	if (dev->settings.useLogicalNameReferencing) {
+		char LN[32] = { 0 };
+		hlp_getLogicalNameToString(object->logicalName, LN);
+		log(L_INFO, "Reading object: '%s', OBIS '%s'\n", obj_typeToString2(object->objectType), LN);
+	} else {
+		log(L_INFO, "Reading object: '%s', OBIS '%d'\n", obj_typeToString2(object->objectType), cosem_object->object->shortName);
+	}
+
+	bb_init(&attributes);
+	ret = obj_getAttributeIndexToRead(object, &attributes);
+	if (ret != DLMS_ERROR_CODE_OK) {
+		log(L_ERROR, "Failed to read object. Error: %s", hlp_getErrorMessage(ret));
+		goto err;
+	}
+
+	for (unsigned long index = 0; index < attributes.size; index++) {
+		ret = bb_getUInt8ByIndex(&attributes, index, &ch);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			log(L_ERROR, "Failed to get uint by index %d", ch);
+			goto err;
+		}
+
+		log(L_INFO, "Index: %ld, Reading attribute: %d", index, ch);
+
+		if (object->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC && ch == BUFFER_ATTRIBUTE_INDEX) {
+			log(L_INFO, "Skipping profile generic 'buffer' attribute for later reading\n");
+			continue;
+		}
+
+		ret = com_read(dev->connection, &dev->settings, object, ch);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			log(L_ERROR, "Failed to read object attribute, index: %d", ch);
+
+			if ((object->objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME) &&
+			    (ret == DLMS_ERROR_CODE_ACCESS_VIOLATED || ret == DLMS_ERROR_CODE_OTHER_REASON)) {
+				log(L_ERROR, "Device reports access violation, skipping...");
+				ret = 0;
+				continue;
+			}
+
+			if (ret != DLMS_ERROR_CODE_READ_WRITE_DENIED) {
+				goto err;
+			}
+		}
+	}
+
+	if (object->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC) {
+		ret = cg_read_profile_generic_data(cosem_object, (gxProfileGeneric *)object, dev);
+		if (ret != DLMS_ERROR_CODE_OK) {
+			log(L_ERROR, "Failed to read profile generic data");
+			goto err;
+		}
+	}
+
+err:
+	bb_clear(&attributes);
+	return ret;
+}
+
+PRIVATE int cg_read_profile_generic_data(cosem_object *obj, gxProfileGeneric *pg, physical_device *dev)
+{
+	log(L_INFO, "Reading profile generic rows, total entries: %ld", pg->profileEntries);
+	int calc = pg->profileEntries - obj->entries;
+
+	return com_readRowsByEntry(dev->connection, &dev->settings, pg, calc, obj->entries + 1);
+}
+
+PRIVATE int cg_format_group_data(char **data, object_attributes *attr, char *device_name)
+{
+	char *json = attr_to_json(attr);
+	if (!json) {
+		log(L_ERROR, "Failed to format attributes to JSON");
+		return 1;
+	}
+
+	utl_append_obj_name(data, device_name);
+	utl_append_to_str(data, "{");
+	utl_append_to_str(data, json);
+	utl_append_to_str(data, "}");
+	free(json);
+
+	return 0;
+}
diff --recursive --unified --new-file --no-dereference orig/src/getopt.c src/src/getopt.c
--- orig/src/getopt.c	2023-11-10 10:15:18.000000000 +0000
+++ src/src/getopt.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,51 +0,0 @@
-/* *****************************************************************
-*
-* Copyright 2016 Microsoft
-*
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*
-******************************************************************/
-
-#include "../include/getopt.h"
-#include <string.h>
-
-char* optarg = 0;
-int optind = 1;
-
-int getopt(int argc, char *const argv[], const char *optstring)
-{
-    if ((optind >= argc) || (argv[optind][0] != '-') || (argv[optind][0] == 0))
-    {
-        return -1;
-    }
-    int opt = argv[optind][1];
-    const char *p = strchr(optstring, opt);
-
-    if (p == 0)
-    {
-        return '?';
-    }
-    ++optind;
-    if (p[1] == ':')
-    {
-        if (optind >= argc)
-        {
-            optarg = (char*)p;
-            return '?';
-        }
-        optarg = argv[optind];
-        ++optind;
-    }
-    return opt;
-}
diff --recursive --unified --new-file --no-dereference orig/src/main.c src/src/main.c
--- orig/src/main.c	2023-11-10 10:15:18.000000000 +0000
+++ src/src/main.c	2024-01-10 07:48:57.000000000 +0000
@@ -1,785 +1,59 @@
-//
-// --------------------------------------------------------------------------
-//  Gurux Ltd
-//
-//
-//
-// Filename:        $HeadURL:  $
-//
-// Version:         $Revision:  $,
-//                  $Date:  $
-//                  $Author: $
-//
-// Copyright (c) Gurux Ltd
-//
-//---------------------------------------------------------------------------
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#if defined(_WIN32) || defined(_WIN64)//Windows includes
-#include <conio.h>
-#include "../include/getopt.h"
-#include <process.h>//Add support for threads
-#if _MSC_VER > 1000
-#include <crtdbg.h>
-#endif
-//Windows doesn't implement strcasecmp. It uses strcmpi.
-#define strcasecmp _strcmpi
-#else
-#include <string.h> /* memset */
-#include <unistd.h>
-#include <strings.h>
-#endif
-
-#include "../include/communication.h"
-#include "../../development/include/gxserializer.h"
-
-//Client don't need this.
-unsigned char svr_isTarget(
-    dlmsSettings* settings,
-    unsigned long serverAddress,
-    unsigned long clientAddress)
-{
-    return 0;
-}
-
-//Client don't need this.
-int svr_connected(
-    dlmsServerSettings* settings) {
-    return 0;
-
-}
-
-//Client don't need this.
-DLMS_ACCESS_MODE svr_getAttributeAccess(
-    dlmsSettings* settings,
-    gxObject* obj,
-    unsigned char index)
-{
-    return DLMS_ACCESS_MODE_READ_WRITE;
-}
-
-//Client don't need this.
-DLMS_METHOD_ACCESS_MODE svr_getMethodAccess(
-    dlmsSettings* settings,
-    gxObject* obj,
-    unsigned char index)
-{
-    return DLMS_METHOD_ACCESS_MODE_ACCESS;
-}
+#include "master.h"
 
-/**
-* Updates clock and reads it.
-*/
-int com_updateClock(connection* connection)
-{
-    int ret;
-    gxClock clock;
-    unsigned char ln[] = { 0,0,1,0,0,255 };
-    INIT_OBJECT(clock, DLMS_OBJECT_TYPE_CLOCK, ln);
-    //Initialize connection.
-    ret = com_initializeConnection(connection);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    //Write clock.
-    time_init(&clock.time, 2000, 1, 1, 0, 0, 0, 0, 0x8000);
-    ret = com_write(connection, &clock.base, 2);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-
-    //Read clock.
-    ret = com_read(connection, &clock.base, 2);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        return ret;
-    }
-    //Print clock.
-    ret = time_print(NULL, &clock.time);
-    return ret;
-}
+master *g_master = NULL;
+log_level_type g_debug_level = L_EMERG;
 
-/**
-* Calls disconnect method.
-*/
-int disconnect(connection* connection)
+int MAIN(int argc, char **argv)
 {
-    int ret;
-    gxDisconnectControl dc;
-    unsigned char ln[] = { 0,0,96,3,10,255 };
-    INIT_OBJECT(dc, DLMS_OBJECT_TYPE_DISCONNECT_CONTROL, ln);
-    //Call Disconnect action.
-    dlmsVARIANT param;
-    GX_INT8(param) = 0;
-    ret = com_method(connection, &dc.base, 1, &param);
-    return ret;
-}
+	int rc = EXIT_FAILURE;
 
-/**
-* Update firmware of the meter.
-*
-* In image update following steps are made:
-1. Image_transfer_enabled is read.
-2. Image block size is read.
-3. image_transferred_blocks_status is read to check is image try to update before.
-4. image_transfer_initiate
-5. image_transfer_status is read.
-6. image_block_transfer
-7. image_transfer_status is read.
-8. image_transfer_status is read.
-9. image_verify is called.
-10. image_transfer_status is read.
-11. image_activate is called.
-*/
-int imageUpdate(connection* connection, char* identification, uint16_t identificationSize, unsigned char* image, uint32_t imageSize)
-{
-    int ret;
-    gxByteBuffer bb;
-    bb_init(&bb);
-    dlmsVARIANT param;
-    var_init(&param);
-    gxImageTransfer im;
-    unsigned char ln[] = { 0,0,44,0,0,255 };
-    INIT_OBJECT(im, DLMS_OBJECT_TYPE_IMAGE_TRANSFER, ln);
-
-    //1. Image_transfer_enabled is read.
-    if ((ret = com_read(connection, BASE(im), 5)) == 0 &&
-        //2. Image block size is read.
-        (ret = com_read(connection, BASE(im), 2)) == 0 &&
-        //3. image_transferred_blocks_status is read to check is image try to update before.
-        (ret = com_read(connection, BASE(im), 3)) == 0 &&
-        //4. image_transfer_initiate
-        (ret = bb_setInt8(&bb, DLMS_DATA_TYPE_STRUCTURE)) == 0 &&
-        (ret = bb_setInt8(&bb, 2)) == 0 &&
-        (ret = bb_setInt8(&bb, DLMS_DATA_TYPE_OCTET_STRING)) == 0 &&
-        (ret = hlp_setObjectCount(identificationSize, &bb)) == 0 &&
-        (ret = bb_set(&bb, identification, identificationSize)) == 0 &&
-        (ret = bb_setInt8(&bb, DLMS_DATA_TYPE_UINT32)) == 0 &&
-        (ret = bb_setInt32(&bb, imageSize)) == 0 &&
-        (ret = var_addOctetString(&param, &bb)) == 0 &&
-        (ret = com_method(connection, BASE(im), 1, &param)) == 0)
-    {
-        //5. image_transfer_status is read.
-        if ((ret = com_read(connection, BASE(im), 6)) == 0)
-        {
-            // 6. image_block_transfer
-            uint32_t count = im.imageBlockSize;
-            uint32_t blockNumber = 0;
-            while (imageSize != 0)
-            {
-                if (imageSize < im.imageBlockSize)
-                {
-                    count = imageSize;
-                }
-                bb_clear(&bb);
-                if ((ret = bb_setInt8(&bb, DLMS_DATA_TYPE_STRUCTURE)) == 0 &&
-                    (ret = bb_setInt8(&bb, 2)) == 0 &&
-                    (ret = bb_setInt8(&bb, DLMS_DATA_TYPE_UINT32)) == 0 &&
-                    (ret = bb_setInt32(&bb, blockNumber)) == 0 &&
-                    (ret = bb_setInt8(&bb, DLMS_DATA_TYPE_OCTET_STRING)) == 0 &&
-                    (ret = hlp_setObjectCount(count, &bb)) == 0 &&
-                    (ret = bb_set(&bb, image, count)) != 0 ||
-                    (ret = var_addOctetString(&param, &bb)) != 0 ||
-                    (ret = com_method(connection, BASE(im), 2, &param)) != 0)
-                {
-                    break;
-                }
-                imageSize -= count;
-                ++blockNumber;
-            }
-            if (ret == 0)
-            {
-                //7. image_transfer_status is read.
-                ret = com_read(connection, BASE(im), 6);
-                if (ret == 0)
-                {
-                    //9. image_verify is called.
-                    var_clear(&param);
-                    GX_INT8(param) = 0;
-                    if ((ret = com_method(connection, BASE(im), 3, &param)) == 0 ||
-                        ret == DLMS_ERROR_CODE_TEMPORARY_FAILURE)
-                    {
-                        while (1)
-                        {
-                            //10. image_transfer_status is read.
-                            ret = com_read(connection, BASE(im), 6);
-                            if (im.imageTransferStatus == DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_SUCCESSFUL)
-                            {
-                                break;
-                            }
-                            if (im.imageTransferStatus == DLMS_IMAGE_TRANSFER_STATUS_VERIFICATION_FAILED)
-                            {
-                                ret = DLMS_ERROR_CODE_INVALID_PARAMETER;
-                                break;
-                            }
-
-                            //Wait until image is activated.
-                            Sleep(10000);
-                        }
-                        if (ret == 0)
-                        {
-                            ret = com_read(connection, BASE(im), 6);
-                            //11. image_activate is called.
-                            ret = com_method(connection, BASE(im), 4, &param);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    bb_clear(&bb);
-    var_clear(&param);
-    return ret;
+	if (utl_parse_args(argc, argv, &g_debug_level)) {
+		fprintf(stderr, "Failed to parse arguments\n");
+		return rc;
+	}
+
+	logger_init(g_debug_level, L_TYPE_STDOUT, "dlms_client");
+
+	if (init_ubus_test_functions()) {
+		log(L_ERROR, "Failed to initiate UBUS");
+		return rc;
+	}
+
+	if (uloop_init()) {
+		log(L_ERROR, "Failed to initiate uloop");
+		goto err_free_ubus;
+	}
+
+	g_master = cfg_get_master();
+	if (!g_master) {
+		log(L_ERROR, "Failed to read configuration. Only UBUS will be initiated\n");
+		goto uloop;
+	}
+
+	// utl_debug_master(g_master);
+
+	if (mstr_create_db(g_master)) {
+		log(L_ERROR, "Failed to create database\n");
+		goto err_free_master;
+	}
+
+	if (mstr_initialize_cosem_groups(g_master)) {
+		log(L_ERROR, "Failed to initialize COSEM groups");
+		goto err_free_db;
+	}
+
+uloop:
+	if (uloop_run()) {
+		log(L_ERROR, "uloop_run returned an error");
+		goto err_free_db;
+	}
+
+	rc = 0;
+err_free_db:
+	mstr_db_free(g_master);
+err_free_master:
+	cfg_free_master(g_master);
+err_free_ubus:
+	ubus_exit();
+	return rc;
 }
-
-
-/*Read DLMS meter using TCP/IP connection.*/
-int readTcpIpConnection(
-    connection* connection,
-    const char* address,
-    const int port,
-    char* readObjects,
-    const char* invocationCounter,
-    const char* outputFile)
-{
-    int ret;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-    WSADATA wsaData;
-    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
-    {
-        // Tell the user that we could not find a usable WinSock DLL.
-        return 1;
-    }
-#endif
-    if (connection->trace > GX_TRACE_LEVEL_WARNING)
-    {
-        printf("Connecting to %s:%d\n", address, port);
-    }
-    //Make connection to the meter.
-    ret = com_makeConnect(connection, address, port, 5000);
-    if (ret != DLMS_ERROR_CODE_OK)
-    {
-        con_close(connection);
-        com_close(connection);
-        return ret;
-    }
-    if (readObjects != NULL)
-    {
-        if ((ret = com_updateInvocationCounter(connection, invocationCounter)) == 0 &&
-            (ret = com_initializeConnection(connection)) == 0 &&
-            (ret = com_getAssociationView(connection, outputFile)) == 0)
-        {
-            int index;
-            unsigned char buff[200];
-            gxObject* obj = NULL;
-            char* p2, * p = readObjects;
-            do
-            {
-                if (p != readObjects)
-                {
-                    ++p;
-                }
-
-                p2 = strchr(p, ':');
-                *p2 = '\0';
-                ++p2;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-                sscanf_s(p2, "%d", &index);
-#else
-                sscanf(p2, "%d", &index);
-#endif
-                hlp_setLogicalName(buff, p);
-                if ((ret = oa_findByLN(&connection->settings.objects, DLMS_OBJECT_TYPE_NONE, buff, &obj)) == 0)
-                {
-                    if (obj == NULL)
-                    {
-                        printf("Object '%s' not found from the association view.\n", p);
-                        break;
-                    }
-                    com_readValue(connection, obj, index);
-                }
-            } while ((p = strchr(p2, ',')) != NULL);
-        }
-    }
-    else
-    {
-        //Initialize connection.
-        if ((ret = com_updateInvocationCounter(connection, invocationCounter)) != 0 ||
-            (ret = com_initializeConnection(connection)) != 0 ||
-            (ret = com_readAllObjects(connection, outputFile)) != 0)
-            //Read all objects from the meter.
-        {
-            //Error code is returned at the end of the function.
-        }
-    }
-    //Close connection.
-    com_close(connection);
-    con_close(connection);
-    return ret;
-}
-
-/*Read DLMS meter using serial port connection.*/
-int readSerialPort(
-    connection* connection,
-    const char* port,
-    char* readObjects,
-    const char* invocationCounter,
-    const char* outputFile)
-{
-    int ret;
-    ret = com_open(connection, port);
-    if (ret == 0 && readObjects != NULL)
-    {
-        if ((ret = com_initializeOpticalHead(connection)) == 0 &&
-            (ret = com_updateInvocationCounter(connection, invocationCounter)) == 0 &&
-            (ret = com_initializeOpticalHead(connection)) == 0 &&
-            (ret = com_initializeConnection(connection)) == 0 &&
-            (ret = com_getAssociationView(connection, outputFile)) == 0)
-        {
-            int index;
-            unsigned char buff[200];
-            gxObject* obj = NULL;
-            char* p2, * p = readObjects;
-            do
-            {
-                if (p != readObjects)
-                {
-                    ++p;
-                }
-
-                p2 = strchr(p, ':');
-                *p2 = '\0';
-                ++p2;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-                sscanf_s(p2, "%d", &index);
-#else
-                sscanf(p2, "%d", &index);
-#endif
-                hlp_setLogicalName(buff, p);
-                oa_findByLN(&connection->settings.objects, DLMS_OBJECT_TYPE_NONE, buff, &obj);
-                com_readValue(connection, obj, index);
-            } while ((p = strchr(p2, ',')) != NULL);
-        }
-    }
-    else if (ret == 0)
-    {
-        //Initialize connection.
-        if ((ret = com_initializeOpticalHead(connection)) != 0 ||
-            (ret = com_updateInvocationCounter(connection, invocationCounter)) != 0 ||
-            (ret = com_initializeOpticalHead(connection)) != 0 ||
-            (ret = com_initializeConnection(connection)) != 0 ||
-            (ret = com_readAllObjects(connection, outputFile)) != 0)
-            //Read all objects from the meter.
-        {
-            //Error code is returned at the end of the function.
-        }
-    }
-    //Close connection.
-    com_close(connection);
-    con_close(connection);
-    return ret;
-}
-
-static void ShowHelp()
-{
-    printf("GuruxDlmsSample reads data from the DLMS/COSEM device.\n");
-    printf("GuruxDlmsSample -h [Meter IP Address] -p [Meter Port No] -c 16 -s 1 -r SN\n");
-    printf(" -h \t host name or IP address.\n");
-    printf(" -p \t port number or name (Example: 1000).\n");
-    printf(" -S \t serial port.\n");
-    printf(" -a \t Authentication (None, Low, High, HighMd5, HighSha1, HighGmac, HighSha256).\n");
-    printf(" -P \t Password for authentication.\n");
-    printf(" -c \t Client address. (Default: 16)\n");
-    printf(" -s \t Server address. (Default: 1)\n");
-    printf(" -n \t Server address as serial number.\n");
-    printf(" -r \t [sn, sn]\t Short name or Logican Name (default) referencing is used.\n");
-    printf(" -w \t WRAPPER profile is used. HDLC is default.\n");
-    printf(" -t \t Trace messages.\n");
-    printf(" -g \t Get selected object(s) with given attribute index. Ex -g \"0.0.1.0.0.255:1; 0.0.1.0.0.255:2\" \n");
-    printf(" -C \t Security Level. (None, Authentication, Encrypted, AuthenticationEncryption)\n");
-    printf(" -v \t Invocation counter data object Logical Name. Ex. 0.0.43.1.1.255\n");
-    printf(" -I \t Auto increase invoke ID\n");
-    printf(" -o \t Cache association view to make reading faster. Ex. -o C:\\device.bin");
-    printf(" -T \t System title that is used with chiphering. Ex -T 4775727578313233\n");
-    printf(" -A \t Authentication key that is used with chiphering. Ex -A D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF\n");
-    printf(" -B \t Block cipher key that is used with chiphering. Ex -B 000102030405060708090A0B0C0D0E0F\n");
-    printf(" -D \t Dedicated key that is used with chiphering. Ex -D 00112233445566778899AABBCCDDEEFF\n");
-    printf(" -i \t Used communication interface. Ex. -i WRAPPER.");
-    printf(" -m \t Used PLC MAC address. Ex. -m 1.");
-    printf("Example:\n");
-    printf("Read LG device using TCP/IP connection.\n");
-    printf("GuruxDlmsSample -r SN -c 16 -s 1 -h [Meter IP Address] -p [Meter Port No]\n");
-    printf("Read LG device using serial port connection.\n");
-    printf("GuruxDlmsSample -r SN -c 16 -s 1 -sp COM1 -i\n");
-    printf("Read Indian device using serial port connection.\n");
-    printf("GuruxDlmsSample -S COM1 -c 16 -s 1 -a Low -P [password]\n");
-}
-
-int connectMeter(int argc, char* argv[])
-{
-    connection con;
-    gxByteBuffer item;
-    bb_init(&item);
-    con_init(&con, GX_TRACE_LEVEL_INFO);
-    //Initialize settings using Logical Name referencing and HDLC.
-    cl_init(&con.settings, 1, 16, 1, DLMS_AUTHENTICATION_NONE, NULL, DLMS_INTERFACE_TYPE_HDLC);
-    int ret, opt = 0;
-    int port = 0;
-    char* address = NULL;
-    char* serialPort = NULL;
-    char* p, * readObjects = NULL, * outputFile = NULL;
-    int index, a, b, c, d, e, f;
-    char* invocationCounter = NULL;
-    while ((opt = getopt(argc, argv, "h:p:c:s:r:i:It:a:p:wP:g:S:C:v:T:A:B:D:l:F:o:")) != -1)
-    {
-        switch (opt)
-        {
-        case 'w':
-            con.settings.interfaceType = DLMS_INTERFACE_TYPE_WRAPPER;
-            break;
-        case 'r':
-            if (strcasecmp("sn", optarg) == 0)
-            {
-                con.settings.useLogicalNameReferencing = 0;
-            }
-            else if (strcasecmp("ln", optarg) == 0)
-            {
-                con.settings.useLogicalNameReferencing = 1;
-            }
-            else
-            {
-                printf("Invalid reference option.\n");
-                return 1;
-            }
-            break;
-        case 'h':
-            //Host address.
-            address = optarg;
-            break;
-        case 't':
-            //Trace.
-            if (strcasecmp("Error", optarg) == 0)
-                con.trace = GX_TRACE_LEVEL_ERROR;
-            else  if (strcasecmp("Warning", optarg) == 0)
-                con.trace = GX_TRACE_LEVEL_WARNING;
-            else  if (strcasecmp("Info", optarg) == 0)
-                con.trace = GX_TRACE_LEVEL_INFO;
-            else  if (strcasecmp("Verbose", optarg) == 0)
-                con.trace = GX_TRACE_LEVEL_VERBOSE;
-            else  if (strcasecmp("Off", optarg) == 0)
-                con.trace = GX_TRACE_LEVEL_OFF;
-            else
-            {
-                printf("Invalid trace option '%s'. (Error, Warning, Info, Verbose, Off)", optarg);
-                return 1;
-            }
-            break;
-        case 'p':
-            //Port.
-            port = atoi(optarg);
-            break;
-        case 'P':
-            bb_init(&con.settings.password);
-            bb_addString(&con.settings.password, optarg);
-            break;
-        case 'i':
-            //Interface
-            if (strcasecmp("HDLC", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_HDLC;
-            else  if (strcasecmp("WRAPPER", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_WRAPPER;
-            else  if (strcasecmp("HdlcModeE", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_HDLC_WITH_MODE_E;
-            else  if (strcasecmp("Plc", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_PLC;
-            else if (strcasecmp("PlcHdlc", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_PLC_HDLC;
-            else if (strcasecmp("PlcPrime", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_PLC_PRIME;
-            else if (strcasecmp("Pdu", optarg) == 0)
-                con.settings.interfaceType = DLMS_INTERFACE_TYPE_PDU;
-            else
-            {
-                printf("Invalid interface option '%s'. (HDLC, WRAPPER, HdlcModeE, Plc, PlcHdlc)", optarg);
-                return 1;
-            }
-            //Update PLC settings.
-#ifndef DLMS_IGNORE_PLC
-            plc_reset(&con.settings);
-#endif //DLMS_IGNORE_PLC
-            break;
-        case 'I':
-            // AutoIncreaseInvokeID.
-            con.settings.autoIncreaseInvokeID = 1;
-            break;
-        case 'C':
-            if (strcasecmp("None", optarg) == 0)
-            {
-                con.settings.cipher.security = DLMS_SECURITY_NONE;
-            }
-            else if (strcasecmp("Authentication", optarg) == 0)
-            {
-                con.settings.cipher.security = DLMS_SECURITY_AUTHENTICATION;
-            }
-            else if (strcasecmp("Encryption", optarg) == 0)
-            {
-                con.settings.cipher.security = DLMS_SECURITY_ENCRYPTION;
-            }
-            else if (strcasecmp("AuthenticationEncryption", optarg) == 0)
-            {
-                con.settings.cipher.security = DLMS_SECURITY_AUTHENTICATION_ENCRYPTION;
-            }
-            else
-            {
-                printf("Invalid Ciphering option '%s'. (None, Authentication, Encryption, AuthenticationEncryption)", optarg);
-                return 1;
-            }
-            break;
-        case 'T':
-            bb_clear(&con.settings.cipher.systemTitle);
-            bb_addHexString(&con.settings.cipher.systemTitle, optarg);
-            if (con.settings.cipher.systemTitle.size != 8)
-            {
-                printf("Invalid system title '%s'.", optarg);
-                return 1;
-            }
-            break;
-        case 'A':
-            bb_clear(&con.settings.cipher.authenticationKey);
-            bb_addHexString(&con.settings.cipher.authenticationKey, optarg);
-            if (con.settings.cipher.authenticationKey.size != 16)
-            {
-                printf("Invalid authentication key '%s'.", optarg);
-                return 1;
-            }
-            break;
-        case 'B':
-            bb_clear(&con.settings.cipher.blockCipherKey);
-            bb_addHexString(&con.settings.cipher.blockCipherKey, optarg);
-            if (con.settings.cipher.blockCipherKey.size != 16)
-            {
-                printf("Invalid block cipher key '%s'.", optarg);
-                return 1;
-            }
-            break;
-        case 'D':
-            con.settings.cipher.dedicatedKey = (gxByteBuffer*)malloc(sizeof(gxByteBuffer));
-            bb_init(con.settings.cipher.dedicatedKey);
-            bb_addHexString(con.settings.cipher.dedicatedKey, optarg);
-            if (con.settings.cipher.dedicatedKey->size != 16)
-            {
-                printf("Invalid dedicated key '%s'.", optarg);
-                return 1;
-            }
-            break;
-        case 'F':
-            con.settings.cipher.invocationCounter = atol(optarg);
-            break;
-        case 'o':
-            outputFile = optarg;
-            break;
-        case 'v':
-            invocationCounter = optarg;
-#if defined(_WIN32) || defined(_WIN64)//Windows
-            if ((ret = sscanf_s(optarg, "%d.%d.%d.%d.%d.%d", &a, &b, &c, &d, &e, &f)) != 6)
-#else
-            if ((ret = sscanf(optarg, "%d.%d.%d.%d.%d.%d", &a, &b, &c, &d, &e, &f)) != 6)
-#endif
-            {
-                ShowHelp();
-                return 1;
-        }
-            break;
-        case 'g':
-            //Get (read) selected objects.
-            p = optarg;
-            do
-            {
-                if (p != optarg)
-                {
-                    ++p;
-                }
-#if defined(_WIN32) || defined(_WIN64)//Windows
-                if ((ret = sscanf_s(p, "%d.%d.%d.%d.%d.%d:%d", &a, &b, &c, &d, &e, &f, &index)) != 7)
-#else
-                if ((ret = sscanf(p, "%d.%d.%d.%d.%d.%d:%d", &a, &b, &c, &d, &e, &f, &index)) != 7)
-#endif
-                {
-                    ShowHelp();
-                    return 1;
-            }
-    } while ((p = strchr(p, ',')) != NULL);
-    readObjects = optarg;
-    break;
-        case 'S':
-            serialPort = optarg;
-            break;
-        case 'a':
-            if (strcasecmp("None", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_NONE;
-            }
-            else if (strcasecmp("Low", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_LOW;
-            }
-            else if (strcasecmp("High", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_HIGH;
-            }
-            else if (strcasecmp("HighMd5", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_HIGH_MD5;
-            }
-            else if (strcasecmp("HighSha1", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_HIGH_SHA1;
-            }
-            else if (strcasecmp("HighGmac", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_HIGH_GMAC;
-            }
-            else if (strcasecmp("HighSha256", optarg) == 0)
-            {
-                con.settings.authentication = DLMS_AUTHENTICATION_HIGH_SHA256;
-            }
-            else
-            {
-                printf("Invalid Authentication option. (None, Low, High, HighMd5, HighSha1, HighGmac, HighSha256)\n");
-                return 1;
-            }
-            break;
-        case 'c':
-            con.settings.clientAddress = atoi(optarg);
-            break;
-        case 's':
-            con.settings.serverAddress = atoi(optarg);
-            break;
-        case 'l':
-            con.settings.serverAddress = cl_getServerAddress(atoi(optarg), con.settings.serverAddress, 0);
-            break;
-        case 'n':
-            //TODO: Add support for serial number. con.settings.serverAddress = cl_getServerAddress(atoi(optarg));
-            break;
-        case 'm':
-            con.settings.plcSettings.macDestinationAddress = atoi(optarg);
-            break;
-        case '?':
-        {
-            if (optarg[0] == 'c')
-            {
-                printf("Missing mandatory client option.\n");
-            }
-            else if (optarg[0] == 's')
-            {
-                printf("Missing mandatory server option.\n");
-            }
-            else if (optarg[0] == 'h')
-            {
-                printf("Missing mandatory host name option.\n");
-            }
-            else if (optarg[0] == 'p')
-            {
-                printf("Missing mandatory port option.\n");
-            }
-            else if (optarg[0] == 'r')
-            {
-                printf("Missing mandatory reference option.\n");
-            }
-            else if (optarg[0] == 'a')
-            {
-                printf("Missing mandatory authentication option.\n");
-            }
-            else if (optarg[0] == 'S')
-            {
-                printf("Missing mandatory Serial port option.\n");
-            }
-            else if (optarg[0] == 'g') {
-                printf("Missing mandatory OBIS code option.\n");
-            }
-            else if (optarg[0] == 'C') {
-                printf("Missing mandatory Ciphering option.\n");
-            }
-            else if (optarg[0] == 'v') {
-                printf("Missing mandatory invocation counter logical name option.\n");
-            }
-            else if (optarg[0] == 'T') {
-                printf("Missing mandatory system title option.");
-            }
-            else if (optarg[0] == 'A') {
-                printf("Missing mandatory authentication key option.");
-            }
-            else if (optarg[0] == 'B') {
-                printf("Missing mandatory block cipher key option.");
-            }
-            else if (optarg[0] == 'D') {
-                printf("Missing mandatory dedicated key option.");
-            }
-            else
-            {
-                return 1;
-            }
-        }
-        break;
-        default:
-            return 1;
-}
-}
-
-    if (port != 0 || address != NULL)
-    {
-        if (port == 0)
-        {
-            printf("Missing mandatory port option.\n");
-            return 1;
-        }
-        if (address == NULL)
-        {
-            printf("Missing mandatory host option.\n");
-            return 1;
-        }
-        ret = readTcpIpConnection(&con, address, port, readObjects, invocationCounter, outputFile);
-    }
-    else if (serialPort != NULL)
-    {
-        ret = readSerialPort(&con, serialPort, readObjects, invocationCounter, outputFile);
-    }
-    else
-    {
-        printf("Missing mandatory connection information for TCP/IP or serial port connection.\n");
-        return 1;
-    }
-
-    //Clear objects.
-    if (ret != 0)
-    {
-        printf("%s\n", hlp_getErrorMessage(ret));
-    }
-    else
-    {
-        printf("All items are read.\n");
-    }
-    cl_clear(&con.settings);
-    return 0;
-}
-
-int main(int argc, char* argv[])
-{
-    int ret = connectMeter(argc, argv);
-    if (ret != 0)
-    {
-        ShowHelp();
-    }
-#if defined(_WIN32) || defined(_WIN64)//Windows
-    WSACleanup();
-#if _MSC_VER > 1000
-    //Show memory leaks.
-    _CrtDumpMemoryLeaks();
-#endif //_MSC_VER
-#endif
-    return ret;
-}
-
diff --recursive --unified --new-file --no-dereference orig/src/master.c src/src/master.c
--- orig/src/master.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/master.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,161 @@
+#include "master.h"
+
+#define SQL_TABLE	  "dlms_data"
+#define DB_PATH		  "/tmp/dlms.db"
+#define DB_TIMEOUT	  30000
+#define DB_MAX_PAGE_COUNT 1024 //!< Set maximum number of pages in database (each page is 4096B)
+
+#define DB_DELETE_COUNT   100
+#define DB_DELETE_QUERY   "DELETE FROM " SQL_TABLE " WHERE id IN (SELECT id FROM dlms_data ORDER BY id ASC LIMIT " UTL_STR(DB_DELETE_COUNT) ")"
+#define DB_INSERT_QUERY	  "INSERT INTO " SQL_TABLE " VALUES (?, ?, ?, ?, ?)"
+#define DB_QUERY_MAX_SIZE -1 //!< up to the first zero terminator
+
+PRIVATE void *mstr_thread_routine(void *p);
+
+PUBLIC int mstr_create_db(master *m)
+{
+	if (!sqlite3_threadsafe()) {
+		log(L_ERROR, "SQLite3 is not thread-safe!\n");
+		goto err0;
+	}
+
+	if (sqlite3_open(DB_PATH, &m->db)) {
+		log(L_ERROR, "Failed to open database ('%s')\n", DB_PATH);
+		goto err0;
+	}
+
+	if (sqlite3_busy_timeout(m->db, DB_TIMEOUT)) {
+		log(L_ERROR, "Failed to set DB timeout: %s\n", sqlite3_errmsg(m->db));
+		goto err1;
+	}
+
+	const char *query = "CREATE TABLE IF NOT EXISTS dlms_data ("
+			    "id INTEGER PRIMARY KEY AUTOINCREMENT,"
+			    "time TIMESTAMP,"
+			    "name TEXT,"
+			    "size INT,"
+			    "data TEXT"
+			    ");";
+
+	if (sqlite3_exec(m->db, query, NULL, NULL, NULL)) {
+		log(L_ERROR, "Failed to CREATE TABLE dlms_data: %s\n", sqlite3_errmsg(m->db));
+		goto err1;
+	}
+
+	query = "CREATE TABLE IF NOT EXISTS sent_id_table ("
+		"id INTEGER PRIMARY KEY AUTOINCREMENT,"
+		"sender_id TEXT,"
+		"last_sent_id INT"
+		");";
+
+	if (sqlite3_exec(m->db, query, NULL, NULL, NULL)) {
+		log(L_ERROR, "Failed to CREATE TABLE sent_id_table: %s\n", sqlite3_errmsg(m->db));
+		goto err1;
+	}
+
+	if (sqlite3_exec(m->db, "PRAGMA max_page_count = " UTL_STR(DB_MAX_PAGE_COUNT), NULL, NULL, NULL)) {
+		log(L_ERROR, "Failed to set max page count: %s\n", sqlite3_errmsg(m->db));
+		goto err1;
+	}
+
+	if (sqlite3_prepare_v2(m->db, DB_INSERT_QUERY, DB_QUERY_MAX_SIZE, &m->stmt_insert, NULL) != SQLITE_OK) {
+		log(L_ERROR, "Failed to prepare SQL statement: %s\n", sqlite3_errmsg(m->db));
+		goto err1;
+	}
+
+	return 0;
+err1:
+	sqlite3_close_v2(m->db);
+err0:
+	return 1;
+}
+
+PUBLIC int mstr_initialize_cosem_groups(master *m)
+{
+	static pthread_t threads[MAX_COSEM_GROUPS_COUNT] = { 0 };
+	for (size_t i = 0; i < m->cosem_group_count; i++) {
+		if (pthread_create(&threads[i], NULL, mstr_thread_routine, m->cosem_groups[i])) {
+			log(L_ERROR, "Failed to initialize COSEM group thread: %s\n",
+			    UTL_SAFE_STR(m->cosem_groups[i]->name));
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+PRIVATE void *mstr_thread_routine(void *p)
+{
+	cosem_group *group = (cosem_group *)p;
+	time_t t0	   = time(NULL);
+	unsigned long tn   = 0;
+
+	while (1) {
+		int rc	   = 0;
+		char *data = cg_read_group_codes(group, &rc);
+		if (rc || !data) {
+			log(L_ERROR, "('%d', '%s') Not writing to the database: %s", group->id,
+			    UTL_SAFE_STR(group->name), UTL_SAFE_STR(data));
+			goto end;
+		}
+
+		mstr_write_group_data_to_db(group, data);
+	end:
+		free(data);
+		data = NULL;
+		utl_smart_sleep(&t0, &tn, group->interval);
+		TEST_BREAK
+	}
+
+	return NULL; // should never happen
+}
+
+PUBLIC void mstr_write_group_data_to_db(cosem_group *group, char *data)
+{
+	log(L_DEBUG, "('%d', '%s') Writing to database: %s", group->id, UTL_SAFE_STR(group->name), data);
+
+	uint8_t i = 1;
+	if (sqlite3_bind_null(g_master->stmt_insert, i++) != SQLITE_OK ||
+	    sqlite3_bind_int(g_master->stmt_insert, i++, time(NULL)) != SQLITE_OK ||
+	    sqlite3_bind_text(g_master->stmt_insert, i++, group->name, group->name ? strlen(group->name) : 0,
+			      SQLITE_STATIC) != SQLITE_OK ||
+	    sqlite3_bind_int(g_master->stmt_insert, i++, strlen(data)) != SQLITE_OK ||
+	    sqlite3_bind_text(g_master->stmt_insert, i++, data, strlen(data), SQLITE_STATIC) !=
+		    SQLITE_OK) {
+		log(L_ERROR, "Failed to bind DB parameter: %s\n", sqlite3_errmsg(g_master->db));
+		goto err;
+	}
+
+	int rc = sqlite3_step(g_master->stmt_insert);
+	if (rc == SQLITE_FULL) {
+		if (sqlite3_exec(g_master->db, DB_DELETE_QUERY, NULL, NULL, NULL) != SQLITE_OK) {
+			log(L_ERROR, "DELETE failed: %s\n", sqlite3_errmsg(g_master->db));
+			goto err;
+		}
+
+		log(L_DEBUG, "Repeat INSERT after DELETE");
+
+		if (sqlite3_step(g_master->stmt_insert) != SQLITE_DONE) {
+			log(L_ERROR, "INSERT failed after DELETE: %s", sqlite3_errmsg(g_master->db));
+			goto err;
+		}
+	} else if (rc != SQLITE_DONE) {
+		log(L_ERROR, "INSERT failed: %s\n", sqlite3_errmsg(g_master->db));
+		goto err;
+	}
+
+	log(L_DEBUG, "Record added to the database successfully");
+err:
+	sqlite3_reset(g_master->stmt_insert);
+	sqlite3_clear_bindings(g_master->stmt_insert);
+}
+
+PUBLIC void mstr_db_free(master *m)
+{
+	if (!m) {
+		return;
+	}
+
+	sqlite3_finalize(m->stmt_insert);
+	sqlite3_close_v2(m->db);
+}
diff --recursive --unified --new-file --no-dereference orig/src/master.h src/src/master.h
--- orig/src/master.h	1970-01-01 00:00:00.000000000 +0000
+++ src/src/master.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,172 @@
+#pragma once
+
+#ifdef TEST
+#include "stub_external.h"
+#else
+#define PRIVATE static
+#define PUBLIC
+#define MAIN main
+#define TEST_BREAK
+#endif
+
+#include <libubox/uloop.h>
+#include <libubox/utils.h>
+#include <tlt_logger.h>
+#include <libubus.h>
+#include <sqlite3.h>
+#include <pthread.h>
+
+//!< DLMS headers
+#include <converters.h>
+#include <gxignore.h>
+#include <cosem.h>
+#include <client.h>
+
+#define UTL_SAFE_STR(x) ((x) ? (x) : "")
+#define UTL_STR(x) UTL_STR2(x)
+#define UTL_STR2(x) #x
+
+#define MAX_CONNECTIONS_COUNT	   10
+#define MAX_PHYSICAL_DEVICES_COUNT 30 // overall
+#define MAX_COSEM_OBJECTS_COUNT	   20 // each group
+#define MAX_COSEM_GROUPS_COUNT	   10
+
+typedef struct {
+	int enabled;
+	int id;
+	char *name;
+	enum { TCP, SERIAL } type;
+	union {
+		struct {
+			char *host;
+			int port;
+		} tcp;
+		struct {
+			char *device;
+			int baudrate;
+			char *parity;
+			int databits;
+			int stopbits;
+			char *flow_control;
+		} serial;
+	} parameters;
+	int socket;
+	unsigned long wait_time;
+	gxByteBuffer data;
+	pthread_mutex_t *mutex;
+} connection;
+
+typedef struct {
+	int enabled;
+	int id;
+	char *name;
+	char *invocation_counter;
+	connection *connection;
+	dlmsSettings settings;
+} physical_device;
+
+typedef struct {
+	int enabled;
+	int id;
+	char *name;
+	int entries;
+	gxObject *object;
+	physical_device **devices;
+	size_t device_count;
+} cosem_object;
+
+typedef struct {
+	int enabled;
+	int id;
+	char *name;
+	uint32_t interval;
+	size_t cosem_object_count;
+	cosem_object **cosem_objects;
+} cosem_group;
+
+typedef struct {
+	size_t physical_dev_count;
+	size_t cosem_group_count;
+	physical_device **physical_devices;
+	cosem_group **cosem_groups;
+	sqlite3 *db;
+	sqlite3_stmt *stmt_insert;
+	pthread_mutex_t *mutex_rs232;
+	pthread_mutex_t *mutex_rs485;
+
+	//!< these only needed for free at the end:
+	size_t connection_count;
+	size_t cosem_object_count;
+	connection **connections;
+	cosem_object **cosem_objects;
+} master;
+
+typedef struct {
+	char **values;
+	int count;
+} object_attributes;
+
+extern master *g_master;
+extern log_level_type g_debug_level;
+
+// config.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC master *cfg_get_master();
+PUBLIC void cfg_free_master(master *m);
+
+// master.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC int mstr_create_db(master *m);
+PUBLIC int mstr_initialize_cosem_groups(master *m);
+PUBLIC void mstr_write_group_data_to_db(cosem_group *group, char *data);
+PUBLIC void mstr_db_free(master *m);
+
+// attribute_converter.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC void attr_init(object_attributes *attributes, gxObject *object);
+PUBLIC void attr_free(object_attributes *attributes);
+PUBLIC char *attr_to_json(object_attributes *attributes);
+PUBLIC int attr_to_string(gxObject *object, object_attributes *attributes, int use_ln_ref);
+
+// cosem_group.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC char *cg_read_group_codes(cosem_group *group, int *rc);
+PUBLIC int cg_make_connection(physical_device *dev);
+
+// utils.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC int utl_parse_args(int argc, char **argv, log_level_type *debug_lvl);
+PUBLIC void utl_append_to_str(char **destination, const char *source);
+PUBLIC void utl_append_obj_name(char **data, char *name);
+PUBLIC void utl_append_if_needed(char **data, int index, int value, char *str);
+PUBLIC void utl_add_error_message(char **data, char *device_name, const char *err_msg, const int err_num);
+PUBLIC void utl_smart_sleep(time_t *t0, unsigned long *tn, unsigned p);
+PUBLIC void utl_lock_mutex_if_required(physical_device *d);
+PUBLIC void utl_unlock_mutex_if_required(physical_device *d);
+PUBLIC int utl_validate_cosem_id(const int cosem_id);
+__attribute__((unused)) PUBLIC void utl_debug_master(master *m);
+PUBLIC int utl_is_logical_name(const char *name);
+
+// ubus.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC int init_ubus_test_functions();
+PUBLIC void ubus_exit();
+
+// communication.c
+//////////////////////////////////////////////////////////////////////////////////////////
+
+PUBLIC int com_open_connection(physical_device *dev);
+PUBLIC void com_close(connection *c, dlmsSettings *s);
+PUBLIC void com_close_socket(connection *c);
+PUBLIC int com_update_invocation_counter(connection *c, dlmsSettings *s, const char *invocationCounter);
+PUBLIC int com_initialize_connection(connection *c, dlmsSettings *s);
+PUBLIC int com_read(connection *c, dlmsSettings *s, gxObject *object, unsigned char attributeOrdinal);
+PUBLIC int com_getKeepAlive(connection *c, dlmsSettings *s);
+PUBLIC int com_readRowsByEntry(connection *c, dlmsSettings *s, gxProfileGeneric *obj, int index, int count);
+PUBLIC int com_get_association_view(connection *c, dlmsSettings *s);
diff --recursive --unified --new-file --no-dereference orig/src/ubus.c src/src/ubus.c
--- orig/src/ubus.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/ubus.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,590 @@
+#include "master.h"
+
+#define __UNUSED   __attribute__((unused))
+#define KEY_SIZE   32
+#define TITLE_SIZE 16
+
+PRIVATE int reply(struct ubus_context *ctx, struct ubus_request_data *req, const int err_code, const char *y);
+PRIVATE int device_cb(struct ubus_context *ctx, __UNUSED struct ubus_object *obj,
+		      struct ubus_request_data *req, __UNUSED const char *method, struct blob_attr *msg);
+PRIVATE int device_cb_args(physical_device *d, struct blob_attr *msg);
+PRIVATE int read_security_settings(struct blob_attr **tb, physical_device *d);
+PRIVATE int validate_key(const char *key, size_t len);
+PRIVATE void find_corresponding_mutex(connection *c);
+PRIVATE int tcp_connection_match(connection *g_c, connection *c);
+PRIVATE void free_device(physical_device *d);
+PRIVATE int cosem_group_cb(struct ubus_context *ctx, __UNUSED struct ubus_object *obj,
+			   struct ubus_request_data *req, __UNUSED const char *method, struct blob_attr *msg);
+PRIVATE int cosem_group_args(cosem_group *d, struct blob_attr *msg);
+PRIVATE cosem_object *parse_cosem_object(struct blob_attr *b);
+PRIVATE void free_cosem_group(cosem_group *g);
+
+enum {
+	TEST_DEVICE_OPT_TYPE,
+	TEST_DEVICE_OPT_TCP_ADDRESS,
+	TEST_DEVICE_OPT_TCP_PORT,
+	TEST_DEVICE_OPT_SERIAL_DEVICE,
+	TEST_DEVICE_OPT_SERIAL_BAUDRATE,
+	TEST_DEVICE_OPT_SERIAL_DATABITS,
+	TEST_DEVICE_OPT_SERIAL_STOPBITS,
+	TEST_DEVICE_OPT_SERIAL_PARITY,
+	TEST_DEVICE_OPT_SERIAL_FLOWCONTROL,
+	TEST_DEVICE_OPT_SERVER_ADDR,
+	TEST_DEVICE_OPT_LOG_SERVER_ADDR,
+	TEST_DEVICE_OPT_CLIENT_ADDR,
+	TEST_DEVICE_OPT_USE_LN,
+	TEST_DEVICE_OPT_TRANSPORT_SECURITY,
+	TEST_DEVICE_OPT_INTERFACE_TYPE,
+	TEST_DEVICE_OPT_ACCESS_SECURITY,
+	TEST_DEVICE_OPT_PASSWORD,
+	TEST_DEVICE_OPT_SYSTEM_TITLE,
+	TEST_DEVICE_OPT_AUTHENTICATION_KEY,
+	TEST_DEVICE_OPT_BLOCK_CIPHER_KEY,
+	TEST_DEVICE_OPT_DEDICATED_KEY,
+	TEST_DEVICE_OPT_INVOCATION_COUNTER,
+	TEST_DEVICE_OPT_COUNT
+};
+
+PRIVATE struct blobmsg_policy device_policy[] = {
+	[TEST_DEVICE_OPT_TYPE]		     = { .name = "type", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_TCP_ADDRESS]	     = { .name = "tcp_address", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_TCP_PORT]	     = { .name = "tcp_port", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_SERIAL_DEVICE]	     = { .name = "serial_dev", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_SERIAL_BAUDRATE]    = { .name = "serial_baudrate", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_SERIAL_DATABITS]    = { .name = "serial_databits", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_SERIAL_STOPBITS]    = { .name = "serial_stopbits", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_SERIAL_PARITY]	     = { .name = "serial_parity", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL] = { .name = "serial_flowcontrol", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_SERVER_ADDR]	     = { .name = "server_addr", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_LOG_SERVER_ADDR]    = { .name = "logical_server_addr", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_CLIENT_ADDR]	     = { .name = "client_addr", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_USE_LN]	     = { .name = "use_ln_ref", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_TRANSPORT_SECURITY] = { .name = "transport_security", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_INTERFACE_TYPE]     = { .name = "interface", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_ACCESS_SECURITY]    = { .name = "access_security", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_DEVICE_OPT_PASSWORD]	     = { .name = "password", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_SYSTEM_TITLE]	     = { .name = "system_title", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_AUTHENTICATION_KEY] = { .name = "auth_key", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY]   = { .name = "block_cipher_key", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_DEDICATED_KEY]	     = { .name = "dedicated_key", .type = BLOBMSG_TYPE_STRING },
+	[TEST_DEVICE_OPT_INVOCATION_COUNTER] = { .name = "invocation_counter", .type = BLOBMSG_TYPE_STRING }
+};
+
+enum {
+	TEST_COSEM_OBJECT_OPT_ID,
+	TEST_COSEM_OBJECT_OPT_ENABLED,
+	TEST_COSEM_OBJECT_OPT_NAME,
+	TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES,
+	TEST_COSEM_OBJECT_OPT_OBIS,
+	TEST_COSEM_OBJECT_OPT_COSEM_ID,
+	TEST_COSEM_OBJECT_OPT_ENTRIES,
+	TEST_COSEM_OBJECT_OPT_COUNT
+};
+
+PRIVATE struct blobmsg_policy cosem_object_policy[] = {
+	[TEST_COSEM_OBJECT_OPT_ID]		 = { .name = "id", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_COSEM_OBJECT_OPT_ENABLED]		 = { .name = "enabled", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_COSEM_OBJECT_OPT_NAME]		 = { .name = "name", .type = BLOBMSG_TYPE_STRING },
+	[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES] = { .name = "devices", .type = BLOBMSG_TYPE_ARRAY },
+	[TEST_COSEM_OBJECT_OPT_OBIS]		 = { .name = "obis", .type = BLOBMSG_TYPE_STRING },
+	[TEST_COSEM_OBJECT_OPT_COSEM_ID]	 = { .name = "cosem_id", .type = BLOBMSG_TYPE_INT32 },
+	[TEST_COSEM_OBJECT_OPT_ENTRIES]		 = { .name = "entries", .type = BLOBMSG_TYPE_INT32 }
+};
+
+enum {
+	TEST_COSEM_GROUP_OPT_OBJECTS,
+	TEST_COSEM_GROUP_OPT_COUNT
+};
+
+PRIVATE struct blobmsg_policy cosem_group_policy[] = {
+	[TEST_COSEM_GROUP_OPT_OBJECTS] = { .name = "objects", .type = BLOBMSG_TYPE_ARRAY },
+};
+
+PRIVATE const struct ubus_method ubus_methods[] = {
+	UBUS_METHOD("test_device", device_cb, device_policy),
+	UBUS_METHOD("test_cosem_group", cosem_group_cb, cosem_group_policy),
+};
+
+PRIVATE struct ubus_object_type ubus_obj_type = UBUS_OBJECT_TYPE("dlms", ubus_methods);
+
+PRIVATE struct ubus_object ubus_obj = {
+	.name	   = "dlms",
+	.type	   = &ubus_obj_type,
+	.methods   = ubus_methods,
+	.n_methods = ARRAY_SIZE(ubus_methods),
+};
+
+PRIVATE struct ubus_context *ubus = NULL;
+
+PUBLIC int init_ubus_test_functions()
+{
+	ubus = ubus_connect(NULL);
+	if (!ubus) {
+		log(L_ERROR, "Failed to connect to UBUS\n");
+		return 1;
+	}
+
+	if (ubus_add_object(ubus, &ubus_obj)) {
+		log(L_ERROR, "Failed to add UBUS object\n");
+		return 1;
+	}
+
+	ubus_add_uloop(ubus);
+	return 0;
+}
+
+PRIVATE int reply(struct ubus_context *ctx, struct ubus_request_data *req, const int err_code, const char *y)
+{
+	int rc		  = 1;
+	struct blob_buf b = { 0 };
+
+	if (blob_buf_init(&b, 0)) {
+		log(L_WARNING, "Failed to initiate blob buffer\n");
+		goto end;
+	}
+
+	if (blobmsg_add_u32(&b, "error", err_code)) {
+		log(L_WARNING, "Failed to add integer to blob message\n");
+		goto end;
+	}
+
+	if (blobmsg_add_string(&b, "result", y)) {
+		log(L_WARNING, "Failed to add string to blob message");
+		goto end;
+	}
+
+	if (ubus_send_reply(ctx, req, b.head)) {
+		log(L_WARNING, "Failed to send UBUS reply\n");
+		goto end;
+	}
+
+	rc = 0;
+end:
+	blob_buf_free(&b);
+	return rc;
+}
+
+PRIVATE int device_cb(struct ubus_context *ctx, __UNUSED struct ubus_object *obj,
+		      struct ubus_request_data *req, __UNUSED const char *method, struct blob_attr *msg)
+{
+	int rc		    = DLMS_ERROR_CODE_OK;
+	const char *result  = "OK";
+	physical_device dev = {
+		.connection = (connection[]){ { .socket = -1, .name = "UBUS TEST" } },
+		.settings   = { 0 },
+	};
+
+	rc = device_cb_args(&dev, msg);
+	if (rc != DLMS_ERROR_CODE_OK) {
+		result = "Failed to parse device parameters.";
+		goto end;
+	}
+
+	utl_lock_mutex_if_required(&dev);
+
+	rc = cg_make_connection(&dev);
+	if (rc != DLMS_ERROR_CODE_OK) {
+		result = "Failed to make connection with device.";
+		goto end;
+	}
+
+	com_close(dev.connection, &dev.settings);
+end:
+	utl_unlock_mutex_if_required(&dev);
+	rc = reply(ctx, req, !!rc, result);
+	free_device(&dev);
+	return rc;
+}
+
+PRIVATE int device_cb_args(physical_device *d, struct blob_attr *msg)
+{
+	int rc = DLMS_ERROR_CODE_OTHER_REASON;
+	struct blob_attr *tb[TEST_DEVICE_OPT_COUNT] = { 0 };
+
+	if (!msg) {
+		log(L_WARNING, "UBUS message is null\n");
+		goto end;
+	}
+
+	if (blobmsg_parse(device_policy, TEST_DEVICE_OPT_COUNT, tb, blob_data(msg), blob_len(msg))) {
+		log(L_WARNING, "Failed to parse device policy\n");
+		goto end;
+	}
+
+	if (!tb[TEST_DEVICE_OPT_TYPE]) {
+		log(L_WARNING, "Option 'type' is not specified. It should be 0 (TCP) or 1 (SERIAL)\n");
+		goto end;
+	}
+	d->connection->type = blobmsg_get_u32(tb[TEST_DEVICE_OPT_TYPE]);
+
+	if (d->connection->type == TCP) {
+		if (!tb[TEST_DEVICE_OPT_TCP_ADDRESS] || !tb[TEST_DEVICE_OPT_TCP_PORT]) {
+			log(L_WARNING, "'address' or 'port' options can't be empty\n");
+			goto end;
+		}
+	} else if (d->connection->type == SERIAL) {
+		if (!tb[TEST_DEVICE_OPT_SERIAL_DEVICE] || !tb[TEST_DEVICE_OPT_SERIAL_BAUDRATE] ||
+		    !tb[TEST_DEVICE_OPT_SERIAL_DATABITS] || !tb[TEST_DEVICE_OPT_SERIAL_STOPBITS] ||
+		    !tb[TEST_DEVICE_OPT_SERIAL_PARITY] || !tb[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL]) {
+			log(L_WARNING, "Serial settings are missing\n");
+			goto end;
+		}
+	} else {
+		log(L_WARNING, "Option 'type' is invalid. It should be 0 (TCP) or 1 (SERIAL)\n");
+		goto end;
+	}
+
+	if (d->connection->type == TCP) {
+		int port = blobmsg_get_u32(tb[TEST_DEVICE_OPT_TCP_PORT]);
+		if (port < 1 || port > 65535) {
+			log(L_WARNING, "Option 'port' (%d) is outside range [1;65535]\n", port);
+			goto end;
+		}
+		d->connection->parameters.tcp.port = port;
+		d->connection->parameters.tcp.host = blobmsg_get_string(tb[TEST_DEVICE_OPT_TCP_ADDRESS]);
+	} else {
+		d->connection->parameters.serial.device =
+			blobmsg_get_string(tb[TEST_DEVICE_OPT_SERIAL_DEVICE]);
+		d->connection->parameters.serial.baudrate =
+			blobmsg_get_u32(tb[TEST_DEVICE_OPT_SERIAL_BAUDRATE]);
+		d->connection->parameters.serial.parity =
+			blobmsg_get_string(tb[TEST_DEVICE_OPT_SERIAL_PARITY]);
+		d->connection->parameters.serial.databits =
+			blobmsg_get_u32(tb[TEST_DEVICE_OPT_SERIAL_DATABITS]);
+		d->connection->parameters.serial.stopbits =
+			blobmsg_get_u32(tb[TEST_DEVICE_OPT_SERIAL_STOPBITS]);
+		d->connection->parameters.serial.flow_control =
+			blobmsg_get_string(tb[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL]);
+	}
+
+	if (!tb[TEST_DEVICE_OPT_SERVER_ADDR]) {
+		log(L_WARNING, "Option 'server_addr' is empty\n");
+		goto end;
+	}
+
+	if (!tb[TEST_DEVICE_OPT_LOG_SERVER_ADDR]) {
+		log(L_WARNING, "Option 'logical_server_addr' is empty\n");
+		goto end;
+	}
+	int server_address = cl_getServerAddress(blobmsg_get_u32(tb[TEST_DEVICE_OPT_LOG_SERVER_ADDR]),
+					     blobmsg_get_u32(tb[TEST_DEVICE_OPT_SERVER_ADDR]), 0);
+
+	if (!tb[TEST_DEVICE_OPT_CLIENT_ADDR]) {
+		log(L_WARNING, "Option 'client_addr' is empty\n");
+		goto end;
+	}
+	int client_address = blobmsg_get_u32(tb[TEST_DEVICE_OPT_CLIENT_ADDR]);
+
+	int use_logical_name_referencing = 1; // default
+	if (tb[TEST_DEVICE_OPT_USE_LN]) {
+		use_logical_name_referencing = blobmsg_get_u32(tb[TEST_DEVICE_OPT_USE_LN]);
+	}
+
+	int interface_type = DLMS_INTERFACE_TYPE_HDLC;
+	if (tb[TEST_DEVICE_OPT_INTERFACE_TYPE]) {
+		interface_type = blobmsg_get_u32(tb[TEST_DEVICE_OPT_INTERFACE_TYPE]);
+	}
+
+	int access_security = DLMS_AUTHENTICATION_NONE;
+	if (tb[TEST_DEVICE_OPT_ACCESS_SECURITY]) {
+		access_security = blobmsg_get_u32(tb[TEST_DEVICE_OPT_ACCESS_SECURITY]);
+	}
+
+	const char *password = NULL;
+	if (tb[TEST_DEVICE_OPT_PASSWORD]) {
+		password = blobmsg_get_string(tb[TEST_DEVICE_OPT_PASSWORD]);
+	}
+
+	cl_init(&d->settings, use_logical_name_referencing, client_address, server_address, access_security,
+		password, interface_type);
+
+	if (read_security_settings(tb, d)) {
+		log(L_WARNING, "Failed to read security settings\n");
+		goto end;
+	}
+
+	d->connection->wait_time = 5000;
+	bb_init(&d->connection->data);
+	bb_capacity(&d->connection->data, 500);
+	find_corresponding_mutex(d->connection);
+
+	rc = 0;
+end:
+	return rc;
+}
+
+PRIVATE int read_security_settings(struct blob_attr **tb, physical_device *d)
+{
+	int rc = 1;
+
+	if (tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY]) {
+		d->settings.cipher.security = blobmsg_get_u32(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY]);
+	}
+
+	if (tb[TEST_DEVICE_OPT_INVOCATION_COUNTER]) {
+		d->invocation_counter = blobmsg_get_string(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER]);
+	}
+
+	if (tb[TEST_DEVICE_OPT_SYSTEM_TITLE]) {
+		const char *system_title = blobmsg_get_string(tb[TEST_DEVICE_OPT_SYSTEM_TITLE]);
+		if (validate_key(system_title, TITLE_SIZE)) {
+			log(L_ERROR, "system title size must be 16 bytes");
+			goto end;
+		}
+
+		bb_clear(&d->settings.cipher.systemTitle);
+		bb_addHexString(&d->settings.cipher.systemTitle, system_title);
+	}
+
+
+	if (tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY]) {
+		const char *authentication_key = blobmsg_get_string(tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY]);
+		if (validate_key(authentication_key, KEY_SIZE)) {
+			log(L_ERROR, "Authentication key size must be 32 bytes");
+			goto end;
+		}
+
+		bb_clear(&d->settings.cipher.authenticationKey);
+		bb_addHexString(&d->settings.cipher.authenticationKey, authentication_key);
+	}
+
+	if (tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY]) {
+		const char *block_cipher_key = blobmsg_get_string(tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY]);
+		if (validate_key(block_cipher_key, KEY_SIZE)) {
+			log(L_ERROR, "Block cipher key size must be 32 bytes");
+			goto end;
+		}
+
+		bb_clear(&d->settings.cipher.blockCipherKey);
+		bb_addHexString(&d->settings.cipher.blockCipherKey, block_cipher_key);
+	}
+
+	if (tb[TEST_DEVICE_OPT_DEDICATED_KEY]) {
+		const char *dedicated_key = blobmsg_get_string(tb[TEST_DEVICE_OPT_DEDICATED_KEY]);
+		if (validate_key(dedicated_key, KEY_SIZE)) {
+			log(L_ERROR, "Dedicated key size must be 32 bytes");
+			goto end;
+		}
+
+		d->settings.cipher.dedicatedKey = calloc(1, sizeof(gxByteBuffer));
+		bb_init(d->settings.cipher.dedicatedKey);
+		bb_addHexString(d->settings.cipher.dedicatedKey, dedicated_key);
+	}
+
+	rc = 0;
+end:
+	return rc;
+}
+
+PRIVATE int validate_key(const char *key, size_t len)
+{
+	return (strlen(key) != len);
+}
+
+/// if a connection already exists, we must first find the connection mutex to prevent simultaneous connections.
+PRIVATE void find_corresponding_mutex(connection *c)
+{
+	for (size_t i = 0; g_master && i < g_master->connection_count; i++) {
+		if (c->type == TCP) {
+			connection *g_master_c = g_master->connections[i];
+			if (tcp_connection_match(g_master_c, c)) {
+				c->mutex = g_master_c->mutex;
+				break;
+			}
+		} else if (c->type == SERIAL) {
+			c->mutex = (strstr(c->parameters.serial.device, "rs485")) ? g_master->mutex_rs485 : g_master->mutex_rs232;
+			break;
+		}
+	}
+}
+
+PRIVATE int tcp_connection_match(connection *g_c, connection *c)
+{
+	return (!strncmp(g_c->parameters.tcp.host, c->parameters.tcp.host, strlen(g_c->parameters.tcp.host)) &&
+	       (g_c->parameters.tcp.port == c->parameters.tcp.port));
+}
+
+PRIVATE void free_device(physical_device *d)
+{
+	cip_clear(&d->settings.cipher);
+	cl_clear(&d->settings);
+	bb_clear(&d->connection->data);
+}
+
+PRIVATE int cosem_group_cb(struct ubus_context *ctx, __UNUSED struct ubus_object *obj,
+			   struct ubus_request_data *req, __UNUSED const char *method, struct blob_attr *msg)
+{
+	int rc		    = DLMS_ERROR_CODE_OK;
+	char *result	    = NULL;
+	const char *err_msg = NULL;
+	cosem_group g	    = { 0 };
+
+	rc = cosem_group_args(&g, msg);
+	if (rc != DLMS_ERROR_CODE_OK) {
+		err_msg = "Failed to parse COSEM group parameters.";
+		goto end;
+	}
+
+	result = cg_read_group_codes(&g, &rc);
+	log(L_INFO, "Payload: %s", UTL_SAFE_STR(result));
+end:
+	rc = reply(ctx, req, rc, err_msg ? err_msg : result);
+	free_cosem_group(&g);
+	free(result);
+	return rc;
+}
+
+PRIVATE int cosem_group_args(cosem_group *g, struct blob_attr *msg)
+{
+	int rc = 1;
+	struct blob_attr *tb[TEST_COSEM_GROUP_OPT_COUNT];
+
+	if (!msg) {
+		log(L_ERROR, "UBUS message is null\n");
+		goto end;
+	}
+
+	if (blobmsg_parse(cosem_group_policy, TEST_COSEM_GROUP_OPT_COUNT, tb, blob_data(msg), blob_len(msg))) {
+		log(L_ERROR, "Failed to parse COSEM group policy\n");
+		goto end;
+	}
+
+	if (!tb[TEST_COSEM_GROUP_OPT_OBJECTS]) {
+		log(L_ERROR, "Option 'objects' is missing\n");
+		goto end;		
+	}
+
+	if (blobmsg_check_array(tb[TEST_COSEM_GROUP_OPT_OBJECTS], BLOBMSG_TYPE_TABLE) <= 0) {
+		log(L_ERROR, "Validation of 'objects' failed\n");
+		goto end;
+	}
+
+	#ifndef TEST
+	struct blob_attr *tb_obj = NULL;
+	int r			 = 0;
+	blobmsg_for_each_attr(tb_obj, tb[TEST_COSEM_GROUP_OPT_OBJECTS], r) {
+		cosem_object *cosem = parse_cosem_object(tb_obj);
+		if (!cosem) {
+			log(L_WARNING, "Failed to parse COSEM object, continuing\n");
+			continue;
+		}
+		g->cosem_objects = realloc(g->cosem_objects, (g->cosem_object_count + 1) * sizeof(cosem_object));
+		g->cosem_objects[g->cosem_object_count++] = cosem;
+	}
+
+	if (!g->cosem_object_count) {
+		log(L_WARNING, "Valid COSEM objects not found\n");
+		goto end;
+	}
+	#endif
+
+	rc = 0;
+end:
+	return rc;
+}
+
+PRIVATE cosem_object *parse_cosem_object(struct blob_attr *b)
+{
+	struct blob_attr *tb[TEST_COSEM_OBJECT_OPT_COUNT];
+
+	if (blobmsg_parse(cosem_object_policy, TEST_COSEM_OBJECT_OPT_COUNT, tb, blobmsg_data(b), blobmsg_len(b))) {
+		log(L_ERROR, "Failed to parse COSEM object policy\n");
+		return NULL;
+	}
+
+	if (!tb[TEST_COSEM_OBJECT_OPT_ID] || !tb[TEST_COSEM_OBJECT_OPT_ENABLED] ||
+	    !tb[TEST_COSEM_OBJECT_OPT_NAME] || !tb[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES] ||
+	    !tb[TEST_COSEM_OBJECT_OPT_OBIS] || !tb[TEST_COSEM_OBJECT_OPT_COSEM_ID]) {
+		log(L_ERROR, "COSEM object options are missing\n");
+		return NULL;
+	}
+
+	cosem_object *obj = calloc(1, sizeof(cosem_object));
+	if (!obj) {
+		log(L_ERROR, "Failed to allocate memory for COSEM object\n");
+		return NULL;
+	}
+
+	obj->id	     = blobmsg_get_u32(tb[TEST_COSEM_OBJECT_OPT_ID]);
+	obj->enabled = blobmsg_get_u32(tb[TEST_COSEM_OBJECT_OPT_ENABLED]);
+	obj->name    = blobmsg_get_string(tb[TEST_COSEM_OBJECT_OPT_NAME]);
+
+	if (tb[TEST_COSEM_OBJECT_OPT_ENTRIES]) {
+		obj->entries = blobmsg_get_u32(tb[TEST_COSEM_OBJECT_OPT_ENTRIES]);
+	}
+
+	int size = blobmsg_check_array(tb[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES], BLOBMSG_TYPE_STRING);
+	if (size < 0) {
+		log(L_ERROR, "Option 'devices' should be an array of strings with section IDs\n");
+		goto err0;
+	}
+
+	obj->devices = calloc(size, sizeof(*obj->devices));
+	if (!obj->devices) {
+		log(L_ERROR, "Failed to allocate memory for COSEM object devices\n");
+		goto err0;
+	}
+
+	int cosem_id = blobmsg_get_u32(tb[TEST_COSEM_OBJECT_OPT_COSEM_ID]);
+	if (!utl_validate_cosem_id(cosem_id)) {
+		log(L_ERROR, "cosem id (%d) is not supported\n", cosem_id);
+		goto err0;
+	}
+
+	#ifndef TEST
+	struct blob_attr *cur = NULL;
+	int r		      = 0;
+	bool found	      = false;
+	blobmsg_for_each_attr (cur, tb[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES], r) {
+		const int id = strtol(blobmsg_get_string(cur), NULL, 10);
+		for (size_t i = 0; g_master && i < g_master->physical_dev_count; i++) {
+			if (id == g_master->physical_devices[i]->id) {
+				obj->devices[obj->device_count++] = g_master->physical_devices[i];
+				found = true;
+				break;
+			}
+		}
+	}
+
+	if (!found) {
+		log(L_WARNING, "Physical devices with listed names were not found\n");
+		goto err1;
+	}
+	#endif
+
+	char *obis = blobmsg_get_string(tb[TEST_COSEM_OBJECT_OPT_OBIS]);
+	cosem_createObject2(cosem_id, obis, &obj->object);
+	if (utl_is_logical_name(obis)) {
+		cosem_init(obj->object, cosem_id, obis);
+	} else {
+		obj->object->shortName = strtol(obis, NULL, 10);
+	}
+
+	return obj;
+err1:
+	free(obj->devices);
+err0:
+	free(obj);
+	return NULL;
+}
+
+PRIVATE void free_cosem_group(cosem_group *g)
+{
+	if (!g->cosem_objects) {
+		return;
+	}
+
+	for (size_t i = 0; i < g->cosem_object_count; i++) {
+		free(g->cosem_objects[i]->devices);
+		obj_clear(g->cosem_objects[i]->object);
+		free(g->cosem_objects[i]->object);
+		free(g->cosem_objects[i]);
+	}
+
+	free(g->cosem_objects);
+}
+
+PUBLIC void ubus_exit()
+{
+	ubus_free(ubus);
+}
diff --recursive --unified --new-file --no-dereference orig/src/utils.c src/src/utils.c
--- orig/src/utils.c	1970-01-01 00:00:00.000000000 +0000
+++ src/src/utils.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,175 @@
+#include "master.h"
+
+PUBLIC int utl_parse_args(int argc, char **argv, log_level_type *debug_lvl)
+{
+	if (argc <= 1) {
+		return 0;
+	}
+
+	if (argc != 3 || strcmp(argv[1], "-D")) {
+		fprintf(stderr, "Usage: %s [-D DEBUG_LEVEL]\n", argv[0]);
+		return 1;
+	}
+
+	char *endptr = NULL;
+	long int value = strtol(argv[2], &endptr, 10);
+	if (errno || *endptr) {
+		fprintf(stderr, "Invalid -D argument\n");
+		return 1;
+	}
+
+	*debug_lvl = (log_level_type)value;
+	return 0;
+}
+
+PUBLIC void utl_append_to_str(char **destination, const char *source)
+{
+	if (!source) {
+		log(L_ERROR, "Source is NULL");
+		return;
+	}
+
+	if (!(*destination)) {
+		*destination = strdup(source);
+		return;
+	}
+
+	size_t source_len = strlen(source);
+	size_t sum_len = strlen(*destination) + source_len + 1;
+
+	*destination = realloc(*destination, sum_len);
+	if (!(*destination)) {
+		log(L_ERROR, "Failed to reallocate memory for destination");
+		return;
+	}
+
+	strncat(*destination, source, source_len);
+}
+
+PUBLIC void utl_append_obj_name(char **data, char *name)
+{
+	char device_name[256] = { 0 };
+
+	snprintf(device_name, sizeof(device_name), "\"%s\":", name);
+	utl_append_to_str(data, device_name);
+}
+
+PUBLIC void utl_append_if_needed(char **data, int index, int value, char *str)
+{
+	if (index != value) {
+		utl_append_to_str(data, str);
+	}
+}
+
+PUBLIC void utl_add_error_message(char **data, char *device_name, const char *err_msg, const int err_num)
+{
+	char str[256] = { 0 };
+
+	utl_append_obj_name(data, device_name);
+	snprintf(str, sizeof(str), "{\"error\": %d, \"result\": \"%s\"}", err_num, err_msg);
+	utl_append_to_str(data, str);
+}
+
+PUBLIC void utl_smart_sleep(time_t *t0, unsigned long *tn, unsigned p)
+{
+	++*tn;
+
+	time_t target = *t0 + *tn * p;
+	time_t now    = time(NULL);
+
+	if (target > now) {
+		sleep(target - now);
+	}
+
+	if (llabs(target - now) > p * 2) {
+		*t0 = now;
+		*tn = 0;
+	}
+}
+
+// Could be useful to check errno here
+PUBLIC void utl_lock_mutex_if_required(physical_device *d)
+{
+	if (d->connection->mutex) {
+		pthread_mutex_lock(d->connection->mutex);
+	}
+}
+
+PUBLIC void utl_unlock_mutex_if_required(physical_device *d)
+{
+	if (d->connection->mutex) {
+		pthread_mutex_unlock(d->connection->mutex);
+	}
+}
+
+PUBLIC int utl_validate_cosem_id(const int cosem_id)
+{
+	return (cosem_id > 0 || cosem_id < 72);
+}
+
+__attribute__((unused)) PUBLIC void utl_debug_master(master *m)
+{
+	if (!m) {
+		log(L_DEBUG, "Nothing to debug");
+		return;
+	}
+
+	printf("\n\n********* PHYSICAL DEVICES *********\n");
+	for (size_t i = 0; i < m->physical_dev_count; i++) {
+		physical_device *p = m->physical_devices[i];
+		printf("\t---------------- device %d ----------------\n", i);
+		printf("\tid:\t\t\t%d\n", p->id);
+		printf("\tname:\t\t\t%s\n", UTL_SAFE_STR(p->name));
+		printf("\tinvocation counter:\t%s\n", UTL_SAFE_STR(p->invocation_counter));
+		if (p->connection) {
+			printf("\tconnection type:\t%s\n", (p->connection->type == TCP) ? "TCP" : "SERIAL");
+			printf("\twait_time:\t\t%ld\n", p->connection->wait_time);
+			if (p->connection->type == TCP) {
+				printf("\thost:\t\t\t%s\n", UTL_SAFE_STR(p->connection->parameters.tcp.host));
+				printf("\tport:\t\t\t%d\n", p->connection->parameters.tcp.port);
+			} else {
+				printf("\tdevice:\t\t\t%s\n", UTL_SAFE_STR(p->connection->parameters.serial.device));
+				printf("\tparity:\t\t\t%s\n", UTL_SAFE_STR(p->connection->parameters.serial.parity));
+				printf("\tbaudrate:\t\t%d\n", p->connection->parameters.serial.baudrate);
+				printf("\tdatabits:\t\t%d\n", p->connection->parameters.serial.databits);
+				printf("\tstopbits:\t\t%d\n", p->connection->parameters.serial.stopbits);
+				printf("\tflow control:\t\t%s\n", p->connection->parameters.serial.flow_control);
+			}
+		}
+	}
+
+	printf("\n\n********* COSEM GROUPS *********\n");
+	for (size_t i = 0; i < m->cosem_group_count; i++) {
+		cosem_group *c = m->cosem_groups[i];
+		printf("\t---------------- group %d ----------------\n", i);
+		printf("\tid:\t\t\t%d\n", c->id);
+		printf("\tname:\t\t\t%s\n", UTL_SAFE_STR(c->name));
+		printf("\tinterval:\t\t%ld\n", c->interval);
+		printf("\tCOSEM object count:\t%d\n", c->cosem_object_count);
+		printf("********* COSEM GROUP OBJECTS *********\n");
+		for (size_t j = 0; j < c->cosem_object_count; j++) {
+			cosem_object *o = c->cosem_objects[j];
+			printf("\t---------------- object %d ----------------\n", j);
+			printf("\tname:\t\t%s\n", UTL_SAFE_STR(o->name));
+			printf("\tid:\t\t%d\n", o->id);
+			if (o->object) {
+				printf("\tobject type:\t%s\n", obj_typeToString2(o->object->objectType));
+				if (o->object->objectType == DLMS_OBJECT_TYPE_PROFILE_GENERIC) {
+					printf("\tentries:\t%d\n", o->entries);
+				}
+			}
+			printf("\tdevices:\t");
+			for (size_t k = 0; k < o->device_count; k++) {
+				printf("'%s', '%d' |", UTL_SAFE_STR(o->devices[k]->name), o->devices[k]->id);
+				printf(" ");
+			}
+			printf("\t\n");
+		}
+		printf("\t\n");
+	}
+}
+
+PUBLIC int utl_is_logical_name(const char *name)
+{
+	return (strlen(name) > 6);
+}
diff --recursive --unified --new-file --no-dereference orig/test/include/config.h src/test/include/config.h
--- orig/test/include/config.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/config.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+#include "master.h"
diff --recursive --unified --new-file --no-dereference orig/test/include/config_info.h src/test/include/config_info.h
--- orig/test/include/config_info.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/config_info.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,71 @@
+#include "master.h"
+
+typedef struct connection_params_cfg {
+	int id;
+	char *name;
+	enum { TCP_CFG, SERIAL_CFG } type;
+	union {
+		struct {
+			char *host;
+			int port;
+		} tcp;
+		struct {
+			char *device;
+			int baudrate;
+			char *parity;
+			int databits;
+			int stopbits;
+			char *flow_control;
+		} serial;
+	} parameters;
+	int wait_time;
+} connection_params_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	int server_address;
+	int logical_server_address;
+	int client_address;
+	int access_security;
+	int interface_type;
+	int logical_name_ref;
+	char *password;
+	int transport_security;
+	int connection;
+	char *authentication_key;
+	char *block_cipher_key;
+	char *dedicated_key;
+	char *invocation_counter;
+} physical_device_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	uint32_t interval;
+} cosem_group_cfg;
+
+typedef struct {
+	int id;
+	char *name;
+	int enabled;
+	char *obis;
+	int cosem_id;
+	int entries;
+	char *physical_devices;
+	int cosem_group;
+} cosem_object_cfg;
+
+typedef struct {
+	size_t connection_cfg_count;
+	size_t physical_device_cfg_count;
+	size_t cosem_object_cfg_count;
+	size_t cosem_group_cfg_count;
+
+	connection_params_cfg **connections;
+	physical_device_cfg **physical_devices;
+	cosem_object_cfg **cosem_objects;
+	cosem_group_cfg **cosem_groups;
+} dlms_cfg;
diff --recursive --unified --new-file --no-dereference orig/test/include/cosem_group.h src/test/include/cosem_group.h
--- orig/test/include/cosem_group.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/cosem_group.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,6 @@
+#include "master.h"
+
+PRIVATE void cg_monitor_cb(struct uloop_timeout *timeout);
+PRIVATE int cg_read_profile_generic_data(cosem_object *obj, gxProfileGeneric *pg, physical_device *dev);
+PRIVATE int cg_read_cosem_object(cosem_object *cosem_object, physical_device *dev);
+PRIVATE int cg_format_group_data(char **data, object_attributes *attr, char *device_name);
diff --recursive --unified --new-file --no-dereference orig/test/include/main.h src/test/include/main.h
--- orig/test/include/main.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/main.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+#include "master.h"
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_config.h src/test/include/stub_config.h
--- orig/test/include/stub_config.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_config.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,15 @@
+#include "config_info.h"
+
+PRIVATE connection_params_cfg *cfg_read_connection(struct uci_context *uci, struct uci_section *section);
+PRIVATE physical_device_cfg *cfg_read_physical_device(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_object_cfg *cfg_read_cosem_object(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_group_cfg *cfg_read_cosem_group(struct uci_context *uci, struct uci_section *section);
+
+PRIVATE connection **cfg_get_connections(dlms_cfg *cfg, size_t *connection_count);
+PRIVATE physical_device **cfg_get_physical_devices(dlms_cfg *cfg, connection **connections, size_t connection_count, size_t *physical_dev_count);
+PRIVATE cosem_object **cfg_get_cosem_objects(dlms_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count, size_t *cosem_object_count);
+PRIVATE cosem_group **cfg_get_cosem_groups(dlms_cfg *cfg, cosem_object **cosem_objects, size_t cosem_object_count, size_t *cosem_group_count);
+
+PRIVATE int cfg_init_mutex(pthread_mutex_t **mutex);
+
+PRIVATE void cfg_free_dlms_cfg(dlms_cfg *dlms);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_config_2.h src/test/include/stub_config_2.h
--- orig/test/include/stub_config_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_config_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,19 @@
+#include "config_info.h"
+
+PRIVATE dlms_cfg *cfg_read_dlms_cfg();
+PRIVATE master *cfg_read_master(dlms_cfg *cfg);
+
+PRIVATE int cfg_init_mutexes(master *m);
+
+PRIVATE connection *cfg_get_connection(connection_params_cfg *cfg);
+PRIVATE physical_device *cfg_get_physical_device(physical_device_cfg *cfg, connection **connections, size_t connection_count);
+PRIVATE cosem_object *cfg_get_cosem_object(cosem_object_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count);
+PRIVATE cosem_group *cfg_get_cosem_group(dlms_cfg *cfg, cosem_group_cfg *cosem_group_cfg, cosem_object **cosem_objects, size_t cosem_object_count);
+
+PRIVATE void cfg_free_connection_cfg(connection_params_cfg *conn);
+PRIVATE void cfg_free_physical_device_cfg(physical_device_cfg *dev);
+PRIVATE void cfg_free_cosem_object_cfg(cosem_object_cfg *cosem);
+PRIVATE void cfg_free_cosem_group_cfg(cosem_group_cfg *group);
+
+PRIVATE void cfg_free_dlms_cfg(dlms_cfg *dlms);
+PRIVATE void cfg_free_master(master *m);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_config_free.h src/test/include/stub_config_free.h
--- orig/test/include/stub_config_free.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_config_free.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,11 @@
+#include "config_info.h"
+
+PRIVATE void cfg_free_connection_cfg(connection_params_cfg *conn);
+PRIVATE void cfg_free_physical_device_cfg(physical_device_cfg *dev);
+PRIVATE void cfg_free_cosem_object_cfg(cosem_object_cfg *cosem);
+PRIVATE void cfg_free_cosem_group_cfg(cosem_group_cfg *group);
+
+PRIVATE void cfg_free_cosem_object(cosem_object *o);
+PRIVATE void cfg_free_cosem_group(cosem_group *g);
+PRIVATE void cfg_free_connection(connection *c);
+PRIVATE void cfg_free_physical_device(physical_device *d);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_config_free_2.h src/test/include/stub_config_free_2.h
--- orig/test/include/stub_config_free_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_config_free_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+#include "config_info.h"
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_cosem_group.h src/test/include/stub_cosem_group.h
--- orig/test/include/stub_cosem_group.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_cosem_group.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,24 @@
+#include "master.h"
+
+PUBLIC void utl_append_to_str(char **source, const char *values);
+
+PUBLIC int com_open_connection(connection *connection);
+PUBLIC int com_disconnect(connection *connection, dlmsSettings *settings);
+PUBLIC int com_close(connection *connection, dlmsSettings *settings);
+PUBLIC int com_update_invocation_counter(connection *connection, dlmsSettings *settings,
+				  const char *invocationCounter);
+PUBLIC int com_initialize_connection(connection *connection, dlmsSettings *settings);
+PUBLIC int com_readRowsByEntry(connection *c, dlmsSettings *s, gxProfileGeneric *obj, int index, int count);
+PUBLIC int com_close(connection *connection, dlmsSettings *settings);
+
+PRIVATE int cg_read_cosem_object(cosem_object *cosem_object, physical_device *dev);
+PRIVATE int cg_format_group_data(char **data, object_attributes *attr, char *device_name);
+
+PUBLIC void attr_init(object_attributes *attributes, gxObject *object);
+PUBLIC int attr_to_string(gxObject *object, object_attributes *attributes);
+PUBLIC void attr_free(object_attributes *attributes);
+
+PUBLIC void utl_append_to_str(char **source, const char *values);
+PUBLIC void utl_append_if_needed(char **data, int index, int value, char *str);
+PUBLIC void utl_append_obj_name(char **data, char *name);
+PUBLIC void utl_add_error_message(char **data, char *device_name, const char *err_msg, const int err_num);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_cosem_group_2.h src/test/include/stub_cosem_group_2.h
--- orig/test/include/stub_cosem_group_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_cosem_group_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,14 @@
+#include "master.h"
+
+PUBLIC char *cg_read_group_codes(cosem_group *group, int *rc);
+PRIVATE int cg_read_profile_generic_data(cosem_object *obj, gxProfileGeneric *pg, physical_device *dev);
+
+PUBLIC void utl_append_obj_name(char **data, char *name);
+PUBLIC void utl_append_to_str(char **source, const char *values);
+
+PUBLIC int com_read(connection *c, dlmsSettings *s, gxObject *object,
+		    unsigned char attributeOrdinal);
+
+PUBLIC void mstr_write_group_data_to_db(cosem_group *group, char *data);
+
+char *attr_to_json(object_attributes *attributes);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_cosem_group_3.h src/test/include/stub_cosem_group_3.h
--- orig/test/include/stub_cosem_group_3.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_cosem_group_3.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,19 @@
+#include "master.h"
+
+PUBLIC void attr_init(object_attributes *attributes, gxObject *object);
+PUBLIC void attr_free(object_attributes *attributes);
+PUBLIC int attr_to_string(gxObject *object, object_attributes *attributes);
+
+PUBLIC void utl_append_if_needed(char **data, int index, int value, char *str);
+PUBLIC void utl_append_obj_name(char **data, char *name);
+PUBLIC void utl_append_to_str(char **source, const char *values);
+PUBLIC void utl_add_error_message(char **data, char *device_name, const char *err_msg, const int err_num);
+PUBLIC void utl_lock_mutex_if_required(physical_device *d);
+PUBLIC void utl_unlock_mutex_if_required(physical_device *d);
+
+PUBLIC int cg_make_connection(physical_device *dev);
+PRIVATE int cg_read_cosem_object(cosem_object *cosem_object, physical_device *dev);
+PRIVATE int cg_format_group_data(char **data, object_attributes *attr, char *device_name);
+
+PUBLIC int com_read(connection *c, dlmsSettings *s, gxObject *object, unsigned char attributeOrdinal);
+PUBLIC int com_close(connection *c, dlmsSettings *s);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_external.h src/test/include/stub_external.h
--- orig/test/include/stub_external.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_external.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,102 @@
+#ifndef __STUB_EXTERNAL_H__  // pragma once generates warnings for this one for some reason
+#define __STUB_EXTERNAL_H__  // so using traditional include guard instead
+
+#define PRIVATE __attribute__((weak))
+#define PUBLIC __attribute__((weak))
+#define MAIN mymain
+#define TEST_BREAK break;
+
+#include "stub_uci.h"
+#include "stub_blob.h"
+#include "stub_blobmsg.h"
+#include "stub_uloop.h"
+#include "stub_sqlite3.h"
+#include "stub_libubus.h"
+
+#include <libubus.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+
+#define pthread_mutex_lock mypthread_mutex_lock
+#define pthread_mutex_unlock mypthread_mutex_unlock
+
+int pthread_mutex_lock(pthread_mutex_t *__mutex);
+int pthread_mutex_unlock(pthread_mutex_t *__mutex);
+
+#define ubus_add_uloop myubus_add_uloop
+
+#define strdup mystrdup
+#define strcmp mystrcmp
+#define strncmp mystrncmp
+#define strlcpy mystrlcpy
+#define strncat mystrncat
+#define strtol mystrtol
+#define strlen mystrlen
+#define strtok_r mystrtok_r
+#define strstr mystrstr
+
+#define malloc mymalloc
+#define calloc mycalloc
+#define realloc myrealloc
+#define free myfree
+#define exit myexit
+
+#define snprintf mysnprintf
+#define vfprintf myvfprintf
+#define snprintf mysnprintf
+#define fprintf myfprintf
+
+#define signal mysignal
+
+#ifdef va_start
+#undef va_start
+#endif
+#ifdef va_end
+#undef va_end
+#endif
+#define va_start myva_start
+#define va_end myva_end
+
+#define clock_gettime myclock_gettime
+
+void myubus_add_uloop(struct ubus_context *ctx);
+
+void myva_start(va_list ap, ...);
+void myva_end(va_list ap);
+
+// apparently this is too hard for ceedling to swallow
+//void (*)(int) mysignal(int signum, void (*handler)(int));
+typedef void (*signal_handler_fp)(int);
+signal_handler_fp mysignal(int signum, signal_handler_fp);
+
+char *mystrdup(const char *s);
+int mystrcmp(const char *s1, const char *s2);
+int strncmp(const char *s1, const char *s2, size_t n);
+size_t mystrlcpy(char *dst, const char *src, size_t size);
+char *mystrncat(char *dest, const char *src, size_t n);
+long int mystrtol(const char *nptr, char **endptr, int base);
+
+void *mymalloc(size_t size);
+void *mycalloc(size_t nmemb, size_t size);
+void *myrealloc(void *ptr, size_t size);
+void myfree(void *ptr);
+void myexit(int status);
+
+char *strtok_r(char *str, const char *delim, char **saveptr);
+
+int mysnprintf(char *str, size_t size, const char *format, ...);
+int myvfprintf(void *stream, const char *format, va_list ap);
+int mysnprintf(char *str, size_t size, const char *format, ...);
+int myfprintf(void *stream, const char *format, ...);
+
+char *strstr(const char *haystack, const char *needle);
+
+int mystrlen(const char *s);
+
+int myclock_gettime(clockid_t clk_id, struct timespec *tp);
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_main.h src/test/include/stub_main.h
--- orig/test/include/stub_main.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_main.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,13 @@
+#include "master.h"
+
+PUBLIC master *cfg_get_master();
+PUBLIC void cfg_free_master(master *m);
+
+PUBLIC int mstr_create_db(master *m);
+PUBLIC void mstr_db_free(master *m);
+PUBLIC int mstr_initialize_cosem_groups(master *m);
+
+PUBLIC int init_ubus_test_functions();
+PUBLIC void ubus_exit();
+
+PUBLIC int utl_parse_args(int argc, char **argv, log_level_type *debug_lvl);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_master_2.h src/test/include/stub_master_2.h
--- orig/test/include/stub_master_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_master_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,5 @@
+#include "master.h"
+
+PUBLIC char *cg_read_group_codes(cosem_group *group, int *rc);
+PUBLIC void utl_smart_sleep(time_t *t0, unsigned long *tn, unsigned p);
+PUBLIC void mstr_write_group_data_to_db(cosem_group *group, char *data);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_ubus.h src/test/include/stub_ubus.h
--- orig/test/include/stub_ubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_ubus.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,3 @@
+#include "master.h"
+
+PRIVATE int validate_key(const char *key, size_t len);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_ubus_2.h src/test/include/stub_ubus_2.h
--- orig/test/include/stub_ubus_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_ubus_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,15 @@
+#include "master.h"
+
+PRIVATE int reply(struct ubus_context *ctx, struct ubus_request_data *req, const int err_code, const char *y);
+
+PRIVATE int device_cb_args(physical_device *d, struct blob_attr *msg);
+PUBLIC int cg_make_connection(physical_device *dev);
+PUBLIC int com_close(connection *c, dlmsSettings *s);
+PRIVATE void free_device(physical_device *dev);
+
+PRIVATE int cosem_group_args(cosem_group *g, struct blob_attr *msg);
+PUBLIC char *cg_read_group_codes(cosem_group *group, int *rc);
+PRIVATE void free_cosem_group(cosem_group *g);
+
+PUBLIC void utl_lock_mutex_if_required(physical_device *d);
+PUBLIC void utl_unlock_mutex_if_required(physical_device *d);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_ubus_3.h src/test/include/stub_ubus_3.h
--- orig/test/include/stub_ubus_3.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_ubus_3.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,5 @@
+#include "master.h"
+
+PRIVATE void find_corresponding_mutex(connection *c);
+PRIVATE int read_security_settings(struct blob_attr **tb, physical_device *d);
+PRIVATE cosem_object *parse_cosem_object(struct blob_attr *b);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_utils.h src/test/include/stub_utils.h
--- orig/test/include/stub_utils.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_utils.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,3 @@
+#include "master.h"
+
+PUBLIC void utl_add_error_message(char **data, char *device_name, const char *err_msg, const int err_num);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_utils_2.h src/test/include/stub_utils_2.h
--- orig/test/include/stub_utils_2.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_utils_2.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,3 @@
+#include "master.h"
+
+PUBLIC void utl_append_to_str(char **source, const char *values);
diff --recursive --unified --new-file --no-dereference orig/test/include/stub_utils_3.h src/test/include/stub_utils_3.h
--- orig/test/include/stub_utils_3.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/stub_utils_3.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,4 @@
+#include "master.h"
+
+PUBLIC void utl_append_to_str(char **destination, const char *source);
+PUBLIC void utl_append_obj_name(char **data, char *name);
diff --recursive --unified --new-file --no-dereference orig/test/include/ubus.h src/test/include/ubus.h
--- orig/test/include/ubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/ubus.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+#include "master.h"
diff --recursive --unified --new-file --no-dereference orig/test/include/utils.h src/test/include/utils.h
--- orig/test/include/utils.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/include/utils.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+#include "master.h"
diff --recursive --unified --new-file --no-dereference orig/test/support/.git src/test/support/.git
--- orig/test/support/.git	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/.git	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1 @@
+gitdir: ../../.git/modules/test/support
diff --recursive --unified --new-file --no-dereference orig/test/support/README.md src/test/support/README.md
--- orig/test/support/README.md	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/README.md	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,3 @@
+# Stubs
+
+Stub headers that enable inline function mocking with Cmock.
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_blob.h src/test/support/stub_blob.h
--- orig/test/support/stub_blob.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_blob.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,25 @@
+#ifndef STUB_BLOB_H
+#define STUB_BLOB_H
+
+#define blob_data     blob_data_orig
+#define blob_len      blob_len_orig
+#define blob_buf_init blob_buf_init_orig
+#define blob_buf_free blob_buf_free_orig
+#define blob_pad_len  blob_pad_len_orig
+#define blob_next     blob_next_orig
+#include <blob.h>
+#undef blob_data
+#undef blob_len
+#undef blob_buf_init
+#undef blob_buf_free
+#undef blob_pad_len
+#undef blob_next
+
+void *blob_data(const struct blob_attr *attr);
+size_t blob_len(const struct blob_attr *attr);
+int blob_buf_init(struct blob_buf *buf, int id);
+void blob_buf_free(struct blob_buf *buf);
+size_t blob_pad_len(const struct blob_attr *attr);
+struct blob_attr *blob_next(const struct blob_attr *attr);
+
+#endif // STUB_BLOB_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_blobmsg.h src/test/support/stub_blobmsg.h
--- orig/test/support/stub_blobmsg.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_blobmsg.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,41 @@
+#ifndef STUB_BLOBMSG_H
+#define STUB_BLOBMSG_H
+
+#define blobmsg_add_field   blobmsg_add_field_orig
+#define blobmsg_add_string  blobmsg_add_string_orig
+#define blobmsg_add_u32	    blobmsg_add_u32_orig
+#define blobmsg_get_string  blobmsg_get_string_orig
+#define blobmsg_get_bool    blobmsg_get_bool_orig
+#define blobmsg_get_u32	    blobmsg_get_u32_orig
+#define blobmsg_parse	    blobmsg_parse_orig
+#define blobmsg_data	    blobmsg_data_orig
+#define blobmsg_len	    blobmsg_len_orig
+#define blobmsg_data_len    blobmsg_data_len_orig
+#define blobmsg_check_array blobmsg_check_array_orig
+#include <libubox/blobmsg.h>
+#undef blobmsg_add_field
+#undef blobmsg_add_string
+#undef blobmsg_add_u32
+#undef blobmsg_get_string
+#undef blobmsg_get_bool
+#undef blobmsg_get_u32
+#undef blobmsg_parse
+#undef blobmsg_data
+#undef blobmsg_len
+#undef blobmsg_data_len
+#undef blobmsg_check_array
+
+int blobmsg_add_field(struct blob_buf *buf, int type, const char *name, const void *data, unsigned int len);
+int blobmsg_add_string(struct blob_buf *buf, const char *name, const char *string);
+int blobmsg_add_u32(struct blob_buf *buf, const char *name, uint32_t val);
+char *blobmsg_get_string(struct blob_attr *attr);
+bool blobmsg_get_bool(struct blob_attr *attr);
+uint32_t blobmsg_get_u32(struct blob_attr *attr);
+int blobmsg_parse(const struct blobmsg_policy *policy, int policy_len, struct blob_attr **tb, void *data,
+		  unsigned int len);
+void *blobmsg_data(const struct blob_attr *attr);
+size_t blobmsg_len(const struct blob_attr *attr);
+size_t blobmsg_data_len(const struct blob_attr *attr);
+int blobmsg_check_array(const struct blob_attr *attr, int type);
+
+#endif // STUB_BLOBMSG_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_libubus.h src/test/support/stub_libubus.h
--- orig/test/support/stub_libubus.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_libubus.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,47 @@
+#ifndef STUB_LIBUBUS_H
+#define STUB_LIBUBUS_H
+#ifdef TEST
+#include "stub_blobmsg.h"
+#else
+#include <libubox/blobmsg.h>
+#endif
+
+#define ubus_connect		 ubus_connect_orig
+#define ubus_free		 ubus_free_orig
+#define ubus_strerror		 ubus_strerror_orig
+#define ubus_lookup_id		 ubus_lookup_id_orig
+#define ubus_add_object		 ubus_add_object_orig
+#define ubus_register_subscriber ubus_register_subscriber_orig
+#define ubus_invoke		 ubus_invoke_orig
+#define ubus_subscribe		 ubus_subscribe_orig
+#define ubus_send_event		 ubus_send_event_orig
+#define ubus_invoke_fd		 ubus_invoke_fd_orig
+#define ubus_send_reply		 ubus_send_reply_orig
+#include <libubus.h>
+#undef ubus_connect
+#undef ubus_free
+#undef ubus_strerror
+#undef ubus_lookup_id
+#undef ubus_add_object
+#undef ubus_register_subscriber
+#undef ubus_invoke
+#undef ubus_subscribe
+#undef ubus_send_event
+#undef ubus_invoke_fd
+#undef ubus_send_reply
+
+struct ubus_context *ubus_connect(const char *path);
+void ubus_free(struct ubus_context *ctx);
+const char *ubus_strerror(int error);
+int ubus_lookup_id(struct ubus_context *ctx, const char *path, uint32_t *id);
+int ubus_add_object(struct ubus_context *ctx, struct ubus_object *obj);
+int ubus_register_subscriber(struct ubus_context *ctx, struct ubus_subscriber *obj);
+int ubus_subscribe(struct ubus_context *ctx, struct ubus_subscriber *obj, uint32_t id);
+int ubus_invoke(struct ubus_context *ctx, uint32_t obj, const char *method, struct blob_attr *msg,
+		ubus_data_handler_t cb, void *priv, int timeout);
+int ubus_send_event(struct ubus_context *ctx, const char *id, struct blob_attr *data);
+int ubus_invoke_fd(struct ubus_context *ctx, uint32_t obj, const char *method, struct blob_attr *msg,
+		   ubus_data_handler_t cb, void *priv, int timeout, int fd);
+int ubus_send_reply(struct ubus_context *ctx, struct ubus_request_data *req, struct blob_attr *msg);
+
+#endif // STUB_LIBUBUS_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_pthread.h src/test/support/stub_pthread.h
--- orig/test/support/stub_pthread.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_pthread.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,22 @@
+#ifndef STUB_PTHREAD_H
+#define STUB_PTHREAD_H
+
+#define pthread_create	      pthread_create_orig
+#define pthread_mutex_init    pthread_mutex_init_orig
+#define pthread_mutex_destroy pthread_mutex_destroy_orig
+// #define pthread_mutex_lock    pthread_mutex_lock_orig
+// #define pthread_mutex_unlock  pthread_mutex_unlock_orig
+#include <pthread.h>
+#undef pthread_create
+#undef pthread_mutex_init
+#undef pthread_mutex_destroy
+// #undef pthread_mutex_lock
+// #undef pthread_mutex_unlock
+
+int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
+int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr);
+int pthread_mutex_destroy(pthread_mutex_t *__mutex);
+// int pthread_mutex_lock(pthread_mutex_t *__mutex);
+// int pthread_mutex_unlock(pthread_mutex_t *__mutex);
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_sqlite3.h src/test/support/stub_sqlite3.h
--- orig/test/support/stub_sqlite3.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_sqlite3.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,69 @@
+#ifndef STUB_SQLITE3_H
+#define STUB_SQLITE3_H
+
+#define sqlite3_bind_blob sqlite3_bind_blob_orig
+#define sqlite3_bind_int sqlite3_bind_int_orig
+#define sqlite3_bind_null sqlite3_bind_null_orig
+#define sqlite3_bind_text sqlite3_bind_text_orig
+#define sqlite3_busy_timeout sqlite3_busy_timeout_orig
+#define sqlite3_close sqlite3_close_orig
+#define sqlite3_errmsg sqlite3_errmsg_orig
+#define sqlite3_exec sqlite3_exec_orig
+#define sqlite3_finalize sqlite3_finalize_orig
+#define sqlite3_open sqlite3_open_orig
+#define sqlite3_prepare_v2 sqlite3_prepare_v2_orig
+#define sqlite3_reset sqlite3_reset_orig
+#define sqlite3_step sqlite3_step_orig
+#define sqlite3_stmt sqlite3_stmt_orig
+#define sqlite3_column_int sqlite3_column_int_orig
+#define sqlite3_clear_bindings sqlite3_clear_bindings_orig
+#define sqlite3_threadsafe sqlite3_threadsafe_orig
+#define sqlite3_close_v2 sqlite3_close_v2_orig
+#define sqlite3 sqlite3_orig
+#include <sqlite3.h>
+#undef sqlite3_bind_blob
+#undef sqlite3_bind_int
+#undef sqlite3_bind_null
+#undef sqlite3_bind_text
+#undef sqlite3_busy_timeout
+#undef sqlite3_close
+#undef sqlite3_errmsg
+#undef sqlite3_exec
+#undef sqlite3_finalize
+#undef sqlite3_open
+#undef sqlite3_prepare_v2
+#undef sqlite3_reset
+#undef sqlite3_step
+#undef sqlite3_stmt
+#undef sqlite3_column_int
+#undef sqlite3_clear_bindings
+#undef sqlite3_threadsafe
+#undef sqlite3_close_v2
+#undef sqlite3
+
+typedef struct {
+	int x;
+} sqlite3; // make cmock happy
+typedef struct {
+	int x;
+} sqlite3_stmt; // make cmock happy
+
+int sqlite3_bind_blob(sqlite3_stmt *stmt, int index, const void *value, int valueBytes, void(*destructor)(void *));
+int sqlite3_bind_int(sqlite3_stmt *stmt, int index, int value);
+int sqlite3_bind_null(sqlite3_stmt *stmt, int index);
+int sqlite3_bind_text(sqlite3_stmt *stmt, int index, const char *value, int valueBytes, void(*destructor)(void *));
+int sqlite3_busy_timeout(sqlite3 *db, int timeout);
+int sqlite3_close(sqlite3 *db);
+const char *sqlite3_errmsg(sqlite3 *db);
+int sqlite3_exec(sqlite3 *db, const char *sql, int (*callback)(void*,int,char**,char**), void *p, char **errmsg);
+int sqlite3_finalize(sqlite3_stmt *pStmt);
+int sqlite3_open(const char *path, sqlite3 **db);
+int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail);
+int sqlite3_reset(sqlite3_stmt *pStmt);
+int sqlite3_step(sqlite3_stmt *pStmt);
+int sqlite3_column_int(sqlite3_stmt*, int iCol);
+int sqlite3_clear_bindings(sqlite3_stmt*);
+int sqlite3_threadsafe(void);
+int sqlite3_close_v2(sqlite3*);
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_stat.h src/test/support/stub_stat.h
--- orig/test/support/stub_stat.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_stat.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,16 @@
+#ifndef STUB_STAT_H
+#define STUB_STAT_H
+
+struct stat;
+typedef unsigned int __mode_t;
+
+#define stat  stat_orig
+#define mkdir mkdir_orig
+#include <sys/stat.h>
+#undef stat
+#undef mkdir
+
+int stat(const char *__restrict __file, struct stat *__restrict __buf);
+int mkdir(const char *__path, __mode_t __mode);
+
+#endif // STUB_STAT_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_stdio.h src/test/support/stub_stdio.h
--- orig/test/support/stub_stdio.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_stdio.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,25 @@
+#ifndef STUB_STDIO_H
+#define STUB_STDIO_H
+
+#define fopen	fopen_orig
+#define fgets	fgets_orig
+#define fprintf fprintf_orig
+#define fflush	fflush_orig
+#define fclose	fclose_orig
+#define remove	remove_orig
+#include <stdio.h>
+#undef fopen
+#undef fgets
+#undef fprintf
+#undef fflush
+#undef fclose
+#undef remove
+
+FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
+char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
+int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
+int fflush(FILE *__stream);
+int fclose(FILE *__stream);
+int remove(const char *__filename);
+
+#endif // STUB_STDIO_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_sysinfo.h src/test/support/stub_sysinfo.h
--- orig/test/support/stub_sysinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_sysinfo.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,22 @@
+#ifndef STUB_SYSINFO_H
+#define STUB_SYSINFO_H
+
+struct sysinfo {
+	unsigned long uptime;
+	unsigned long loads[3];
+	unsigned long totalram;
+	unsigned long freeram;
+	unsigned long sharedram;
+	unsigned long bufferram;
+	unsigned long totalswap;
+	unsigned long freeswap;
+	unsigned short procs, pad;
+	unsigned long totalhigh;
+	unsigned long freehigh;
+	unsigned mem_unit;
+	char __reserved[256];
+};
+
+int sysinfo(struct sysinfo *info);
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_uci.h src/test/support/stub_uci.h
--- orig/test/support/stub_uci.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_uci.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,43 @@
+#ifndef STUB_UCI_H
+#define STUB_UCI_H
+
+#define uci_alloc_context	 uci_alloc_context_orig
+#define uci_free_context	 uci_free_context_orig
+#define uci_load		 uci_load_orig
+#define uci_unload		 uci_unload_orig
+#define uci_get_errorstr	 uci_get_errorstr_orig
+#define uci_lookup_package	 uci_lookup_package_orig
+#define uci_lookup_section	 uci_lookup_section_orig
+#define uci_lookup_option	 uci_lookup_option_orig
+#define uci_lookup_option_string uci_lookup_option_string_orig
+#define uci_lookup_ptr		 uci_lookup_ptr_orig
+#define uci_set			 uci_set_orig
+#define uci_commit		 uci_commit_orig
+#include <uci.h>
+#undef uci_alloc_context
+#undef uci_free_context
+#undef uci_load
+#undef uci_unload
+#undef uci_get_errorstr
+#undef uci_lookup_package
+#undef uci_lookup_section
+#undef uci_lookup_option_string
+#undef uci_lookup_ptr
+#undef uci_set
+#undef uci_commit
+#undef uci_lookup_option
+
+struct uci_context *uci_alloc_context(void);
+void uci_free_context(struct uci_context *ctx);
+int uci_load(struct uci_context *ctx, const char *name, struct uci_package **package);
+int uci_unload(struct uci_context *ctx, struct uci_package *p);
+void uci_get_errorstr(struct uci_context *ctx, char **dest, const char *str);
+struct uci_package *uci_lookup_package(struct uci_context *ctx, const char *name);
+const char *uci_lookup_option_string(struct uci_context *ctx, struct uci_section *s, const char *name);
+extern int uci_lookup_ptr(struct uci_context *ctx, struct uci_ptr *ptr, char *str, bool extended);
+extern int uci_set(struct uci_context *ctx, struct uci_ptr *ptr);
+extern int uci_commit(struct uci_context *ctx, struct uci_package **p, bool overwrite);
+struct uci_section *uci_lookup_section(struct uci_context *ctx, struct uci_package *p, const char *name);
+struct uci_option *uci_lookup_option(struct uci_context *ctx, struct uci_section *s, const char *name);
+
+#endif // STUB_UCI_H
diff --recursive --unified --new-file --no-dereference orig/test/support/stub_uloop.h src/test/support/stub_uloop.h
--- orig/test/support/stub_uloop.h	1970-01-01 00:00:00.000000000 +0000
+++ src/test/support/stub_uloop.h	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,25 @@
+#ifndef STUB_ULOOP_H
+#define STUB_ULOOP_H
+
+#define uloop_timeout_set uloop_timeout_set_orig
+#define uloop_init	  uloop_init_orig
+#define uloop_done	  uloop_done_orig
+#define uloop_fd_add	  uloop_fd_add_orig
+#define uloop_run_timeout uloop_run_timeout_orig
+#define uloop_run	  uloop_run_orig
+#include <libubox/uloop.h>
+#undef uloop_timeout_set
+#undef uloop_init
+#undef uloop_done
+#undef uloop_fd_add
+#undef uloop_run_timeout
+#undef uloop_run
+
+int uloop_timeout_set(struct uloop_timeout *timeout, int msecs);
+int uloop_init(void);
+void uloop_done(void);
+int uloop_fd_add(struct uloop_fd *sock, unsigned int flags);
+int uloop_run_timeout(int timeout);
+int uloop_run(void);
+
+#endif // STUB_ULOOP_H
diff --recursive --unified --new-file --no-dereference orig/test/test_config.c src/test/test_config.c
--- orig/test/test_config.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_config.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,802 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "config.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_config.h"
+
+#include "mock_stub_uci.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+PRIVATE dlms_cfg *cfg_read_dlms_cfg();
+PRIVATE master *cfg_read_master(dlms_cfg *cfg);
+
+PRIVATE connection *cfg_get_connection(connection_params_cfg *cfg);
+PRIVATE physical_device *cfg_get_physical_device(physical_device_cfg *cfg, connection **connections, size_t connection_count);
+PRIVATE cosem_object *cfg_get_cosem_object(cosem_object_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count);
+PRIVATE cosem_group *cfg_get_cosem_group(dlms_cfg *cfg, cosem_group_cfg *cosem_group_cfg, cosem_object **cosem_objects, size_t cosem_object_count);
+
+PRIVATE int cfg_init_mutexes(master *m);
+
+master *g_master = NULL;
+
+void test_cfg_read_dlms_cfg_calloc_failure(void)
+{
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_alloc_failure(void)
+{
+	dlms_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+
+	uci_alloc_context_ExpectAndReturn(NULL);
+	_log_ExpectAnyArgs();
+
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_load_returns_error(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = NULL;
+	dlms_cfg cfg		= { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_IgnoreArg_package();
+	_log_ExpectAnyArgs();
+
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_connections_are_not_found(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= { 0 };
+	struct uci_section sec1 = { .type = "master" };
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 1);
+	_log_ExpectAnyArgs();
+
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_fail_to_read_connection_section(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= { 0 };
+	struct uci_section sec1 = { .type = "connection" };
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 0);
+	cfg_read_connection_ExpectAndReturn(&uci, &sec1, NULL);
+
+	_log_ExpectAnyArgs();
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+
+void test_cfg_read_dlms_cfg_physical_devices_are_not_found(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= { 0 };
+	struct uci_section sec1 = { .type = "connection" };
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 0);
+	cfg_read_connection_ExpectAndReturn(&uci, &sec1, (connection_params_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.connections,
+				  (cfg.connection_cfg_count + 1) * sizeof(connection_params_cfg),
+				  (connection_params_cfg[]){ 0 });
+
+	mystrcmp_ExpectAndReturn(sec1.type, "physical_device", 1);
+	_log_ExpectAnyArgs();
+
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_fail_to_read_physical_device_section(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= { 0 };
+	struct uci_section sec1 = { .type = "connection" };
+	struct uci_section sec2 = { .type = "physical_device" };
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &sec2.e.list;
+	sec2.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 0);
+	cfg_read_connection_ExpectAndReturn(&uci, &sec1, (connection_params_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.connections,
+				  (cfg.connection_cfg_count + 1) * sizeof(connection_params_cfg),
+				  (connection_params_cfg[]){ 0 });
+	mystrcmp_ExpectAndReturn(sec2.type, "connection", 1);
+
+	mystrcmp_ExpectAndReturn(sec1.type, "physical_device", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "physical_device", 0);
+	cfg_read_physical_device_ExpectAndReturn(&uci, &sec2, NULL);
+
+	_log_ExpectAnyArgs();
+	uci_free_context_Ignore();
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_read_all_sections(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= { 0 };
+	struct uci_section sec1 = { .type = "connection" };
+	struct uci_section sec2 = { .type = "physical_device" };
+	struct uci_section sec3 = { .type = "cosem" };
+	struct uci_section sec4 = { .type = "cosem_group" };
+
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &sec2.e.list;
+	sec2.e.list.next   = &sec3.e.list;
+	sec3.e.list.next   = &sec4.e.list;
+	sec4.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 0);
+	cfg_read_connection_ExpectAndReturn(&uci, &sec1, (connection_params_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.connections,
+				  (cfg.connection_cfg_count + 1) * sizeof(connection_params_cfg),
+				  (connection_params_cfg[]){ 0 });
+	mystrcmp_ExpectAndReturn(sec2.type, "connection", 1);
+	mystrcmp_ExpectAndReturn(sec3.type, "connection", 1);
+	mystrcmp_ExpectAndReturn(sec4.type, "connection", 1);
+
+	mystrcmp_ExpectAndReturn(sec1.type, "physical_device", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "physical_device", 0);
+	cfg_read_physical_device_ExpectAndReturn(&uci, &sec2, (physical_device_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.physical_devices,
+				  (cfg.physical_device_cfg_count + 1) * sizeof(physical_device_cfg),
+				  (physical_device_cfg[]){ 0 });
+	mystrcmp_ExpectAndReturn(sec3.type, "physical_device", 1);
+	mystrcmp_ExpectAndReturn(sec4.type, "physical_device", 1);
+
+	mystrcmp_ExpectAndReturn(sec1.type, "cosem", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "cosem", 1);
+	mystrcmp_ExpectAndReturn(sec3.type, "cosem", 0);
+	cfg_read_cosem_object_ExpectAndReturn(&uci, &sec3, NULL);
+	mystrcmp_ExpectAndReturn(sec4.type, "cosem", 1);
+
+	mystrcmp_ExpectAndReturn(sec1.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec3.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec4.type, "cosem_group", 0);
+	cfg_read_cosem_group_ExpectAndReturn(&uci, &sec4, NULL);
+
+	uci_free_context_Ignore();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_dlms_cfg());
+}
+
+void test_cfg_read_dlms_cfg_uci_check_limits(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_package *pkg = (struct uci_package []) { 0 };
+	dlms_cfg cfg		= {
+			   .connection_cfg_count      = 9,
+			   .physical_device_cfg_count = 29,
+			   .cosem_group_cfg_count     = 9,
+	};
+	struct uci_section sec1 = { .type = "connection" };
+	struct uci_section sec2 = { .type = "physical_device" };
+	struct uci_section sec3 = { .type = "cosem" };
+	struct uci_section sec4 = { .type = "cosem_group" };
+
+	pkg->sections.next = &sec1.e.list;
+	sec1.e.list.next   = &sec2.e.list;
+	sec2.e.list.next   = &sec3.e.list;
+	sec3.e.list.next   = &sec4.e.list;
+	sec4.e.list.next   = &pkg->sections;
+
+	mycalloc_ExpectAndReturn(1, sizeof(dlms_cfg), &cfg);
+	uci_alloc_context_ExpectAndReturn(&uci);
+
+	uci_load_ExpectAndReturn(&uci, "dlms_master", &pkg, 0);
+	uci_load_ReturnThruPtr_package(&pkg);
+	uci_load_IgnoreArg_package();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "connection", 0);
+	cfg_read_connection_ExpectAndReturn(&uci, &sec1, (connection_params_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.connections, (cfg.connection_cfg_count + 1) * sizeof(connection_params_cfg), (connection_params_cfg []) { 0 });
+	_log_ExpectAnyArgs();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "physical_device", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "physical_device", 0);
+	cfg_read_physical_device_ExpectAndReturn(&uci, &sec2, (physical_device_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.physical_devices, (cfg.physical_device_cfg_count + 1) * sizeof(physical_device_cfg), (physical_device_cfg []) { 0 });
+	_log_ExpectAnyArgs();
+
+	mystrcmp_ExpectAndReturn(sec1.type, "cosem", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "cosem", 1);
+	mystrcmp_ExpectAndReturn(sec3.type, "cosem", 0);
+	cfg_read_cosem_object_ExpectAndReturn(&uci, &sec3, (cosem_object_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.cosem_objects, (cfg.cosem_object_cfg_count + 1) * sizeof(cosem_object_cfg), (cosem_object_cfg []) { 0 });
+	mystrcmp_ExpectAndReturn(sec4.type, "cosem", 1);
+
+	mystrcmp_ExpectAndReturn(sec1.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec2.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec3.type, "cosem_group", 1);
+	mystrcmp_ExpectAndReturn(sec4.type, "cosem_group", 0);
+	cfg_read_cosem_group_ExpectAndReturn(&uci, &sec4, (cosem_group_cfg []) { 0 });
+	myrealloc_ExpectAndReturn(cfg.cosem_groups, (cfg.cosem_group_cfg_count + 1) * sizeof(cosem_group_cfg), (cosem_group_cfg []) { 0 });
+	_log_ExpectAnyArgs();
+
+	uci_free_context_Ignore();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_dlms_cfg());
+	TEST_ASSERT_EQUAL(cfg.connection_cfg_count, 10);
+	TEST_ASSERT_EQUAL(cfg.physical_device_cfg_count, 30);
+	TEST_ASSERT_EQUAL(cfg.cosem_group_cfg_count, 10);
+}
+
+void test_cfg_read_master_calloc_failure(void)
+{
+	mycalloc_ExpectAndReturn(1, sizeof(master), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_master(NULL));
+}
+
+void test_cfg_read_master_connections_is_null(void)
+{
+	dlms_cfg cfg = { 0 };
+	master m     = { 0 };
+
+	size_t connections_count     = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(master), &m);
+
+	cfg_get_connections_ExpectAndReturn(&cfg, &connections_count, NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_master(&cfg));
+}
+
+void test_cfg_read_master_physical_devices_is_null(void)
+{
+	dlms_cfg cfg = { 0 };
+	master m     = { 0 };
+
+	size_t devices_count	     = 0;
+	size_t connections_count     = 0;
+	size_t connections_count_ret = 1;
+
+	mycalloc_ExpectAndReturn(1, sizeof(master), &m);
+
+	connection **c = (connection *[]) { 0 };
+
+	cfg_get_connections_ExpectAndReturn(&cfg, &connections_count, c);
+	cfg_get_connections_ReturnThruPtr_connection_count(&connections_count_ret);
+	cfg_get_physical_devices_ExpectAndReturn(&cfg, c, 1, &devices_count, NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_master(&cfg));
+}
+
+void test_cfg_read_master_physical_successful(void)
+{
+	dlms_cfg cfg	      = { 0 };
+	master m	      = { 0 };
+	physical_device **dev = (physical_device *[]){ 0 };
+	connection **c	      = (connection *[]){ 0 };
+
+	size_t devices_count	     = 0;
+	size_t connections_count     = 0;
+	size_t connections_count_ret = 1;
+	size_t cosem_object_count    = 0;
+	size_t cosem_group_count     = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(master), &m);
+
+	cfg_get_connections_ExpectAndReturn(&cfg, &connections_count, c);
+	cfg_get_connections_ReturnThruPtr_connection_count(&connections_count_ret);
+	cfg_get_physical_devices_ExpectAndReturn(&cfg, c, 1, &devices_count, dev);
+	cfg_get_physical_devices_ReturnThruPtr_physical_dev_count(&connections_count_ret);
+	cfg_get_cosem_objects_ExpectAndReturn(&cfg, dev, 1, &cosem_object_count, NULL);
+	cfg_get_cosem_groups_ExpectAndReturn(&cfg, NULL, 0, &cosem_group_count, NULL);
+
+	TEST_ASSERT_NOT_NULL(cfg_read_master(&cfg));
+}
+
+void test_cfg_get_connection_calloc_failure(void)
+{
+	connection_params_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_connection(&cfg));
+}
+
+////////////////////  TODO: ASSERT ALL STRUCT VARIABLES <<<<<<<<<<<<<<<<<<<<<<<
+void test_cfg_get_connection_TCP_connection_type(void)
+{
+	connection_params_cfg cfg = { 0 };
+	connection *c = (connection []) { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection), c);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	mystrdup_ExpectAndReturn(cfg.parameters.tcp.host, "");
+
+	bb_init_ExpectAndReturn(&c->data, 0);
+	bb_capacity_ExpectAndReturn(&c->data, 500, 0);
+
+	TEST_ASSERT_NOT_NULL(cfg_get_connection(&cfg));
+}
+
+void test_cfg_get_connection_SERIAL_connection_type(void)
+{
+	connection_params_cfg cfg = { .type = 1 };
+	connection *c = (connection []) { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection), c);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	mystrdup_ExpectAndReturn(cfg.parameters.serial.device, "");
+	mystrdup_ExpectAndReturn(cfg.parameters.serial.parity, "");
+	mystrdup_ExpectAndReturn(cfg.parameters.serial.flow_control, "");
+
+	bb_init_ExpectAndReturn(&c->data, 0);
+	bb_capacity_ExpectAndReturn(&c->data, 500, 0);
+
+	TEST_ASSERT_NOT_NULL(cfg_get_connection(&cfg));
+}
+
+void test_cfg_get_connection_unknown_connection_type(void)
+{
+	connection_params_cfg cfg = { .type = 9 };
+	connection *c = (connection []) { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection), c);
+
+	mystrdup_ExpectAndReturn(cfg.name, NULL);
+
+	_log_ExpectAnyArgs();
+
+	myfree_Expect(c->name);
+	myfree_Expect(c);
+
+	TEST_ASSERT_NULL(cfg_get_connection(&cfg));
+}
+
+void test_cfg_get_physical_device_calloc_failure(void)
+{
+	physical_device_cfg cfg = { 0 };
+	connection **connections  = (connection *[]){ 0 };
+	size_t connection_count	  = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_physical_device(&cfg, connections, connection_count));
+}
+
+void test_cfg_get_physical_device_fail_to_find_connection(void)
+{
+	physical_device_cfg cfg = { .invocation_counter = "0.4.5.6.7.8", .name = "labas" };
+	connection **connections  = (connection *[]){ 0 };
+	size_t connection_count	  = 0;
+
+	physical_device *dev = (physical_device[]) { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device), dev);
+	mystrdup_ExpectAndReturn(cfg.name, cfg.name);
+	mystrdup_ExpectAndReturn(cfg.invocation_counter, cfg.invocation_counter);
+	_log_ExpectAnyArgs();
+
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_physical_device(&cfg, connections, connection_count));
+}
+
+void test_cfg_get_physical_device_successfully_get_device(void)
+{
+	physical_device_cfg cfg = {
+		.invocation_counter = "0.4.5.6.7.8",
+		.connection	    = 4,
+		.authentication_key = "987654321",
+		.block_cipher_key   = "7777",
+		.dedicated_key	    = "123456",
+	};
+	connection **connections  = (connection *[]){
+		 (connection[]){
+			 { .id = 4 },
+		 },
+	};
+	size_t connection_count = 1;
+
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device), (physical_device[]){ 0 });
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	mystrdup_ExpectAndReturn(cfg.invocation_counter, "");
+
+	// TODO: take real life example, calculate serveraddress return yourself
+	cl_getServerAddress_IgnoreAndReturn(0);
+	cl_init_Ignore();
+	bb_clear_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+	bb_init_IgnoreAndReturn(0);
+	mycalloc_ExpectAndReturn(1, sizeof(gxByteBuffer), (gxByteBuffer[]) { 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_physical_device(&cfg, connections, connection_count));
+}
+
+void test_cfg_get_cosem_object_calloc_failure(void)
+{
+	cosem_object_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_object(&cfg, NULL, 0));
+}
+
+void test_cfg_get_cosem_object_fail_to_find_physical_devices(void)
+{
+	cosem_object_cfg cfg = { 0 };
+	cosem_object *o	     = (cosem_object[]){ 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), o);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	char *tok_save = NULL;
+	mystrtok_r_ExpectAndReturn(cfg.physical_devices, " ", &tok_save, NULL);
+	mystrtok_r_IgnoreArg_saveptr();
+	_log_ExpectAnyArgs();
+
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_object(&cfg, NULL, 0));
+}
+
+void test_cfg_get_cosem_object_fail_to_create_object(void)
+{
+	cosem_object_cfg cfg = { .physical_devices = "4" };
+	cosem_object *o	     = (cosem_object[]){ 0 };
+	physical_device **dev = (physical_device *[]){
+		(physical_device[]){
+			{ .id = 4 },
+		},
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), o);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	char *tok_save = NULL;
+	mystrtok_r_ExpectAndReturn(cfg.physical_devices, " ", &tok_save, cfg.physical_devices);
+	mystrtok_r_IgnoreArg_saveptr();
+	mystrtol_ExpectAnyArgsAndReturn(4);
+
+
+	myrealloc_ExpectAndReturn(o->devices, 1 * sizeof(physical_device *), (physical_device *[]) { 0 });
+	mystrtok_r_ExpectAndReturn(NULL, " ", &tok_save, NULL);
+	mystrtok_r_IgnoreArg_saveptr();
+
+	cosem_createObject2_ExpectAndReturn(cfg.cosem_id, cfg.obis, &o->object, 1);
+	_log_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_object(&cfg, dev, 1));
+}
+
+void test_cfg_get_cosem_object_fail_to_init_object(void)
+{
+	cosem_object_cfg cfg  = { .physical_devices = "4" };
+	cosem_object *o	      = (cosem_object[]){ 0 };
+	physical_device **dev = (physical_device *[]){
+		(physical_device[]){
+			{ .id = 4 },
+		},
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), o);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	char *tok_save = NULL;
+	mystrtok_r_ExpectAndReturn(cfg.physical_devices, " ", &tok_save, cfg.physical_devices);
+	mystrtok_r_IgnoreArg_saveptr();
+	mystrtol_ExpectAnyArgsAndReturn(4);
+
+	myrealloc_ExpectAndReturn(o->devices, 1 * sizeof(physical_device *), (physical_device *[]) { 0 });
+	mystrtok_r_ExpectAndReturn(NULL, " ", &tok_save, NULL);
+	mystrtok_r_IgnoreArg_saveptr();
+
+	cosem_createObject2_ExpectAndReturn(cfg.cosem_id, cfg.obis, &o->object, 0);
+	cosem_init_ExpectAndReturn(o->object, cfg.cosem_id, cfg.obis, 1);
+	_log_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_object(&cfg, dev, 1));
+}
+
+void test_cfg_get_cosem_object_successfully_get_devices(void)
+{
+	cosem_object_cfg cfg = { .physical_devices = "4" };
+	cosem_object *o	     = (cosem_object[]){ 0 };
+	physical_device **dev = (physical_device *[]){
+		(physical_device[]){
+			{ .id = 4 },
+		},
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), o);
+
+	mystrdup_ExpectAndReturn(cfg.name, "");
+	char *tok_save = NULL;
+	mystrtok_r_ExpectAndReturn(cfg.physical_devices, " ", &tok_save, cfg.physical_devices);
+	mystrtok_r_IgnoreArg_saveptr();
+	mystrtol_ExpectAnyArgsAndReturn(4);
+
+
+	myrealloc_ExpectAndReturn(o->devices, 1 * sizeof(physical_device *), (physical_device *[]) { 0 });
+
+
+	mystrtok_r_ExpectAndReturn(NULL, " ", &tok_save, NULL);
+	mystrtok_r_IgnoreArg_saveptr();
+
+	cosem_createObject2_ExpectAndReturn(cfg.cosem_id, cfg.obis, &o->object, 0);
+	cosem_init_ExpectAndReturn(o->object, cfg.cosem_id, cfg.obis, 0);
+
+	TEST_ASSERT_NOT_NULL(cfg_get_cosem_object(&cfg, dev, 1));
+}
+
+void test_cfg_get_cosem_group_calloc_failure(void)
+{
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_group(NULL, NULL, NULL, 0));
+}
+
+void test_cfg_get_cosem_group_zero_cosem_objects(void)
+{
+	dlms_cfg cfg	      = { 0 };
+	cosem_group g	      = { 0 };
+	cosem_group_cfg g_cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group), &g);
+	mystrdup_ExpectAndReturn(g_cfg.name, "");
+
+	_log_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_group(&cfg, &g_cfg, NULL, 0));
+}
+
+void test_cfg_get_cosem_group_fail_to_find_cosem_objects(void)
+{
+	dlms_cfg cfg = {
+		.cosem_object_cfg_count = 1,
+		.cosem_objects =
+			(cosem_object_cfg *[]){
+				(cosem_object_cfg[]){
+					{ .id = 3 },
+				},
+			},
+	};
+	cosem_group g	      = { 0 };
+	cosem_group_cfg g_cfg = { 0 };
+	cosem_object **obj    = (cosem_object *[]){
+		   (cosem_object[]){
+			{ .id = 4 }
+		   },
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group), &g);
+	mystrdup_ExpectAndReturn(g_cfg.name, "");
+
+	_log_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_group(&cfg, &g_cfg, obj, 1));
+}
+
+#undef calloc
+void test_cfg_get_cosem_group_check_limits(void)
+{
+	dlms_cfg cfg = {
+		.cosem_object_cfg_count = 1,
+		.cosem_objects =
+			(cosem_object_cfg *[]){
+				(cosem_object_cfg[]){
+					{ .id = 4 },
+				},
+			},
+	};
+	cosem_group g	      = { .cosem_object_count = 20 };
+	cosem_group_cfg g_cfg = { 0 };
+	cosem_object **obj    = (cosem_object *[]){
+		   (cosem_object[]){
+			{ .id = 4 }
+		   },
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group), &g);
+	mystrdup_ExpectAndReturn(g_cfg.name, "");
+	myrealloc_ExpectAndReturn(g.cosem_objects, (g.cosem_object_count + 1) * sizeof(cosem_object *), (cosem_object[20]){ 0 });
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NOT_NULL(cfg_get_cosem_group(&cfg, &g_cfg, obj, 1));
+}
+
+void test_cfg_get_cosem_group_successfully_get_cosem_group(void)
+{
+	dlms_cfg cfg = {
+		.cosem_object_cfg_count = 1,
+		.cosem_objects =
+			(cosem_object_cfg *[]){
+				(cosem_object_cfg[]){
+					{ .id = 4 },
+				},
+			},
+	};
+	cosem_group g	      = { 0 };
+	cosem_group_cfg g_cfg = { 0 };
+	cosem_object **obj    = (cosem_object *[]){
+		   (cosem_object[]){
+			{ .id = 4 }
+		   },
+	};
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group), &g);
+	mystrdup_ExpectAndReturn(g_cfg.name, "");
+	myrealloc_ExpectAndReturn(g.cosem_objects, (g.cosem_object_count + 1) * sizeof(cosem_object *), (cosem_object []) { 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_cosem_group(&cfg, &g_cfg, obj, 1));
+}
+
+void test_cfg_init_mutexes_connection_count_is_zero(void)
+{
+	master m = { 0 };
+
+	TEST_ASSERT_EQUAL(0, cfg_init_mutexes(&m));
+}
+
+void test_cfg_init_mutexes_connection_tcp_fail_to_initiate(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections	  = (connection *[]){ (connection[]){ {
+			     .type = TCP,
+			     .id   = 4,
+		     } } },
+	};
+
+	cfg_init_mutex_ExpectAndReturn(&m.connections[0]->mutex, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL(1, cfg_init_mutexes(&m));
+}
+
+void test_cfg_init_mutexes_connection_serial_rs232_fail_to_initiate(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections	  = (connection *[]){ (connection[]){ {
+			     .type = SERIAL,
+			     .id   = 4,
+		     } } },
+	};
+
+	mystrstr_ExpectAndReturn(m.connections[0]->parameters.serial.device, "rs485", NULL);
+	cfg_init_mutex_ExpectAndReturn(&m.mutex_rs232, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL(1, cfg_init_mutexes(&m));
+}
+
+void test_cfg_init_mutexes_connection_serial_rs485_fail_to_initiate(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections	  = (connection *[]){ (connection[]){ {
+			     .type = SERIAL,
+			     .id   = 4,
+		     } } },
+	};
+
+	mystrstr_ExpectAndReturn(m.connections[0]->parameters.serial.device, "rs485", "r");
+	cfg_init_mutex_ExpectAndReturn(&m.mutex_rs485, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL(1, cfg_init_mutexes(&m));
+}
+
+void test_cfg_init_mutexes_connection_tcp_succesfful_initiation(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections	  = (connection *[]){ (connection[]){ {
+			     .type = TCP,
+			     .id   = 4,
+		     } } },
+	};
+
+	cfg_init_mutex_ExpectAndReturn(&m.connections[0]->mutex, 0);
+
+	TEST_ASSERT_EQUAL(0, cfg_init_mutexes(&m));
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_config_2.c src/test/test_config_2.c
--- orig/test/test_config_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_config_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,1266 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "config.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_config_2.h"
+
+#include "mock_libtlt_uci.h"
+#include "mock_stub_pthread.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+PRIVATE connection_params_cfg *cfg_read_connection(struct uci_context *uci, struct uci_section *section);
+PRIVATE physical_device_cfg *cfg_read_physical_device(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_object_cfg *cfg_read_cosem_object(struct uci_context *uci, struct uci_section *section);
+PRIVATE cosem_group_cfg *cfg_read_cosem_group(struct uci_context *uci, struct uci_section *section);
+
+PRIVATE connection **cfg_get_connections(dlms_cfg *cfg, size_t *connection_count);
+PRIVATE physical_device **cfg_get_physical_devices(dlms_cfg *cfg, connection **connections, size_t connection_count, size_t *physical_dev_count);
+PRIVATE cosem_object **cfg_get_cosem_objects(dlms_cfg *cfg, physical_device **physical_devices, size_t physical_dev_count, size_t *cosem_object_count);
+PRIVATE cosem_group **cfg_get_cosem_groups(dlms_cfg *cfg, cosem_object **cosem_objects, size_t cosem_object_count, size_t *cosem_group_count);
+
+PRIVATE int cfg_init_mutex(pthread_mutex_t **mutex);
+
+master *g_master = NULL;
+
+void test_cfg_get_master_dlms_cfg_is_null(void)
+{
+	cfg_read_dlms_cfg_ExpectAndReturn(NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_master());
+}
+
+void test_cfg_get_master_m_is_null(void)
+{
+	dlms_cfg cfg = { 0 };
+	master m     = { 0 };
+
+	cfg_read_dlms_cfg_ExpectAndReturn(&cfg);
+	_log_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+	cfg_read_master_ExpectAndReturn(&cfg, NULL);
+	_log_ExpectAnyArgs();
+
+	cfg_free_dlms_cfg_Expect(&cfg);
+	cfg_free_master_Expect(&m);
+	cfg_free_master_IgnoreArg_m();
+
+	TEST_ASSERT_NULL(cfg_get_master());
+}
+
+void test_cfg_get_master_fail_to_init_mutexes(void)
+{
+	dlms_cfg cfg = { 0 };
+	master m     = { 0 };
+
+	cfg_read_dlms_cfg_ExpectAndReturn(&cfg);
+	_log_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+	cfg_read_master_ExpectAndReturn(&cfg, &m);
+	_log_ExpectAnyArgs();
+	cfg_init_mutexes_ExpectAndReturn(&m, 1);
+	_log_ExpectAnyArgs();
+
+	cfg_free_dlms_cfg_Expect(&cfg);
+	cfg_free_master_Expect(&m);
+
+	TEST_ASSERT_NULL(cfg_get_master());
+}
+
+void test_cfg_get_master_successful(void)
+{
+	dlms_cfg cfg = { 0 };
+	master m     = { 0 };
+
+	cfg_read_dlms_cfg_ExpectAndReturn(&cfg);
+	_log_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+	cfg_read_master_ExpectAndReturn(&cfg, &m);
+	_log_ExpectAnyArgs();
+	cfg_init_mutexes_ExpectAndReturn(&m, 0);
+
+	cfg_free_dlms_cfg_Expect(&cfg);
+
+	TEST_ASSERT_NOT_NULL(cfg_get_master());
+}
+
+void test_cfg_read_connection_calloc_failure(void)
+{
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_connection(NULL, NULL));
+}
+
+void test_cfg_read_connection_section_name_is_null(void)
+{
+	struct uci_section sec	= { 0 };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+	
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(NULL, &sec));
+}
+
+void test_cfg_read_connection_invalid_section_id(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "labas" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_section_name(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_connection_type(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 2);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_TCP_host(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "address", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_TCP_port_min_port(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 0);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "address", "192.168.1.1");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "port", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_TCP_port_max_port(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 0);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "address", "192.168.1.1");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "port", 0, 999999);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_SERIAL_settings_device(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+
+void test_cfg_read_connection_invalid_SERIAL_settings_baudrate(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_SERIAL_settings_databits(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 115200);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "databits", 0, 3);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_SERIAL_settings_stopbits(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 115200);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "databits", 0, 8);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "stopbits", 0, 3);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_SERIAL_settings_parity(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 115200);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "databits", 0, 8);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "stopbits", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "parity",  NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_connection_invalid_SERIAL_settings_flowcontrol(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 115200);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "databits", 0, 8);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "stopbits", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "parity",  "none");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "flowcontrol",  NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_connection_cfg_Expect(&c);
+
+	TEST_ASSERT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+// TODO: add struct variables check ASSERTS
+void test_cfg_read_connection_successful(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	connection_params_cfg c = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(connection_params_cfg), &c);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "connection_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection_type", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "device",  "/dev/rs232");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "baudrate", 0, 115200);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "databits", 0, 8);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "stopbits", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "parity",  "none");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "flowcontrol",  "none");
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_connection(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_calloc_failure(void)
+{
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(NULL, NULL));
+}
+
+void test_cfg_read_physical_device_section_name_is_null(void)
+{
+	struct uci_section sec	= { 0 };
+	physical_device_cfg d = { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(NULL, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_section_id(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "labas" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_section_name(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_server_address(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, -1);
+	
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_logical_server_address(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "log_server_addr", 0, -1);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_client_address(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "log_server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "client_addr", 0, -1);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_use_logical_name_ref(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "log_server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "client_addr", 0, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "use_logical_name_ref", 1, 2);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_physical_device_invalid_connection(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "log_server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "client_addr", 0, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "use_logical_name_ref", 1, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_physical_device_cfg_Expect(&d);
+
+	TEST_ASSERT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+// TODO: add struct variables check ASSERTS
+void test_cfg_read_physical_device_success(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	physical_device_cfg d	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device_cfg), &d);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "device_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "log_server_addr", 0, 0);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "client_addr", 0, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "use_logical_name_ref", 1, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "connection", 0, 1);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "access_security", 0, 0);
+	_log_ExpectAnyArgs();
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "interface_type", 0, 0);
+	_log_ExpectAnyArgs();
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "password", NULL);
+	_log_ExpectAnyArgs();
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "transport_security", 0, 0);
+	_log_ExpectAnyArgs();
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "authentication_key", NULL);
+	_log_ExpectAnyArgs();
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "block_cipher_key", NULL);
+	_log_ExpectAnyArgs();
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "dedicated_key", NULL);
+	_log_ExpectAnyArgs();
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "invocation_counter", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_physical_device(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_calloc_failure(void)
+{
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(NULL, NULL));
+}
+
+void test_cfg_read_cosem_object_section_name_is_null(void)
+{
+	struct uci_section sec	= { 0 };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(NULL, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_section_id(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "labas" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_enabled(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_section_name(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_obis(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_cosem_id(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", "0.0.42.0.0.255");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_id", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_profile_generic_entries(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", "0.0.42.0.0.255");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_id", 0, DLMS_OBJECT_TYPE_PROFILE_GENERIC);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "entries", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_phyiscal_devices(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", "0.0.42.0.0.255");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_id", 0, DLMS_OBJECT_TYPE_PROFILE_GENERIC);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "entries", 0, 1);
+	ucix_get_list_option_ExpectAndReturn(&uci, "dlms_master", "1", "physical_device", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_object_invalid_cosem_group(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", "0.0.42.0.0.255");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_id", 0, DLMS_OBJECT_TYPE_PROFILE_GENERIC);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "entries", 0, 1);
+	ucix_get_list_option_ExpectAndReturn(&uci, "dlms_master", "1", "physical_device", "4 5 6");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_group", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_object_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+// TODO: add struct variables check ASSERTS
+void test_cfg_read_cosem_object_successful(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_object_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "object_one");
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "obis", "0.0.42.0.0.255");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_id", 0, DLMS_OBJECT_TYPE_PROFILE_GENERIC);
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "entries", 0, 1);
+	ucix_get_list_option_ExpectAndReturn(&uci, "dlms_master", "1", "physical_device", "4 5 6");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "cosem_group", 0, 5);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_cosem_object(&uci, &sec));
+}
+
+void test_cfg_read_cosem_group_calloc_failure(void)
+{
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(NULL, NULL));
+}
+
+void test_cfg_read_cosem_group_section_name_is_null(void)
+{
+	struct uci_section sec	= { 0 };
+	cosem_group_cfg o	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &o);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_group_cfg_Expect(&o);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(NULL, &sec));
+}
+
+void test_cfg_read_cosem_group_invalid_section_id(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "labas" };
+	cosem_group_cfg g	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &g);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_group_cfg_Expect(&g);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(&uci, &sec));
+}
+
+void test_cfg_read_cosem_group_invalid_enabled(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_group_cfg g	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &g);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_group_cfg_Expect(&g);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(&uci, &sec));
+}
+
+void test_cfg_read_cosem_group_invalid_section_name(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_group_cfg g	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &g);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", NULL);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_group_cfg_Expect(&g);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(&uci, &sec));
+}
+
+void test_cfg_read_cosem_group_invalid_interval(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_group_cfg g	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &g);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "group_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "interval", 1, 0);
+	_log_ExpectAnyArgs();
+
+	_log_ExpectAnyArgs();
+	cfg_free_cosem_group_cfg_Expect(&g);
+
+	TEST_ASSERT_NULL(cfg_read_cosem_group(&uci, &sec));
+}
+
+// TODO: add struct variables check ASSERTS
+void test_cfg_read_cosem_group_successful(void)
+{
+	struct uci_context uci	= { 0 };
+	struct uci_section sec	= { .e.name = "1" };
+	cosem_group_cfg g	= { 0 };
+
+	_log_ExpectAnyArgs();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group_cfg), &g);
+	_log_ExpectAnyArgs();
+
+	mystrtol_ExpectAndReturn(sec.e.name, NULL, 10, 1);
+
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "enabled", 0, 1);
+	ucix_get_option_cfg_ExpectAndReturn(&uci, "dlms_master", "1", "name", "group_one");
+	ucix_get_option_int_ExpectAndReturn(&uci, "dlms_master", "1", "interval", 1, 50);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NOT_NULL(cfg_read_cosem_group(&uci, &sec));
+}
+
+void test_cfg_get_connections_calloc_failure(void)
+{
+	dlms_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(0, sizeof(connection *), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_connections(&cfg, NULL));
+}
+
+void test_cfg_get_connections_fail_to_get_connection(void)
+{
+	dlms_cfg cfg = {
+		.connection_cfg_count = 1,
+		.connections =
+			(connection_params_cfg *[]){
+				(connection_params_cfg[]){ 0 },
+			},
+	};
+
+	connection **c = (connection *[]){ 0 };
+	size_t conn    = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection *), c);
+	cfg_get_connection_ExpectAndReturn(cfg.connections[0], NULL);
+	myfree_Expect(c);
+
+	TEST_ASSERT_NULL(cfg_get_connections(&cfg, &conn));
+}
+
+void test_cfg_get_connections_successfully_get_connection(void)
+{
+	dlms_cfg cfg = {
+		.connection_cfg_count = 1,
+		.connections =
+			(connection_params_cfg *[]){
+				(connection_params_cfg[]){ 0 },
+			},
+	};
+
+	connection **c = (connection *[]){ 0 };
+	size_t conn    = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(connection *), c);
+	cfg_get_connection_ExpectAndReturn(cfg.connections[0], (connection []) { 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_connections(&cfg, &conn));
+}
+
+void test_cfg_get_physical_devices_calloc_failure(void)
+{
+	dlms_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(0, sizeof(physical_device *), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_physical_devices(&cfg, NULL, 0, NULL));
+}
+
+void test_cfg_get_physical_devices_fail_to_get_physical_device(void)
+{
+	dlms_cfg cfg = {
+		.physical_device_cfg_count = 1,
+		.physical_devices =
+			(physical_device_cfg *[]){
+				(physical_device_cfg[]){ 0 },
+			},
+	};
+
+	physical_device **dev = (physical_device *[]){ 0 };
+	connection **c	      = (connection *[]){ 0 };
+	size_t conn	      = 0;
+	size_t dev_count      = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device *), dev);
+	cfg_get_physical_device_ExpectAndReturn(cfg.physical_devices[0], c, 0, NULL);
+	myfree_Expect(dev);
+
+	TEST_ASSERT_NULL(cfg_get_physical_devices(&cfg, c, 0, &dev_count));
+}
+
+void test_cfg_get_physical_devices_successfully_get_physical_device(void)
+{
+	dlms_cfg cfg = {
+		.physical_device_cfg_count = 1,
+		.physical_devices =
+			(physical_device_cfg *[]){
+				(physical_device_cfg[]){ 0 },
+			},
+	};
+
+	physical_device **dev = (physical_device *[]){ 0 };
+	connection **c	    = (connection *[]){ 0 };
+	size_t conn	    = 1;
+	size_t dev_count    = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(physical_device *), dev);
+	cfg_get_physical_device_ExpectAndReturn(cfg.physical_devices[0], c, conn, (physical_device[]){ 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_physical_devices(&cfg, c, conn, &dev_count));
+}
+
+void test_cfg_get_cosem_objects_calloc_failure(void)
+{
+	dlms_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(0, sizeof(cosem_object *), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_objects(&cfg, NULL, 0, NULL));
+}
+
+void test_cfg_get_cosem_objects_fail_to_get_cosem_object(void)
+{
+	dlms_cfg cfg = {
+		.cosem_object_cfg_count = 1,
+		.cosem_objects =
+			(cosem_object_cfg *[]){
+				(cosem_object_cfg[]){ 0 },
+			},
+	};
+
+	cosem_object **o = (cosem_object *[]){ 0 };
+	size_t obj_count = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object *), o);
+	cfg_get_cosem_object_ExpectAndReturn(cfg.cosem_objects[0], NULL, 0, NULL);
+	myfree_Expect(o);
+
+	TEST_ASSERT_NULL(cfg_get_cosem_objects(&cfg, NULL, 0, &obj_count));
+}
+
+void test_cfg_get_cosem_objects_successfully_get_cosem_object(void)
+{
+	dlms_cfg cfg = {
+		.cosem_object_cfg_count = 1,
+		.cosem_objects =
+			(cosem_object_cfg *[]){
+				(cosem_object_cfg[]){ 0 },
+			},
+	};
+
+	cosem_object **o = (cosem_object *[]){ 0 };
+	size_t obj_count = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object *), o);
+	cfg_get_cosem_object_ExpectAndReturn(cfg.cosem_objects[0], NULL, 0, (cosem_object []) { 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_cosem_objects(&cfg, NULL, 0, &obj_count));
+}
+
+void test_cfg_get_cosem_groups_calloc_failure(void)
+{
+	dlms_cfg cfg = { 0 };
+
+	mycalloc_ExpectAndReturn(0, sizeof(cosem_group *), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(cfg_get_cosem_groups(&cfg, NULL, 0, NULL));
+}
+
+void test_cfg_get_cosem_groups_fail_to_get_cosem_group(void)
+{
+	dlms_cfg cfg = {
+		.cosem_group_cfg_count = 1,
+		.cosem_groups =
+			(cosem_group_cfg *[]){
+				(cosem_group_cfg[]){ 0 },
+			},
+	};
+
+	cosem_group **g = (cosem_group *[]){ 0 };
+	size_t group_count = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group *), g);
+	cfg_get_cosem_group_ExpectAndReturn(&cfg, cfg.cosem_groups[0], NULL, 0, NULL);
+	myfree_Expect(g);
+
+	TEST_ASSERT_NULL(cfg_get_cosem_groups(&cfg, NULL, 0, &group_count));
+}
+
+void test_cfg_get_cosem_groups_successfully_get_cosem_group(void)
+{
+	dlms_cfg cfg = {
+		.cosem_group_cfg_count = 1,
+		.cosem_groups =
+			(cosem_group_cfg *[]){
+				(cosem_group_cfg[]){ 0 },
+			},
+	};
+
+	cosem_group **g = (cosem_group *[]){ 0 };
+	size_t group_count = 0;
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_group *), g);
+	cfg_get_cosem_group_ExpectAndReturn(&cfg, cfg.cosem_groups[0], NULL, 0, (cosem_group []){ 0 });
+
+	TEST_ASSERT_NOT_NULL(cfg_get_cosem_groups(&cfg, NULL, 0, &group_count));
+}
+
+void test_cfg_init_mutex_already_allocated_mutex(void)
+{
+	pthread_mutex_t *mutex = (pthread_mutex_t[]){ 0 };
+
+	TEST_ASSERT_EQUAL_INT(0, cfg_init_mutex(&mutex));
+}
+
+void test_cfg_init_mutex_fail_to_allocate_memory(void)
+{
+	pthread_mutex_t *mutex = NULL;
+
+	mycalloc_ExpectAndReturn(1, sizeof(pthread_mutex_t), NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cfg_init_mutex(&mutex));
+}
+
+void test_cfg_init_mutex_fail_to_init_mutex(void)
+{
+	pthread_mutex_t *mutex	 = NULL;
+	pthread_mutex_t *mutex_2 = (pthread_mutex_t[]){ 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(pthread_mutex_t), mutex_2);
+	pthread_mutex_init_ExpectAndReturn(mutex_2, NULL, 1);
+	myfree_Expect(mutex_2);
+
+	TEST_ASSERT_EQUAL_INT(1, cfg_init_mutex(&mutex));
+	TEST_ASSERT_NULL(mutex);
+}
+
+void test_cfg_init_mutex_successful(void)
+{
+	pthread_mutex_t *mutex	 = NULL;
+	pthread_mutex_t *mutex_2 = (pthread_mutex_t[]){ 0 };
+
+	mycalloc_ExpectAndReturn(1, sizeof(pthread_mutex_t), mutex_2);
+	pthread_mutex_init_ExpectAndReturn(mutex_2, NULL, 0);
+
+	TEST_ASSERT_EQUAL_INT(0, cfg_init_mutex(&mutex));
+	TEST_ASSERT_NOT_NULL(mutex);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_config_free.c src/test/test_config_free.c
--- orig/test/test_config_free.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_config_free.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,132 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "config.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_config_free.h"
+
+#include "mock_stub_pthread.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+PRIVATE void cfg_free_dlms_cfg(dlms_cfg *dlms);
+PUBLIC void cfg_free_master(master *m);
+
+master *g_master = NULL;
+
+void test_cfg_free_dlms_cfg_empty_dlms_cfg(void)
+{
+	cfg_free_dlms_cfg(NULL);
+}
+
+void test_cfg_free_dlms_cfg_successfully(void)
+{
+	dlms_cfg cfg = {
+		.connection_cfg_count	   = 1,
+		.connections		   = (connection_params_cfg *[]) {
+                        (connection_params_cfg []) {
+                                { 0 }
+                        },
+                },
+		.physical_device_cfg_count = 1,
+		.physical_devices	   = (physical_device_cfg *[]) {
+                        (physical_device_cfg []) {
+                                { 0 }
+                        },
+                },
+		.cosem_object_cfg_count	   = 1,
+		.cosem_objects		   = (cosem_object_cfg *[]) {
+                        (cosem_object_cfg []) {
+                                { 0 }
+                        },
+                },
+		.cosem_group_cfg_count	   = 1,
+		.cosem_groups		   = (cosem_group_cfg *[]) {
+                        (cosem_group_cfg []) {
+                                { 0 }
+                        },
+                },
+	};
+
+        cfg_free_connection_cfg_Expect(cfg.connections[0]);
+        cfg_free_physical_device_cfg_Expect(cfg.physical_devices[0]);
+        cfg_free_cosem_object_cfg_Expect(cfg.cosem_objects[0]);
+        cfg_free_cosem_group_cfg_Expect(cfg.cosem_groups[0]);
+
+        myfree_Expect(cfg.connections);
+        myfree_Expect(cfg.physical_devices);
+        myfree_Expect(cfg.cosem_objects);
+        myfree_Expect(cfg.cosem_groups);
+        myfree_Expect(&cfg);
+
+	cfg_free_dlms_cfg(&cfg);
+}
+
+void test_cfg_free_dlms_empty_master(void)
+{
+	cfg_free_master(NULL);
+}
+
+void test_cfg_free_master_successfully(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){
+					{ 0 },
+				},
+			},
+		.physical_dev_count = 1,
+		.physical_devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{ 0 },
+				},
+			},
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ 0 },
+				},
+			},
+		.cosem_group_count = 1,
+		.cosem_groups =
+			(cosem_group *[]){
+				(cosem_group[]){
+					{ 0 },
+				},
+			},
+	};
+
+	cfg_free_connection_Expect(m.connections[0]);
+        cfg_free_physical_device_Expect(m.physical_devices[0]);
+        cfg_free_cosem_object_Expect(m.cosem_objects[0]);
+        cfg_free_cosem_group_Expect(m.cosem_groups[0]);
+
+        pthread_mutex_destroy_ExpectAndReturn(m.mutex_rs232, 0);
+        myfree_Expect(m.mutex_rs232);
+        pthread_mutex_destroy_ExpectAndReturn(m.mutex_rs485, 0);
+        myfree_Expect(m.mutex_rs485);
+
+        myfree_Expect(m.connections);
+        myfree_Expect(m.physical_devices);
+        myfree_Expect(m.cosem_objects);
+        myfree_Expect(m.cosem_groups);
+        myfree_Expect(&m);
+
+	cfg_free_master(&m);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_config_free_2.c src/test/test_config_free_2.c
--- orig/test/test_config_free_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_config_free_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,201 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "config.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "stub_config_free_2.h"
+
+#include "mock_stub_pthread.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+PRIVATE void cfg_free_connection_cfg(connection_params_cfg *c);
+PRIVATE void cfg_free_physical_device_cfg(physical_device_cfg *d);
+PRIVATE void cfg_free_cosem_object_cfg(cosem_object_cfg *o);
+PRIVATE void cfg_free_cosem_group_cfg(cosem_group_cfg *g);
+
+PRIVATE void cfg_free_connection(connection *c);
+PRIVATE void cfg_free_physical_device(physical_device *d);
+PRIVATE void cfg_free_cosem_object(cosem_object *o);
+PRIVATE void cfg_free_cosem_group(cosem_group *g);
+
+master *g_master = NULL;
+
+void test_cfg_free_connection_cfg_empty_connection(void)
+{
+	cfg_free_connection_cfg(NULL);
+}
+
+void test_cfg_free_connection_cfg_successfully_clean_tcp(void)
+{
+        connection_params_cfg c = { .type = TCP_CFG };
+
+        myfree_Expect(c.name);
+        myfree_Expect(c.parameters.tcp.host);
+        myfree_Expect(&c);
+
+	cfg_free_connection_cfg(&c);
+}
+
+void test_cfg_free_connection_cfg_successfully_clean_serial(void)
+{
+        connection_params_cfg c = { .type = SERIAL };
+
+        myfree_Expect(c.name);
+        myfree_Expect(c.parameters.serial.device);
+        myfree_Expect(c.parameters.serial.parity);
+        myfree_Expect(c.parameters.serial.flow_control);
+        myfree_Expect(&c);
+
+	cfg_free_connection_cfg(&c);
+}
+
+void test_cfg_free_physical_device_cfg_empty_physical_device(void)
+{
+	cfg_free_physical_device_cfg(NULL);
+}
+
+void test_cfg_free_physical_device_cfg_successfully(void)
+{
+        physical_device_cfg d = { 0 };
+
+        myfree_Expect(d.name);
+        myfree_Expect(d.password);
+        myfree_Expect(d.authentication_key);
+        myfree_Expect(d.block_cipher_key);
+        myfree_Expect(d.dedicated_key);
+        myfree_Expect(d.invocation_counter);
+        myfree_Expect(&d);
+
+	cfg_free_physical_device_cfg(&d);
+}
+
+void test_cfg_free_cosem_object_cfg_empty_cosem_object(void)
+{
+	cfg_free_cosem_object_cfg(NULL);
+}
+
+void test_cfg_free_connection_cfg_successfully(void)
+{
+        cosem_object_cfg o = { 0 };
+
+        myfree_Expect(o.name);
+        myfree_Expect(o.physical_devices);
+        myfree_Expect(o.obis);
+        myfree_Expect(&o);
+
+	cfg_free_cosem_object_cfg(&o);
+}
+
+
+void test_cfg_free_cosem_group_cfg_empty_cosem_group(void)
+{
+	cfg_free_cosem_group_cfg(NULL);
+}
+
+void test_cfg_free_cosem_group_cfg_successfully(void)
+{
+        cosem_group_cfg g = { 0 };
+
+        myfree_Expect(g.name);
+        myfree_Expect(&g);
+
+	cfg_free_cosem_group_cfg(&g);
+}
+
+void test_cfg_free_connection_empty_connection(void)
+{
+        cfg_free_connection(NULL);
+}
+
+void test_cfg_free_connection_clean_tcp(void)
+{
+        connection c = { .type = TCP };
+
+        myfree_Expect(c.name);
+        bb_clear_ExpectAndReturn(&c.data, 0);
+        myfree_Expect(c.parameters.tcp.host);
+        pthread_mutex_destroy_ExpectAndReturn(c.mutex, 0);
+        myfree_Expect(&c);
+
+        cfg_free_connection(&c);
+}
+
+void test_cfg_free_connection_clean_serial(void)
+{
+        connection c = { .type = SERIAL };
+
+        myfree_Expect(c.name);
+        bb_clear_ExpectAndReturn(&c.data, 0);
+        myfree_Expect(c.parameters.serial.device);
+        myfree_Expect(c.parameters.serial.parity);
+        myfree_Expect(c.parameters.serial.flow_control);
+        myfree_Expect(&c);
+
+        cfg_free_connection(&c);
+}
+
+void test_cfg_free_physical_device_empty_physical_device(void)
+{
+        cfg_free_physical_device(NULL);
+}
+
+void test_cfg_free_physical_device_successfully(void)
+{
+        physical_device d = { 0 };
+
+	cip_clear_Expect(&d.settings.cipher);
+	cl_clear_Expect(&d.settings);
+
+        myfree_Expect(d.name);
+        myfree_Expect(d.invocation_counter);
+        myfree_Expect(&d);
+
+        cfg_free_physical_device(&d);
+}
+
+void test_cfg_free_cosem_object_empty_cosem_object(void)
+{
+        cfg_free_cosem_object(NULL);
+}
+
+void test_cfg_free_cosem_object_successfully(void)
+{
+        cosem_object o = { 0 };
+
+        obj_clear_Expect(o.object);
+        myfree_Expect(o.name);
+        myfree_Expect(o.object);
+        myfree_Expect(o.devices);
+        myfree_Expect(&o);
+
+        cfg_free_cosem_object(&o);
+}
+
+void test_cfg_free_cosem_group_empty_cosem_group(void)
+{
+        cfg_free_cosem_group(NULL);
+}
+
+void test_cfg_free_cosem_group_successfully(void)
+{
+        cosem_group g = { 0 };
+
+        myfree_Expect(g.name);
+        myfree_Expect(g.cosem_objects);
+        myfree_Expect(&g);
+
+        cfg_free_cosem_group(&g);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_cosem_group.c src/test/test_cosem_group.c
--- orig/test/test_cosem_group.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_cosem_group.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,111 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "cosem_group.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_cosem_group.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_helpers.h"
+#include "mock_converters.h"
+
+void test_cg_read_group_codes_empty_group()
+{
+	cosem_group g = { 0 };
+
+	int rc	   = 0;
+	char *data = "";
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	cg_read_group_codes(&g, &rc);
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_profile_generic_data(void)
+{
+	cosem_object o = { .entries = 5 };
+	physical_device d   = { .connection = (connection[]){ { .socket = 1 } } };
+	gxProfileGeneric pg = { .profileEntries = 50 };
+	_log_ExpectAnyArgs();
+	com_readRowsByEntry_ExpectAndReturn(d.connection, &d.settings, &pg, 45, o.entries + 1, 0);
+	TEST_ASSERT_EQUAL_INT(0, cg_read_profile_generic_data(&o, &pg, &d));
+}
+
+void test_cg_make_connection_already_connected(void)
+{
+	physical_device d = { .connection = (connection[]){ { .socket = 1 } } };
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(0, cg_make_connection(&d));
+}
+
+void test_cg_make_connection_device_NULL(void)
+{
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cg_make_connection(NULL));
+}
+
+void test_cg_make_connection_open_connection_failure(void)
+{
+	physical_device d = { .connection = (connection[]){ { .socket = -1 } } };
+
+	com_open_connection_ExpectAndReturn(d.connection, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cg_make_connection(&d));
+}
+
+void test_cg_make_connection_updating_invocation_counter_failure(void)
+{
+	physical_device d = { .connection	  = (connection[]){ { .socket = -1 } },
+			      .invocation_counter = "255.255" };
+
+	com_open_connection_ExpectAndReturn(d.connection, 0);
+	com_update_invocation_counter_ExpectAndReturn(d.connection, &d.settings, d.invocation_counter, 1);
+	_log_ExpectAnyArgs();
+	com_close_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_make_connection(&d));
+}
+
+void test_cg_make_connection_initialisation_failure(void)
+{
+	physical_device d = { .connection	  = (connection[]){ { .socket = -1 } },
+			      .invocation_counter = "255.255" };
+
+	com_open_connection_ExpectAndReturn(d.connection, 0);
+	com_update_invocation_counter_ExpectAndReturn(d.connection, &d.settings, d.invocation_counter, 0);
+	com_initialize_connection_ExpectAndReturn(d.connection, &d.settings, 1);
+	_log_ExpectAnyArgs();
+	com_close_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_make_connection(&d));
+}
+
+void test_cg_make_connection_initialisation_successful(void)
+{
+	physical_device d = { .connection	  = (connection[]){ { .socket = -1 } },
+			      .invocation_counter = "255.255" };
+
+	com_open_connection_ExpectAndReturn(d.connection, 0);
+	com_update_invocation_counter_ExpectAndReturn(d.connection, &d.settings, d.invocation_counter, 0);
+	com_initialize_connection_ExpectAndReturn(d.connection, &d.settings, 0);
+
+	TEST_ASSERT_EQUAL_INT(0, cg_make_connection(&d));
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_cosem_group_2.c src/test/test_cosem_group_2.c
--- orig/test/test_cosem_group_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_cosem_group_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,368 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "cosem_group.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_cosem_group_2.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_helpers.h"
+#include "mock_converters.h"
+
+#undef strdup
+#undef free
+
+void test_cg_format_group_data(void)
+{
+	char *data = strdup("data");
+
+	attr_to_json_ExpectAndReturn(NULL, "{ \"data\" :");
+	utl_append_obj_name_Expect(&data, "device_one");
+	utl_append_to_str_Expect(&data, "{");
+	utl_append_to_str_Expect(&data, "{ \"data\" :");
+	utl_append_to_str_Expect(&data, "}");
+	myfree_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(0, cg_format_group_data(&data, NULL, "device_one"));
+	free(data);
+}
+
+void test_cg_format_group_data_return_attribute_NULL(void)
+{
+	char *data = strdup("data");
+
+	attr_to_json_ExpectAndReturn(NULL, NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cg_format_group_data(&data, NULL, "device_one"));
+	free(data);
+}
+
+void test_cg_read_cosem_object_attribute_index_failure(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "0668", .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+			},
+	};
+
+	gxByteBuffer attributes = { 0 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAndReturn(o.object, &attributes, 1);
+	hlp_getErrorMessage_ExpectAndReturn(1, "Error");
+	_log_ExpectAnyArgs();
+
+	bb_clear_ExpectAndReturn(&attributes, 0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_bb_getuint8byindex_failure(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 2 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(1);
+	_log_ExpectAnyArgs();
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_com_read_failure(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = 4 },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 2 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(1);
+	_log_ExpectAnyArgs();
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_com_read_failure_with_permission_error(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = 4 },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 2 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(DLMS_ERROR_CODE_READ_WRITE_DENIED);
+	_log_ExpectAnyArgs();
+
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(1);
+	_log_ExpectAnyArgs();
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_read_profile_generic_failure(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 2 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(0);
+
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	bb_getUInt8ByIndex_ReturnThruPtr_value((unsigned char[]){ 2 });
+	_log_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+	// out of loop
+
+	cg_read_profile_generic_data_ExpectAndReturn(&o, (gxProfileGeneric *)o.object, o.devices[0], 1);
+	_log_ExpectAnyArgs();
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_succesful_profile_generic_tests(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 2 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Register");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(0);
+
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	bb_getUInt8ByIndex_ReturnThruPtr_value((unsigned char[]){ 2 });
+	_log_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+	// out of loop
+
+	cg_read_profile_generic_data_ExpectAndReturn(&o, (gxProfileGeneric *)o.object, o.devices[0], 0);
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(0, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+void test_cg_read_cosem_object_succesful_non_profile_generic_tests(void)
+{
+	cosem_object o = {
+		.device_count = 1,
+		.devices =
+			(physical_device *[]){
+				(physical_device[]){
+					{
+						.id = 6,
+						.connection =
+							(connection[]){
+								{ .socket = 1 },
+							},
+					},
+				},
+			},
+		.object =
+			(gxObject[]){
+				{ .logicalName = "50", .objectType = 1 },
+			},
+	};
+
+	gxByteBuffer attributes = { .size = 1 };
+
+	hlp_getLogicalNameToString_ExpectAndReturn(o.object->logicalName, NULL, 0);
+	hlp_getLogicalNameToString_IgnoreArg_ln();
+	obj_typeToString2_ExpectAndReturn(o.object->objectType, "Data");
+	_log_ExpectAnyArgs();
+
+	bb_init_IgnoreAndReturn(0);
+	obj_getAttributeIndexToRead_ExpectAnyArgsAndReturn(0);
+	obj_getAttributeIndexToRead_ReturnThruPtr_ba(&attributes);
+
+	//entering loop here
+	bb_getUInt8ByIndex_ExpectAnyArgsAndReturn(0);
+	_log_ExpectAnyArgs();
+	com_read_ExpectAnyArgsAndReturn(0);
+	// out of loop
+
+	bb_clear_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(0, cg_read_cosem_object(&o, o.devices[0]));
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_cosem_group_3.c src/test/test_cosem_group_3.c
--- orig/test/test_cosem_group_3.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_cosem_group_3.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,402 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "cosem_group.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_cosem_group_3.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_helpers.h"
+#include "mock_converters.h"
+
+void test_cg_read_group_codes_device_is_disabled(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 0,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	utl_add_error_message_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_group_codes_fail_to_make_connection(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 1,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	cg_make_connection_ExpectAndReturn(g.cosem_objects[0]->devices[0], 1);
+	utl_add_error_message_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_group_codes_fail_to_read_cosem_object(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 1,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	cg_make_connection_ExpectAndReturn(g.cosem_objects[0]->devices[0], 0);
+
+	cg_read_cosem_object_ExpectAndReturn(g.cosem_objects[0], g.cosem_objects[0]->devices[0], 1);
+	hlp_getErrorMessage_ExpectAnyArgsAndReturn("COSEM object error");
+	utl_add_error_message_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+
+
+	com_close_ExpectAnyArgsAndReturn(0);
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_group_codes_fail_to_convert_attributes_to_string(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 1,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	cg_make_connection_ExpectAndReturn(g.cosem_objects[0]->devices[0], 0);
+
+	cg_read_cosem_object_ExpectAndReturn(g.cosem_objects[0], g.cosem_objects[0]->devices[0], 0);
+
+	attr_init_ExpectAnyArgs();
+	attr_to_string_ExpectAnyArgsAndReturn(1);
+	utl_add_error_message_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+
+
+	com_close_ExpectAnyArgsAndReturn(0);
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_group_codes_fail_to_format_group_data(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 1,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	cg_make_connection_ExpectAndReturn(g.cosem_objects[0]->devices[0], 0);
+
+	cg_read_cosem_object_ExpectAndReturn(g.cosem_objects[0], g.cosem_objects[0]->devices[0], 0);
+
+	attr_init_ExpectAnyArgs();
+	attr_to_string_ExpectAnyArgsAndReturn(0);
+
+	cg_format_group_data_ExpectAnyArgsAndReturn(1);
+	utl_add_error_message_ExpectAnyArgs();
+	_log_ExpectAnyArgs();
+
+
+	com_close_ExpectAnyArgsAndReturn(0);
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(1, rc);
+}
+
+void test_cg_read_group_codes_get_successful_message(void)
+{
+	cosem_group g = {
+		.id		    = 3,
+		.name		    = "group_one",
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{ .id		= 4,
+					  .device_count = 1,
+					  .name		= "device_one",
+					  .devices =
+						  (physical_device *[]){
+							  (physical_device[]){
+								  { .id		= 6,
+								    .enabled	= 1,
+								    .connection = (connection[]){ { 0 } } } },
+						  } } },
+			},
+	};
+
+	int rc = 0;
+
+	char *expected_data = "{";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	expected_data = "{\"device_one\": ";
+	utl_append_obj_name_ExpectAnyArgs();
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_data, sizeof(expected_data));
+
+	expected_data = "{\"device_one\": {";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	utl_lock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	cg_make_connection_ExpectAndReturn(g.cosem_objects[0]->devices[0], 0);
+
+	cg_read_cosem_object_ExpectAndReturn(g.cosem_objects[0], g.cosem_objects[0]->devices[0], 0);
+
+	attr_init_ExpectAnyArgs();
+	attr_to_string_ExpectAnyArgsAndReturn(0);
+
+	cg_format_group_data_ExpectAnyArgsAndReturn(0);
+
+	com_close_ExpectAnyArgsAndReturn(0);
+
+	utl_unlock_mutex_if_required_Expect(g.cosem_objects[0]->devices[0]);
+
+	utl_append_if_needed_ExpectAnyArgs();
+	attr_free_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+	utl_append_if_needed_ExpectAnyArgs();
+
+	expected_data = "{\"device_one\": {}}";
+	utl_append_to_str_ExpectAnyArgs();
+	utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+	TEST_ASSERT_NOT_NULL(cg_read_group_codes(&g, &rc));
+	TEST_ASSERT_EQUAL(0, rc);
+}
+
+#endif
\ No newline at end of file
diff --recursive --unified --new-file --no-dereference orig/test/test_main.c src/test/test_main.c
--- orig/test/test_main.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_main.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,158 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "main.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_main.h"
+
+#include "mock_stub_uloop.h"
+
+int mymain(int argc, char **argv);
+
+void test_mymain_fail_to_parse_arguments(void)
+{
+	char *argv[] = { [0] = "dlms_master" };
+
+	utl_parse_args_ExpectAndReturn(1, argv, NULL, 1);
+    utl_parse_args_IgnoreArg_debug_lvl();
+	myfprintf_ExpectAnyArgsAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, argv));
+}
+
+static void expect_parse_arg()
+{
+    utl_parse_args_ExpectAndReturn(1, NULL, NULL, 0);
+    utl_parse_args_IgnoreArg_debug_lvl();
+}
+
+void test_mymain_fail_to_init_ubus(void)
+{
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+
+    init_ubus_test_functions_ExpectAndReturn(1);
+    _log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, NULL));
+}
+
+void test_mymain_fail_to_init_uloop(void)
+{
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+
+    uloop_init_ExpectAndReturn(1);
+    _log_ExpectAnyArgs();
+
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, NULL));
+}
+
+void test_mymain_fail_to_read_config(void)
+{
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+    uloop_init_ExpectAndReturn(0);
+
+    cfg_get_master_ExpectAndReturn(NULL);
+    _log_ExpectAnyArgs();
+
+    uloop_run_ExpectAndReturn(0);
+
+    mstr_db_free_ExpectAnyArgs();
+    cfg_free_master_ExpectAnyArgs();
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(0, mymain(1, NULL));
+}
+
+void test_mymain_fail_to_create_db(void)
+{
+    master g = { 0 };
+
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+    uloop_init_ExpectAndReturn(0);
+
+    cfg_get_master_ExpectAndReturn(&g);
+    mstr_create_db_ExpectAndReturn(&g, 1);
+    _log_ExpectAnyArgs();
+
+    cfg_free_master_ExpectAnyArgs();
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, NULL));
+}
+
+void test_mymain_fail_to_initialize_cosem_groups(void)
+{
+    master g = { 0 };
+
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+    uloop_init_ExpectAndReturn(0);
+    cfg_get_master_ExpectAndReturn(&g);
+    mstr_create_db_ExpectAndReturn(&g, 0);
+    mstr_initialize_cosem_groups_ExpectAndReturn(&g, 1);
+    _log_ExpectAnyArgs();
+
+    mstr_db_free_Expect(&g);
+    cfg_free_master_ExpectAnyArgs();
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, NULL));
+}
+
+void test_mymain_fail_to_run_uloop(void)
+{
+    master g = { 0 };
+
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+    uloop_init_ExpectAndReturn(0);
+    cfg_get_master_ExpectAndReturn(&g);
+    mstr_create_db_ExpectAndReturn(&g, 0);
+    mstr_initialize_cosem_groups_ExpectAndReturn(&g, 0);
+    uloop_run_ExpectAndReturn(1);
+    _log_ExpectAnyArgs();
+
+    mstr_db_free_Expect(&g);
+    cfg_free_master_ExpectAnyArgs();
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, mymain(1, NULL));
+}
+
+void test_mymain_every_method_return_success(void)
+{
+    master g = { 0 };
+
+    expect_parse_arg();
+    logger_init_ExpectAndReturn(L_EMERG, L_TYPE_STDOUT, "dlms_master", 0);
+    init_ubus_test_functions_ExpectAndReturn(0);
+    uloop_init_ExpectAndReturn(0);
+    cfg_get_master_ExpectAndReturn(&g);
+    mstr_create_db_ExpectAndReturn(&g, 0);
+    mstr_initialize_cosem_groups_ExpectAndReturn(&g, 0);
+    uloop_run_ExpectAndReturn(0);
+
+    mstr_db_free_Expect(&g);
+    cfg_free_master_ExpectAnyArgs();
+    ubus_exit_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(0, mymain(1, NULL));
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_master.c src/test/test_master.c
--- orig/test/test_master.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_master.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,427 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "master.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+
+#include "mock_stub_sqlite3.h"
+#include "mock_stub_pthread.h"
+
+master *g_master = NULL;
+
+void setUp(void)
+{
+	static master m = { 0 };
+	g_master = &m;
+}
+
+void test_mstr_create_db_check_compiled_without_threadsafe(void)
+{
+	sqlite3_threadsafe_ExpectAndReturn(0);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_open_db(void)
+{
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_set_db_timeout(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 1);
+	sqlite3_errmsg_ExpectAndReturn(db, "Busy timeout error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_close_v2_ExpectAndReturn(db, 0);
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_create_data_table(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 0);
+
+	sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 1);
+	sqlite3_exec_IgnoreArg_sql();
+	sqlite3_errmsg_ExpectAndReturn(db, "Exec error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_close_v2_ExpectAndReturn(db, 0);
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_create_sent_table(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 0);
+	sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 0);
+	sqlite3_exec_IgnoreArg_sql();
+
+	sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 1);
+	sqlite3_exec_IgnoreArg_sql();
+	sqlite3_errmsg_ExpectAndReturn(db, "Exec error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_close_v2_ExpectAndReturn(db, 0);
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_set_page_size(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 0);
+
+	for (size_t i = 0; i < 2; i++) {
+		sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 0);
+		sqlite3_exec_IgnoreArg_sql();
+	}
+
+	sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 1);
+	sqlite3_exec_IgnoreArg_sql();
+	sqlite3_errmsg_ExpectAndReturn(db, "Exec error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_close_v2_ExpectAndReturn(db, 0);
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_fail_to_prepare_statement(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 0);
+
+	for (size_t i = 0; i < 3; i++) {
+		sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 0);
+		sqlite3_exec_IgnoreArg_sql();
+	}
+
+	sqlite3_prepare_v2_ExpectAndReturn(db, NULL, -1, &g_master->stmt_insert, NULL, 1);
+	sqlite3_prepare_v2_IgnoreArg_zSql();
+	sqlite3_errmsg_ExpectAndReturn(db, "");
+	_log_ExpectAnyArgs();
+
+	sqlite3_close_v2_ExpectAndReturn(db, 0);
+	TEST_ASSERT_EQUAL_INT(1, mstr_create_db(g_master));
+}
+
+void test_mstr_create_db_successfully(void)
+{
+	sqlite3 *db = (sqlite3 *)"database";
+
+	sqlite3_threadsafe_ExpectAndReturn(1);
+	sqlite3_open_ExpectAndReturn("/tmp/dlms_master.db", &g_master->db, 0);
+	sqlite3_open_ReturnThruPtr_db(&db);
+
+	sqlite3_busy_timeout_ExpectAndReturn(db, 30000, 0);
+
+	for (size_t i = 0; i < 3; i++) {
+		sqlite3_exec_ExpectAndReturn(db, NULL, NULL, NULL, NULL, 0);
+		sqlite3_exec_IgnoreArg_sql();
+	}
+
+	sqlite3_prepare_v2_ExpectAndReturn(db, NULL, -1, &g_master->stmt_insert, NULL, 0);
+	sqlite3_prepare_v2_IgnoreArg_zSql();
+
+	TEST_ASSERT_EQUAL_INT(0, mstr_create_db(g_master));
+}
+
+void test_mstr_initialize_cosem_group_initialisation_failed(void)
+{
+	master m = {
+		.cosem_group_count = 1,
+		.cosem_groups =
+			(cosem_group *[]){
+				(cosem_group[]) { { .id = 4 } },
+			},
+	};
+
+	pthread_t thread = { 0 };
+	pthread_create_ExpectAndReturn(&thread, NULL, NULL, m.cosem_groups[0], 1);
+	pthread_create_IgnoreArg_start_routine();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_initialize_cosem_groups(&m));
+}
+
+void test_mstr_initialize_cosem_group_initialisation_failed_with_name(void)
+{
+	master m = {
+		.cosem_group_count = 1,
+		.cosem_groups =
+			(cosem_group *[]){
+				(cosem_group[]) { { .id = 4,
+				.name = "group_one" } },
+			},
+	};
+
+	pthread_t thread = { 0 };
+	pthread_create_ExpectAndReturn(&thread, NULL, NULL, m.cosem_groups[0], 1);
+	pthread_create_IgnoreArg_start_routine();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, mstr_initialize_cosem_groups(&m));
+}
+
+void test_mstr_initialize_cosem_group_initialisation_success(void)
+{
+	master m = {
+		.cosem_group_count = 1,
+		.cosem_groups =
+			(cosem_group *[]){
+				(cosem_group[]) { { .id = 4 } },
+			},
+	};
+
+	pthread_t thread = { 0 };
+	pthread_create_ExpectAndReturn(&thread, NULL, NULL, m.cosem_groups[0], 0);
+	pthread_create_IgnoreArg_start_routine();
+
+	TEST_ASSERT_EQUAL_INT(0, mstr_initialize_cosem_groups(&m));
+}
+
+static void expect_binding_failure()
+{
+	sqlite3_errmsg_ExpectAndReturn(g_master->db, "failure");
+	_log_ExpectAnyArgs();
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+}
+
+void test_mstr_write_group_data_to_db_bind_null_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_bind_time_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_bind_group_name_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 0);
+	mystrlen_ExpectAndReturn(g.name, 9);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 3, g.name, 9, SQLITE_STATIC, 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_bind_group_name_length_zero(void)
+{
+	cosem_group g = { .name = "group_one" };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 0);
+	mystrlen_ExpectAndReturn(g.name, 9);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 3, g.name, 9, SQLITE_STATIC, 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_bind_group_name_is_null(void)
+{
+	cosem_group g = { 0 };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 0);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 3, g.name, 0, SQLITE_STATIC, 0);
+	mystrlen_ExpectAndReturn("data", 4);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 4, 4, 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_bind_data_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 0);
+	mystrlen_ExpectAndReturn(g.name, 9);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 3, g.name, 9, SQLITE_STATIC, 0);
+	mystrlen_ExpectAndReturn("data", 4);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 4, 4, 0);
+	mystrlen_ExpectAndReturn("data", 4);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 5, "data", 4, SQLITE_STATIC, 1);
+	expect_binding_failure();
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+static void successful_bindings(cosem_group g)
+{
+	_log_ExpectAnyArgs();
+
+	sqlite3_bind_null_ExpectAndReturn(g_master->stmt_insert, 1, 0);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 2, time(NULL), 0);
+	mystrlen_ExpectAndReturn(g.name, 9);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 3, g.name, 9, SQLITE_STATIC, 0);
+	mystrlen_ExpectAndReturn("data", 4);
+	sqlite3_bind_int_ExpectAndReturn(g_master->stmt_insert, 4, 4, 0);
+	mystrlen_ExpectAndReturn("data", 4);
+	sqlite3_bind_text_ExpectAndReturn(g_master->stmt_insert, 5, "data", 4, SQLITE_STATIC, 0);
+}
+
+void test_mstr_write_group_data_to_db_step_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	successful_bindings(g);
+
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, 1);
+	sqlite3_errmsg_ExpectAndReturn(g_master->db, "sqlite3_step failure");
+	_log_ExpectAnyArgs();
+
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_database_is_full_and_cleanup_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	successful_bindings(g);
+
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_FULL);
+	sqlite3_exec_ExpectAndReturn(g_master->db, NULL, NULL, NULL, NULL, 1);
+	sqlite3_exec_IgnoreArg_sql();
+	sqlite3_errmsg_ExpectAndReturn(g_master->db, "Exec error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_database_is_full_and_step_failure(void)
+{
+	cosem_group g = { .name = "group_one" };
+	successful_bindings(g);
+
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_FULL);
+	sqlite3_exec_ExpectAndReturn(g_master->db, NULL, NULL, NULL, NULL, SQLITE_OK);
+	sqlite3_exec_IgnoreArg_sql();
+
+	_log_ExpectAnyArgs();
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_FULL);
+	sqlite3_errmsg_ExpectAndReturn(g_master->db, "step error");
+	_log_ExpectAnyArgs();
+
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_database_is_full_and_step_success_after_delete(void)
+{
+	cosem_group g = { .name = "group_one" };
+	successful_bindings(g);
+
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_FULL);
+	sqlite3_exec_ExpectAndReturn(g_master->db, NULL, NULL, NULL, NULL, SQLITE_OK);
+	sqlite3_exec_IgnoreArg_sql();
+
+	_log_ExpectAnyArgs();
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_DONE);
+
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_write_group_data_to_db_success(void)
+{
+	cosem_group g = { .name = "group_one" };
+	successful_bindings(g);
+
+	sqlite3_step_ExpectAndReturn(g_master->stmt_insert, SQLITE_DONE);
+
+	sqlite3_reset_IgnoreAndReturn(0);
+	sqlite3_clear_bindings_IgnoreAndReturn(0);
+
+	mstr_write_group_data_to_db(&g, "data");
+}
+
+void test_mstr_db_free(void)
+{
+	master m = {
+		.db	     = (sqlite3 *)"database",
+		.stmt_insert = (sqlite3_stmt *)"stmt",
+	};
+
+	sqlite3_finalize_ExpectAndReturn(m.stmt_insert, 0);
+	sqlite3_close_v2_ExpectAndReturn(m.db, 0);
+
+	mstr_db_free(&m);
+}
+
+void test_mstr_db_free_master_struct_is_null(void)
+{
+	mstr_db_free(NULL);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_master_2.c src/test/test_master_2.c
--- orig/test/test_master_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_master_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,87 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "master.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_master_2.h"
+
+PRIVATE void *mstr_thread_routine(void *p);
+
+master *g_master = NULL;
+
+void setUp(void)
+{
+	static master m = { 0 };
+	g_master = &m;
+}
+
+void test_mstr_thread_routine_returned_data_is_NULL()
+{
+	cosem_group g = { .name = "group_one" };
+	int rc = 0;
+	char *data = NULL;
+
+	cg_read_group_codes_ExpectAndReturn(&g, &rc, data);
+	_log_ExpectAnyArgs();
+
+	myfree_Expect(data);
+	utl_smart_sleep_Ignore();
+
+	mstr_thread_routine(&g);
+}
+
+void test_mstr_thread_routine_rc_is_not_zero()
+{
+	cosem_group g = { .name = "group_one" };
+	char *data = "data";
+	int rc = 0;
+	int rc_returned = 1;
+
+	cg_read_group_codes_ExpectAndReturn(&g, &rc, data);
+	cg_read_group_codes_ReturnThruPtr_rc(&rc_returned);
+
+	_log_ExpectAnyArgs();
+	myfree_Expect(data);
+	utl_smart_sleep_Ignore();
+
+	mstr_thread_routine(&g);
+}
+
+void test_mstr_thread_routine_rc_is_not_zero_without_name()
+{
+	cosem_group g = { 0 };
+	char *data = "data";
+	int rc = 0;
+	int rc_returned = 1;
+
+	cg_read_group_codes_ExpectAndReturn(&g, &rc, data);
+	cg_read_group_codes_ReturnThruPtr_rc(&rc_returned);
+
+	_log_ExpectAnyArgs();
+	myfree_Expect(data);
+	utl_smart_sleep_Ignore();
+
+	mstr_thread_routine(&g);
+}
+
+void test_mstr_thread_routine_rc_success()
+{
+	cosem_group g = { .name = "group_one" };
+	char *data = "data";
+	int rc = 0;
+
+	cg_read_group_codes_ExpectAndReturn(&g, &rc, data);
+        mstr_write_group_data_to_db_Expect(&g, data);
+
+	myfree_Expect(data);
+	utl_smart_sleep_Ignore();
+
+	mstr_thread_routine(&g);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_ubus.c src/test/test_ubus.c
--- orig/test/test_ubus.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_ubus.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,517 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "ubus.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_ubus.h"
+
+#include "mock_stub_blobmsg.h"
+#include "mock_stub_libubus.h"
+#include "mock_stub_blob.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+PRIVATE void find_corresponding_mutex(connection *c);
+PRIVATE void free_device(physical_device *dev);
+PRIVATE void free_cosem_group(cosem_group *g);
+PRIVATE int reply(struct ubus_context *ctx, struct ubus_request_data *req, int err_code, const char *y);
+PRIVATE int read_security_settings(struct blob_attr **tb, physical_device *d);
+
+master *g_master = NULL;
+
+void test_init_ubus_test_functions_fail_to_connect_to_ubus(void)
+{
+	ubus_connect_ExpectAndReturn(NULL, NULL);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, init_ubus_test_functions());
+}
+
+void test_init_ubus_test_functions_fail_add_ubus_object(void)
+{
+	struct ubus_context *ubus = (struct ubus_context[]){ 0 };
+
+	ubus_connect_ExpectAndReturn(NULL, ubus);
+	ubus_add_object_ExpectAndReturn(ubus, NULL, 1);
+	ubus_add_object_IgnoreArg_obj();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, init_ubus_test_functions());
+}
+
+void test_init_ubus_test_functions_successful(void)
+{
+	struct ubus_context *ubus = (struct ubus_context[]){ 0 };
+
+	ubus_connect_ExpectAndReturn(NULL, ubus);
+	ubus_add_object_ExpectAndReturn(ubus, NULL, 0);
+	ubus_add_object_IgnoreArg_obj();
+
+	myubus_add_uloop_Expect(ubus);
+
+	TEST_ASSERT_EQUAL_INT(0, init_ubus_test_functions());
+}
+
+void test_reply_blob_buf_fail_to_init(void)
+{
+	blob_buf_init_ExpectAndReturn(NULL, 0, 1);
+	blob_buf_init_IgnoreArg_buf();
+	_log_ExpectAnyArgs();
+
+	blob_buf_free_Expect(NULL);
+	blob_buf_free_IgnoreArg_buf();
+
+	TEST_ASSERT_EQUAL_INT(1, reply(NULL, NULL, 0, "data"));
+}
+
+void test_reply_fail_to_add_error_code(void)
+{
+	blob_buf_init_ExpectAndReturn(NULL, 0, 0);
+	blob_buf_init_IgnoreArg_buf();
+
+	blobmsg_add_u32_ExpectAndReturn(NULL, "error", 1, 1);
+	blobmsg_add_u32_IgnoreArg_buf();
+	_log_ExpectAnyArgs();
+
+	blob_buf_free_Expect(NULL);
+	blob_buf_free_IgnoreArg_buf();
+
+	TEST_ASSERT_EQUAL_INT(1, reply(NULL, NULL, 1, "data"));
+}
+
+void test_reply_fail_to_add_reply_message(void)
+{
+	blob_buf_init_ExpectAndReturn(NULL, 0, 0);
+	blob_buf_init_IgnoreArg_buf();
+
+	blobmsg_add_u32_ExpectAndReturn(NULL, "error", 1, 0);
+	blobmsg_add_u32_IgnoreArg_buf();
+	blobmsg_add_string_ExpectAndReturn(NULL, "result", "data", 1);
+	blobmsg_add_string_IgnoreArg_buf();
+	_log_ExpectAnyArgs();
+
+	blob_buf_free_Expect(NULL);
+	blob_buf_free_IgnoreArg_buf();
+
+	TEST_ASSERT_EQUAL_INT(1, reply(NULL, NULL, 1, "data"));
+}
+
+void test_reply_fail_to_send_reply(void)
+{
+	struct ubus_context ubus     = { 0 };
+	struct ubus_request_data req = { 0 };
+
+	blob_buf_init_ExpectAndReturn(NULL, 0, 0);
+	blob_buf_init_IgnoreArg_buf();
+
+	blobmsg_add_u32_ExpectAndReturn(NULL, "error", 1, 0);
+	blobmsg_add_u32_IgnoreArg_buf();
+	blobmsg_add_string_ExpectAndReturn(NULL, "result", "data", 0);
+	blobmsg_add_string_IgnoreArg_buf();
+
+	ubus_send_reply_ExpectAndReturn(&ubus, &req, NULL, 1);
+	_log_ExpectAnyArgs();
+
+	blob_buf_free_Expect(NULL);
+	blob_buf_free_IgnoreArg_buf();
+
+	TEST_ASSERT_EQUAL_INT(1, reply(&ubus, &req, 1, "data"));
+}
+
+void test_reply_successful(void)
+{
+	struct ubus_context ubus     = { 0 };
+	struct ubus_request_data req = { 0 };
+
+	blob_buf_init_ExpectAndReturn(NULL, 0, 0);
+	blob_buf_init_IgnoreArg_buf();
+
+	blobmsg_add_u32_ExpectAndReturn(NULL, "error", 1, 0);
+	blobmsg_add_u32_IgnoreArg_buf();
+	blobmsg_add_string_ExpectAndReturn(NULL, "result", "data", 0);
+	blobmsg_add_string_IgnoreArg_buf();
+
+	ubus_send_reply_ExpectAndReturn(&ubus, &req, NULL, 0);
+
+	blob_buf_free_Expect(NULL);
+	blob_buf_free_IgnoreArg_buf();
+
+	TEST_ASSERT_EQUAL_INT(0, reply(&ubus, &req, 1, "data"));
+}
+
+void test_find_corresponding_mutex_g_master_is_null(void)
+{
+	connection c = { 0 };
+
+	find_corresponding_mutex(&c);
+}
+
+void test_find_corresponding_mutex_g_master_connection_count_is_zero(void)
+{
+	master m     = { 0 };
+	g_master     = &m;
+	connection c = { 0 };
+
+	find_corresponding_mutex(&c);
+}
+
+void test_find_corresponding_mutex_exact_tcp_connection_host_does_not_exist(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { 0 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { 0 };
+
+
+	mystrlen_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, 0);
+	mystrncmp_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, c.parameters.tcp.host, 0, 1);
+
+	find_corresponding_mutex(&c);
+}
+
+void test_find_corresponding_mutex_exact_tcp_connection_port_does_not_exist(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { .parameters.tcp.host = "1.1", .parameters.tcp.port = 55 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { .parameters.tcp.host = "1.1" , .parameters.tcp.port = 54 };
+
+
+	mystrlen_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, 3);
+	mystrncmp_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, c.parameters.tcp.host, 3, 0);
+
+	find_corresponding_mutex(&c);
+}
+
+void test_find_corresponding_mutex_exact_tcp_connection_exist()
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { .parameters.tcp.host = "1.1", .parameters.tcp.port = 55 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { .parameters.tcp.host = "1.1" , .parameters.tcp.port = 55 };
+
+
+	mystrlen_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, 3);
+	mystrncmp_ExpectAndReturn(g_master->connections[0]->parameters.tcp.host, c.parameters.tcp.host, 3, 0);
+
+	find_corresponding_mutex(&c);
+	// TEST_ASSERT_EQUAL(true, c.mutex_needed);
+}
+
+void test_find_corresponding_mutex_exact_serial_connection_does_not_exist(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { 0 } },
+			},
+	};
+	g_master = &m;
+
+	connection c = { .type = SERIAL };
+
+	mystrstr_ExpectAndReturn(c.parameters.serial.device, "rs485", NULL);
+
+	find_corresponding_mutex(&c);
+}
+
+void test_find_corresponding_mutex_exact_serial_rs232_connection_does_exist(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { 0 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { .type = SERIAL };
+
+	mystrstr_ExpectAndReturn(c.parameters.serial.device, "rs485", NULL);
+
+	find_corresponding_mutex(&c);
+	// TEST_ASSERT_EQUAL(true, c.mutex_needed);
+}
+
+void test_find_corresponding_mutex_exact_serial_rs485_connection_does_exist(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { 0 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { .type = SERIAL };
+
+	mystrstr_ExpectAndReturn(c.parameters.serial.device, "rs485", c.parameters.serial.device + 5);
+
+	find_corresponding_mutex(&c);
+	// TEST_ASSERT_EQUAL(true, c.mutex_needed);
+}
+
+void test_find_corresponding_mutex_connection_type_is_invalid(void)
+{
+	master m = {
+		.connection_count = 1,
+		.connections =
+			(connection *[]){
+				(connection[]){ { 0 } },
+			},
+	};
+	g_master	= &m;
+	connection c = { .type = 3 };
+
+	find_corresponding_mutex(&c);
+}
+
+void test_free_device_device_with_connection(void)
+{
+	physical_device dev = {
+		.connection =
+			(connection[]){
+				{ 0 },
+			},
+	};
+
+	cip_clear_Expect(&dev.settings.cipher);
+	cl_clear_Expect(&dev.settings);
+	bb_clear_ExpectAndReturn(&dev.connection->data, 0);
+
+	free_device(&dev);
+}
+
+void test_free_cosem_group_cosem_objects_are_null(void)
+{
+	cosem_group g = { 0 };
+
+	free_cosem_group(&g);
+}
+
+void test_free_cosem_group_successful(void)
+{
+	cosem_group g = {
+		.cosem_object_count = 1,
+		.cosem_objects =
+			(cosem_object *[]){
+				(cosem_object[]){
+					{
+						.devices = (physical_device *[]){ 0 },
+					},
+				},
+			},
+	};
+
+	myfree_Expect(g.cosem_objects[0]->devices);
+	obj_clear_Expect(g.cosem_objects[0]->object);
+	myfree_Expect(g.cosem_objects[0]->object);
+	myfree_Expect(g.cosem_objects[0]);
+	myfree_Expect(g.cosem_objects);
+
+	free_cosem_group(&g);
+}
+
+void test_ubus_exit(void)
+{
+	ubus_free_ExpectAnyArgs();
+
+	ubus_exit();
+}
+
+struct blob_attr *tb[] = {
+	(struct blob_attr *)"type",
+	(struct blob_attr *)"address",
+	(struct blob_attr *)"port",
+	(struct blob_attr *)"serial_device",
+	(struct blob_attr *)"serial_baudrate",
+	(struct blob_attr *)"serial_databits",
+	(struct blob_attr *)"serial_stopbits",
+	(struct blob_attr *)"serial_parity",
+	(struct blob_attr *)"serial_flowcontrol",
+	(struct blob_attr *)"server_addr",
+	(struct blob_attr *)"log_server_addr",
+	(struct blob_attr *)"client_addr",
+	(struct blob_attr *)"use_ln",
+	(struct blob_attr *)"transport_security",
+	(struct blob_attr *)"interface_type",
+	(struct blob_attr *)"access_security",
+	(struct blob_attr *)"password",
+	(struct blob_attr *)"system_title",
+	(struct blob_attr *)"authentication_key",
+	(struct blob_attr *)"block_cipher_key",
+	(struct blob_attr *)"dedicated_key",
+	(struct blob_attr *)"invocation_counter",
+};
+
+enum {
+	TEST_DEVICE_OPT_TYPE,
+	TEST_DEVICE_OPT_TCP_ADDRESS,
+	TEST_DEVICE_OPT_TCP_PORT,
+	TEST_DEVICE_OPT_SERIAL_DEVICE,
+	TEST_DEVICE_OPT_SERIAL_BAUDRATE,
+	TEST_DEVICE_OPT_SERIAL_DATABITS,
+	TEST_DEVICE_OPT_SERIAL_STOPBITS,
+	TEST_DEVICE_OPT_SERIAL_PARITY,
+	TEST_DEVICE_OPT_SERIAL_FLOWCONTROL,
+	TEST_DEVICE_OPT_SERVER_ADDR,
+	TEST_DEVICE_OPT_LOG_SERVER_ADDR,
+	TEST_DEVICE_OPT_CLIENT_ADDR,
+	TEST_DEVICE_OPT_USE_LN,
+	TEST_DEVICE_OPT_TRANSPORT_SECURITY,
+	TEST_DEVICE_OPT_INTERFACE_TYPE,
+	TEST_DEVICE_OPT_ACCESS_SECURITY,
+	TEST_DEVICE_OPT_PASSWORD,
+	TEST_DEVICE_OPT_SYSTEM_TITLE,
+	TEST_DEVICE_OPT_AUTHENTICATION_KEY,
+	TEST_DEVICE_OPT_BLOCK_CIPHER_KEY,
+	TEST_DEVICE_OPT_DEDICATED_KEY,
+	TEST_DEVICE_OPT_INVOCATION_COUNTER,
+	TEST_DEVICE_OPT_MAX
+};
+
+void test_read_security_settings_fail_to_validate_system_title(void)
+{
+	physical_device d = { 0 };
+
+	blobmsg_get_u32_ExpectAndReturn(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER], "0.0.0.0");
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_SYSTEM_TITLE], "abcdefghjkl");
+
+	validate_key_ExpectAndReturn("abcdefghjkl", 16, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, read_security_settings(tb, &d));
+}
+
+void test_read_security_settings_fail_to_validate_authentication_key(void)
+{
+	physical_device d = { 0 };
+
+	blobmsg_get_u32_ExpectAndReturn(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER], "0.0.0.0");
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_SYSTEM_TITLE], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 16, 0);
+	bb_clear_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, read_security_settings(tb, &d));
+}
+
+void test_read_security_settings_fail_to_validate_block_cipher_key(void)
+{
+	physical_device d = { 0 };
+
+	blobmsg_get_u32_ExpectAndReturn(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER], "0.0.0.0");
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_SYSTEM_TITLE], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 16, 0);
+	bb_clear_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, read_security_settings(tb, &d));
+}
+
+void test_read_security_settings_fail_to_validate_dedicated_key(void)
+{
+	physical_device d = { 0 };
+
+	blobmsg_get_u32_ExpectAndReturn(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER], "0.0.0.0");
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_SYSTEM_TITLE], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 16, 0);
+	bb_clear_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_DEDICATED_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, read_security_settings(tb, &d));
+}
+
+void test_read_security_settings_successful(void)
+{
+	physical_device d = { 0 };
+
+	blobmsg_get_u32_ExpectAndReturn(tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_INVOCATION_COUNTER], "0.0.0.0");
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_SYSTEM_TITLE], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 16, 0);
+	bb_clear_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	blobmsg_get_string_ExpectAndReturn(tb[TEST_DEVICE_OPT_DEDICATED_KEY], "abcdefghjkl1234");
+	validate_key_ExpectAndReturn("abcdefghjkl1234", 32, 0);
+
+	mycalloc_ExpectAndReturn(1, sizeof(gxByteBuffer), (gxByteBuffer[]){ 0 });
+	bb_init_IgnoreAndReturn(0);
+	bb_addHexString_IgnoreAndReturn(0);
+
+	TEST_ASSERT_EQUAL_INT(0, read_security_settings(tb, &d));
+}
+
+void test_read_security_settings_blob_data_is_empty(void)
+{
+	physical_device d = { 0 };
+
+	tb[TEST_DEVICE_OPT_TRANSPORT_SECURITY] = NULL;
+	tb[TEST_DEVICE_OPT_INVOCATION_COUNTER] = NULL;
+	tb[TEST_DEVICE_OPT_SYSTEM_TITLE]       = NULL;
+	tb[TEST_DEVICE_OPT_AUTHENTICATION_KEY] = NULL;
+	tb[TEST_DEVICE_OPT_BLOCK_CIPHER_KEY]   = NULL;
+	tb[TEST_DEVICE_OPT_DEDICATED_KEY]      = NULL;
+
+	TEST_ASSERT_EQUAL_INT(0, read_security_settings(tb, &d));
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_ubus_2.c src/test/test_ubus_2.c
--- orig/test/test_ubus_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_ubus_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,371 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "ubus.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_ubus_2.h"
+
+#include "mock_stub_blobmsg.h"
+#include "mock_stub_blob.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+struct blob_attr *tb_object[] = {
+	(struct blob_attr *)"id",
+	(struct blob_attr *)"enabled",
+	(struct blob_attr *)"name",
+	(struct blob_attr *)"physical_devices",
+	(struct blob_attr *)"obis",
+	(struct blob_attr *)"cosem_id",
+	(struct blob_attr *)"entries",
+};
+
+enum {
+	TEST_COSEM_OBJECT_OPT_ID,
+	TEST_COSEM_OBJECT_OPT_ENABLED,
+	TEST_COSEM_OBJECT_OPT_NAME,
+	TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES,
+	TEST_COSEM_OBJECT_OPT_OBIS,
+	TEST_COSEM_OBJECT_OPT_COSEM_ID,
+	TEST_COSEM_OBJECT_OPT_ENTRIES,
+	TEST_COSEM_OBJECT_OPT_COUNT
+};
+
+struct blob_attr *tb_group[] = { (struct blob_attr *)"objects" };
+
+PRIVATE int device_cb(struct ubus_context *ctx, struct ubus_object *obj,
+		      struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+PRIVATE int cosem_group_cb(struct ubus_context *ctx, struct ubus_object *obj,
+			   struct ubus_request_data *req, const char *method, struct blob_attr *msg);
+PRIVATE int validate_key(const char *key, size_t len);
+PRIVATE cosem_object *parse_cosem_object(struct blob_attr *b);
+static int expect_blobmsg_parse();
+
+master *g_master = NULL;
+
+void test_device_cb_fail_to_parse_parameters(void)
+{
+	device_cb_args_ExpectAndReturn(NULL, NULL, 1);
+	device_cb_args_IgnoreArg_d();
+
+	utl_unlock_mutex_if_required_ExpectAnyArgs();
+	reply_ExpectAndReturn(NULL, NULL, 1, NULL, 1);
+	reply_IgnoreArg_y();
+
+	free_device_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, device_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_device_cb_fail_to_make_connection(void)
+{
+	device_cb_args_ExpectAndReturn(NULL, NULL, 0);
+	device_cb_args_IgnoreArg_d();
+
+	utl_lock_mutex_if_required_ExpectAnyArgs();
+
+	cg_make_connection_ExpectAndReturn(NULL, 1);
+	cg_make_connection_IgnoreArg_dev();
+
+	utl_unlock_mutex_if_required_ExpectAnyArgs();
+
+	reply_ExpectAndReturn(NULL, NULL, 1, NULL, 1);
+	reply_IgnoreArg_y();
+
+	free_device_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, device_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_device_cb_reply_failure(void)
+{
+	device_cb_args_ExpectAndReturn(NULL, NULL, 0);
+	device_cb_args_IgnoreArg_d();
+
+	utl_lock_mutex_if_required_ExpectAnyArgs();
+
+	cg_make_connection_ExpectAndReturn(NULL, 0);
+	cg_make_connection_IgnoreArg_dev();
+
+	com_close_ExpectAnyArgsAndReturn(0);
+	utl_unlock_mutex_if_required_ExpectAnyArgs();
+
+	reply_ExpectAndReturn(NULL, NULL, 0, NULL, 1);
+	reply_IgnoreArg_y();
+
+	free_device_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, device_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_device_cb_successful(void)
+{
+	device_cb_args_ExpectAndReturn(NULL, NULL, 0);
+	device_cb_args_IgnoreArg_d();
+
+	utl_lock_mutex_if_required_ExpectAnyArgs();
+
+	cg_make_connection_ExpectAndReturn(NULL, 0);
+	cg_make_connection_IgnoreArg_dev();
+
+	com_close_ExpectAnyArgsAndReturn(0);
+	utl_unlock_mutex_if_required_ExpectAnyArgs();
+
+	reply_ExpectAndReturn(NULL, NULL, 0, NULL, 0);
+	reply_IgnoreArg_y();
+
+	free_device_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(0, device_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_cosem_group_cb_fail_to_parse_parameters(void)
+{
+	cosem_group_args_ExpectAndReturn(NULL, NULL, 1);
+	cosem_group_args_IgnoreArg_g();
+
+	reply_ExpectAndReturn(NULL, NULL, 1, NULL, 1);
+	reply_IgnoreArg_y();
+
+	free_cosem_group_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_cosem_group_cb_payload_is_null(void)
+{
+	cosem_group_args_ExpectAndReturn(NULL, NULL, 0);
+	cosem_group_args_IgnoreArg_g();
+
+	cg_read_group_codes_ExpectAnyArgsAndReturn(NULL);
+	_log_ExpectAnyArgs();
+
+	reply_ExpectAndReturn(NULL, NULL, 0, NULL, 1);
+	reply_IgnoreArg_y();
+
+	free_cosem_group_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_cosem_group_cb_successful(void)
+{
+	cosem_group_args_ExpectAndReturn(NULL, NULL, 0);
+	cosem_group_args_IgnoreArg_g();
+
+	cg_read_group_codes_ExpectAnyArgsAndReturn("data");
+	_log_ExpectAnyArgs();
+
+	reply_ExpectAndReturn(NULL, NULL, 0, NULL, 0);
+	reply_IgnoreArg_y();
+
+	free_cosem_group_ExpectAnyArgs();
+	myfree_Ignore();
+
+	TEST_ASSERT_EQUAL_INT(0, cosem_group_cb(NULL, NULL, NULL, NULL, NULL));
+}
+
+void test_validate_key_is_equal(void)
+{
+	const char *str = "labas";
+
+	mystrlen_ExpectAndReturn(str, 5);
+	TEST_ASSERT_EQUAL_INT(0, validate_key(str, 5));
+}
+
+void test_validate_key_is_not_equal(void)
+{
+	const char *str = "labas";
+
+	mystrlen_ExpectAndReturn(str, 5);
+	TEST_ASSERT_EQUAL_INT(1, validate_key(str, 10));
+}
+
+void test_parse_cosem_object_fail_to_blobmsg_parse(void)
+{
+	struct blob_attr msg = { 0 };
+
+	blob_data_ExpectAndReturn(tb_group[0], tb_group[0]->data);
+	blob_len_ExpectAndReturn(tb_group[0], tb_group[0]->id_len);
+	blobmsg_parse_ExpectAndReturn(NULL, 7, NULL, tb_group[0]->data, tb_group[0]->id_len, 1);
+	blobmsg_parse_IgnoreArg_policy();
+	blobmsg_parse_IgnoreArg_tb();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+}
+
+static int expect_blobmsg_parse()
+{
+	blob_data_ExpectAndReturn(tb_group[0], tb_group[0]->data);
+	blob_len_ExpectAndReturn(tb_group[0], tb_group[0]->id_len);
+	blobmsg_parse_ExpectAndReturn(NULL, 7, NULL, tb_group[0]->data, tb_group[0]->id_len, 0);
+	blobmsg_parse_ReturnMemThruPtr_tb(tb_object, sizeof(struct blob_attr) * 7);
+	blobmsg_parse_IgnoreArg_policy();
+	blobmsg_parse_IgnoreArg_tb();
+}
+
+void test_parse_cosem_object_id_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_ID] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_ID] = (struct blob_attr *)"id"; // restore id
+}
+
+void test_parse_cosem_object_enabled_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_ENABLED] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_ENABLED] = (struct blob_attr *)"enabled"; // restore enabled
+}
+
+void test_parse_cosem_object_name_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_NAME] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_NAME] = (struct blob_attr *)"name"; // restore name
+}
+
+void test_parse_cosem_object_physical_devices_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES] = (struct blob_attr *)"physical_devices"; // restore physical_devices
+}
+
+void test_parse_cosem_object_obis_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_OBIS] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_OBIS] = (struct blob_attr *)"obis"; // restore obis
+}
+
+void test_parse_cosem_object_cosem_id_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_COSEM_ID] = NULL;
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_COSEM_ID] = (struct blob_attr *)"cosem_id"; // restore cosem_id
+}
+
+void test_parse_cosem_object_obj_calloc_failure(void)
+{
+	struct blob_attr msg = { 0 };
+
+	expect_blobmsg_parse();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), NULL);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+}
+
+void test_parse_cosem_object_blobmsg_check_array_failure(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_object *obj = (cosem_object[]){ 0 };
+
+	expect_blobmsg_parse();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), obj);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ID], 0);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ENABLED], 0);
+	blobmsg_get_string_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_NAME], "none");
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ENTRIES], 0);
+
+	blobmsg_check_array_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES], BLOBMSG_TYPE_STRING, -1);
+	_log_ExpectAnyArgs();
+	myfree_Expect(obj);
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+}
+
+void test_parse_cosem_object_devices_calloc_failure(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_object *obj = (cosem_object[]){ 0 };
+
+	expect_blobmsg_parse();
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), obj);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ID], 0);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ENABLED], 0);
+	blobmsg_get_string_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_NAME], "none");
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ENTRIES], 0);
+
+	blobmsg_check_array_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES], BLOBMSG_TYPE_STRING, 1);
+	mycalloc_ExpectAndReturn(1, sizeof(*obj->devices), NULL);
+	_log_ExpectAnyArgs();
+	myfree_Expect(obj);
+
+	TEST_ASSERT_NULL(parse_cosem_object(tb_group[0]));
+}
+
+void test_parse_cosem_object_successful(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_object *obj = (cosem_object[]){ 0 };
+
+	expect_blobmsg_parse();
+	tb_object[TEST_COSEM_OBJECT_OPT_ENTRIES] = NULL;
+
+	mycalloc_ExpectAndReturn(1, sizeof(cosem_object), obj);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ID], 0);
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_ENABLED], 0);
+	blobmsg_get_string_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_NAME], "none");
+
+	physical_device **devices = (physical_device *[]){ 0 };
+	blobmsg_check_array_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_PHYSICAL_DEVICES], BLOBMSG_TYPE_STRING, 1);
+	mycalloc_ExpectAndReturn(1, sizeof(*obj->devices), devices);
+
+	int cosem_id = 4;
+	char *obis = "0.0.42.0.0.255";
+	blobmsg_get_u32_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_COSEM_ID], cosem_id);
+	blobmsg_get_string_ExpectAndReturn(tb_object[TEST_COSEM_OBJECT_OPT_OBIS], obis);
+	cosem_createObject2_ExpectAndReturn(cosem_id, obis, &obj->object, 0);
+	cosem_init_ExpectAndReturn(obj->object, cosem_id, obis, 0);
+
+	TEST_ASSERT_NOT_NULL(parse_cosem_object(tb_group[0]));
+	tb_object[TEST_COSEM_OBJECT_OPT_ENTRIES] = (struct blob_attr *)"entries"; // restore entries
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_ubus_3.c src/test/test_ubus_3.c
--- orig/test/test_ubus_3.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_ubus_3.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,543 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "ubus.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_ubus_3.h"
+
+#include "mock_stub_blobmsg.h"
+#include "mock_stub_blob.h"
+
+#include "mock_bytebuffer.h"
+#include "mock_gxobjects.h"
+#include "mock_client.h"
+#include "mock_dlmssettings.h"
+#include "mock_cosem.h"
+#include "mock_ciphering.h"
+
+struct blob_attr *tb_device[] = {
+	(struct blob_attr *)"type",
+	(struct blob_attr *)"address",
+	(struct blob_attr *)"port",
+	(struct blob_attr *)"serial_device",
+	(struct blob_attr *)"serial_baudrate",
+	(struct blob_attr *)"serial_databits",
+	(struct blob_attr *)"serial_stopbits",
+	(struct blob_attr *)"serial_parity",
+	(struct blob_attr *)"serial_flowcontrol",
+	(struct blob_attr *)"server_addr",
+	(struct blob_attr *)"log_server_addr",
+	(struct blob_attr *)"client_addr",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+enum {
+	TEST_DEVICE_OPT_TYPE,
+	TEST_DEVICE_OPT_TCP_ADDRESS,
+	TEST_DEVICE_OPT_TCP_PORT,
+	TEST_DEVICE_OPT_SERIAL_DEVICE,
+	TEST_DEVICE_OPT_SERIAL_BAUDRATE,
+	TEST_DEVICE_OPT_SERIAL_DATABITS,
+	TEST_DEVICE_OPT_SERIAL_STOPBITS,
+	TEST_DEVICE_OPT_SERIAL_PARITY,
+	TEST_DEVICE_OPT_SERIAL_FLOWCONTROL,
+	TEST_DEVICE_OPT_SERVER_ADDR,
+	TEST_DEVICE_OPT_LOG_SERVER_ADDR,
+	TEST_DEVICE_OPT_CLIENT_ADDR,
+	TEST_DEVICE_OPT_USE_LN,
+	TEST_DEVICE_OPT_TRANSPORT_SECURITY,
+	TEST_DEVICE_OPT_INTERFACE_TYPE,
+	TEST_DEVICE_OPT_ACCESS_SECURITY,
+	TEST_DEVICE_OPT_PASSWORD,
+	TEST_DEVICE_OPT_SYSTEM_TITLE,
+	TEST_DEVICE_OPT_AUTHENTICATION_KEY,
+	TEST_DEVICE_OPT_BLOCK_CIPHER_KEY,
+	TEST_DEVICE_OPT_DEDICATED_KEY,
+	TEST_DEVICE_OPT_INVOCATION_COUNTER,
+	TEST_DEVICE_OPT_MAX
+};
+
+static void expect_blobmsg_parse(struct blob_attr *msg, struct blob_attr **tb, int count);
+
+PRIVATE int device_cb_args(physical_device *d, struct blob_attr *msg);
+PRIVATE int cosem_group_args(cosem_group *g, struct blob_attr *msg);
+
+master *g_master = NULL;
+
+void test_device_cb_args_msg_is_null(void)
+{
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(NULL, NULL));
+}
+
+void test_device_cb_args_fail_to_blobmsg_parse(void)
+{
+	struct blob_attr msg = { 0 };
+
+	blob_data_ExpectAndReturn(&msg, msg.data);
+	blob_len_ExpectAndReturn(&msg, msg.id_len);
+	blobmsg_parse_ExpectAndReturn(NULL, 22, NULL, msg.data, msg.id_len, 1);
+	blobmsg_parse_IgnoreArg_policy();
+	blobmsg_parse_IgnoreArg_tb();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(NULL, &msg));
+}
+
+static void expect_blobmsg_parse(struct blob_attr *msg, struct blob_attr **tb, int count)
+{
+	blob_data_ExpectAndReturn(msg, msg->data);
+	blob_len_ExpectAndReturn(msg, msg->id_len);
+	blobmsg_parse_ExpectAndReturn(NULL, count, NULL, msg->data, msg->id_len, 0);
+	blobmsg_parse_IgnoreArg_policy();
+	blobmsg_parse_IgnoreArg_tb();
+	blobmsg_parse_ReturnMemThruPtr_tb(tb, sizeof(struct blob_attr) * count);
+}
+
+void test_device_cb_args_blob_attr_type_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	tb_device[TEST_DEVICE_OPT_TYPE] = NULL; // make type NULL
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_TYPE] = (struct blob_attr *)"type"; // restore type
+}
+
+void test_device_cb_args_tcp_blob_attr_type_is_invalid(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], 4);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+}
+
+void test_device_cb_args_tcp_blob_attr_address_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	tb_device[TEST_DEVICE_OPT_TCP_ADDRESS] = NULL; // make address NULL
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_TCP_ADDRESS] = (struct blob_attr *)"address"; // restore address
+}
+
+void test_device_cb_args_tcp_blob_attr_port_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	tb_device[TEST_DEVICE_OPT_TCP_PORT] = NULL; // make port NULL
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_TCP_PORT] = (struct blob_attr *)"port"; // restore port
+}
+
+void test_device_cb_args_tcp_blob_attr_port_is_lower_than_minimum(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 0);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+}
+
+void test_device_cb_args_tcp_blob_attr_port_is_higher_than_maximum(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 65536);
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+}
+
+void test_device_cb_args_serial_blob_attr_device_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_DEVICE] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_DEVICE] = (struct blob_attr *)"serial_device"; // restore serial device
+}
+
+void test_device_cb_args_serial_blob_attr_baudrate_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_BAUDRATE] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_BAUDRATE] = (struct blob_attr *)"serial_baudrate"; // restore serial baudrate
+}
+
+void test_device_cb_args_serial_blob_attr_databits_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_DATABITS] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_DATABITS] = (struct blob_attr *)"serial_databits"; // restore serial databits
+}
+
+void test_device_cb_args_serial_blob_attr_stopbits_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_STOPBITS] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_STOPBITS] = (struct blob_attr *)"serial_stopbits"; // restore serial stopbits
+}
+
+void test_device_cb_args_serial_blob_attr_parity_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_PARITY] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_PARITY] = (struct blob_attr *)"serial_parity"; // restore serial parity
+}
+
+void test_device_cb_args_serial_blob_attr_flowcontrol_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	tb_device[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL] = (struct blob_attr *)"serial_flowcontrol"; // restore serial flowcontrol
+}
+
+void test_device_cb_args_serial_blob_attr_server_addr_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], SERIAL);
+
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_DEVICE], "/dev/rs232");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_BAUDRATE], 0);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_DATABITS], "none");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_STOPBITS], 0);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_PARITY], 0);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERIAL_FLOWCONTROL], "none");
+
+	tb_device[TEST_DEVICE_OPT_SERVER_ADDR] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERVER_ADDR] = (struct blob_attr *)"server_addr"; // restore server addr
+}
+
+void test_device_cb_args_tcp_blob_attr_server_addr_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+
+	tb_device[TEST_DEVICE_OPT_SERVER_ADDR] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_SERVER_ADDR] = (struct blob_attr *)"server_addr"; // restore server addr
+}
+
+void test_device_cb_args_blob_attr_log_server_addr_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+
+	tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR] = (struct blob_attr *)"log_server_addr"; // restore logical server addr
+}
+
+void test_device_cb_args_blob_attr_client_addr_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR], 1);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERVER_ADDR], 0);
+	cl_getServerAddress_ExpectAnyArgsAndReturn(0);
+
+	tb_device[TEST_DEVICE_OPT_CLIENT_ADDR] = NULL;
+
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(DLMS_ERROR_CODE_OTHER_REASON, device_cb_args(&d, &msg));
+	tb_device[TEST_DEVICE_OPT_CLIENT_ADDR] = (struct blob_attr *)"client_addr"; // restore client addr
+}
+
+void test_device_cb_args_fail_to_read_security_settings(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR], 1);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERVER_ADDR], 0);
+	cl_getServerAddress_ExpectAnyArgsAndReturn(0);
+        blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_CLIENT_ADDR], 1);
+
+	cl_init_Ignore();
+
+	read_security_settings_ExpectAndReturn(tb_device, &d, 1);
+	read_security_settings_IgnoreArg_tb();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(250, device_cb_args(&d, &msg));
+}
+
+void test_device_cb_args_successful_without_additional_security_settings(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR], 1);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERVER_ADDR], 0);
+	cl_getServerAddress_ExpectAnyArgsAndReturn(0);
+        blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_CLIENT_ADDR], 1);
+
+	cl_init_Ignore();
+
+	read_security_settings_ExpectAndReturn(tb_device, &d, 0);
+	read_security_settings_IgnoreArg_tb();
+
+	bb_init_IgnoreAndReturn(0);
+	bb_capacity_ExpectAnyArgsAndReturn(0);
+	find_corresponding_mutex_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(0, device_cb_args(&d, &msg));
+}
+
+void test_device_cb_args_successful_with_additional_security_settings(void)
+{
+	struct blob_attr msg = { 0 };
+	physical_device d    = { .connection = (connection[]){ 0 } };
+
+	tb_device[TEST_DEVICE_OPT_INTERFACE_TYPE] = (struct blob_attr *)"interface_type";
+	tb_device[TEST_DEVICE_OPT_ACCESS_SECURITY] = (struct blob_attr *)"access_security";
+	tb_device[TEST_DEVICE_OPT_PASSWORD] = (struct blob_attr *)"password";
+	tb_device[TEST_DEVICE_OPT_TRANSPORT_SECURITY] = (struct blob_attr *)"transport_security";
+
+	expect_blobmsg_parse(&msg, tb_device, TEST_DEVICE_OPT_MAX);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TYPE], TCP);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_PORT], 9999);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_TCP_ADDRESS], "0.0.0.0");
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_LOG_SERVER_ADDR], 1);
+	blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_SERVER_ADDR], 0);
+	cl_getServerAddress_ExpectAnyArgsAndReturn(0);
+        blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_CLIENT_ADDR], 1);
+
+        blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_INTERFACE_TYPE], 1);
+        blobmsg_get_u32_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_ACCESS_SECURITY], 1);
+	blobmsg_get_string_ExpectAndReturn(tb_device[TEST_DEVICE_OPT_PASSWORD], "Gurux");
+
+	cl_init_Ignore();
+
+	read_security_settings_ExpectAndReturn(tb_device, &d, 0);
+	read_security_settings_IgnoreArg_tb();
+
+	bb_init_IgnoreAndReturn(0);
+	bb_capacity_ExpectAnyArgsAndReturn(0);
+	find_corresponding_mutex_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(0, device_cb_args(&d, &msg));
+}
+
+void test_cosem_group_args_msg_is_null(void)
+{
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_args(NULL, NULL));
+}
+
+struct blob_attr *tb_cosem_group[] = {
+	(struct blob_attr *)"objects",
+};
+
+enum {
+	TEST_COSEM_GROUP_OPT_OBJECTS,
+	TEST_COSEM_GROUP_OPT_COUNT,
+};
+
+void test_cosem_group_args_fail_to_blobmsg_parse(void)
+{
+	struct blob_attr msg = { 0 };
+
+	blob_data_ExpectAndReturn(&msg, msg.data);
+	blob_len_ExpectAndReturn(&msg, msg.id_len);
+	blobmsg_parse_ExpectAndReturn(NULL, 1, NULL, msg.data, msg.id_len, 1);
+	blobmsg_parse_IgnoreArg_policy();
+	blobmsg_parse_IgnoreArg_tb();
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_args(NULL, &msg));
+}
+
+void test_cosem_group_args_blob_attr_type_is_null(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_group g	     = { 0 };
+
+	tb_cosem_group[0] = NULL; // make objects NULL
+
+	expect_blobmsg_parse(&msg, tb_cosem_group, 1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_args(&g, &msg));
+	tb_cosem_group[0] = (struct blob_attr *)"objects"; // restore objects
+}
+
+void test_cosem_group_args_blobmsg_check_array_failure(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_group g	     = { 0 };
+
+	expect_blobmsg_parse(&msg, tb_cosem_group, 1);
+	blobmsg_check_array_ExpectAndReturn(tb_cosem_group[TEST_COSEM_GROUP_OPT_OBJECTS], BLOBMSG_TYPE_TABLE, -1);
+	_log_ExpectAnyArgs();
+
+	TEST_ASSERT_EQUAL_INT(1, cosem_group_args(&g, &msg));
+}
+
+void test_cosem_group_args_successful(void)
+{
+	struct blob_attr msg = { 0 };
+	cosem_group g	     = { 0 };
+
+	expect_blobmsg_parse(&msg, tb_cosem_group, 1);
+	blobmsg_check_array_ExpectAndReturn(tb_cosem_group[TEST_COSEM_GROUP_OPT_OBJECTS], BLOBMSG_TYPE_TABLE, 1);
+
+	TEST_ASSERT_EQUAL_INT(0, cosem_group_args(&g, &msg));
+}
+
+//!!!! maybe someday: test for blobmsg_for_each_attr
+// void test_cosem_group_args_parse_cosem_object_is_NULL(void)
+// {
+// 	struct blob_attr msg = { 0 };
+// 	cosem_group g	     = { 0 };
+
+// 	blobmsg_data_len_IgnoreAndReturn(1);
+// 	blobmsg_data_IgnoreAndReturn("object");
+
+// 	expect_blobmsg_parse(&msg, tb_cosem_group, 1);
+// 	blobmsg_check_array_ExpectAndReturn(tb_cosem_group[TEST_COSEM_GROUP_OPT_OBJECTS], BLOBMSG_TYPE_TABLE, 1);
+// 	_log_ExpectAnyArgs();
+
+// 	TEST_ASSERT_EQUAL_INT(1, cosem_group_args(&g, &msg));
+// }
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_utils.c src/test/test_utils.c
--- orig/test/test_utils.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_utils.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,207 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "utils.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+
+#include "mock_converters.h"
+
+#undef calloc
+#undef free
+#undef strlen
+
+static long mystrtol_cb_1(const char *nptr, char **endptr, int base, int call_count)
+{
+	errno = 1;
+	return 0;
+}
+
+static long mystrtol_cb_2(const char *nptr, char **endptr, int base, int call_count)
+{
+	errno = 0;
+	return 0;
+}
+
+void test_utl_parse_args_zero_arguments(void)
+{
+	TEST_ASSERT_EQUAL(0, utl_parse_args(0, NULL, NULL));
+}
+
+void test_utl_parse_args_argc_is_not_three(void)
+{
+	char *argv[] = { "dlms_master", "-D", "4", "too much" };
+
+	myfprintf_ExpectAnyArgsAndReturn(0);
+
+	TEST_ASSERT_EQUAL(1, utl_parse_args(4, argv, NULL));
+}
+
+void test_utl_parse_args_argv_second_parameter_is_not_valid(void)
+{
+	char *argv[] = { "dlms_master", "-E", "4" };
+
+	mystrcmp_ExpectAndReturn(argv[1], "-D", 1);
+	myfprintf_ExpectAnyArgsAndReturn(0);
+
+	TEST_ASSERT_EQUAL(1, utl_parse_args(3, argv, NULL));
+}
+
+void test_utl_parse_args_invalid_debug_parameter(void)
+{
+	char *argv[] = { "dlms_master", "-D", "labas" };
+	log_level_type dbg = 0;
+
+	mystrcmp_ExpectAndReturn(argv[1], "-D", 0);
+	mystrtol_AddCallback(mystrtol_cb_1);
+	mystrtol_ExpectAndReturn(argv[2], NULL, 10, 0);
+	mystrtol_IgnoreArg_endptr();
+	myfprintf_ExpectAnyArgsAndReturn(0);
+
+	TEST_ASSERT_EQUAL(1, utl_parse_args(3, argv, &dbg));
+}
+
+void test_utl_parse_args_endptr_not_null(void)
+{
+	char *argv[] = { "dlms_master", "-D", "4asd" };
+	log_level_type dbg = 0;
+
+	mystrcmp_ExpectAndReturn(argv[1], "-D", 0);
+	mystrtol_AddCallback(mystrtol_cb_2);
+	mystrtol_ExpectAndReturn(argv[2], NULL, 10, 4);
+	mystrtol_ReturnThruPtr_endptr((char *[]){"asd"});
+	mystrtol_IgnoreArg_endptr();
+	myfprintf_ExpectAnyArgsAndReturn(0);
+
+	TEST_ASSERT_EQUAL(1, utl_parse_args(3, argv, &dbg));
+}
+
+void test_utl_parse_args_successful(void)
+{
+	char *argv[] = { "dlms_master", "-D", "4" };
+	log_level_type dbg = 0;
+
+	mystrcmp_ExpectAndReturn(argv[1], "-D", 0);
+	mystrtol_AddCallback(mystrtol_cb_2);
+	mystrtol_ExpectAndReturn(argv[2], NULL, 10, 4);
+	mystrtol_ReturnThruPtr_endptr((char *[]){""});
+	mystrtol_IgnoreArg_endptr();
+
+	TEST_ASSERT_EQUAL(0, utl_parse_args(3, argv, &dbg));
+}
+
+void test_append_if_destination_null_should_copy_target(void)
+{
+	char *destination = NULL;
+	char *target = "NOT NULL";
+
+	mystrdup_ExpectAndReturn(target, target);
+	utl_append_to_str(&destination, target);
+
+	TEST_ASSERT_NOT_NULL(destination);
+}
+
+void test_append_target_if_source_null_do_nothing(void)
+{
+	char *source = NULL;
+	char *destination = "NOT NULL";
+
+	_log_ExpectAnyArgs();
+	utl_append_to_str(&destination, source);
+
+	TEST_ASSERT_NULL(source);
+	TEST_ASSERT_NOT_NULL(destination);
+}
+
+void test_append_if_realloc_succeed_should_append_string(void)
+{
+	char *destination = calloc(10, sizeof(char));
+	char *source = "appending";
+	char *result = "appending";
+
+	mystrlen_ExpectAndReturn(source, strlen(source));
+	mystrlen_ExpectAndReturn(destination, strlen(destination));
+	myrealloc_ExpectAndReturn(destination, strlen(destination) + strlen(source) + 1, destination);
+	mystrncat_ExpectAndReturn(destination, result, 9, result);
+	mystrncat_ReturnMemThruPtr_dest(result, strlen(result));
+
+	utl_append_to_str(&destination, source);
+	TEST_ASSERT_EQUAL_STRING(destination, "appending");
+	free(destination);
+}
+
+void test_append_if_realloc_fail_should_exit(void)
+{
+	char *destination = calloc(1, sizeof(char));
+	char *source = "appending";
+
+	mystrlen_ExpectAndReturn(source, 9);
+	mystrlen_ExpectAndReturn(destination, 0);
+	myrealloc_ExpectAndReturn(destination, 10, NULL);
+	_log_ExpectAnyArgs();
+	utl_append_to_str(&destination, source);
+	TEST_ASSERT_NULL(destination);
+	free(destination);
+}
+
+void test_utl_smart_sleep_case1(void)
+{
+	int period	 = 2;
+	time_t t0	 = time(NULL);
+	unsigned long tn = 0;
+
+	utl_smart_sleep(&t0, &tn, period);
+	TEST_ASSERT_EQUAL(period, time(NULL) - t0);
+	TEST_ASSERT_EQUAL(1, tn);
+}
+
+void test_utl_smart_sleep_case2(void)
+{
+	time_t t0	 = time(NULL);
+	unsigned long tn = 2;
+
+	utl_smart_sleep(&t0, &tn, 1);
+	TEST_ASSERT_EQUAL(0, tn);
+}
+
+void test_utl_lock_mutex_if_required_mutex_is_NULL(void)
+{
+	physical_device d = { .connection = (connection[]){ {
+				      0,
+			      } } };
+
+	utl_lock_mutex_if_required(&d);
+}
+
+void test_utl_lock_mutex_if_required_mutex_is_NOT_NULL(void)
+{
+	physical_device d = { .connection = (connection[]){ { .mutex = (pthread_mutex_t *)"NOT NULL" } } };
+
+	mypthread_mutex_lock_ExpectAndReturn(d.connection->mutex, 0);
+
+	utl_lock_mutex_if_required(&d);
+}
+
+void test_utl_unlock_mutex_if_required_mutex_is_NULL(void)
+{
+	physical_device d = { .connection = (connection[]){ {
+				      0,
+			      } } };
+
+	utl_unlock_mutex_if_required(&d);
+}
+
+void test_utl_unlock_mutex_if_required_mutex_is_NOT_NULL(void)
+{
+	physical_device d = { .connection = (connection[]){ { .mutex = (pthread_mutex_t *)"NOT NULL" } } };
+
+	mypthread_mutex_unlock_ExpectAndReturn(d.connection->mutex, 0);
+
+	utl_unlock_mutex_if_required(&d);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_utils_2.c src/test/test_utils_2.c
--- orig/test/test_utils_2.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_utils_2.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,291 @@
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "utils.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_utils_2.h"
+
+#include "mock_converters.h"
+
+void test_append_obj_name_should_append_json_name(void)
+{
+    char *data = "";
+    char device_name[64] = { 0 };
+    char *expected_data = "\"object_name\":";
+
+    mysnprintf_ExpectAnyArgsAndReturn(1);
+    mysnprintf_ReturnMemThruPtr_str(expected_data, sizeof(expected_data));
+
+    utl_append_to_str_ExpectAnyArgs();
+    utl_append_to_str_ReturnThruPtr_source(&expected_data);
+
+    utl_append_obj_name(&data, device_name);
+
+    TEST_ASSERT_EQUAL_STRING(data, "\"object_name\":");
+}
+
+void test_append_obj_name_should_append_data(void)
+{
+    char *data = "";
+    char *expected_data = ",";
+
+    utl_append_to_str_ExpectAnyArgs();
+    utl_append_to_str_ReturnThruPtr_source(&expected_data);
+    utl_append_if_needed(&data, 1, 0, ",");
+
+    TEST_ASSERT_EQUAL_STRING(data, ",");
+}
+
+void test_append_obj_name_should_not_append_data(void)
+{
+    char *data = "";
+
+    utl_append_if_needed(&data, 1, 1, ",");
+
+    TEST_ASSERT_EQUAL_STRING(data, "");
+}
+
+void test_utl_debug_print_do_nothing_if_master_is_null(void)
+{
+    _log_ExpectAnyArgs();
+    utl_debug_master(NULL);
+}
+
+void test_utl_print_debug_physical_devices_without_connection(void)
+{
+    physical_device **ptr1 = (physical_device *[]){
+	    (physical_device[]){
+		    { .id = 4, .name = "device_one", .invocation_counter = "101.25.25.25.0.255" },
+	    },
+	    (physical_device[]){
+		    { .id = 5, .name = "device_two", .invocation_counter = "102.26.26.25.0.255" },
+	    }
+    };
+
+    master master = { .physical_dev_count = 2, .physical_devices = ptr1 };
+
+    utl_debug_master(&master);
+}
+
+void test_utl_print_debug_physical_devices_with_tcp_connection(void)
+{
+    physical_device **dev = (physical_device *[]){
+	    (physical_device[]){
+		    {
+			    .id			= 4,
+			    .name		= "device_one",
+			    .invocation_counter = "101.25.25.25.0.255",
+		    },
+	    },
+	    (physical_device[]){
+		    {
+			    .id			= 5,
+			    .name		= "device_two",
+			    .invocation_counter = "102.26.26.25.0.255",
+			    .connection =
+				    (connection[]){
+					    { .id		   = 5,
+					      .type		   = TCP,
+					      .parameters.tcp.host = "0.0.0.0",
+					      .parameters.tcp.port = 42168,
+					      .socket		   = 7,
+					      .wait_time	   = 99 },
+				    },
+		    },
+	    },
+    };
+
+    master master = { .physical_dev_count = 2, .physical_devices = dev };
+
+    utl_debug_master(&master);
+}
+
+void test_utl_print_debug_physical_devices_with_serial_connection(void)
+{
+    physical_device **dev = (physical_device *[]){
+	    (physical_device[]){
+		    {
+			    .id			= 4,
+			    .name		= "device_one",
+			    .invocation_counter = "101.25.25.25.0.255",
+		    },
+	    },
+	    (physical_device[]){
+		    {
+			    .id			= 5,
+			    .name		= "device_two",
+			    .invocation_counter = "102.26.26.25.0.255",
+			    .connection =
+				    (connection[]){
+					    { .id			= 4,
+					      .type			= SERIAL,
+					      .parameters.serial.device = "/dev/rs485",
+					      .parameters.serial.parity = "None",
+					      .socket			= 7,
+					      .wait_time		= 99 },
+				    },
+		    },
+	    },
+    };
+
+    master master = { .physical_dev_count = 2, .physical_devices = dev };
+
+    utl_debug_master(&master);
+}
+
+void test_utl_print_debug_physical_devices_with_serial_without__stty_settings(void)
+{
+    physical_device **dev = (physical_device *[]){
+	    (physical_device[]){
+		    {
+			    .id			= 4,
+			    .invocation_counter = "101.25.25.25.0.255",
+		    },
+	    },
+	    (physical_device[]){
+		    {
+			    .id			= 5,
+			    .invocation_counter = "102.26.26.25.0.255",
+			    .connection =
+				    (connection[]){
+					    { .id			= 4,
+					      .type			= SERIAL,
+					      .socket			= 7,
+					      .wait_time		= 99 },
+				    },
+		    },
+	    },
+    };
+
+    master master = { .physical_dev_count = 2, .physical_devices = dev };
+
+    utl_debug_master(&master);
+}
+
+void test_utl_print_debug_cosem_groups(void)
+{
+    physical_device **dev = (physical_device *[]){
+	    (physical_device[]){
+		    { .id = 4, .name = "device_one" },
+	    },
+    };
+
+    cosem_object **ptr1 = (cosem_object *[]){
+	    (cosem_object[]){
+		    { .id = 88, .name = "object_one", .entries = 0 },
+	    },
+	    (cosem_object[]){
+		    {
+			    .id		  = 89,
+			    .name	  = "object_two",
+			    .entries	  = 15,
+			    .device_count = 1,
+			    .devices	  = dev,
+			    .object =
+				    (gxObject[]){
+					    { .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+				    },
+		    },
+	    },
+    };
+
+    cosem_group group[] = {
+	    [0] = { .id			= 3,
+		    .name		= "group_one",
+		    .interval		= 4,
+		    .cosem_object_count = 2,
+		    .cosem_objects	= ptr1 },
+	    [1] = { .id			= 7,
+		    .name		= "group_two",
+		    .interval		= 8,
+		    .cosem_object_count = 2,
+		    .cosem_objects	= ptr1 },
+    };
+
+    cosem_group **ptr2 = (cosem_group *[]){
+	    (cosem_group[]){
+		    { .id		  = 3,
+		      .name		  = "group_one",
+		      .interval		  = 4,
+		      .cosem_object_count = 2,
+		      .cosem_objects	  = ptr1 },
+	    },
+	    (cosem_group[]){
+		    { .id		  = 7,
+		      .name		  = "group_two",
+		      .interval		  = 8,
+		      .cosem_object_count = 2,
+		      .cosem_objects	  = ptr1 },
+	    },
+    };
+
+    master master = { .cosem_group_count = 2, .cosem_groups = ptr2 };
+    obj_typeToString2_ExpectAndReturn(ptr1[1]->object->objectType, "Profile Generic");
+    obj_typeToString2_ExpectAndReturn(ptr1[1]->object->objectType, "Profile Generic");
+    utl_debug_master(&master);
+}
+
+void test_utl_print_debug_cosem_groups_without_name(void)
+{
+    physical_device **dev = (physical_device *[]){
+	    (physical_device[]){
+		    { .id = 4 },
+	    },
+    };
+
+    cosem_object **ptr1 = (cosem_object *[]){
+	    (cosem_object[]){
+		    { .id = 88, .entries = 0 },
+	    },
+	    (cosem_object[]){
+		    {
+			    .id		  = 89,
+			    .entries	  = 15,
+			    .device_count = 1,
+			    .devices	  = dev,
+			    .object =
+				    (gxObject[]){
+					    { .objectType = DLMS_OBJECT_TYPE_PROFILE_GENERIC },
+				    },
+		    },
+	    },
+    };
+
+    cosem_group group[] = {
+	    [0] = { .id			= 3,
+		    .interval		= 4,
+		    .cosem_object_count = 2,
+		    .cosem_objects	= ptr1 },
+	    [1] = { .id			= 7,
+		    .interval		= 8,
+		    .cosem_object_count = 2,
+		    .cosem_objects	= ptr1 },
+    };
+
+    cosem_group **ptr2 = (cosem_group *[]){
+	    (cosem_group[]){
+		    { .id		  = 3,
+		      .interval		  = 4,
+		      .cosem_object_count = 2,
+		      .cosem_objects	  = ptr1 },
+	    },
+	    (cosem_group[]){
+		    { .id		  = 7,
+		      .interval		  = 8,
+		      .cosem_object_count = 2,
+		      .cosem_objects	  = ptr1 },
+	    },
+    };
+
+    master master = { .cosem_group_count = 2, .cosem_groups = ptr2 };
+    obj_typeToString2_ExpectAndReturn(ptr1[1]->object->objectType, "Profile Generic");
+    obj_typeToString2_ExpectAndReturn(ptr1[1]->object->objectType, "Profile Generic");
+    utl_debug_master(&master);
+}
+
+#endif
diff --recursive --unified --new-file --no-dereference orig/test/test_utils_3.c src/test/test_utils_3.c
--- orig/test/test_utils_3.c	1970-01-01 00:00:00.000000000 +0000
+++ src/test/test_utils_3.c	2024-01-10 07:48:57.000000000 +0000
@@ -0,0 +1,40 @@
+
+#ifndef TEST
+#define TEST
+#endif
+#ifdef TEST
+
+#include "unity.h"
+#include "utils.h"
+#include "mock_tlt_logger.h"
+
+#include "mock_stub_external.h"
+#include "mock_stub_utils_3.h"
+
+#include "mock_converters.h"
+
+#undef strlen
+
+void test_utl_add_error_message(void)
+{
+	char *data = "";
+	char str[256] = { 0 };
+
+	char *expected_str = "\"device_one\":";
+	utl_append_obj_name_Expect(&data, "device_one");
+	utl_append_obj_name_ReturnMemThruPtr_data(&expected_str, sizeof(expected_str));
+
+        expected_str = "{\"error\": 4, \"result\": \"Connection error\"}";
+	mysnprintf_ExpectAndReturn(str, sizeof(str), "{\"error\": %d, \"result\": \"%s\"}", 5);
+	mysnprintf_ReturnMemThruPtr_str(expected_str, strlen(expected_str));
+
+	utl_append_to_str_Expect(&data, expected_str);
+        expected_str = "\"device_one\": {\"error\": 4, \"result\": \"Connection error\"}";
+	utl_append_to_str_ReturnThruPtr_destination(&expected_str);
+
+	utl_add_error_message(&data, "device_one", "Connection error", 4);
+
+        TEST_ASSERT_EQUAL_STRING(data, "\"device_one\": {\"error\": 4, \"result\": \"Connection error\"}");
+}
+
+#endif
