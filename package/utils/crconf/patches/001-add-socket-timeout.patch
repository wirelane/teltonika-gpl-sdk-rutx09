--- a/lib/libnetlink.c	2025-08-26 11:46:59.865796460 +0300
+++ b/lib/libnetlink.c	2025-08-26 11:39:35.063180743 +0300
@@ -33,6 +33,8 @@
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
 #endif
 
+#define NL_MAX_RETRIES 3
+
 int rcvbuf = 1024 * 1024;
 
 #ifdef HAVE_LIBMNL
@@ -138,6 +140,7 @@
 		      int protocol)
 {
 	socklen_t addr_len;
+	struct timeval timeout = { .tv_sec = 1, .tv_usec = 0 };
 	int sndbuf = 32768;
 	int one = 1;
 
@@ -162,6 +165,11 @@
 		return -1;
 	}
 
+	if (setsockopt(rth->fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
+		perror("SO_RCVTIMEO");
+		return -1;
+	}
+
 	/* Older kernels may no support extended ACK reporting */
 	setsockopt(rth->fd, SOL_NETLINK, NETLINK_EXT_ACK,
 		   &one, sizeof(one));
@@ -410,9 +418,20 @@
 static int __rtnl_recvmsg(int fd, struct msghdr *msg, int flags)
 {
 	int len;
+	int cnt = 0;
 
 	do {
 		len = recvmsg(fd, msg, flags);
+
+		if (errno == EAGAIN) {
+			cnt++;
+
+			if (cnt >= NL_MAX_RETRIES) {
+				fprintf(stderr, "netlink receive error %s (%d)\n",
+					strerror(errno), errno);
+				return -errno;
+			}
+		}
 	} while (len < 0 && (errno == EINTR || errno == EAGAIN));
 
 	if (len < 0) {
