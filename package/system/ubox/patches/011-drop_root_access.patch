--- a/log/logdb.c
+++ b/log/logdb.c
@@ -509,6 +509,7 @@ sqlite3_stmt *db_prepare(char *query)
 
 int init_db(void)
 {
+	fprintf(stdout, "Initializing database...\n");
 	if (sqlite3_open(DB, &conn)) {
 		syslog(LOG_ERR, "Can't open database\n");
 		return SQLITE_ERROR;
--- a/log/syslog.c
+++ b/log/syslog.c
@@ -41,7 +41,7 @@
 #include "syslog.h"
 
 #define LOG_DEFAULT_SIZE	(16 * 1024)
-#define LOG_DEFAULT_SOCKET	"/dev/log"
+#define LOG_DEFAULT_SOCKET	"/var/run/logd/log"
 #define SYSLOG_PADDING		16
 
 #define KLOG_DEFAULT_PROC	"/proc/kmsg"
--- a/log/logd.c
+++ b/log/logd.c
@@ -501,7 +501,6 @@ static void
 ubus_connect_handler(struct ubus_context *ctx)
 {
 	int ret;
-
 	ret = ubus_add_object(ctx, &log_object);
 	if (ret) {
 		fprintf(stderr, "Failed to add object: %s\n", ubus_strerror(ret));
@@ -514,7 +513,6 @@ int
 main(int argc, char **argv)
 {
 	int ch, log_size = 16;
-	struct passwd *p = NULL;
 
 	signal(SIGPIPE, SIG_IGN);
 	while ((ch = getopt(argc, argv, "S:")) != -1) {
@@ -532,21 +530,7 @@ main(int argc, char **argv)
 	log_init(log_size);
 	conn.cb = ubus_connect_handler;
 	ubus_auto_connect(&conn);
-
-	/*
-	 * Looks like autoconnect feature here is broken on this version of ubox.
-	 * After lost connection it should try to reconnect. It succeeds
-	 * but as `logd` user not `root`. In this case `log` ubus object becomes
-	 * invisible to other processes. This kills logd and forces procd to restart
-	 * it again. Ubus id of object changes but it is still better than having no
-	 * `log` object
-	 */
 	conn.ctx.connection_lost = logd_die;
-	p = getpwnam("logd");
-	if (p) {
-		setuid(p->pw_uid);
-		setgid(p->pw_gid);
-	}
 	uloop_run();
 	log_shutdown();
 	uloop_done();
--- a/log/logread.c
+++ b/log/logread.c
@@ -226,6 +226,7 @@ static void compress_log_file(const char
 		syslog(LOG_ERR, "Failed to open compressed file %s: %s", compressed_file, gzerror(out, NULL));
 		return;
 	}
+	chmod(compressed_file, 0660);
 
 	int in = open(log_file, O_RDONLY);
 	if (in < 0) {
@@ -318,12 +319,13 @@ static int log_notify(struct blob_attr *
 		if (next_index) {
 			close(sender.fd);
 			rotate_log_file(log_file, next_index);
-			sender.fd = open(log_file, O_CREAT | O_WRONLY | O_APPEND, 0600);
+			sender.fd = open(log_file, O_CREAT | O_WRONLY | O_APPEND, 0660);
 		}
 		if (sender.fd < 0) {
 			fprintf(stderr, "failed to open %s: %m\n", log_file);
 			exit(-1);
 		}
+		chmod(log_file, 0660);
 	}
 	p = blobmsg_get_u32(tb[LOG_PRIO]);
 
@@ -511,11 +513,12 @@ static void logread_setup_output(void)
 		uloop_timeout_set(&retry, 1000);
 	} else if (log_file) {
 		log_type = LOG_FILE;
-		sender.fd = open(log_file, O_CREAT | O_WRONLY| O_APPEND, 0600);
+		sender.fd = open(log_file, O_CREAT | O_WRONLY| O_APPEND, 0660);
 		if (sender.fd < 0) {
 			fprintf(stderr, "failed to open %s: %m\n", log_file);
 			exit(-1);
 		}
+		chmod(log_file, 0660);
 	} else {
 		sender.fd = STDOUT_FILENO;
 	}
