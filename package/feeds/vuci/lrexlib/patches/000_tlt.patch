diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/.gitignore src/.gitignore
--- upstream/.gitignore	2021-12-28 20:05:16.000000000 +0000
+++ src/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-*.[oa]
-*~
-*.so.*
-*.so
-*.src.rock
-ChangeLog
-*.zip
-release-notes
-/*.rockspec
-/luarocks
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/ChangeLog.old src/ChangeLog.old
--- upstream/ChangeLog.old	2021-12-28 20:05:16.000000000 +0000
+++ src/ChangeLog.old	1970-01-01 00:00:00.000000000 +0000
@@ -1,845 +0,0 @@
-2010-07-06  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lonig.c: casts to suppress compiler warnings.
-
-2010-07-05  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c: added flags up to PCRE version 8.10.
-
-2010-01-19  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* several files: luaL_typerror renamed to luaL_typeerror (as in Lua 5.2).
-	* common.h: added a macro for handling luaL_typeerror and luaL_typerror.
-
-2009-11-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ltre.c: changes to adapt to TRE 0.8
-	    1) #include <tre/tre.h> (was: <tre/regex.h>).
-	    2) added tre_ prefix to all TRE functions.
-
-2009-11-08  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c: added flags up to PCRE version 8.00.
-
-2008-08-04  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* onig.c: making 'locale' and 'syntax' case sensitive again.
-	* onig_f.c: enclose all flags definitions into #ifdef's.
-
-2008-07-30  Reuben Thomas  <rrt@sc3d.org>
-
-	* Fixes in make files and docs. Testing on Linux.
-
-2008-07-30  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* Place each binding in separate directory:
-	  src/posix, src/pcre, src/tre, src/oniguruma.
-
-2008-07-27  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* Initial binding of Oniguruma library.
-
-2008-06-22  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/luatest.lua: a fix; did not work with 'strict'.
-
-2008-06-14  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h: [API extension; suggested by Reuben Thomas]
-	    all functions receiving string-type regex accept a compiled regex too.
-	    If this is the case, cf and lo arguments are ignored (should be
-	    either supplied as nils or omitted).
-	* algo.h: update version string to "Lrexlib 2.4.0".
-
-2008-05-09  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c: added new flag from PCRE-7.7.
-
-2008-03-28  Shmuel Zeigerman  <shmuz@013net.net>
-	* algo.h, lpcre.h, lposix.h, ltre.h: add two new methods (find and match).
-	* algo.h: rename functions:
-	    checkarg_tfind  --> checkarg_find_method;
-	    generic_tfind   --> generic_find_method;
-	    checkarg_find_f --> checkarg_find_func;
-	    generic_find    --> generic_find_func;
-
-2008-03-25  Shmuel Zeigerman  <shmuz@013net.net>
-	* algo.h (plainfind_func): optimize for speed.
-	* algo.h (plainfind_func): treat empty patterns as valid.
-	* test/common_sets.lua (set_f_plainfind): add tests with empty patterns.
-
-2008-01-12  Shmuel Zeigerman  <shmuz@013net.net>
-	* test/luatest.lua: refactoring.
-
-2007-12-27  Shmuel Zeigerman  <shmuz@013net.net>
-	* test/runtest.lua: add new command-line switch -d<directory> that
-	    will prepend <directory> to package.cpath.
-	* Makefile: add -d../src to testing commands, for testing the freshly built
-	    libraries rather than the installed ones.
-
-2007-12-25  Shmuel Zeigerman  <shmuz@013net.net>
-	* test/common_sets.lua, test/spencer_sets.lua, test/pcre_sets.lua,
-	  test/pcre_sets2.lua:
-	    move tests with NULs in subject from common_sets.lua into other set
-	    files.
-
-2007-12-19  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* Makefile: [fix] remove TRE-related parts (reported by Christian Wiese).
-	* Makefile: separate PCRE and POSIX targets (suggested by Hisham Muhammad).
-	* src/common.mak: express "ld" and "-shared" via variables (suggested by
-	    Hisham Muhammad).
-	* src/algo.h: update version string to "Lrexlib 2.2.2".
-
-2007-11-09  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* 4 source files: refactoring (ALG_GETCFLAGS redefined).
-
-2007-10-25  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h: version string updated to "Lrexlib 2.2.1".
-
-2007-09-25  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c: added new flags from PCRE-7.4.
-
-2007-09-20  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h (generic_tfind): bugfix.
-
-	* common_sets.lua (set_m_exec): one test added.
-
-2007-08-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c: added new flags from PCRE-7.3.
-
-2007-06-10  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* makefiles for Windows/MinGW:
-	    * .a files are not needed anymore
-	    * added test and install targets
-
-2007-06-08  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo_t.h: file removed; its contents moved to common.h.
-
-2007-05-03  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (settables): removed API function.
-
-2007-05-02  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo_t.h: new file added, for making struct definitions visible to
-	    the file parts lying above the line #include algo.h.
-
-	* lpcre.c: [API extension]: cflags may be specified by a string.
-
-2007-04-30  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (REX_OPENLIB, OPTLOCALE, compile_regex): bugfix: "tables"
-	    userdata could be garbage-collected before the "regex" userdata
-	    that was using it.
-
-	* lpcre_f.c: added a new flag from PCRE-7.1.
-
-2007-04-21  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/luatest.lua (eq): no more relying on tostring producing unique
-	    strings for different tables.
-
-2007-04-20  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ltre.c (get_int_field, set_int_field): moved to common.c.
-
-2007-04-19  Reuben Thomas  <rrt@sc3d.org>
-
-	* Add build system support for TRE on POSIX systems.
-
-2007-04-18  Reuben Thomas  <rrt@sc3d.org>
-
-	* lpcre.c, lposix.c, ltre.c, algo.h:  Fix some compiler warnings.
-
-2007-04-17  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* <all source files>: the metatable for regex userdata is the C-functions
-	    environment (not kept in the lua_State registry anymore).
-	* lpcre.c: the metatable for 'pcre_tables' userdata is kept at index 1
-	    of the C-functions environment.
-
-2007-04-14  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.h (maketables): new API function (PCRE only).
-
-2007-04-13  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h (gmatch_iter, split_iter): bugfix: was improper detection
-	    of a "no advance" situation.
-	* algo.h (split_iter): bugfix: if the subject ends with a separator,
-	    there must be an additional pass giving an empty section.
-	* test/common_sets.lua: test results adjusted for bugfix in 'split'.
-	* test/pcre_sets.lua: gmatch tests added (testing "retry" feature).
-
-2007-04-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h, lpcre.c (USE_RETRY): new macro. Changed gsub and gmatch
-	    behavior under PCRE when a "no advance" situation occurs.
-	* test/pcre_sets2.lua: test results adjusted for the change in gsub
-	    behavior.
-
-2007-04-11  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (settables): new API function (PCRE only).
-	* test/pcre_sets.lua: locale tests added.
-
-2007-03-19  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h, lpcre.c, lposix.c, ltre.c: improved userdata check
-	    (detects bad userdata error prior to calling methods;
-	    prevents crashes).
-
-2007-03-10  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h: many functions added.
-	* lpcre.c, lposix.c, ltre.c: many functions removed.
-
-2007-03-09  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* algo.h: new file added -- to contain the code of common algorithms.
-	    * It is, in fact, a C-file.
-	    * gsub, match, find: functions added
-
-	* lpcre.c, lposix.c, ltre.c (gsub, match, find): functions removed.
-
-2007-03-07  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lposix.c (REX_NSUB_BASE1): macro added, to facilitate building for
-	    Tom Lord's library.
-
-2007-03-06  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lposix.c, ltre.c (gmatch, split, gsub): bugfixes:
-	    incorrect processing of patterns anchored at the beginning.
-	    Was cured that way:  if (offset > 0) eflags |= REG_NOTBOL;
-
-	* test/common_sets.lua: test cases added.
-
-2007-03-05  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (gsub): bugfix:
-	    Test: { {"abcd", "\\b", "%1"}, {"abcd", 2, 2} }.
-
-	* test/pcre_sets2.lua: a test case added.
-
-2007-03-03  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c, ltre.c (gsub): [API change]:
-	    gsub returns 3 values; the 3-rd is number of replacements made.
-
-	* test/*.lua: corrected tests for gsub (after API change).
-
-2007-03-02  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/common_sets.lua: added new tests for gsub (after API change).
-
-2007-03-01  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c, ltre.c (gsub): [API change]:
-	    a) 2-nd return of rep() is ignored --> API-compatible with string.gsub
-	    b) argument `n' can be a function --> API extension wrt string.gsub
-
-	* common.h (REX_VERSION): updated to "2.2.0 beta".
-
-2007-02-23  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lpcre_f.c:
-	    * added #ifdef's to do named subpatterns only if PCRE_MAJOR >= 4,
-	      otherwise it wouldn't compile for PCRE 3.x [bugreport by Zhao Zhiguo].
-	    * same #ifdef for Lpcre_config function.
-
-2007-02-20  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ltre.c (aexec, atfind, have_backrefs, have_approx): new methods.
-	    aexec          -->  exec  + approximate matching;
-	    atfind         -->  tfind + approximate matching;
-	    have_backrefs  -->  binding of tre_have_backrefs;
-	    have_approx    -->  binding of tre_have_approx;
-
-2007-02-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ltre.c: all uses of regexec replaced by regnexec.
-	* test/common_sets.lua: added tests with nuls in the subject.
-
-2007-02-17  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ltre.c: new file added (started the binding of the TRE regex library).
-	* test/posix_sets.lua: added tests with nuls in the subject or/and
-	    the pattern.
-
-2007-02-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* all sources (match, find, tfind, exec, dfa_exec): [API change]
-	    in case of ordinary non-match, only a nil is returned;
-	    other non-match cases generate an error.
-
-	* test suite and the manual: updated to reflect the above API change.
-
-	* all sources (gmatch, split, gsub): [bugfix]
-	    if during repeated matching pcre_exec/regexec returns a value that
-	    means neither match nor no-match, then an error is generated.
-
-	* common.h (REX_VERSION): updated to "2.1.0".
-
-2007-01-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lposix.c (checkarg_find_f): [bugfix] incorrect default for eflags.
-	* lposix.c (generic_find): [bugfix] dereferencing uninitialized pointer.
-	* common.h (REX_VERSION): updated to "2.0.2".
-
-2007-01-27  Reuben Thomas  <rrt@sc3d.org>
-
-	* lpcre.c, lposix.c (gsub): [bugfix]
-	    - it was incorrectly assumed that the value on Lua stack was a string;
-	    - luaL_error was used where lua_error was more appropriate;
-
-2007-01-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (gsub): [API change undone].
-	* all source files: refactoring.
-
-2007-01-14  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (gsub): [API change]:
-	    a) 2-nd return of rep() is ignored --> API-compatible with string.gsub
-	    b) argument `n' can be a function --> API extension wrt string.gsub
-
-2007-01-13  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: refactoring.
-	* common.c, common.h: refactoring.
-	* common.h (REX_VERSION): a new #define.
-	* lpcre.c, lposix.c (REX_OPENLIB): using REX_VERSION.
-
-2007-01-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.h, common.c: a nasty bug fixed.
-	* lpcre.c, lposix.c: version updated to 2.0.1.
-
-2007-01-10  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: refactoring.
-
-2007-01-08  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: refactoring.
-
-2007-01-04  Reuben Thomas  <rrt@sc3d.org>
-
-	* Add a top-level Makefile with all, clean and test targets.
-	* Split src/*.mak common parts into src/common.mak.
-
-2007-01-04  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (Lpcre_gsub): unnecessary (though harmless) assignment removed.
-	* test/runtest.lua: extended the command-line interface.
-	* most files: the copyright notice changed to reference LICENSE file.
-
-2007-01-02  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c (CheckFunction, OptFunction): functions removed.
-	* lpcre.c (put_integer): function removed.
-
-2006-12-31  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c (udata_tostring): function removed.
-	* lpcre.c (Lpcre_tostring): added handling of deleted userdatum.
-	* lposix.c (Posix_tostring): added handling of deleted userdatum.
-	* lpcre.c: [API change] method `exec' now supports "named subpatterns".
-	* test/all_test.lua: renamed to runtest.lua.
-
-2006-12-30  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c: [API change] `versionPCRE' renamed to `version'.
-
-2006-12-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c: [API change] removed support of PCRE callout.
-	* test/pcre_sets.lua: removed testing of PCRE callout.
-
-2006-12-27  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre_f.c (config): [API change] the function accepts one optional
-	    argument (a table), like the `flags' function.
-
-2006-12-26  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c (gsub): [API change] method become function.
-	* test/*.lua: modifying tests to reflect methods become functions.
-	* lua/rex.lua: file deleted.
-	* lpcre.c (luaopen_rex_pcre): changed the condition for validating
-	    run-time PCRE version.
-	* lpcre_f.c: added new flags for support of PCRE 7.0.
-	* lpcre.c, lposix.c (checkarg_gsub): if the 3-rd argument is of type
-	    "number" then it is converted to string (as in string.gsub).
-
-2006-12-25  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c (match, find, gmatch, split): [API change]
-	    methods become functions.
-
-2006-12-23  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: refactoring.
-
-2006-12-22  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c (tfind and exec): [API change]
-	    the return value of the underlying pcre_exec/regexec call
-	    is not added in the case of successfull match.
-	* lpcre.c, lposix.c (gtfind): [API change] method removed.
-	* lpcre.c, lposix.c: Lrexlib 2.0 beta -> Lrexlib 2.0.
-	* test/luatest.lua (eq): bugfix.
-	* lua/*.lua: deleted all lua files except for rex.lua.
-	* lua/rex.lua: fully rewritten; now contains wrappers for all methods.
-
-2006-12-21  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: added tests for `split' method.
-	* test/luatest.lua (print_results): function added.
-	* test/common_sets.lua: file added.
-
-2006-12-19  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.lua:  `split' method added.
-	* lposix.lua: `split' method added.
-	* test/framework.lua: renamed to luatest.lua.
-
-2006-12-15  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: refactoring.
-
-2006-12-11  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: refactoring; deleting files; adding new files.
-
-2006-12-10  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: gmatch bug fixed. Test case added.
-	* lpcre.c, lposix.c: gtfind bug fixed. Test case added.
-
-2006-12-09  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lua/gsub_test.lua, gsub_tstpsx.lua: 2 files deleted.
-	* lua/posix_sets.lua, pcre_sets.lua, framework.lua, all_test.lua:
-	    4 files added.
-	* lpcre.c, lposix.c, common.c, common.h:
-	    an API alteration in gsub and gtfind methods: if a non-positive number
-	    is supplied as the 'n' parameter, then no iterations are done.
-	    Test cases added to *.lua test files.
-
-2006-12-07  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c (gsub): if parameter rep is a function,
-	    and its 2-nd return value (if present) is a string "break",
-	    then gsub immediately returns.
-	* test/*.lua: refactoring.
-
-2006-12-06  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: refactoring.
-
-2006-12-05  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lposix.c: cosmetics.
-
-2006-12-04  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: introduced new macros: CAP_BEG, CAP_END and CAP_LEN.
-	* lpcre.c, lpcre_f.c, lposix.c: refactoring.
-
-2006-12-03  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (Lpcre_gsub_func): an improvement.
-	* lposix.c (posix_gsub_func): an improvement.
-	* lpcre.c, lposix.c (gmatch, match, find): functions removed.
-	* lpcre.c, lposix.c: method tgfind renamed to gtfind.
-	* lpcre.c, lposix.c: gsub function become method.
-	* test/posix_test.lua, pcre_test.lua: removed tests for removed functions.
-
-2006-12-02  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c, common.h (TBuffer): moved here from lpcre.c.
-	* common.c, common.h (TFreeList): helper class created.
-	* lpcre.c (Lpcre_gsub_func): many changes.
-	* lposix.c (posix_gsub_func): added function gsub.
-	* test/gsub_test.lua: added testing for the new written-in-C gsub.
-	* test/gsub_tstpsx.lua: file added.
-	* test/rex_.lua: file deleted.
-
-2006-12-01  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (TBuffer): helper class created.
-	* lpcre.c (Lpcre_gsub_func): many changes.
-
-2006-11-30  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (TExecData): struct renamed to TCallout.
-	* lpcre.c (LpcreSetExecData): function renamed to SetupCallout.
-	* lpcre.c (Lpcre_gsub_func): added function gsub.
-
-2006-11-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: refactoring.
-	* lpcre.c, lposix.c: refactoring.
-	* lpcre.c, lposix.c (oldmatch): renamed to tfind.
-	* lpcre.c, lposix.c (oldgmatch): renamed to tgfind.
-	* */*.lua: renamed: oldmatch -> tfind; oldgmatch -> tgfind.
-
-2006-11-28  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (Lpcre_dfa_exec): one Lmalloc call instead of two.
-
-2006-11-27  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c (plainfind_func): rewritten to not use memicmp
-	* test/*.lua: every test returns number of failures
-
-2006-11-26  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: all Check_arg_* functions renamed to Checkarg_*
-	* lpcre.c (Lpcre_dfa_exec): added 2 arguments to dfa_exec
-	* common.h (DIM): macro removed
-	* test/pcre_test.lua: tests for dfa_exec method added
-
-2006-11-25  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: alpha -> beta.
-	* lpcre_f.c: file added (was: part of lpcre.c).
-	* rex_pcre.mak: updated due to the new file lpcre_f.c
-	* *.mak: version updated to 2.0
-	* test/all_test.lua: file added.
-	* test/posix_test.lua, test/pcre_test.lua: made modules.
-	* test/posix_test.lua: tests added.
-	* test/*.lua: refactoring.
-	* lua/generic_gsub.lua: refactoring.
-
-2006-11-23  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/*.lua: refactoring.
-	* lua/rex.lua, lua/rex_.lua (gsub): 6th and 7th arguments swapped.
-
-2006-11-22  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (Check_arg_findmatch_func): 5th and 6th arguments swapped.
-	* lpcre.c (Check_arg_gmatch_func): 4th and 5th arguments swapped.
-	* test/posix_test.lua: file added.
-	* lposix.c: 2 bugs fixed.
-
-2006-11-21  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* test/pcre_test.lua: "named subpatterns" tests added.
-
-2006-11-20  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c, common.h (plainfind_func): function added.
-	* lpcre.c, lposix.c (rex.plainfind): new function (from Lua side).
-	* test/framework.lua: file added.
-	* test/pcre_test.lua: file added.
-
-2006-11-19  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (Lpcre_config): new function (pcre.config from Lua side).
-	* lpcre.c: callout handling improved.
-
-2006-11-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: old 'gmatch' method put back; renamed into 'oldgmatch'.
-
-2006-11-17  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* windows/bcc32/make_bcc.mak: deleted -DCOMPAT51, added -D$(CMDLINE)
-
-2006-11-16  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* gsub_test.lua (PatternLua2Pcre): function renamed into 'pat2pcre'.
-	* lua/pat2pcre.lua: file added (was part of gsub_test.lua).
-
-2006-11-15  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c, lposix.c: Lua API has changed:
-	    * 'match' method renamed to 'oldmatch'
-	    * added (as much as possible) Lua string library API compatible:
-	      'find', 'match' and 'gmatch' - each one being a function/method pair.
-	* lpcre.c (newPCRE, flagsPCRE): functions removed.
-	* lposix.c (newPOSIX, flagsPOSIX): functions removed.
-	* lpcre.c, lposix.c: added literal rex._VERSION.
-	* rex.lua: deleted everything except gsub.
-	* rex.lua (gsub): rex.oldmatch is used instead of rex.match.
-	* generic_gsub.lua: rex.oldmatch is used instead of rex.match.
-	* test/test1.lua: file added
-
-2006-11-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* rex.lua (r:gmatch): metamethod added.
-	* lpcre.c (Lpcre_maketables): function API simplified.
-	* lpcre.c (Lpcre_getargs): function removed.
-	* lpcre.c (LpcreGetExecParams): renamed from LpcreProcessExecParams.
-
-2006-11-09  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lua/bit.lua: file removed.
-
-2006-11-05  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* rex.lua (gsub): a few structural optimizations.
-	* rex.lua (gmatch): a bugfix.
-	* rex.lua: tests deleted from the file.
-	* gsub.lua: renamed into 'generic_gsub.lua'; made a module.
-	* new_gsub.lua: file deleted.
-	* lua/bit.lua: file added.
-
-2006-11-04  Reuben Thomas  <rrt@sc3d.org>
-
-	* rex.lua (gmatch): function rewritten to be compatible with
-	    string.gmatch.
-	* find.lua: file deleted.
-	* lpcre.c (Lpcre_gmatch): function deleted.
-	* lposix.c (posix_gmatch): function deleted.
-
-2006-11-04  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* gsub.lua, new_gsub.lua, gsub_test.lua, rex.lua: bugfixes.
-
-2006-10-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* [Windows] DLL builds need lua5.1.dll rather than lua51.dll.
-
-2006-10-02  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* Support of Lua 5.0 was dropped.
-
-2006-09-03  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.h (REX_LIB_API): renamed into REX_API.
-	* common.h (flags_pair): renamed into flag_pair.
-	* common.h, lpcre.h, lposix.h (REX_REGISTER): renamed into rex_register.
-	* lpcre.h (luaopen_rex_pcre): error message text changed.
-	* lposix.c (posix_handle, posix_typename):
-	    string literals are prefixed by $(REX_LIBNAME).
-	    [ This makes possible using multiple rex_posix libraries
-	      at a time by one lua_State. ]
-	* lpcre.c (pcre_handle, pcre_typename):
-	    string literals are prefixed by $(REX_LIBNAME).
-	    [ This makes possible using multiple rex_pcre libraries
-	      at a time by one lua_State. ]
-	* added directory test/Spencer (containing test.lua).
-	* test/Spencer/test.lua: file returns a function.
-
-2006-08-27  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* (local) merge with the version put into CVS by R.Thomas.
-	* common.h: added conditional #define's for lua_pushinteger and
-	    lua_tointeger (needed to compile with Lua 5.0).
-
-2006-08-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c, lpcre.c, lposix.c: lua_pushnumber replaced with
-	    lua_pushinteger where appropriate (in many places).
-	* lpcre.c (put_number): function renamed into put_integer.
-
-2006-06-17  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lpcre.c (TPcreExecParam): `use_callout' struct member was eliminated.
-	    Instead, a special value of function reference (LUA_NOREF) is used.
-
-2006-04-01  Reuben Thomas  <rrt@sc3d.org>
-
-	* lpcre.c, common.c: Remove trailing whitespace.
-	* lpcre.c (Lpcre_gmatch): Remove unnecessary limit variable.
-
-2006-02-17  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c, common.h (L_lua_error): function deleted.
-	* common.c, lpcre.c, lposix.c: luaL_error used in place of L_lua_error.
-	* lposix.c (posix2): struct renamed into TPosix.
-	* lposix.c (posix_comp): lua_newuserdata() used instead of Lmalloc().
-
-2005-12-26  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* Separate makefiles for POSIX and PCRE. No config file.
-
-2005-11-28  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.h (REXLIB_API): macro renamed into REX_LIB_API.
-	* lposix.c (LREXLIB_POSIX_EXT): macro renamed into REX_POSIX_EXT.
-
-2005-11-26  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.h (LUAL_REGISTER): macro renamed into REX_REGISTER.
-	* lpcre.c (LUAOPEN_LIB): macro renamed into REX_OPENLIB.
-	* lpcre.c (LIBNAME): macro renamed into REX_LIBNAME.
-
-2005-11-15  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* common.c, common.h, lposix.c, lpcre.c: new files (lrexlib.c was
-		  splitted); POSIX and PCRE parts now live in their own
-		  separate files.
-	* common.h (REXLIB_API): new macro.
-	* lposix.c (LREXLIB_POSIX): macro removed.
-	* lposix.c (LUAOPEN_LIB, LIBNAME): new macros.
-	* lposix.c (rexlib): Lua-side functions flagsPOSIX and newPOSIX
-		  now have aliases (flags and new, correspondently).
-	* lpcre.c (LREXLIB_PCRE): macro removed.
-	* lpcre.c (LUAOPEN_LIB, LIBNAME): new macros.
-	* lpcre.c (rexlib): Lua-side functions flagsPCRE and newPCRE now
-		  have aliases (flags and new, correspondently).
-	* lpcre.c (Lpcre_vers): function renamed into Lpcre_version.
-
-2005-11-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (LUAL_REGISTER): new macro.
-
-2005-11-10  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (posix_match_generic): return (on Lua-side) an
-		  additional value (the return code of regexec).
-	* lrexlib.c (Lpcre_match_generic): return (on Lua-side) an
-		  additional value (the return code of pcre_exec).
-	* lrexlib.c (Lpcre_dfa_exec): return (on Lua-side) an additional
-		  value (the return code of pcre_dfa_exec).
-
-2005-10-29  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (get_flags): the function now accepts one parameter
-		  from the Lua stack (a table). Was: no parameters. (This
-		  affects the Lua-side functions: flagsPOSIX and
-		  flagsPCRE).
-	* lrexlib.c (LREXLIB_POSIX_EXT): it's now possible to force-define
-		  this macro at compile time, bypassing the automatic
-		  detection.
-	* lrexlib.c: added new POSIX flags (error values).
-	* lrexlib.c (LpcreProcessParams): renamed into
-		  LpcreProcessExecParams.
-	* lrexlib.c: added all missing PCRE flags starting from PCRE
-		  version 4.
-
-2005-10-25  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (DIM): new macro.
-	* lrexlib.c (pcre2): renamed into TPcre.
-	* lrexlib.c (TPcreExecParam): new struct.
-	* lrexlib.c (LpcreProcessParams): new function.
-	* lrexlib.c (Lpcre_dfa_exec): new function. Lua-side: dfa_exec.
-	* lrexlib.c (Lpcre_dfa_restart): new function. Lua-side: dfa_restart.
-
-2005-10-23  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (TPcreCalloutData): new struct.
-	* lrexlib.c (Lpcre_callout): new function.
-	* lrexlib.c (Lpcre_match_generic): PCRE callout support added.
-	* lrexlib.c: added new PCRE flags (from PCRE versions 5 and 6).
-	* lrexlib.c (put_number): new helper function.
-
-2005-05-27  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c: updated to work with Compat-5.1.
-
-2004-12-18  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (regex_tostring): error handling added.
-	* lrexlib.c (regex_tostring): renamed into udata_tostring.
-	* lrexlib.c (regex_get_flags): renamed into get_flags.
-	* lrexlib.c (Lpcre_comp): pattern offset included in error message.
-	* lrexlib.c (Lpcre_comp): error check added after pcre_study call.
-	* lrexlib.c (Lpcre_push_substrings): eliminated inserting nil
-		  values into the matches table (not a bug, redundancy).
-	* lrexlib.c (Lpcre_push_substrings): lua_rawset call instead of
-		  lua_settable.
-	* lrexlib.c: all stack buffers used for message formatting changed
-		  in size from 128 to 256 bytes.
-
-2004-11-17  Nick Gammon  <nick@gammon.com.au>
-
-	* lrexlib.c (pcre2): new member pcre2.extra.
-	* lrexlib.c (Lpcre_comp): pcre_study call added.
-	* lrexlib.c (Lpcre_push_matches, Lpcre_push_substrings,
-		  Lpcre_push_offsets): function signatures changed.
-	* lrexlib.c (Lpcre_push_substrings): added support for "named
-		  subpatterns".
-
-2004-09-15  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* gsub.lua (is_odd): Function removed; math.mod used instead.
-
-2004-08-24  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* ChangeLog: File added.
-	* NEWS: File added.
-
-2004-08-12  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (posix_exec, Lpcre_exec): New C functions, that
-		  correspond to the new lua function 'r:exec'.
-	* lrexlib.c (posix_tostring, Lpcre_tostring): New C functions,
-		  that correspond to the new lua function 'r:__tostring'.
-	* lrexlib.c: A table returned by r:match() as its 3rd result has
-		  no "n" index set anymore.
-	* lrexlib.c (LREXLIB_POSIX_EXT): New macro.
-	* lrexlib.c (PCRE_LOCALE_SUPPORT): Macro removed.
-	* lrexlib.c (posix_push_matches, Lpcre_push_matches): Functions
-		  became typedef's.
-	* lrexlib.c (posix_match_generic, Lpcre_match_generic)
-		  (posix_push_substrings, Lpcre_push_substrings)
-		  (posix_push_offsets, Lpcre_push_offsets): New functions.
-	* gsub.lua: File added.
-
-2004-08-11  Reuben Thomas  <rrt@sc3d.org>
-
-	* config: Many changes.
-	* Makefile: Many changes.
-
-2004-08-11  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* config: File added + many changes.
-	* Makefile: Many changes.
-
-2004-07-15  Shmuel Zeigerman  <shmuz@013net.net>
-
-	* lrexlib.c (posix_get_flags, Lpcre_get_flags, Lpcre_vers): New C
-		  functions, that correspond to new lua functions
-		  'flagsPOSIX', 'flagsPCRE', 'versionPCRE'.
-	* lrexlib.c: Lua functions 'newPCRE' and 'newPOSIX' accept an
-		  optional 2nd argument ("compilation flags").
-	* lrexlib.c: Lua function 'newPCRE' accepts an optional 3rd
-		  argument ("locale") - but only if the macro
-		  PCRE_LOCALE_SUPPORT was defined at the compilation time.
-	* lrexlib.c: Lua function 'r:match' accepts optional 2nd and 3rd
-		  arguments ("startoffset" and "execution flags").
-	* lrexlib.c: Lua function 'r:gmatch' accepts an optional 2nd
-		  argument ("execution flags").
-	* lrexlib.c (posix_gmatch, Lpcre_gmatch): If a user-defined lua
-		  function passed as the 2nd parameter returns true value,
-		  then lua function 'r:gmatch' returns.
-	* lrexlib.c (posix_push_matches, Lpcre_push_matches): The table of
-		  substring matches contains false in the positions
-		  correspondent to non-matched subpatterns.
-	* lrexlib.c: Static functions that began with 'pcre' were renamed
-		  to begin with 'Lpcre'.
-	* lrexlib.c (posix_getargs, Lpcre_getargs):
-		  Fixed - allocated memory was not freed.
-		  Fixed - removed redundant calls of lua_checkstack.
-	* lrexlib.c: Allocation/freeing memory moved from matching
-		  operations to pattern-compiling and garbage-collecting
-		  ones.
-	* lrexlib.c (posix_match, posix_gmatch, Lpcre_match, Lpcre_gmatch):
-		  luaL_checkudata is used in checking of userdata-type
-		  parameter.
-	* lrexlib.c: Removed conditional compilation controlled by the
-		  macro REG_BASIC.
-	* lrexlib.c (posix_comp): The following invalid ANSI C89 code:
-		  size_t sz = <expression>; char errbuf[sz];
-		  made valid with the use of malloc/free.
-	* lrexlib.c (Lpcre_gmatch): Keeping 'subject' and 'length'
-		  unchanged while updating 'startoffset'.
-	* lbitlib.c: File removed.
-	* Makefile: Removed parts related to lbitlib.c.
-	* make_bcc.mak: File added.
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/Makefile src/Makefile
--- upstream/Makefile	2021-12-28 20:05:16.000000000 +0000
+++ src/Makefile	2025-08-18 08:15:02.086524935 +0000
@@ -1,54 +1,26 @@
-# Makefile for lrexlib
+WFLAGS=-Wall -Wextra -Wno-unused-parameter
+DEFINES=-DREX_NOEMBEDDEDTEST -DPCRE2_CODE_UNIT_WIDTH=8  -D VERSION=\"2.9.1\" 
+INCLUDES=-I$(STAGING_DIR)/usr/include/lua5.1 -I/usr/include/lua5.1 -I$(STAGING_DIR)/usr/include
+LLUA=-llua
 
-VERSION = 2.9.1
-PROJECT = lrexlib
-PROJECT_VERSIONED = $(PROJECT)-$(VERSION)
+LIBNAME=rex_pcre2.so
 
-# Commands
-LUA = lua
-LUAROCKS = luarocks
-CP = cp -a
-RM = rm -f
-RST2HTML = rst2html
-REGNAMES = gnu pcre pcre2 posix oniguruma tre
-LUAROCKS_COMMAND = make
+O_COMPILE=$(CC) $(WFLAGS) -fPIC $(DEFINES) -c -o $@ $(INCLUDES) $(CFLAGS) $<
 
+all: $(LIBNAME)
 
-.SUFFIXES: .txt .html
+lpcre2.o: ./src/pcre2/lpcre2.c
+	$(O_COMPILE)
 
-HTML = doc/index.html doc/manual.html
+lpcre2_f.o: ./src/pcre2/lpcre2_f.c
+	$(O_COMPILE)
 
-.txt.html:
-	$(RST2HTML) --stylesheet-path=doc/lrexlib.css --link-stylesheet --initial-header-level=2 --date --time $< $@
+common.o: ./src/common.c
+	$(O_COMPILE)
 
-build:
-	$(MAKE) install LUAROCKS="$(LUAROCKS) --tree=luarocks"
-
-install: rockspecs
-	for i in *.rockspec; do \
-	  $(LUAROCKS) $(LUAROCKS_COMMAND) $$i; \
-	done
-
-rockspecs:
-	rm -f *.rockspec
-	$(LUA) mkrockspecs.lua $(PROJECT) $(VERSION)
-
-doc/index.txt: README.rst
-	$(CP) $< $@
-
-check: build
-	for i in $(REGNAMES); do \
-	  LUA_PATH="test/?.lua;$(LUA_PATH);" $(LUA) test/runtest.lua -dsrc/$$i $$i; \
-	done
+$(LIBNAME): common.o lpcre2.o lpcre2_f.o
+	$(CC) -Wall $(LLUA) -lpcre2-8  -shared -fPIC $(DEFINES) -o $@ $^ $(INCLUDES)
 
 clean:
-	$(RM) $(HTML) doc/index.txt *.rockspec
-
-release: check
-	agrep -d 'Release' $(VERSION) NEWS | tail -n +3 | head -n -2 > release-notes && \
-	git diff --exit-code && \
-	git tag -a -m "Release tag" rel-`echo $(VERSION) | sed -e 's/\./-/g'` && \
-	git push && git push --tags && \
-	$(MAKE) build LUAROCKS_COMMAND=build && \
-	woger lua package=$(PROJECT) package_name=$(PROJECT) version=$(VERSION) description="Lua binding for regex libraries" notes=release-notes home="`$(LUA) -e'version="'$(VERSION)'"; flavour="none"; t = require "rockspecs"; print(t.default.description.homepage)'`"
-	rm -f release-notes
+	$(RM) ./*.o
+	$(RM) ./*.so
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/NEWS src/NEWS
--- upstream/NEWS	2021-12-28 20:05:16.000000000 +0000
+++ src/NEWS	1970-01-01 00:00:00.000000000 +0000
@@ -1,189 +0,0 @@
-2020-08-07  Release 2.9.1
-
-  * Add Lua 5.4 support
-
-2017-11-07  Release 2.9.0
-
-  * Add PCRE2 support.
-
-2015-02-26  Release 2.8.0
-
-  * Add Lua 5.3 support
-  * No longer return empty matches adjacent to previous non-empty match.
-
-2013-01-08  Release 2.7.2
-
-  * Fixed the use of alternative allocators, and a memory leak.
-  * Simplify the build system further.
-  * Change rockspec to build from git now that github no longer
-    supports downloads.
-
-2012-10-18  Release 2.7.1
-
-  * Fixed Lua 5.1 compatibility, broken in 2.7.0.
-  * Added ability to specify no replacement to gsub with a nil or
-    false replacement argument.
-
-2012-10-04  Release 2.7.0
-
-  * Added support for searching raw memory buffers (e.g. made with
-    alien).
-  * Fixed possible invalid code generation in C (thanks, Michael
-    Tautschnig).
-  * Generate LuaRock rockspecs for all modules.
-  * Greatly simplify UNIX build system, relying on LuaRocks.
-  * Allow POSIX REG_STARTEND to be used on any system supporting it.
-  * Add a test set for POSIX regex engine (thanks, Enrico Tassi).
-  * Simplify some code.
-  * Always use Lua state memory allocator.
-
-2012-04-13  Release 2.6.0
-
-  * Added support for Lua 5.2.
-
-2010-12-15  Release 2.5.3
-
-  * Bug fix to rex.split.
-  * Support for new flags in PCRE 8.11.
-
-2010-11-10  Release 2.5.2
-
-  * Important bug fix (thanks to Enrico Tassi for the report)
-    affecting platforms with certain alignment requirements.
-  * Improved build system for Windows.
-  * Minor improvements to the manual.
-
-2010-10-04  Release 2.5.1
-
-  * Minor improvements and fixes, no changes to library code.
-
-
-2010-10-03  Release 2.5.0
-
-  * Added bindings of the TRE and GNU regex APIs.
-
-  * Improved and simplified the build system.
-
-
-2008-08-04  Release 2.4.0
-
-  * All functions receiving string-type regex accept a compiled regex too.
-
-  * Added binding of the Oniguruma library.
-
-
-2008-05-31  Release 2.3.0
-
-  * Added methods: find and match.
-
-
-2007-12-29  Release 2.2.2
-
-  * Makefiles fixed.
-
-
-2007-10-25  Release 2.2.1
-
-  * Added new PCRE constants up to version 7.4.
-
-  * 1 bugfix.
-
-
-2007-06-19  Release 2.2.0
-
-  * gsub API extension: allow the 4-th argument to be a function.
-
-  * Added functions: maketables (PCRE).
-
-  * Improved algorithm for global searches (PCRE; retry after empty match).
-
-  * cflags may be specified by a string (PCRE).
-
-  * Bugfixes.
-
-
-2007-02-13  Release 2.1.0
-
-  * Improved error handling.
-
-  * A minor change in API.
-
-
-2007-01-30  Release 2.0.2
-
-  * 3 bugfixes.
-
-  * Corrections in the Reference Manual.
-
-
-2007-01-12  Release 2.0.1
-
-  * Bugfix in memory deallocation.
-
-
-2007-01-05  Release 2.0
-
-  * Added functions: match, find, gmatch, gsub, split, config, plainfind.
-
-  * Added methods: dfa_exec.
-
-  * Removed methods: gmatch.
-
-  * Renamed functions:
-      newPCRE, newPOSIX     --> new.
-      flagsPCRE, flagsPOSIX --> flags.
-      versionPCRE           --> version.
-
-  * Renamed methods: match --> tfind.
-
-  * Added test suite.
-
-  * Added reference manual.
-
-
-2004-12-19  Release 1.19
-
-  * Added support for PCRE "named subpatterns" (thanks to Nick Gammon).
-
-  * Several minor improvements.
-
-
-2004-08-25  Release 1.18
-
-  * New lua function 'r:exec'.
-
-  * New lua function 'r:__tostring'.
-
-  * A table returned by r:match() as its 3rd result has no "n" index
-    set anymore. Use table.getn instead.
-
-  * Fixed the bug preventing compilation with the "basic" POSIX
-    regexp library.
-
-  * Makefile improved.
-
-  * Added file gsub.lua containing function 'generic_gsub'.
-
-
-2004-07-16  Release 17
-  
-  * New lua functions 'flagsPOSIX', 'flagsPCRE', 'versionPCRE'.
-  
-  * Lua functions 'newPCRE' and 'newPOSIX' accept an optional
-    2nd argument ("compilation flags").
-  
-  * Lua function 'newPCRE' accepts an optional 3rd argument
-    ("locale").
-  
-  * Lua function 'r:match' accepts optional 2nd and 3rd
-    arguments ("startoffset" and "execution flags").
-  
-  * Lua function 'r:gmatch' accepts an optional 2nd argument
-    ("execution flags").
-  
-  * If a user-defined function passed to r:gmatch() as its
-    2nd parameter returns true value, then r:gmatch() returns.
-  
-  * The table of substring matches contains false in the positions
-    correspondent to non-matched subpatterns.
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/README.rst src/README.rst
--- upstream/README.rst	2021-12-28 20:05:16.000000000 +0000
+++ src/README.rst	1970-01-01 00:00:00.000000000 +0000
@@ -1,56 +0,0 @@
-Lrexlib
-=======
-
-|  by Reuben Thomas (rrt@sc3d.org)
-|  and Shmuel Zeigerman (shmuz@013net.net)
-
-**Lrexlib** provides bindings of five regular expression library APIs
-(POSIX_, PCRE_, PCRE2_, GNU_, TRE_ and Oniguruma_) to Lua_ >= 5.1.
-The bindings for TRE and Oniguruma are not currently complete.
-
-**Lrexlib** is copyright Reuben Thomas 2000-2020 and copyright Shmuel
-Zeigerman 2004-2020, and is released under the same license as Lua,
-the MIT_ license (otherwise known as the revised BSD license). There
-is no warranty.
-
-.. _POSIX: http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html
-.. _PCRE: http://www.pcre.org/pcre.txt
-.. _PCRE2: http://www.pcre.org/pcre2.txt
-.. _GNU: ftp://ftp.gnu.org/old-gnu/regex/
-.. _Oniguruma: https://github.com/kkos/oniguruma
-.. _TRE: http://laurikari.net/tre/documentation/
-.. _Lua: http://www.lua.org
-.. _MIT: http://www.opensource.org/licenses/mit-license.php
-
-Please report bugs and make suggestions to the maintainer, or use the
-LuaForge trackers and mailing lists.
-
-Thanks to Thatcher Ulrich for bug and warning fixes, and to Nick
-Gammon for adding support for PCRE named subpatterns.
-
------------------------------------------------------------
-
-Installation
-------------
-
-Lrexlib is installed with LuaRocks_, using the command::
-
-  luarocks install lrexlib-FLAVOUR
-
-where **FLAVOUR** is one of PCRE, PCRE2, POSIX, oniguruma, TRE, GNU
-
-.. _LuaRocks: http://www.luarocks.org
-
-
-Links
------
-
-- License_
-- `Reference Manual`_
-- `LuaForge Project Page`_
-- Download_
-
-.. _License: http://rrthomas.github.io/lrexlib/license.html
-.. _Reference Manual: http://rrthomas.github.io/lrexlib/manual.html
-.. _LuaForge Project Page: http://luaforge.net/projects/lrexlib/
-.. _Download: https://github.com/rrthomas/lrexlib/downloads
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/.gitignore src/doc/.gitignore
--- upstream/doc/.gitignore	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/.gitignore	1970-01-01 00:00:00.000000000 +0000
@@ -1,3 +0,0 @@
-index.txt
-index.html
-manual.html
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/SciTE.properties src/doc/SciTE.properties
--- upstream/doc/SciTE.properties	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/SciTE.properties	1970-01-01 00:00:00.000000000 +0000
@@ -1,4 +0,0 @@
-eol.mode=LF
-
-command.compile.*.txt=make -B $(FileName).html
-command.build.*.txt=make
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/html4css1.css src/doc/html4css1.css
--- upstream/doc/html4css1.css	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/html4css1.css	1970-01-01 00:00:00.000000000 +0000
@@ -1,279 +0,0 @@
-/*
-:Author: David Goodger
-:Contact: goodger@users.sourceforge.net
-:Date: $Date: 2006/01/21 03:17:49 $
-:Revision: $Revision: 1.1 $
-:Copyright: This stylesheet has been placed in the public domain.
-
-Default cascading style sheet for the HTML output of Docutils.
-
-See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
-customize this style sheet.
-*/
-
-/* used to remove borders from tables and images */
-.borderless, table.borderless td, table.borderless th {
-  border: 0 }
-
-table.borderless td, table.borderless th {
-  /* Override padding for "table.docutils td" with "! important".
-     The right padding separates the table cells. */
-  padding: 0 0.5em 0 0 ! important }
-
-.first {
-  /* Override more specific margin styles with "! important". */
-  margin-top: 0 ! important }
-
-.last, .with-subtitle {
-  margin-bottom: 0 ! important }
-
-.hidden {
-  display: none }
-
-a.toc-backref {
-  text-decoration: none ;
-  color: black }
-
-blockquote.epigraph {
-  margin: 2em 5em ; }
-
-dl.docutils dd {
-  margin-bottom: 0.5em }
-
-/* Uncomment (and remove this text!) to get bold-faced definition list terms
-dl.docutils dt {
-  font-weight: bold }
-*/
-
-div.abstract {
-  margin: 2em 5em }
-
-div.abstract p.topic-title {
-  font-weight: bold ;
-  text-align: center }
-
-div.admonition, div.attention, div.caution, div.danger, div.error,
-div.hint, div.important, div.note, div.tip, div.warning {
-  margin: 2em ;
-  border: medium outset ;
-  padding: 1em }
-
-div.admonition p.admonition-title, div.hint p.admonition-title,
-div.important p.admonition-title, div.note p.admonition-title,
-div.tip p.admonition-title {
-  font-weight: bold ;
-  font-family: sans-serif }
-
-div.attention p.admonition-title, div.caution p.admonition-title,
-div.danger p.admonition-title, div.error p.admonition-title,
-div.warning p.admonition-title {
-  color: red ;
-  font-weight: bold ;
-  font-family: sans-serif }
-
-/* Uncomment (and remove this text!) to get reduced vertical space in
-   compound paragraphs.
-div.compound .compound-first, div.compound .compound-middle {
-  margin-bottom: 0.5em }
-
-div.compound .compound-last, div.compound .compound-middle {
-  margin-top: 0.5em }
-*/
-
-div.dedication {
-  margin: 2em 5em ;
-  text-align: center ;
-  font-style: italic }
-
-div.dedication p.topic-title {
-  font-weight: bold ;
-  font-style: normal }
-
-div.figure {
-  margin-left: 2em ;
-  margin-right: 2em }
-
-div.footer, div.header {
-  clear: both;
-  font-size: smaller }
-
-div.line-block {
-  display: block ;
-  margin-top: 1em ;
-  margin-bottom: 1em }
-
-div.line-block div.line-block {
-  margin-top: 0 ;
-  margin-bottom: 0 ;
-  margin-left: 1.5em }
-
-div.sidebar {
-  margin-left: 1em ;
-  border: medium outset ;
-  padding: 1em ;
-  background-color: #ffffee ;
-  width: 40% ;
-  float: right ;
-  clear: right }
-
-div.sidebar p.rubric {
-  font-family: sans-serif ;
-  font-size: medium }
-
-div.system-messages {
-  margin: 5em }
-
-div.system-messages h1 {
-  color: red }
-
-div.system-message {
-  border: medium outset ;
-  padding: 1em }
-
-div.system-message p.system-message-title {
-  color: red ;
-  font-weight: bold }
-
-div.topic {
-  margin: 2em }
-
-h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
-h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
-  margin-top: 0.4em }
-
-h1.title {
-  text-align: center }
-
-h2.subtitle {
-  text-align: center }
-
-hr.docutils {
-  width: 75% }
-
-img.align-left {
-  clear: left }
-
-img.align-right {
-  clear: right }
-
-ol.simple, ul.simple {
-  margin-bottom: 1em }
-
-ol.arabic {
-  list-style: decimal }
-
-ol.loweralpha {
-  list-style: lower-alpha }
-
-ol.upperalpha {
-  list-style: upper-alpha }
-
-ol.lowerroman {
-  list-style: lower-roman }
-
-ol.upperroman {
-  list-style: upper-roman }
-
-p.attribution {
-  text-align: right ;
-  margin-left: 50% }
-
-p.caption {
-  font-style: italic }
-
-p.credits {
-  font-style: italic ;
-  font-size: smaller }
-
-p.label {
-  white-space: nowrap }
-
-p.rubric {
-  font-weight: bold ;
-  font-size: larger ;
-  color: maroon ;
-  text-align: center }
-
-p.sidebar-title {
-  font-family: sans-serif ;
-  font-weight: bold ;
-  font-size: larger }
-
-p.sidebar-subtitle {
-  font-family: sans-serif ;
-  font-weight: bold }
-
-p.topic-title {
-  font-weight: bold }
-
-pre.address {
-  margin-bottom: 0 ;
-  margin-top: 0 ;
-  font-family: serif ;
-  font-size: 100% }
-
-pre.literal-block, pre.doctest-block {
-  margin-left: 2em ;
-  margin-right: 2em ;
-  background-color: #eeeeee }
-
-span.classifier {
-  font-family: sans-serif ;
-  font-style: oblique }
-
-span.classifier-delimiter {
-  font-family: sans-serif ;
-  font-weight: bold }
-
-span.interpreted {
-  font-family: sans-serif }
-
-span.option {
-  white-space: nowrap }
-
-span.pre {
-  white-space: pre }
-
-span.problematic {
-  color: red }
-
-span.section-subtitle {
-  /* font-size relative to parent (h1..h6 element) */
-  font-size: 80% }
-
-table.citation {
-  border-left: solid 1px gray;
-  margin-left: 1px }
-
-table.docinfo {
-  margin: 2em 4em }
-
-table.docutils {
-  margin-top: 0.5em ;
-  margin-bottom: 0.5em }
-
-table.footnote {
-  border-left: solid 1px black;
-  margin-left: 1px }
-
-table.docutils td, table.docutils th,
-table.docinfo td, table.docinfo th {
-  padding-left: 0.5em ;
-  padding-right: 0.5em ;
-  vertical-align: top }
-
-table.docutils th.field-name, table.docinfo th.docinfo-name {
-  font-weight: bold ;
-  text-align: left ;
-  white-space: nowrap ;
-  padding-left: 0 }
-
-h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
-h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
-  font-size: 100% }
-
-tt.docutils {
-  background-color: #eeeeee }
-
-ul.auto-toc {
-  list-style-type: none }
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/license.html src/doc/license.html
--- upstream/doc/license.html	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/license.html	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-<!DOCTYPE HTML SYSTEM>
-<html>
-<head>
-<title>Lrexlib: The License</title>
-</head>
-<body>
-
-<h2>Lrexlib</h2>
-<p>Copyright &copy; Reuben Thomas 2000-2020<br>
-Copyright &copy; Shmuel Zeigerman 2004-2020
-
-<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-</body>
-</html>
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/lrexlib.css src/doc/lrexlib.css
--- upstream/doc/lrexlib.css	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/lrexlib.css	1970-01-01 00:00:00.000000000 +0000
@@ -1,33 +0,0 @@
-/*
-:Author: Shmuel Zeigerman
-:Contact: shmuz at actcom co il
-:Copyright: This stylesheet has been placed in the public domain.
-
-[Optionally place a description here.]
-*/
-
-@import url(html4css1.css);
-
-hr.docutils {
-  width: 100%
-}
-
-.funcdef {
-  font-weight: bold ;
-  font-size: 100%
-}
-
-body { 
-    margin-left: 1em ; 
-    margin-right: 1em ; 
-    font-family: "Verdana", sans-serif ;
-}
-
-table {
-  border-spacing: 0;
-}
-
-tr {
-  margin: 0;
-  padding: 0;
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/doc/manual.txt src/doc/manual.txt
--- upstream/doc/manual.txt	2021-12-28 20:05:16.000000000 +0000
+++ src/doc/manual.txt	1970-01-01 00:00:00.000000000 +0000
@@ -1,1073 +0,0 @@
-.. role:: funcdef(literal)
-
-Lrexlib Reference Manual
-========================
-
-.. contents:: Table of Contents
-
-------------------------------------------------------------
-
-**Lrexlib** builds into shared libraries called by default *rex_posix.so*,
-*rex_pcre.so*, *rex_pcre2.so*, *rex_gnu.so*, *rex_tre.so* and *rex_onig.so*,
-which can be used with *require*.
-
-------------------------------------------------------------
-
-Notes
-~~~~~
-
-1. Most functions and methods in Lrexlib have mandatory and optional arguments.
-   There are no dependencies between arguments in Lrexlib's functions and
-   methods. Any optional argument can be supplied as ``nil`` (or omitted if it
-   is a trailing argument), the library will then use the default value for that
-   argument.
-
-2. This document uses the following syntax for optional arguments: they are
-   bracketed separately, and commas are left outside brackets, e.g.::
-
-    MyFunc (arg1, arg2, [arg3], [arg4])
-
-3. Throughout this document (unless it causes ambiguity), the identifier **rex**
-   is used in place of either *rex_posix*, *rex_pcre*, *rex_pcre2*, *rex_gnu*,
-   *rex_onig* or *rex_tre*, which are the default namespaces for the corresponding
-   libraries.
-
-4. All functions that take a regular expression pattern as an argument will
-   generate an error if that pattern is found invalid by the regex library.
-
-5. All functions that take a string-type regex argument accept a compiled regex
-   too. In this case, the cf_ and larg_ arguments are ignored (should
-   be either supplied as nils or omitted).
-
-6. All functions that take a string-type subject accept a table or userdata that
-   has a ``topointer`` method and ``__len`` metamethod, and take the subject to
-   be a block of memory starting at the address returned by
-   ``subject:topointer()`` and of length ``#subject``. This works with buffers
-   objects from the alien library (https://github.com/mascarenhas/alien). Note
-   that special attention is needed with POSIX regex libraries that do not
-   support ``REG_STARTEND``, and hence need NUL-terminated subjects: the NUL is
-   not included in the string length, so alien buffers must be wrapped to report
-   a length that excludes the NUL.
-
-.. _cf:
-
-7. The default value for *compilation flags* (*cf*) that Lrexlib uses when
-   the parameter is not supplied or ``nil`` is:
-
-     * ``REG_EXTENDED`` for POSIX and TRE
-     * ``0`` for PCRE and PCRE2
-     * ``ONIG_OPTION_NONE`` for Oniguruma
-     * ``SYNTAX_POSIX_EXTENDED`` for GNU
-
-   **PCRE**, **PCRE2**, **Oniguruma**: *cf* may also be supplied as a string,
-   whose characters stand for compilation flags. Combinations of the following
-   characters (case sensitive) are supported:
-
-      ===============   ==================   ==================   ==============================
-       **Character**      **PCRE flag**       **PCRE2 flag**        **Oniguruma flag**
-      ===============   ==================   ==================   ==============================
-       **i**              PCRE_CASELESS        PCRE2_CASELESS      ONIG_OPTION_IGNORECASE
-       **m**              PCRE_MULTILINE       PCRE2_MULTILINE     ONIG_OPTION_NEGATE_SINGLELINE
-       **s**              PCRE_DOTALL          PCRE2_DOTALL        ONIG_OPTION_MULTILINE
-       **x**              PCRE_EXTENDED        PCRE2_EXTENDED      ONIG_OPTION_EXTEND
-       **U**              PCRE_UNGREEDY        PCRE2_UNGREEDY      n/a
-       **X**              PCRE_EXTRA           n/a                 n/a
-      ===============   ==================   ==================   ==============================
-
-.. _ef:
-
-8. The default value for *execution flags* (*ef*) that Lrexlib uses when
-   the parameter is not supplied or ``nil``, is:
-
-     * ``0`` for standard POSIX regex library
-     * ``REG_STARTEND`` for those POSIX regex libraries that support it, e.g. Spencer's
-     * ``0`` for PCRE, PCRE2, Oniguruma and TRE
-
-.. _larg:
-
-9. The notation *larg...* is used to indicate optional library-specific
-   arguments, which are documented in the ``new`` method of each library.
-
-10. In the functions searching for multiple matches (``gmatch``, ``gsub``,
-    ``split``, ``count``) every empty match adjacent to the previous match
-    is discarded, e.g. ``rex.count("abc",".*")`` will return 1.
-
-------------------------------------------------------------
-
-Functions and methods common to all bindings
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-match
------
-
-:funcdef:`rex.match (subj, patt, [init], [cf], [ef], [larg...])`
-
-or
-
-:funcdef:`r:match (subj, [init], [ef])`
-
-The function searches for the first match of the regexp *patt* in the string
-*subj*, starting from offset *init*, subject to flags *cf* and *ef*.
-
-  +---------+-------------------------------+--------+-------------+
-  |Parameter|        Description            |  Type  |Default Value|
-  +=========+===============================+========+=============+
-  |    r    |regex object produced by new   |userdata|     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  subj   |          subject              | string |     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  patt   |regular expression pattern     |string  |     n/a     |
-  |         |                               |or      |             |
-  |         |                               |userdata|             |
-  +---------+-------------------------------+--------+-------------+
-  | [init]  |start offset in the subject    | number |      1      |
-  |         |(can be negative)              |        |             |
-  +---------+-------------------------------+--------+-------------+
-  |  [cf]   |compilation flags (bitwise OR) | number |     cf_     |
-  +---------+-------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)   | number |     ef_     |
-  +---------+-------------------------------+--------+-------------+
-  |[larg...]|library-specific arguments     |        |             |
-  +---------+-------------------------------+--------+-------------+
-
-**Returns on success:**
-  1. All substring matches ("captures"), in the order they appear in the
-     pattern. ``false`` is returned for sub-patterns that did not participate in
-     the match. If the pattern specified no captures then the whole matched
-     substring is returned.
-
-**Returns on failure:**
-  1. ``nil``
-
-------------------------------------------------------------
-
-find
-----
-
-:funcdef:`rex.find (subj, patt, [init], [cf], [ef], [larg...])`
-
-or
-
-:funcdef:`r:find (subj, [init], [ef])`
-
-The function searches for the first match of the regexp *patt* in the string
-*subj*, starting from offset *init*, subject to flags *cf* and *ef*.
-
-  +---------+-------------------------------+--------+-------------+
-  |Parameter|        Description            |  Type  |Default Value|
-  +=========+===============================+========+=============+
-  |    r    |regex object produced by new   |userdata|     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  subj   |subject                        | string |     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  patt   |regular expression pattern     |string  |     n/a     |
-  |         |                               |or      |             |
-  |         |                               |userdata|             |
-  +---------+-------------------------------+--------+-------------+
-  | [init]  |start offset in the subject    | number |      1      |
-  |         |(can be negative)              |        |             |
-  +---------+-------------------------------+--------+-------------+
-  |  [cf]   |compilation flags (bitwise OR) | number |      cf_    |
-  +---------+-------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)   | number |      ef_    |
-  +---------+-------------------------------+--------+-------------+
-  |[larg...]|library-specific arguments     |        |             |
-  +---------+-------------------------------+--------+-------------+
-
-**Returns on success:**
-  1. The start point of the match (a number).
-  2. The end point of the match (a number).
-  3. All substring matches ("captures"), in the order they appear in the
-     pattern. ``false`` is returned for sub-patterns that did not participate in
-     the match.
-
-**Returns on failure:**
-  1. ``nil``
-
-------------------------------------------------------------
-
-gmatch
-------
-
-:funcdef:`rex.gmatch (subj, patt, [cf], [ef], [larg...])`
-
-The function is intended for use in the *generic for* Lua construct.
-It returns an iterator for repeated matching of the pattern *patt* in
-the string *subj*, subject to flags *cf* and *ef*.
-
-  +---------+-------------------------------+--------+-------------+
-  |Parameter|      Description              | Type   |Default Value|
-  +=========+===============================+========+=============+
-  |  subj   |subject                        |string  |     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  patt   |regular expression pattern     |string  |     n/a     |
-  |         |                               |or      |             |
-  |         |                               |userdata|             |
-  +---------+-------------------------------+--------+-------------+
-  |  [cf]   |compilation flags (bitwise OR) |number  |     cf_     |
-  +---------+-------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)   |number  |     ef_     |
-  +---------+-------------------------------+--------+-------------+
-  |[larg...]|library-specific arguments     |        |             |
-  +---------+-------------------------------+--------+-------------+
-
-The iterator function is called by Lua. On every iteration (that is, on every
-match), it returns all captures in the order they appear in the pattern (or the
-entire match if the pattern specified no captures). The iteration will continue
-till the subject fails to match.
-
-------------------------------------------------------------
-
-gsub
-----
-
-:funcdef:`rex.gsub (subj, patt, repl, [n], [cf], [ef], [larg...])`
-
-This function searches for all matches of the pattern *patt* in the string
-*subj* and replaces them according to the parameters *repl* and *n* (see details
-below).
-
-  +---------+-----------------------------------+--------------------------+-------------+
-  |Parameter|       Description                 |          Type            |Default Value|
-  +=========+===================================+==========================+=============+
-  |  subj   |subject                            |         string           |     n/a     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  patt   |regular expression pattern         |string or userdata        |     n/a     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  repl   |substitution source                |string, function or table |     n/a     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |   [n]   |maximum number of matches to search| number or function       |   ``nil``   |
-  |         |for, or control function, or nil   |                          |             |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  [cf]   |compilation flags (bitwise OR)     |         number           |     cf_     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       |         number           |     ef_     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |[larg...]|library-specific arguments         |                          |             |
-  +---------+-----------------------------------+--------------------------+-------------+
-
-**Returns:**
-  1. The subject string with the substitutions made.
-  2. Number of matches found.
-  3. Number of substitutions made.
-
-**Details:**
-  The parameter *repl* can be either a string, a function or a table.
-  On each match made, it is converted into a value *repl_out* that may be used
-  for the replacement.
-
-  *repl_out* is generated differently depending on the type of *repl*:
-
-  1. If *repl* is a *string* then it is treated as a template for substitution,
-     where the %X occurences in *repl* are handled in a special way, depending
-     on the value of the character X:
-
-    * if X represents a digit, then each %X occurence is substituted by the
-      value of the X-th submatch (capture), with the following cases handled
-      specially:
-
-      * each %0 is substituted by the entire match
-      * if the pattern contains no captures, then each %1 is substituted by the
-        entire match
-      * any other %X where X is greater than the number of captures in the
-        pattern will generate an error ("invalid capture index")
-      * if the pattern does contain a capture with number X but that capture
-        didn't participate in the match, then %X is substituted by an empty
-        string
-
-    * if X is any non-digit character then %X is substituted by X
-
-    All parts of *repl* other than %X are copied to *repl_out* verbatim.
-
-  2. If *repl* is a *function* then it is called on each match with the
-     submatches passed as parameters (if there are no submatches then the entire
-     match is passed as the only parameter). *repl_out* is the return value of
-     the *repl* call, and is interpreted as follows:
-
-    * if it is a string or a number (coerced to a string), then the replacement
-      value is that string;
-    * if it is a ``nil`` or a ``false``, then no replacement is to be done;
-
-  3. If *repl* is a table then *repl_out* is *repl* [m1], where m1 is the first
-     submatch (or the entire match if there are no submatches), following the
-     same rules as for the return value of *repl* call, described in the above
-     paragraph.
-
-  Note: Under some circumstances, the value of *repl_out* may be ignored; see
-  below_.
-
-  gsub behaves differently depending on the type of *n*:
-
-  1. If *n* is a *number* then it is treated as the maximum number of matches
-     to search for (an omitted or ``nil`` value means an unlimited number of
-     matches). On each match, the replacement value is the *repl_out* string
-     (see above).
-
-.. _below:
-
-  2. If *n* is a function, then it is called on each match, after *repl_out* is
-     produced (so if *repl* is a function, it will be called prior to the *n*
-     call).
-
-     *n* receives 3 arguments and returns 2 values. Its arguments are:
-
-       1. The start offset of the match (a number)
-       2. The end offset of the match (a number)
-       3. *repl_out*
-
-     The type of its first return controls the replacement produced by gsub for
-     the current match:
-
-       * ``true`` -- replace/don't replace, according to *repl_out*;
-       * ``nil``/``false`` -- don't replace;
-       * a string (or a number coerced to a string) -- replace by that string;
-
-     The type of its second return controls gsub behavior after the current
-     match is handled:
-
-       * ``nil``/``false`` -- no changes: *n* will be called on the next match;
-       * ``true`` -- search for an unlimited number of matches; *n* will not be
-         called again;
-       * a number -- maximum number of matches to search for, beginning from the
-         next match; *n* will not be called again;
-
-------------------------------------------------------------
-
-split
------
-
-:funcdef:`rex.split (subj, sep, [cf], [ef], [larg...])`
-
-The function is intended for use in the *generic for* Lua construct.
-It is used for splitting a subject string *subj* into parts (*sections*).
-The *sep* parameter is a regular expression pattern representing
-**separators** between the sections.
-
-The function returns an iterator for repeated matching of the pattern *sep* in
-the string *subj*, subject to flags *cf* and *ef*.
-
-  +---------+-------------------------------+--------+-------------+
-  |Parameter|      Description              | Type   |Default Value|
-  +=========+===============================+========+=============+
-  |  subj   |subject                        |string  |     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |   sep   |separator (regular expression  |string  |     n/a     |
-  |         |pattern)                       |or      |             |
-  |         |                               |userdata|             |
-  +---------+-------------------------------+--------+-------------+
-  |  [cf]   |compilation flags (bitwise OR) |number  |     cf_     |
-  +---------+-------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)   |number  |     ef_     |
-  +---------+-------------------------------+--------+-------------+
-  |[larg...]|library-specific arguments     |        |             |
-  +---------+-------------------------------+--------+-------------+
-
-**On every iteration pass, the iterator returns:**
-
-  1. A subject section (can be an empty string), followed by
-  2. All captures in the order they appear in the *sep* pattern (or the entire
-     match if the *sep* pattern specified no captures). If there is no match
-     (this can occur only in the last iteration), then nothing is returned after
-     the subject section.
-
-The iteration will continue till the end of the subject. Unlike gmatch_, there
-will always be at least one iteration pass, even if there are no matches in the
-subject.
-
-------------------------------------------------------------
-
-count
------
-
-:funcdef:`rex.count (subj, patt, [cf], [ef], [larg...])`
-
-This function counts matches of the pattern *patt* in the string *subj*.
-
-  +---------+-----------------------------------+--------------------------+-------------+
-  |Parameter|       Description                 |          Type            |Default Value|
-  +=========+===================================+==========================+=============+
-  |  subj   |subject                            |         string           |     n/a     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  patt   |regular expression pattern         |string or userdata        |     n/a     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  [cf]   |compilation flags (bitwise OR)     |         number           |     cf_     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       |         number           |     ef_     |
-  +---------+-----------------------------------+--------------------------+-------------+
-  |[larg...]|library-specific arguments         |                          |             |
-  +---------+-----------------------------------+--------------------------+-------------+
-
-**Returns:**
-  1. Number of matches found.
-
-------------------------------------------------------------
-
-flags
------
-
-:funcdef:`rex.flags ([tb])`
-
-This function returns a table containing the numeric values of the constants
-defined by the used regex library, with the keys being the (string) names of the
-constants. If the table argument *tb* is supplied then it is used as the output
-table, otherwise a new table is created.
-
-The constants contained in the returned table can then be used in most functions
-and methods where *compilation flags* or *execution flags* can be specified.
-They can also be used for comparing with return codes of some functions and
-methods for determining the reason of failure. For details, see the relevant
-regex library's documentation.
-
-  +---------+--------------------------------+--------+-------------+
-  |Parameter|        Description             |  Type  |Default Value|
-  +=========+================================+========+=============+
-  |  [tb]   |a table for placing results into| table  |  ``nil``    |
-  +---------+--------------------------------+--------+-------------+
-
-**Returns:**
- 1. A table filled with the results.
-
-**Notes:**
-The keys in the `tb` table are formed from the names of the corresponding
-constants in the used library. They are formed as follows:
-
-* **POSIX**, **TRE**: prefix REG\_ is omitted, e.g. REG_ICASE becomes ``"ICASE"``.
-* **PCRE:** prefix PCRE\_ is omitted, e.g. PCRE_CASELESS becomes ``"CASELESS"``.
-* **PCRE2:** prefix PCRE2\_ is omitted, e.g. PCRE2_CASELESS becomes ``"CASELESS"``.
-* **Oniguruma:** names of constants are converted to strings with no alteration,
-  but for ONIG_OPTION_xxx constants, alias strings are created additionally,
-  e.g., the value of ONIG_OPTION_IGNORECASE constant becomes accessible via
-  either of two keys: ``"ONIG_OPTION_IGNORECASE"`` and ``"IGNORECASE"``.
-* **GNU**: the GNU library provides the flags ``not_bol``, which stops a
-  beginning-of-line anchor from matching at the start of a string, ``not_eol``,
-  which stops an end-of-line anchor from matching at the end of a string, and
-  ``backward`` which causes the search to be performed backwards (that is, the
-  pattern is matched from positions starting at the end of the string; however,
-  the matches themselves are still made forwards), as well as the RE_xxx syntax
-  specifiers (as defined in regex.h), omitting the RE\_ prefix. For example,
-  RE_SYNTAX_GREP becomes ``SYNTAX_GREP`` in Lua.
-
-------------------------------------------------------------
-
-new
----
-
-:funcdef:`rex.new (patt, [cf], [larg...])`
-
-The function compiles regular expression *patt* into a regular expression object
-whose internal representation is corresponding to the library used. The returned
-result then can be used by the methods, e.g. `tfind`_, `exec`_, etc. Regular
-expression objects are automatically garbage collected. See the library-specific
-documentation below for details of the library-specific arguments *larg...*, if
-any.
-
-  +---------+-------------------------------+--------+-------------+
-  |Parameter|        Description            |  Type  |Default Value|
-  +=========+===============================+========+=============+
-  |  patt   |regular expression pattern     | string |     n/a     |
-  +---------+-------------------------------+--------+-------------+
-  |  [cf]   |compilation flags (bitwise OR) | number |     cf_     |
-  +---------+-------------------------------+--------+-------------+
-  |[larg...]|library-specific arguments     |        |             |
-  +---------+-------------------------------+--------+-------------+
-
-**Returns:**
- 1. Compiled regular expression (a userdata).
-
-------------------------------------------------------------
-
-tfind
------
-
-:funcdef:`r:tfind (subj, [init], [ef])`
-
-The method searches for the first match of the compiled regexp *r* in the
-string *subj*, starting from offset *init*, subject to execution flags *ef*.
-
-  +---------+-----------------------------------+--------+-------------+
-  |Parameter|        Description                |  Type  |Default Value|
-  +=========+===================================+========+=============+
-  |    r    |regex object produced by new       |userdata|     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  |  subj   |subject                            | string |     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  | [init]  |start offset in the subject        | number |      1      |
-  |         |(can be negative)                  |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       | number |     ef_     |
-  +---------+-----------------------------------+--------+-------------+
-
-**Returns on success:**
- 1. The start point of the match (a number).
- 2. The end point of the match (a number).
- 3. Substring matches ("captures" in Lua terminology) are returned as a third
-    result, in a table. This table contains ``false`` in the positions where the
-    corresponding sub-pattern did not participate in the match.
-
-    1. **PCRE**, **PCRE2**, **Oniguruma**: if *named subpatterns* are used then
-       the table also contains substring matches keyed by their correspondent
-       subpattern names (strings).
-
-**Returns on failure:**
- 1. ``nil``
-
-------------------------------------------------------------
-
-exec
-----
-
-:funcdef:`r:exec (subj, [init], [ef])`
-
-The method searches for the first match of the compiled regexp *r* in the
-string *subj*, starting from offset *init*, subject to execution flags *ef*.
-
-  +---------+-----------------------------------+--------+-------------+
-  |Parameter|        Description                |  Type  |Default Value|
-  +=========+===================================+========+=============+
-  |    r    |regex object produced by new       |userdata|     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  |  subj   |subject                            | string |     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  | [init]  |start offset in the subject        | number |      1      |
-  |         |(can be negative)                  |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       | number |     ef_     |
-  +---------+-----------------------------------+--------+-------------+
-
-**Returns on success:**
- 1. The start point of the first match (a number).
- 2. The end point of the first match (a number).
- 3. The offsets of substring matches ("captures" in Lua terminology) are
-    returned as a third result, in a table. This table contains ``false`` in the
-    positions where the corresponding sub-pattern did not participate in the
-    match.
-
-    1. **PCRE**, **PCRE2**, **Oniguruma**: if *named subpatterns* are used then
-       the table also contains substring matches keyed by their correspondent
-       subpattern names (strings).
-
-**Returns on failure:**
- 1. ``nil``
-
-**Example:**
- If the whole match is at offsets 10,20 and substring matches are at offsets
- 12,14 and 16,19 then the function returns the following: 10, 20,
- { 12,14,16,19 }.
-
-------------------------------------------------------------
-
-PCRE-only functions and methods
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-new
----
-
-:funcdef:`rex.new (patt, [cf], [lo])`
-
-The locale (*lo*) can be either a string (e.g., "French_France.1252"), or a
-userdata obtained from a call to maketables__. The default value, used when
-the parameter is not supplied or ``nil``, is the built-in PCRE set of character
-tables.
-
-__ maketables_pcre_
-
-------------------------------------------------------------
-
-fullinfo
---------
-
-[See *pcre_fullinfo* in the PCRE docs.]
-
-:funcdef:`r:fullinfo ()`
-
-This function returns a table containing information about the compiled pattern.
-The keys are strings formed in the following way:
-``PCRE_INFO_CAPTURECOUNT`` -> ``"CAPTURECOUNT"``. The values are numbers.
-
-------------------------------------------------------------
-
-.. _dfa_exec_pcre:
-
-dfa_exec
---------
-
-[PCRE 6.0 and later. See *pcre_dfa_exec* in the PCRE docs.]
-
-:funcdef:`r:dfa_exec (subj, [init], [ef], [ovecsize], [wscount])`
-
-The method matches a compiled regular expression *r* against a given subject
-string *subj*, using a DFA matching algorithm.
-
-  +----------+-------------------------------------+--------+-------------+
-  |Parameter |                 Description         |  Type  |Default Value|
-  +==========+=====================================+========+=============+
-  |    r     |regex object produced by new         |userdata|     n/a     |
-  +----------+-------------------------------------+--------+-------------+
-  |  subj    |subject                              | string |     n/a     |
-  +----------+-------------------------------------+--------+-------------+
-  | [init]   |start offset in the subject          | number |      1      |
-  |          |(can be negative)                    |        |             |
-  +----------+-------------------------------------+--------+-------------+
-  |   [ef]   |execution flags (bitwise OR)         | number |     ef_     |
-  +----------+-------------------------------------+--------+-------------+
-  |[ovecsize]|size of the array for result offsets | number |     100     |
-  +----------+-------------------------------------+--------+-------------+
-  |[wscount] |number of elements in the working    | number |     50      |
-  |          |space array                          |        |             |
-  +----------+-------------------------------------+--------+-------------+
-
-**Returns on success (either full or partial match):**
- 1. The start point of the matches found (a number).
- 2. A table containing the end points of the matches found, the longer matches
-    first.
- 3. The return value of the underlying *pcre_dfa_exec* call (a number).
-
-**Returns on failure (no match):**
- 1. ``nil``
-
-**Example:**
- If there are 3 matches found starting at offset 10 and ending at offsets 15, 20
- and 25 then the function returns the following: 10, { 25,20,15 }, 3.
-
-------------------------------------------------------------
-
-.. _maketables_pcre:
-
-maketables
-----------
-
-[See *pcre_maketables* in the PCRE docs.]
-
-:funcdef:`rex_pcre.maketables ()`
-
-Creates a set of character tables corresponding to the current locale and
-returns it as a userdata. The returned value can be passed to any Lrexlib
-function accepting the *locale* parameter.
-
-------------------------------------------------------------
-
-config
-------
-
-[PCRE 4.0 and later. See *pcre_config* in the PCRE docs.]
-
-:funcdef:`rex_pcre.config ([tb])`
-
-This function returns a table containing the values of the configuration
-parameters used at PCRE library build-time. Those parameters (numbers) are
-keyed by their names (strings). If the table argument *tb* is supplied then it
-is used as the output table, else a new table is created.
-
-------------------------------------------------------------
-
-.. _version:
-
-version
--------
-
-[See *pcre_version* in the PCRE docs.]
-
-:funcdef:`rex_pcre.version ()`
-
-This function returns a string containing the version of the used PCRE library
-and its release date.
-
-------------------------------------------------------------
-
-PCRE2-only functions and methods
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-new
----
-
-:funcdef:`rex.new (patt, [cf], [lo])`
-
-The locale (*lo*) can be either a string (e.g., "French_France.1252"), or a
-userdata obtained from a call to maketables__. The default value, used when
-the parameter is not supplied or ``nil``, is the built-in PCRE2 set of character
-tables.
-
-__ maketables_pcre2_
-
-------------------------------------------------------------
-
-patterninfo
------------
-
-[See *pcre2_patterninfo* in the PCRE2 docs.]
-
-:funcdef:`r:patterninfo ()`
-
-This function returns a table containing information about the compiled pattern.
-The keys are strings formed in the following way:
-``PCRE2_INFO_CAPTURECOUNT`` -> ``"CAPTURECOUNT"``. The values are numbers.
-
-------------------------------------------------------------
-
-dfa_exec
---------
-
-[See *pcre2_dfa_exec* in the PCRE2 docs.]
-
-:funcdef:`r:dfa_exec (subj, [init], [ef], [ovecsize], [wscount])`
-
-The method matches a compiled regular expression *r* against a given subject
-string *subj*, using a DFA matching algorithm.
-
-  +----------+-------------------------------------+--------+-------------+
-  |Parameter |                 Description         |  Type  |Default Value|
-  +==========+=====================================+========+=============+
-  |    r     |regex object produced by new         |userdata|     n/a     |
-  +----------+-------------------------------------+--------+-------------+
-  |  subj    |subject                              | string |     n/a     |
-  +----------+-------------------------------------+--------+-------------+
-  | [init]   |start offset in the subject          | number |      1      |
-  |          |(can be negative)                    |        |             |
-  +----------+-------------------------------------+--------+-------------+
-  |   [ef]   |execution flags (bitwise OR)         | number |     ef_     |
-  +----------+-------------------------------------+--------+-------------+
-  |[ovecsize]|size of the array for result offsets | number |     100     |
-  +----------+-------------------------------------+--------+-------------+
-  |[wscount] |number of elements in the working    | number |     50      |
-  |          |space array                          |        |             |
-  +----------+-------------------------------------+--------+-------------+
-
-**Returns on success (either full or partial match):**
- 1. The start point of the matches found (a number).
- 2. A table containing the end points of the matches found, the longer matches
-    first.
- 3. The return value of the underlying *pcre_dfa_exec* call (a number).
-
-**Returns on failure (no match):**
- 1. ``nil``
-
-**Example:**
- If there are 3 matches found starting at offset 10 and ending at offsets 15, 20
- and 25 then the function returns the following: 10, { 25,20,15 }, 3.
-
-------------------------------------------------------------
-
-jit_compile
------------
-
-[See *pcre2_jit_compile* in the PCRE2 docs.]
-
-:funcdef:`r:jit_compile ([options])`
-
-Parameter *options* is a number (a bitwise OR of separate options;
-it defaults to ``PCRE2_JIT_COMPLETE``).
-
-The method returns ``true`` on success or ``false`` + error message string on failure.
-
-------------------------------------------------------------
-
-.. _maketables_pcre2:
-
-maketables
-----------
-
-[See *pcre2_maketables* in the PCRE2 docs.]
-
-:funcdef:`rex_pcre2.maketables ()`
-
-Creates a set of character tables corresponding to the current locale and
-returns it as a userdata. The returned value can be passed to any Lrexlib
-function accepting the *locale* parameter.
-
-------------------------------------------------------------
-
-config
-------
-
-[See *pcre2_config* in the PCRE2 docs.]
-
-:funcdef:`rex_pcre2.config ([tb])`
-
-This function returns a table containing the values of the configuration
-parameters used at PCRE2 library build-time. Those parameters (numbers) are
-keyed by their names (strings). If the table argument *tb* is supplied then it
-is used as the output table, else a new table is created.
-
-------------------------------------------------------------
-
-version
--------
-
-[See *pcre2_config(PCRE2_CONFIG_VERSION)* in the PCRE2 docs.]
-
-:funcdef:`rex_pcre2.version ()`
-
-This function returns a string containing the version of the used PCRE2 library
-and its release date.
-
-------------------------------------------------------------
-
-GNU-only functions and methods
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-new
----
-
-:funcdef:`rex.new (patt, [cf], [tr])`
-
-If the compilation flags (*cf*) are not supplied or ``nil``, the default syntax
-is ``SYNTAX_POSIX_EXTENDED``. Note that this is not the same as passing a value
-of zero, which is the same as ``SYNTAX_EMACS``.
-
-The *translation* parameter (*tr*) is a map of eight-bit character codes (0 to
-255 inclusive) to 8-bit characters (strings). If this parameter is given, the
-pattern is translated at compilation time, and each string to be matched is
-translated when it is being matched.
-
-
-Oniguruma-only functions and methods
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-new
----
-
-:funcdef:`rex.new (patt, [cf], [enc], [syn])`
-
-The *encoding* parameter (*enc*) must be one of the predefined strings that are
-formed from the ONIG_ENCODING_xxx identifiers defined in oniguruma.h, by means
-of omitting the ONIG_ENCODING\_ part. For example, ONIG_ENCODING_UTF8 becomes
-``"UTF8"`` on the Lua side. The default value, used when the parameter is not
-supplied or ``nil``, is ``"ASCII"``.
-
-If the caller-supplied value of this parameter is not one of the predefined
-"encoding" string set, an error is raised.
-
-The *syntax* parameter (*syn*) must be one of the predefined strings that are
-formed from the ONIG_SYNTAX_xxx identifiers defined in oniguruma.h, by means of
-omitting the ONIG_SYNTAX\_ part. For example, ONIG_SYNTAX_JAVA becomes
-``"JAVA"`` on the Lua side. The default value, used when the parameter is not
-supplied or ``nil``, is either ``"RUBY"`` (at start-up), or the value set by the
-last setdefaultsyntax_ call.
-
-If the caller-supplied value of `syntax` parameter is not one of the predefined
-"syntax" string set, an error is raised.
-
-setdefaultsyntax
-----------------
-
-:funcdef:`rex_onig.setdefaultsyntax (syntax)`
-
-This function sets the default syntax for the Oniguruma library, according to the
-value of the string syntax. The specified syntax will be further used for
-interpreting string regex patterns by all relevant functions, unless the *syntax*
-argument is passed to those functions explicitly.
-
-**Returns:** nothing
-
-**Examples:**
-
-  1. ``rex_onig.setdefaultsyntax ("ASIS") -- use plain text syntax as the default``
-  2. ``rex_onig.setdefaultsyntax ("PERL") -- use PERL regex syntax as the default``
-
-------------------------------------------------------------
-
-version
--------
-
-[See *onig_version* in the Oniguruma docs.]
-
-:funcdef:`rex_onig.version ()`
-
-This function returns a string containing the version of the used Oniguruma
-library.
-
-------------------------------------------------------------
-
-capturecount
-------------
-
-[See *onig_number_of_captures* in the Oniguruma docs.]
-
-:funcdef:`r:capturecount ()`
-
-Returns the number of captures in the pattern.
-
-------------------------------------------------------------
-
-TRE-only functions and methods
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-new
----
-
-:funcdef:`rex.new (patt, [cf])`
-
-atfind
--------
-
-:funcdef:`r:atfind (subj, params, [init], [ef])`
-
-The method searches for the first match of the compiled regexp *r* in the
-string *subj*, starting from offset *init*, subject to execution flags *ef*.
-
-  +---------+-----------------------------------+--------+-------------+
-  |Parameter|        Description                |  Type  |Default Value|
-  +=========+===================================+========+=============+
-  |    r    |regex object produced by new       |userdata|     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  |  subj   |subject                            | string |     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  | params  |Approximate matching parameters.   | table  |n/a          |
-  |         |The values are integers.           |        |             |
-  |         |The valid string key values are:   |        |(Default     |
-  |         |``cost_ins``, ``cost_del``,        |        |value for    |
-  |         |``cost_subst``, ``max_cost``,      |        |a missing    |
-  |         |``max_ins``, ``max_del``,          |        |field is 0)  |
-  |         |``max_subst``, ``max_err``         |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  | [init]  |start offset in the subject        | number |      1      |
-  |         |(can be negative)                  |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       | number |     ef_     |
-  +---------+-----------------------------------+--------+-------------+
-
-**Returns on success:**
- 1. The start point of the match (a number).
- 2. The end point of the match (a number).
- 3. Substring matches ("captures" in Lua terminology) are returned as a third
-    result, in the array part of a table. Positions where the corresponding
-    sub-pattern did not participate in the match contain ``false``.
-    The hash part of the table contains additional information on the match,
-    in the following fields: ``cost``, ``num_ins``, ``num_del`` and ``num_subst``.
-
-**Returns on failure:**
- 1. ``nil``
-
-------------------------------------------------------------
-
-aexec
-------
-
-:funcdef:`r:aexec (subj, params, [init], [ef])`
-
-The method searches for the first match of the compiled regexp *r* in the
-string *subj*, starting from offset *init*, subject to execution flags *ef*.
-
-  +---------+-----------------------------------+--------+-------------+
-  |Parameter|        Description                |  Type  |Default Value|
-  +=========+===================================+========+=============+
-  |    r    |regex object produced by new       |userdata|     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  |  subj   |subject                            | string |     n/a     |
-  +---------+-----------------------------------+--------+-------------+
-  | params  |Approximate matching parameters.   | table  |n/a          |
-  |         |The values are integers.           |        |             |
-  |         |The valid string key values are:   |        |(Default     |
-  |         |``cost_ins``, ``cost_del``,        |        |value for    |
-  |         |``cost_subst``, ``max_cost``,      |        |a missing    |
-  |         |``max_ins``, ``max_del``,          |        |field is 0)  |
-  |         |``max_subst``, ``max_err``         |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  | [init]  |start offset in the subject        | number |      1      |
-  |         |(can be negative)                  |        |             |
-  +---------+-----------------------------------+--------+-------------+
-  |  [ef]   |execution flags (bitwise OR)       | number |     ef_     |
-  +---------+-----------------------------------+--------+-------------+
-
-**Returns on success:**
- 1. The start point of the first match (a number).
- 2. The end point of the first match (a number).
- 3. The offsets of substring matches ("captures" in Lua terminology) are
-    returned as a third result, in the array part of a table. Positions where
-    the corresponding sub-pattern did not participate in the match contain
-    ``false``. The hash part of the table contains additional information on
-    the match, in the following fields: ``cost``, ``num_ins``, ``num_del`` and
-    ``num_subst``.
-
-**Returns on failure:**
- 1. ``nil``
-
-------------------------------------------------------------
-
-have_approx
-------------
-
-:funcdef:`r:have_approx ()`
-
-The method returns ``true`` if the compiled pattern uses approximate matching,
-and ``false`` if not.
-
-------------------------------------------------------------
-
-have_backrefs
---------------
-
-:funcdef:`r:have_backrefs ()`
-
-The method returns ``true`` if the compiled pattern has back references,
-and ``false`` if not.
-
-------------------------------------------------------------
-
-config
-------
-
-[See *tre_config* in the TRE docs.]
-
-:funcdef:`rex_tre.config ([tb])`
-
-This function returns a table containing the values of the configuration
-parameters used at TRE library build-time. Those parameters are
-keyed by their names. If the table argument *tb* is supplied then it
-is used as the output table, else a new table is created.
-
-------------------------------------------------------------
-
-rex_tre.version
----------------
-
-[See *tre_version* in the TRE docs.]
-
-:funcdef:`rex_tre.version ()`
-
-This function returns a string containing the version of the used TRE library.
-
-------------------------------------------------------------
-
-Incompatibilities with previous versions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-**Incompatibilities between versions 2.8 and 2.7:**
-
-  1. In the functions searching for multiple matches every empty match adjacent
-     to the previous match is discarded.
-
-**Incompatibilities between versions 2.6 and 2.5:**
-
-  1. Removed function ``plainfind``.
-  #. Global variables (e.g. *rex_posix*, *rex_pcre*, etc.) are not created
-     by default. This can be changed at the stage of compilation by adding
-     ``-DREX_CREATEGLOBALVAR`` to ``CFLAGS``.
-
-**Incompatibilities between versions 2.2 and 2.1:**
-
-  1. gsub_: a special "break" return of *repl* function is deprecated.
-  #. (PCRE) gsub_, gmatch_: after finding an empty match at the current
-     position, the functions try to find a non-empty match anchored to the same
-     position.
-
-**Incompatibilities between versions 2.1 and 2.0:**
-
-  1. match_, find_, tfind_, exec_, dfa_exec__: only one value (a ``nil``) is
-     returned when the subject does not match the pattern. Any other failure
-     generates an error.
-
-__ dfa_exec_pcre_
-
-**Incompatibilities between versions 2.0 and 1.19:**
-
-  1. Lua 5.1 is required
-  #. Functions ``newPCRE`` and ``newPOSIX`` renamed to new
-  #. Functions ``flagsPCRE`` and ``flagsPOSIX`` renamed to flags_
-  #. Function ``versionPCRE`` renamed to version_
-  #. Method ``match`` renamed to tfind_
-  #. Method ``gmatch`` removed (similar functionality is provided by function
-     gmatch_)
-  #. Methods tfind_ and exec_: 2 values are returned on failure
-  #. (PCRE) exec_: the returned table may additionally contain *named
-     subpatterns*
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/mkrockspecs.lua src/mkrockspecs.lua
--- upstream/mkrockspecs.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/mkrockspecs.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
--- Generate rockspecs from a prototype with variants
-
-local tree = require "std.tree"
-
-if select ("#", ...) < 2 then
-  io.stderr:write "Usage: mkrockspecs PACKAGE VERSION\n"
-  os.exit ()
-end
-
-package_name = select (1, ...)
-version = select (2, ...)
-
-function format (x, indent)
-  indent = indent or ""
-  if type (x) == "table" then
-    local s = "{\n"
-    for i, v in pairs (x) do
-      if type (i) ~= "number" then
-        s = s..indent..i.." = "..format (v, indent.."  ")..",\n"
-      end
-    end
-    for i, v in ipairs (x) do
-      s = s..indent..format (v, indent.."  ")..",\n"
-    end
-    return s..indent:sub (1, -3).."}"
-  elseif type (x) == "string" then
-    return string.format ("%q", x)
-  else
-    return tostring (x)
-  end
-end
-
-flavour = "" -- a global, visible in loadfile
-for f, spec in pairs (loadfile ("rockspecs.lua") ()) do
-  if f ~= "default" then
-    local specfile = package_name.."-"..(f ~= "" and f:lower ().."-" or "")..version.."-1.rockspec"
-    h = io.open (specfile, "w")
-    assert (h)
-    flavour = f
-    local specs = loadfile ("rockspecs.lua") () -- reload to get current flavour interpolated
-    local spec = tree.merge (tree (specs.default), tree (specs[f]))
-    local s = ""
-    for i, v in pairs (spec) do
-      s = s..i.." = "..format (v, "  ").."\n"
-    end
-    h:write (s)
-    h:close ()
-    os.execute ("luarocks lint " .. specfile)
-  end
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/rockspecs.lua src/rockspecs.lua
--- upstream/rockspecs.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/rockspecs.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,157 +0,0 @@
--- Rockspec data
-
--- Variables to be interpolated:
---
--- flavour: regex library
--- version
-
-local flavours = {"PCRE", "PCRE2", "POSIX", "oniguruma", "TRE", "GNU"}
-local version_dashed = version:gsub ("%.", "-")
--- FIXME: PCRE2 define should be only in PCRE2 rockspec
-local defines = {"VERSION=\""..version.."\"",
-                 "PCRE2_CODE_UNIT_WIDTH=8"}
-
--- FIXME: When Lua 5.1 support is dropped, use an env argument with
--- loadfile instead of wrapping in a table
-return {
-
-default = {
-  package = "Lrexlib-"..flavour,
-  version = version.."-1",
-  source = {
-    url = "git+https://github.com/rrthomas/lrexlib.git",
-    tag = "rel-"..version_dashed,
-  },
-  description = {
-    summary = "Regular expression library binding ("..flavour.." flavour).",
-    detailed = [[
-Lrexlib is a regular expression library for Lua 5.1-5.4, which
-provides bindings for several regular expression libraries.
-This rock provides the ]]..flavour..[[ bindings.]],
-    homepage = "https://github.com/rrthomas/lrexlib",
-    license = "MIT/X11"
-  },
-  dependencies = {
-    "lua >= 5.1"
-  },
-},
-
-PCRE = {
-  external_dependencies = {
-    PCRE = {
-      header = "pcre.h",
-      library = "pcre"
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_pcre = {
-        defines = defines,
-        sources = {"src/common.c", "src/pcre/lpcre.c", "src/pcre/lpcre_f.c"},
-        libraries = {"pcre"},
-        incdirs = {"$(PCRE_INCDIR)"},
-        libdirs = {"$(PCRE_LIBDIR)"}
-      }
-    }
-  }
-},
-
-PCRE2 = {
-  external_dependencies = {
-    PCRE2 = {
-      header = "pcre2.h",
-      library = "pcre2-8"
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_pcre2 = {
-        defines = defines,
-        sources = {"src/common.c", "src/pcre2/lpcre2.c", "src/pcre2/lpcre2_f.c"},
-        libraries = {"pcre2-8"},
-        incdirs = {"$(PCRE2_INCDIR)"},
-        libdirs = {"$(PCRE2_LIBDIR)"}
-      }
-    }
-  }
-},
-
-POSIX = {
-  external_dependencies = {
-    POSIX = {
-      header = "regex.h",
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_posix = {
-        defines = defines,
-        sources = {"src/common.c", "src/posix/lposix.c"}
-      }
-    }
-  }
-},
-
-oniguruma = {
-  external_dependencies = {
-    ONIG = {
-      header = "oniguruma.h",
-      library = "onig"
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_onig = {
-        defines = defines,
-        sources = {"src/common.c", "src/oniguruma/lonig.c", "src/oniguruma/lonig_f.c"},
-        libraries = {"onig"},
-        incdirs = {"$(ONIG_INCDIR)"},
-        libdirs = {"$(ONIG_LIBDIR)"}
-      }
-    }
-  }
-},
-
-TRE = {
-  external_dependencies = {
-    TRE = {
-      header = "tre/tre.h",
-      library = "tre"
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_tre = {
-        defines = defines,
-        sources = {"src/common.c", "src/tre/ltre.c" --[[, "src/tre/tre_w.c"]]},
-        libraries = {"tre"},
-        incdirs = {"$(TRE_INCDIR)"},
-        libdirs = {"$(TRE_LIBDIR)"}
-      }
-    }
-  }
-},
-
-GNU = {
-  external_dependencies = {
-    GNU = {
-      header = "regex.h",
-    }
-  },
-  build = {
-    type = "builtin",
-    modules = {
-      rex_gnu = {
-        defines = defines,
-        sources = {"src/common.c", "src/gnu/lgnu.c"}
-      }
-    }
-  }
-},
-
-} -- close wrapper table
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/algo.h src/src/algo.h
--- upstream/src/algo.h	2021-12-28 20:05:16.000000000 +0000
+++ src/src/algo.h	2025-08-18 08:15:02.086524935 +0000
@@ -1,6 +1,7 @@
 /* algo.h */
 /* See Copyright Notice in the file LICENSE */
-
+#ifndef ALGO_H
+#define ALGO_H
 #include "common.h"
 
 #define REX_VERSION "Lrexlib " VERSION
@@ -752,3 +753,5 @@
   lua_setfield (L, -2, "_newmembuffer");
 #endif
 }
+
+#endif
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/gnu/lgnu.c src/src/gnu/lgnu.c
--- upstream/src/gnu/lgnu.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/gnu/lgnu.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,314 +0,0 @@
-/* lgnu.c - Lua binding of GNU regular expressions library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-#define _GNU_SOURCE
-#ifndef __USE_GNU
-#  define __USE_GNU
-#endif
-#ifndef REX_GNU_INCLUDE
-#  include <regex.h>
-#else
-#  include REX_GNU_INCLUDE
-#endif
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_gnu"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_gnu
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT RE_SYNTAX_POSIX_EXTENDED
-#define ALG_EFLAGS_DFLT 0
-
-#define ALG_GETCFLAGS(L,pos)  (int)luaL_optinteger(L, pos, ALG_CFLAGS_DFLT)
-
-static const unsigned char *gettranslate (lua_State *L, int pos);
-#define ALG_GETCARGS(L,pos,argC)  argC->translate = gettranslate (L, pos)
-
-#define ALG_NOMATCH(res)   ((res) == -1 || (res) == -2)
-#define ALG_ISMATCH(res)   ((res) >= 0)
-#define ALG_SUBBEG(ud,n)   ud->match.start[n]
-#define ALG_SUBEND(ud,n)   ud->match.end[n]
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND(ud,n) - ALG_SUBBEG(ud,n))
-#define ALG_SUBVALID(ud,n) (ALG_SUBBEG(ud,n) >= 0)
-#define ALG_NSUB(ud)     ((int)ud->r.re_nsub)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG(ud,n), ALG_SUBLEN(ud,n))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)                  (st)
-
-typedef struct {
-  struct re_pattern_buffer r;
-  struct re_registers      match;
-  int                      freed;
-  const char *             errmsg;
-} TGnu;
-
-#define TUserdata TGnu
-
-#include "../algo.h"
-
-/*  Functions
- ******************************************************************************
- */
-
-/* Execution flags, which we need to simulate as GNU does not use flags for this. */
-#define GNU_NOTBOL   1
-#define GNU_NOTEOL   2
-#define GNU_BACKWARD 4
-
-static int generate_error (lua_State *L, const TUserdata *ud, int errcode) {
-  const char *errmsg;
-  switch (errcode) {
-  case 0:
-    errmsg = ud->errmsg;
-    break;
-  case -1:
-    errmsg = "no match";
-    break;
-  case -2:
-    errmsg = "internal error in GNU regex";
-    break;
-  default:
-    errmsg = "unknown error";
-  }
-  return luaL_error (L, "%s", errmsg);
-}
-
-#define ALG_TRANSLATE_SIZE (UCHAR_MAX + 1)
-static const unsigned char *gettranslate (lua_State *L, int pos) {
-  unsigned i;
-  const unsigned char *translate;
-
-  if (lua_isnoneornil (L, pos))
-    return NULL;
-
-  translate = (const unsigned char *) malloc (ALG_TRANSLATE_SIZE);
-  if (!translate)
-    luaL_error (L, "malloc failed");
-  memset ((unsigned char *) translate, 0, ALG_TRANSLATE_SIZE); /* initialize all members to 0 */
-  for (i = 0; i <= UCHAR_MAX; i++) {
-    lua_pushinteger (L, i);
-    lua_gettable (L, pos);
-    if (lua_tostring (L, -1))
-      ((unsigned char *) translate)[i] = *lua_tostring (L, -1);
-    lua_pop (L, 1);
-  }
-  return translate;
-}
-
-static void seteflags (TGnu *ud, TArgExec *argE) {
-  ud->r.not_bol = (argE->eflags & GNU_NOTBOL) != 0;
-  ud->r.not_eol = (argE->eflags & GNU_NOTEOL) != 0;
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TGnu **pud) {
-  const char *res;
-  TGnu *ud;
-  int ret;
-
-  ud = (TGnu *)lua_newuserdata (L, sizeof (TGnu));
-  memset (ud, 0, sizeof (TGnu));          /* initialize all members to 0 */
-
-  re_set_syntax (argC->cflags);
-
-  /* translate table is never written to, so this cast is safe */
-  ud->r.translate = (unsigned char *) argC->translate;
-
-  res = re_compile_pattern (argC->pattern, argC->patlen, &ud->r);
-  if (res != NULL) {
-      ud->errmsg = res;
-      ret = generate_error (L, ud, 0);
-  } else {
-    lua_pushvalue (L, ALG_ENVIRONINDEX);
-    lua_setmetatable (L, -2);
-
-    if (pud) *pud = ud;
-    ret = 1;
-  }
-
-  return ret;
-}
-
-static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
-  seteflags (ud, argE);
-  if (argE->startoffset > 0)
-    ud->r.not_bol = 1;
-  argE->text += argE->startoffset;
-  argE->textlen -= argE->startoffset;
-  if (argE->eflags & GNU_BACKWARD)
-    return re_search (&ud->r, argE->text, argE->textlen, argE->textlen, -argE->textlen, &ud->match);
-  else
-    return re_search (&ud->r, argE->text, argE->textlen, 0, argE->textlen, &ud->match);
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int findmatch_exec (TGnu *ud, TArgExec *argE) {
-  argE->text += argE->startoffset;
-  argE->textlen -= argE->startoffset;
-  seteflags (ud, argE);
-  if (argE->eflags & GNU_BACKWARD)
-    return re_search (&ud->r, argE->text, argE->textlen, argE->textlen, -argE->textlen, &ud->match);
-  else
-    return re_search (&ud->r, argE->text, argE->textlen, 0, argE->textlen, &ud->match);
-}
-
-static int gsub_exec (TGnu *ud, TArgExec *argE, int st) {
-  seteflags (ud, argE);
-  if (st > 0)
-    ud->r.not_bol = 1;
-  if (argE->eflags & GNU_BACKWARD)
-    return re_search (&ud->r, argE->text + st, argE->textlen - st, argE->textlen - st, -(argE->textlen - st), &ud->match);
-  else
-    return re_search (&ud->r, argE->text + st, argE->textlen - st, 0, argE->textlen - st, &ud->match);
-}
-
-static int split_exec (TGnu *ud, TArgExec *argE, int offset) {
-  seteflags (ud, argE);
-  if (offset > 0)
-    ud->r.not_bol = 1;
-  if (argE->eflags & GNU_BACKWARD)
-    return re_search (&ud->r, argE->text + offset, argE->textlen - offset, argE->textlen - offset, -(argE->textlen - offset), &ud->match);
-  else
-    return re_search (&ud->r, argE->text + offset, argE->textlen - offset, 0, argE->textlen - offset, &ud->match);
-}
-
-static int Gnu_gc (lua_State *L) {
-  TGnu *ud = check_ud (L);
-  if (ud->freed == 0) {           /* precaution against "manual" __gc calling */
-    ud->freed = 1;
-    regfree (&ud->r);
-    free (ud->match.start);
-    free (ud->match.end);
-  }
-  return 0;
-}
-
-static int Gnu_tostring (lua_State *L) {
-  TGnu *ud = check_ud (L);
-  if (ud->freed == 0)
-    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
-  else
-    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
-  return 1;
-}
-
-static flag_pair gnu_flags[] =
-{
-  { "not_bol",  GNU_NOTBOL },
-  { "not_eol",  GNU_NOTEOL },
-  { "backward", GNU_BACKWARD },
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-static flag_pair gnu_syntax_flags[] = {
-  /* Syntax flag sets. */
-  { "SYNTAX_EMACS",                     RE_SYNTAX_EMACS },
-  { "SYNTAX_AWK",                       RE_SYNTAX_AWK },
-  { "SYNTAX_GNU_AWK",                   RE_SYNTAX_GNU_AWK },
-  { "SYNTAX_POSIX_AWK",                 RE_SYNTAX_POSIX_AWK },
-  { "SYNTAX_POSIX_AWK",                 RE_SYNTAX_POSIX_AWK },
-  { "SYNTAX_EGREP",                     RE_SYNTAX_EGREP },
-  { "SYNTAX_POSIX_EGREP",               RE_SYNTAX_POSIX_EGREP },
-  { "SYNTAX_ED",                        RE_SYNTAX_ED },
-  { "SYNTAX_SED",                       RE_SYNTAX_SED },
-  { "SYNTAX_POSIX_AWK",                 RE_SYNTAX_POSIX_AWK },
-  { "SYNTAX_GREP",                      RE_SYNTAX_GREP },
-  { "SYNTAX_POSIX_BASIC",               RE_SYNTAX_POSIX_BASIC },
-  { "SYNTAX_POSIX_MINIMAL_BASIC",       RE_SYNTAX_POSIX_MINIMAL_BASIC },
-  { "SYNTAX_POSIX_EXTENDED",            RE_SYNTAX_POSIX_EXTENDED },
-  { "SYNTAX_POSIX_MINIMAL_EXTENDED",    RE_SYNTAX_POSIX_MINIMAL_EXTENDED },
-
-  /* Individual syntax flags. */
-  { "BACKSLASH_ESCAPE_IN_LISTS",        RE_BACKSLASH_ESCAPE_IN_LISTS },
-  { "BK_PLUS_QM",                       RE_BK_PLUS_QM },
-  { "CHAR_CLASSES",                     RE_CHAR_CLASSES },
-  { "CONTEXT_INDEP_ANCHORS",            RE_CONTEXT_INDEP_ANCHORS },
-  { "CONTEXT_INDEP_OPS",                RE_CONTEXT_INDEP_OPS },
-  { "CONTEXT_INVALID_OPS",              RE_CONTEXT_INVALID_OPS },
-  { "DOT_NEWLINE",                      RE_DOT_NEWLINE },
-  { "DOT_NOT_NULL",                     RE_DOT_NOT_NULL },
-  { "HAT_LISTS_NOT_NEWLINE",            RE_HAT_LISTS_NOT_NEWLINE },
-  { "INTERVALS",                        RE_INTERVALS },
-  { "LIMITED_OPS",                      RE_LIMITED_OPS },
-  { "NEWLINE_ALT",                      RE_NEWLINE_ALT },
-  { "NO_BK_BRACES",                     RE_NO_BK_BRACES },
-  { "NO_BK_PARENS",                     RE_NO_BK_PARENS },
-  { "NO_BK_REFS",                       RE_NO_BK_REFS },
-  { "NO_BK_VBAR",                       RE_NO_BK_VBAR },
-  { "NO_EMPTY_RANGES",                  RE_NO_EMPTY_RANGES },
-  { "UNMATCHED_RIGHT_PAREN_ORD",        RE_UNMATCHED_RIGHT_PAREN_ORD },
-  { "NO_POSIX_BACKTRACKING",            RE_NO_POSIX_BACKTRACKING },
-  { "NO_GNU_OPS",                       RE_NO_GNU_OPS },
-  { "DEBUG",                            RE_DEBUG },
-  { "INVALID_INTERVAL_ORD",             RE_INVALID_INTERVAL_ORD },
-  { "ICASE",                            RE_ICASE },
-  { "CARET_ANCHORS_HERE",               RE_CARET_ANCHORS_HERE },
-  { "CONTEXT_INVALID_DUP",              RE_CONTEXT_INVALID_DUP },
-  { "NO_SUB",                           RE_NO_SUB },
-#ifdef RE_PLAIN
-  { "PLAIN",                            RE_PLAIN },
-#endif
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-static int Gnu_get_flags (lua_State *L) {
-  const flag_pair* fps[] = { gnu_flags, gnu_syntax_flags, NULL };
-  return get_flags (L, fps);
-}
-
-static const luaL_Reg r_methods[] = {
-  { "exec",       algm_exec },
-  { "tfind",      algm_tfind },    /* old match */
-  { "find",       algm_find },
-  { "match",      algm_match },
-  { "__gc",       Gnu_gc },
-  { "__tostring", Gnu_tostring },
-  { NULL, NULL}
-};
-
-static const luaL_Reg r_functions[] = {
-  { "match",      algf_match },
-  { "find",       algf_find },
-  { "gmatch",     algf_gmatch },
-  { "gsub",       algf_gsub },
-  { "count",      algf_count },
-  { "split",      algf_split },
-  { "new",        algf_new },
-  { "flags",      Gnu_get_flags },
-  { NULL, NULL }
-};
-
-/* Open the library */
-REX_API int REX_OPENLIB (lua_State *L)
-{
-  alg_register(L, r_methods, r_functions, "GNU regexes");
-  return 1;
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oniguruma/lonig.c src/src/oniguruma/lonig.c
--- upstream/src/oniguruma/lonig.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/oniguruma/lonig.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,378 +0,0 @@
-/* lonig.c - Lua binding of Oniguruma library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <locale.h>
-#include <ctype.h>
-#include <oniguruma.h>
-
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-extern int LOnig_get_flags (lua_State *L);
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_onig"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_onig
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT ONIG_OPTION_NONE
-#define ALG_EFLAGS_DFLT 0
-
-static int getcflags (lua_State *L, int pos);
-#define ALG_GETCFLAGS(L,pos)  getcflags(L, pos)
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC);
-#define ALG_GETCARGS(a,b,c)  checkarg_compile(a,b,c)
-
-#define ALG_NOMATCH(res)   ((res) == ONIG_MISMATCH)
-#define ALG_ISMATCH(res)   ((res) >= 0)
-#define ALG_SUBBEG(ud,n)   ud->region->beg[n]
-#define ALG_SUBEND(ud,n)   ud->region->end[n]
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND(ud,n) - ALG_SUBBEG(ud,n))
-#define ALG_SUBVALID(ud,n) (ALG_SUBBEG(ud,n) >= 0)
-#define ALG_NSUB(ud)       onig_number_of_captures(ud->reg)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG(ud,n), ALG_SUBLEN(ud,n))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)  0
-#define ALG_PULL
-
-typedef struct {
-  regex_t *reg;
-  OnigRegion *region;
-  OnigErrorInfo einfo;
-} TOnig;
-
-#define TUserdata TOnig
-
-static void do_named_subpatterns (lua_State *L, TOnig *ud, const char *text);
-#  define DO_NAMED_SUBPATTERNS do_named_subpatterns
-
-#include "../algo.h"
-
-#define CUC const unsigned char*
-
-/*  Functions
- ******************************************************************************
- */
-
-static int getcflags (lua_State *L, int pos) {
-  switch (lua_type (L, pos)) {
-    case LUA_TNONE:
-    case LUA_TNIL:
-      return ALG_CFLAGS_DFLT;
-    case LUA_TNUMBER:
-      return lua_tointeger (L, pos);
-    case LUA_TSTRING: {
-      const char *s = lua_tostring (L, pos);
-      int res = 0, ch;
-      while ((ch = *s++) != '\0') {
-        if (ch == 'i') res |= ONIG_OPTION_IGNORECASE;
-        else if (ch == 'm') res |= ONIG_OPTION_NEGATE_SINGLELINE;
-        else if (ch == 's') res |= ONIG_OPTION_MULTILINE;
-        else if (ch == 'x') res |= ONIG_OPTION_EXTEND;
-        /* else if (ch == 'U') res |= PCRE_UNGREEDY; */
-        /* else if (ch == 'X') res |= PCRE_EXTRA; */
-      }
-      return res;
-    }
-    default:
-      return luaL_typerror (L, pos, "number or string");
-  }
-}
-
-static int generate_error (lua_State *L, const TOnig *ud, int errcode) {
-  char buf [ONIG_MAX_ERROR_MESSAGE_LEN];
-  onig_error_code_to_str((unsigned char*) buf, errcode, &ud->einfo);
-  return luaL_error(L, buf);
-}
-
-typedef struct {
-  const char * name;
-  void * value;
-} EncPair;
-
-/* ATTENTION:
-   This array must always be kept alphabetically sorted, as it's used in the
-   binary search, so take care when manually inserting new elements.
- */
-static EncPair Encodings[] = {
-  { "ASCII",          ONIG_ENCODING_ASCII },
-  { "BIG5",           ONIG_ENCODING_BIG5 },
-  { "CP1251",         ONIG_ENCODING_CP1251 },
-  { "EUC_CN",         ONIG_ENCODING_EUC_CN },
-  { "EUC_JP",         ONIG_ENCODING_EUC_JP },
-  { "EUC_KR",         ONIG_ENCODING_EUC_KR },
-  { "EUC_TW",         ONIG_ENCODING_EUC_TW },
-  { "GB18030",        ONIG_ENCODING_GB18030 },
-  { "ISO_8859_1",     ONIG_ENCODING_ISO_8859_1 },
-  { "ISO_8859_10",    ONIG_ENCODING_ISO_8859_10 },
-  { "ISO_8859_11",    ONIG_ENCODING_ISO_8859_11 },
-  { "ISO_8859_13",    ONIG_ENCODING_ISO_8859_13 },
-  { "ISO_8859_14",    ONIG_ENCODING_ISO_8859_14 },
-  { "ISO_8859_15",    ONIG_ENCODING_ISO_8859_15 },
-  { "ISO_8859_16",    ONIG_ENCODING_ISO_8859_16 },
-  { "ISO_8859_2",     ONIG_ENCODING_ISO_8859_2 },
-  { "ISO_8859_3",     ONIG_ENCODING_ISO_8859_3 },
-  { "ISO_8859_4",     ONIG_ENCODING_ISO_8859_4 },
-  { "ISO_8859_5",     ONIG_ENCODING_ISO_8859_5 },
-  { "ISO_8859_6",     ONIG_ENCODING_ISO_8859_6 },
-  { "ISO_8859_7",     ONIG_ENCODING_ISO_8859_7 },
-  { "ISO_8859_8",     ONIG_ENCODING_ISO_8859_8 },
-  { "ISO_8859_9",     ONIG_ENCODING_ISO_8859_9 },
-/*{ "KOI8",           ONIG_ENCODING_KOI8 }, */
-  { "KOI8_R",         ONIG_ENCODING_KOI8_R },
-  { "SJIS",           ONIG_ENCODING_SJIS },
-  { "UNDEF",          ONIG_ENCODING_UNDEF },
-  { "UTF16_BE",       ONIG_ENCODING_UTF16_BE },
-  { "UTF16_LE",       ONIG_ENCODING_UTF16_LE },
-  { "UTF32_BE",       ONIG_ENCODING_UTF32_BE },
-  { "UTF32_LE",       ONIG_ENCODING_UTF32_LE },
-  { "UTF8",           ONIG_ENCODING_UTF8 },
-};
-
-/* ATTENTION:
-   This array must always be kept alphabetically sorted, as it's used in the
-   binary search, so take care when manually inserting new elements.
- */
-static EncPair Syntaxes[] = {
-  { "ASIS",           ONIG_SYNTAX_ASIS },
-/*{ "DEFAULT",        ONIG_SYNTAX_DEFAULT }, */
-  { "EMACS",          ONIG_SYNTAX_EMACS },
-  { "GNU_REGEX",      ONIG_SYNTAX_GNU_REGEX },
-  { "GREP",           ONIG_SYNTAX_GREP },
-  { "JAVA",           ONIG_SYNTAX_JAVA },
-  { "PERL",           ONIG_SYNTAX_PERL },
-  { "PERL_NG",        ONIG_SYNTAX_PERL_NG },
-  { "POSIX_BASIC",    ONIG_SYNTAX_POSIX_BASIC },
-  { "POSIX_EXTENDED", ONIG_SYNTAX_POSIX_EXTENDED },
-  { "RUBY",           ONIG_SYNTAX_RUBY },
-};
-
-static int fcmp(const void *p1, const void *p2) {
-  return strcmp(((EncPair*)p1)->name, ((EncPair*)p2)->name);
-}
-
-static const char *getlocale (lua_State *L, int pos) {
-  EncPair key, *found;
-  if ((key.name = luaL_optstring(L, pos, NULL)) == NULL)
-    return (const char*)ONIG_ENCODING_ASCII;
-  found = (EncPair*) bsearch(&key, Encodings, sizeof(Encodings)/sizeof(EncPair),
-    sizeof(EncPair), fcmp);
-  if (found == NULL)
-    luaL_argerror(L, pos, "invalid or unsupported encoding string");
-  return (const char*)found->value;
-}
-
-static void *getsyntax (lua_State *L, int pos) {
-  EncPair key, *found;
-  if ((key.name = luaL_optstring(L, pos, NULL)) == NULL)
-    return ONIG_SYNTAX_DEFAULT;
-  found = (EncPair*) bsearch(&key, Syntaxes, sizeof(Syntaxes)/sizeof(EncPair),
-    sizeof(EncPair), fcmp);
-  if (found == NULL)
-    luaL_argerror(L, pos, "invalid or unsupported syntax string");
-  return found->value;
-}
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC) {
-  argC->locale = getlocale (L, pos);
-  argC->syntax = getsyntax (L, pos + 1);
-}
-
-/*
-   rex.setdefaultsyntax (syntax)
-   @param syntax: one of the predefined strings listed in array 'Syntaxes'
-   @return: nothing
-*/
-static int LOnig_setdefaultsyntax (lua_State *L) {
-  (void)luaL_checkstring(L, 1);
-  onig_set_default_syntax((OnigSyntaxType*) getsyntax(L, 1));
-  return 0;
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TOnig **pud) {
-  TOnig *ud;
-  int r;
-
-  ud = (TOnig*)lua_newuserdata (L, sizeof (TOnig));
-  memset (ud, 0, sizeof (TOnig));           /* initialize all members to 0 */
-  lua_pushvalue (L, ALG_ENVIRONINDEX);
-  lua_setmetatable (L, -2);
-
-  r = onig_new(&ud->reg, (CUC)argC->pattern, (CUC)argC->pattern + argC->patlen,
-    argC->cflags, (OnigEncoding)argC->locale, (OnigSyntaxType*)argC->syntax,
-    &ud->einfo);
-  if (r != ONIG_NORMAL)
-    return generate_error(L, ud, r);
-
-  if ((ud->region = onig_region_new()) == NULL)
-    return luaL_error(L, "`onig_region_new' failed");
-
-  if (pud) *pud = ud;
-  return 1;
-}
-
-typedef struct {
-  lua_State *L;
-  TOnig *ud;
-  const char *text;
-} TNameArg;
-
-static int name_callback (const UChar *name, const UChar *name_end,
-      int ngroups, int *groupnumlist, regex_t *reg, void *arg)
-{
-  (void) ngroups;
-  (void) groupnumlist;
-  TNameArg *A = (TNameArg*)arg;
-  int num = onig_name_to_backref_number(reg, name, name_end, A->ud->region);
-  lua_pushlstring (A->L, (const char*)name, name_end - name);
-  ALG_PUSHSUB_OR_FALSE (A->L, A->ud, A->text, num);
-  lua_rawset (A->L, -3);
-  return 0;
-}
-
-/* the target table must be on lua stack top */
-static void do_named_subpatterns (lua_State *L, TOnig *ud, const char *text) {
-  if (onig_number_of_names (ud->reg) > 0) {
-    TNameArg A = { L, ud, text };
-    onig_foreach_name(ud->reg, name_callback, &A);
-  }
-}
-
-static int findmatch_exec (TUserdata *ud, TArgExec *argE) {
-  const char *end = argE->text + argE->textlen;
-  onig_region_clear(ud->region);
-  return onig_search (ud->reg, (CUC)argE->text, (CUC)end,
-                      (CUC)argE->text + argE->startoffset, (CUC)end,
-                      ud->region, argE->eflags);
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int gmatch_exec (TOnig *ud, TArgExec *argE) {
-  return findmatch_exec(ud, argE);
-}
-
-static int gsub_exec (TOnig *ud, TArgExec *argE, int st) {
-  const char *end = argE->text + argE->textlen;
-  onig_region_clear(ud->region);
-  return onig_search (ud->reg, (CUC)argE->text, (CUC)end, (CUC)argE->text + st,
-    (CUC)end, ud->region, argE->eflags);
-}
-
-static int split_exec (TOnig *ud, TArgExec *argE, int st) {
-  return gsub_exec(ud, argE, st);
-}
-
-static int LOnig_capturecount (lua_State *L) {
-  TOnig *ud = check_ud(L);
-  lua_pushinteger(L, onig_number_of_captures(ud->reg));
-  return 1;
-}
-
-static int LOnig_gc (lua_State *L) {
-  TOnig *ud = check_ud (L);
-  if (ud->reg) {           /* precaution against "manual" __gc calling */
-    onig_free (ud->reg);
-    ud->reg = NULL;
-  }
-  if (ud->region) {
-    onig_region_free (ud->region, 1);
-    ud->region = NULL;
-  }
-  return 0;
-}
-
-static int LOnig_tostring (lua_State *L) {
-  TOnig *ud = check_ud (L);
-  if (ud->reg)
-    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
-  else
-    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
-  return 1;
-}
-
-static int LOnig_version (lua_State *L) {
-  lua_pushstring (L, onig_version ());
-  return 1;
-}
-
-static int LOnig_internal_test (lua_State *L) {
-  unsigned int i;
-  for (i=1; i<sizeof(Encodings)/sizeof(Encodings[0]); i++) {
-    if (fcmp(&Encodings[i-1], &Encodings[i]) >= 0) {
-      lua_pushboolean(L, 0);
-      lua_pushstring(L, "Array 'Encodings' is not properly sorted.");
-      return 2;
-    }
-  }
-  for (i=1; i<sizeof(Syntaxes)/sizeof(Syntaxes[0]); i++) {
-    if (fcmp(&Syntaxes[i-1], &Syntaxes[i]) >= 0) {
-      lua_pushboolean(L, 0);
-      lua_pushstring(L, "Array 'Syntaxes' is not properly sorted.");
-      return 2;
-    }
-  }
-  lua_pushboolean(L, 1);
-  return 1;
-}
-
-static const luaL_Reg r_methods[] = {
-  { "exec",        algm_exec },
-  { "tfind",       algm_tfind },    /* old name: match */
-  { "find",        algm_find },
-  { "match",       algm_match },
-  { "capturecount", LOnig_capturecount },
-  { "__gc",        LOnig_gc },
-  { "__tostring",  LOnig_tostring },
-  { NULL, NULL }
-};
-
-static const luaL_Reg r_functions[] = {
-  { "match",            algf_match },
-  { "find",             algf_find },
-  { "gmatch",           algf_gmatch },
-  { "gsub",             algf_gsub },
-  { "count",            algf_count },
-  { "split",            algf_split },
-  { "new",              algf_new },
-  { "flags",            LOnig_get_flags },
-  { "version",          LOnig_version },
-  { "setdefaultsyntax", LOnig_setdefaultsyntax },
-  { "internal_test",    LOnig_internal_test },
-  { NULL, NULL }
-};
-
-/* Open the library */
-REX_API int REX_OPENLIB (lua_State *L) {
-  if (ONIGURUMA_VERSION_MAJOR > atoi (onig_version ())) {
-    return luaL_error (L, "%s requires at least version %d of Oniguruma library",
-      REX_LIBNAME, (int)ONIGURUMA_VERSION_MAJOR);
-  }
-  onig_init();
-  onig_set_default_syntax(ONIG_SYNTAX_RUBY);
-  alg_register(L, r_methods, r_functions, "Oniguruma");
-  return 1;
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/oniguruma/lonig_f.c src/src/oniguruma/lonig_f.c
--- upstream/src/oniguruma/lonig_f.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/oniguruma/lonig_f.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,540 +0,0 @@
-/* lonig_f.c - Lua binding of Oniguruma library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <oniguruma.h>
-#include <lua.h>
-#include <lauxlib.h>
-#include "../common.h"
-
-static flag_pair onig_flags[] = {
-#ifdef ONIG_INFINITE_DISTANCE
-  { "ONIG_INFINITE_DISTANCE",                   ONIG_INFINITE_DISTANCE },
-#endif
-#ifdef ONIG_NREGION
-  { "ONIG_NREGION",                             ONIG_NREGION },
-#endif
-#ifdef ONIG_MAX_BACKREF_NUM
-  { "ONIG_MAX_BACKREF_NUM",                     ONIG_MAX_BACKREF_NUM },
-#endif
-#ifdef ONIG_MAX_REPEAT_NUM
-  { "ONIG_MAX_REPEAT_NUM",                      ONIG_MAX_REPEAT_NUM },
-#endif
-#ifdef ONIG_MAX_MULTI_BYTE_RANGES_NUM
-  { "ONIG_MAX_MULTI_BYTE_RANGES_NUM",           ONIG_MAX_MULTI_BYTE_RANGES_NUM },
-#endif
-#ifdef ONIG_MAX_ERROR_MESSAGE_LEN
-  { "ONIG_MAX_ERROR_MESSAGE_LEN",               ONIG_MAX_ERROR_MESSAGE_LEN },
-#endif
-#ifdef ONIG_OPTION_DEFAULT
-  { "ONIG_OPTION_DEFAULT",                      ONIG_OPTION_DEFAULT },
-  { "DEFAULT",                                  ONIG_OPTION_DEFAULT },
-#endif
-#ifdef ONIG_OPTION_NONE
-  { "ONIG_OPTION_NONE",                         ONIG_OPTION_NONE },
-  { "NONE",                                     ONIG_OPTION_NONE },
-#endif
-#ifdef ONIG_OPTION_IGNORECASE
-  { "ONIG_OPTION_IGNORECASE",                   ONIG_OPTION_IGNORECASE },
-  { "IGNORECASE",                               ONIG_OPTION_IGNORECASE },
-#endif
-#ifdef ONIG_OPTION_EXTEND
-  { "ONIG_OPTION_EXTEND",                       ONIG_OPTION_EXTEND },
-  { "EXTEND",                                   ONIG_OPTION_EXTEND },
-#endif
-#ifdef ONIG_OPTION_MULTILINE
-  { "ONIG_OPTION_MULTILINE",                    ONIG_OPTION_MULTILINE },
-  { "MULTILINE",                                ONIG_OPTION_MULTILINE },
-#endif
-#ifdef ONIG_OPTION_SINGLELINE
-  { "ONIG_OPTION_SINGLELINE",                   ONIG_OPTION_SINGLELINE },
-  { "SINGLELINE",                               ONIG_OPTION_SINGLELINE },
-#endif
-#ifdef ONIG_OPTION_FIND_LONGEST
-  { "ONIG_OPTION_FIND_LONGEST",                 ONIG_OPTION_FIND_LONGEST },
-  { "FIND_LONGEST",                             ONIG_OPTION_FIND_LONGEST },
-#endif
-#ifdef ONIG_OPTION_FIND_NOT_EMPTY
-  { "ONIG_OPTION_FIND_NOT_EMPTY",               ONIG_OPTION_FIND_NOT_EMPTY },
-  { "FIND_NOT_EMPTY",                           ONIG_OPTION_FIND_NOT_EMPTY },
-#endif
-#ifdef ONIG_OPTION_NEGATE_SINGLELINE
-  { "ONIG_OPTION_NEGATE_SINGLELINE",            ONIG_OPTION_NEGATE_SINGLELINE },
-  { "NEGATE_SINGLELINE",                        ONIG_OPTION_NEGATE_SINGLELINE },
-#endif
-#ifdef ONIG_OPTION_DONT_CAPTURE_GROUP
-  { "ONIG_OPTION_DONT_CAPTURE_GROUP",           ONIG_OPTION_DONT_CAPTURE_GROUP },
-  { "DONT_CAPTURE_GROUP",                       ONIG_OPTION_DONT_CAPTURE_GROUP },
-#endif
-#ifdef ONIG_OPTION_CAPTURE_GROUP
-  { "ONIG_OPTION_CAPTURE_GROUP",                ONIG_OPTION_CAPTURE_GROUP },
-  { "CAPTURE_GROUP",                            ONIG_OPTION_CAPTURE_GROUP },
-#endif
-#ifdef ONIG_OPTION_NOTBOL
-  { "ONIG_OPTION_NOTBOL",                       ONIG_OPTION_NOTBOL },
-  { "NOTBOL",                                   ONIG_OPTION_NOTBOL },
-#endif
-#ifdef ONIG_OPTION_NOTEOL
-  { "ONIG_OPTION_NOTEOL",                       ONIG_OPTION_NOTEOL },
-  { "NOTEOL",                                   ONIG_OPTION_NOTEOL },
-#endif
-#ifdef ONIG_OPTION_POSIX_REGION
-  { "ONIG_OPTION_POSIX_REGION",                 ONIG_OPTION_POSIX_REGION },
-  { "POSIX_REGION",                             ONIG_OPTION_POSIX_REGION },
-#endif
-#ifdef ONIG_OPTION_MAXBIT
-  { "ONIG_OPTION_MAXBIT",                       ONIG_OPTION_MAXBIT },
-  { "MAXBIT",                                   ONIG_OPTION_MAXBIT },
-#endif
-#ifdef ONIG_SYN_OP_VARIABLE_META_CHARACTERS
-  { "ONIG_SYN_OP_VARIABLE_META_CHARACTERS",     ONIG_SYN_OP_VARIABLE_META_CHARACTERS },
-#endif
-#ifdef ONIG_SYN_OP_DOT_ANYCHAR
-  { "ONIG_SYN_OP_DOT_ANYCHAR",                  ONIG_SYN_OP_DOT_ANYCHAR },
-#endif
-#ifdef ONIG_SYN_OP_ASTERISK_ZERO_INF
-  { "ONIG_SYN_OP_ASTERISK_ZERO_INF",            ONIG_SYN_OP_ASTERISK_ZERO_INF },
-#endif
-#ifdef ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF
-  { "ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF",        ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF },
-#endif
-#ifdef ONIG_SYN_OP_PLUS_ONE_INF
-  { "ONIG_SYN_OP_PLUS_ONE_INF",                 ONIG_SYN_OP_PLUS_ONE_INF },
-#endif
-#ifdef ONIG_SYN_OP_ESC_PLUS_ONE_INF
-  { "ONIG_SYN_OP_ESC_PLUS_ONE_INF",             ONIG_SYN_OP_ESC_PLUS_ONE_INF },
-#endif
-#ifdef ONIG_SYN_OP_QMARK_ZERO_ONE
-  { "ONIG_SYN_OP_QMARK_ZERO_ONE",               ONIG_SYN_OP_QMARK_ZERO_ONE },
-#endif
-#ifdef ONIG_SYN_OP_ESC_QMARK_ZERO_ONE
-  { "ONIG_SYN_OP_ESC_QMARK_ZERO_ONE",           ONIG_SYN_OP_ESC_QMARK_ZERO_ONE },
-#endif
-#ifdef ONIG_SYN_OP_BRACE_INTERVAL
-  { "ONIG_SYN_OP_BRACE_INTERVAL",               ONIG_SYN_OP_BRACE_INTERVAL },
-#endif
-#ifdef ONIG_SYN_OP_ESC_BRACE_INTERVAL
-  { "ONIG_SYN_OP_ESC_BRACE_INTERVAL",           ONIG_SYN_OP_ESC_BRACE_INTERVAL },
-#endif
-#ifdef ONIG_SYN_OP_VBAR_ALT
-  { "ONIG_SYN_OP_VBAR_ALT",                     ONIG_SYN_OP_VBAR_ALT },
-#endif
-#ifdef ONIG_SYN_OP_ESC_VBAR_ALT
-  { "ONIG_SYN_OP_ESC_VBAR_ALT",                 ONIG_SYN_OP_ESC_VBAR_ALT },
-#endif
-#ifdef ONIG_SYN_OP_LPAREN_SUBEXP
-  { "ONIG_SYN_OP_LPAREN_SUBEXP",                ONIG_SYN_OP_LPAREN_SUBEXP },
-#endif
-#ifdef ONIG_SYN_OP_ESC_LPAREN_SUBEXP
-  { "ONIG_SYN_OP_ESC_LPAREN_SUBEXP",            ONIG_SYN_OP_ESC_LPAREN_SUBEXP },
-#endif
-#ifdef ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR
-  { "ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR",            ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR },
-#endif
-#ifdef ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR
-  { "ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR",   ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR },
-#endif
-#ifdef ONIG_SYN_OP_DECIMAL_BACKREF
-  { "ONIG_SYN_OP_DECIMAL_BACKREF",              ONIG_SYN_OP_DECIMAL_BACKREF },
-#endif
-#ifdef ONIG_SYN_OP_BRACKET_CC
-  { "ONIG_SYN_OP_BRACKET_CC",                   ONIG_SYN_OP_BRACKET_CC },
-#endif
-#ifdef ONIG_SYN_OP_ESC_W_WORD
-  { "ONIG_SYN_OP_ESC_W_WORD",                   ONIG_SYN_OP_ESC_W_WORD },
-#endif
-#ifdef ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END
-  { "ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END",      ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END },
-#endif
-#ifdef ONIG_SYN_OP_ESC_B_WORD_BOUND
-  { "ONIG_SYN_OP_ESC_B_WORD_BOUND",             ONIG_SYN_OP_ESC_B_WORD_BOUND },
-#endif
-#ifdef ONIG_SYN_OP_ESC_S_WHITE_SPACE
-  { "ONIG_SYN_OP_ESC_S_WHITE_SPACE",            ONIG_SYN_OP_ESC_S_WHITE_SPACE },
-#endif
-#ifdef ONIG_SYN_OP_ESC_D_DIGIT
-  { "ONIG_SYN_OP_ESC_D_DIGIT",                  ONIG_SYN_OP_ESC_D_DIGIT },
-#endif
-#ifdef ONIG_SYN_OP_LINE_ANCHOR
-  { "ONIG_SYN_OP_LINE_ANCHOR",                  ONIG_SYN_OP_LINE_ANCHOR },
-#endif
-#ifdef ONIG_SYN_OP_POSIX_BRACKET
-  { "ONIG_SYN_OP_POSIX_BRACKET",                ONIG_SYN_OP_POSIX_BRACKET },
-#endif
-#ifdef ONIG_SYN_OP_QMARK_NON_GREEDY
-  { "ONIG_SYN_OP_QMARK_NON_GREEDY",             ONIG_SYN_OP_QMARK_NON_GREEDY },
-#endif
-#ifdef ONIG_SYN_OP_ESC_CONTROL_CHARS
-  { "ONIG_SYN_OP_ESC_CONTROL_CHARS",            ONIG_SYN_OP_ESC_CONTROL_CHARS },
-#endif
-#ifdef ONIG_SYN_OP_ESC_C_CONTROL
-  { "ONIG_SYN_OP_ESC_C_CONTROL",                ONIG_SYN_OP_ESC_C_CONTROL },
-#endif
-#ifdef ONIG_SYN_OP_ESC_OCTAL3
-  { "ONIG_SYN_OP_ESC_OCTAL3",                   ONIG_SYN_OP_ESC_OCTAL3 },
-#endif
-#ifdef ONIG_SYN_OP_ESC_X_HEX2
-  { "ONIG_SYN_OP_ESC_X_HEX2",                   ONIG_SYN_OP_ESC_X_HEX2 },
-#endif
-#ifdef ONIG_SYN_OP_ESC_X_BRACE_HEX8
-  { "ONIG_SYN_OP_ESC_X_BRACE_HEX8",             ONIG_SYN_OP_ESC_X_BRACE_HEX8 },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE
-  { "ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE",         ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE },
-#endif
-#ifdef ONIG_SYN_OP2_QMARK_GROUP_EFFECT
-  { "ONIG_SYN_OP2_QMARK_GROUP_EFFECT",          ONIG_SYN_OP2_QMARK_GROUP_EFFECT },
-#endif
-#ifdef ONIG_SYN_OP2_OPTION_PERL
-  { "ONIG_SYN_OP2_OPTION_PERL",                 ONIG_SYN_OP2_OPTION_PERL },
-#endif
-#ifdef ONIG_SYN_OP2_OPTION_RUBY
-  { "ONIG_SYN_OP2_OPTION_RUBY",                 ONIG_SYN_OP2_OPTION_RUBY },
-#endif
-#ifdef ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT
-  { "ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT",      ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT },
-#endif
-#ifdef ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL
-  { "ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL",    ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL },
-#endif
-#ifdef ONIG_SYN_OP2_CCLASS_SET_OP
-  { "ONIG_SYN_OP2_CCLASS_SET_OP",               ONIG_SYN_OP2_CCLASS_SET_OP },
-#endif
-#ifdef ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP
-  { "ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP",        ONIG_SYN_OP2_QMARK_LT_NAMED_GROUP },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_K_NAMED_BACKREF
-  { "ONIG_SYN_OP2_ESC_K_NAMED_BACKREF",         ONIG_SYN_OP2_ESC_K_NAMED_BACKREF },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_G_SUBEXP_CALL
-  { "ONIG_SYN_OP2_ESC_G_SUBEXP_CALL",           ONIG_SYN_OP2_ESC_G_SUBEXP_CALL },
-#endif
-#ifdef ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY
-  { "ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY",      ONIG_SYN_OP2_ATMARK_CAPTURE_HISTORY },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL
-  { "ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL",   ONIG_SYN_OP2_ESC_CAPITAL_C_BAR_CONTROL },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META
-  { "ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META",      ONIG_SYN_OP2_ESC_CAPITAL_M_BAR_META },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_V_VTAB
-  { "ONIG_SYN_OP2_ESC_V_VTAB",                  ONIG_SYN_OP2_ESC_V_VTAB },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_U_HEX4
-  { "ONIG_SYN_OP2_ESC_U_HEX4",                  ONIG_SYN_OP2_ESC_U_HEX4 },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR
-  { "ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR",          ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY
-  { "ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY",   ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT
-  { "ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT",  ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT },
-#endif
-#ifdef ONIG_SYN_OP2_ESC_H_XDIGIT
-  { "ONIG_SYN_OP2_ESC_H_XDIGIT",                ONIG_SYN_OP2_ESC_H_XDIGIT },
-#endif
-#ifdef ONIG_SYN_OP2_INEFFECTIVE_ESCAPE
-  { "ONIG_SYN_OP2_INEFFECTIVE_ESCAPE",          ONIG_SYN_OP2_INEFFECTIVE_ESCAPE },
-#endif
-#ifdef ONIG_SYN_CONTEXT_INDEP_ANCHORS
-  { "ONIG_SYN_CONTEXT_INDEP_ANCHORS",           ONIG_SYN_CONTEXT_INDEP_ANCHORS },
-#endif
-#ifdef ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS
-  { "ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS",        ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS },
-#endif
-#ifdef ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS
-  { "ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS",      ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS },
-#endif
-#ifdef ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP
-  { "ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP",    ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP },
-#endif
-#ifdef ONIG_SYN_ALLOW_INVALID_INTERVAL
-  { "ONIG_SYN_ALLOW_INVALID_INTERVAL",          ONIG_SYN_ALLOW_INVALID_INTERVAL },
-#endif
-#ifdef ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV
-  { "ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV",       ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV },
-#endif
-#ifdef ONIG_SYN_STRICT_CHECK_BACKREF
-  { "ONIG_SYN_STRICT_CHECK_BACKREF",            ONIG_SYN_STRICT_CHECK_BACKREF },
-#endif
-#ifdef ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND
-  { "ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND",   ONIG_SYN_DIFFERENT_LEN_ALT_LOOK_BEHIND },
-#endif
-#ifdef ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP
-  { "ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP",        ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP },
-#endif
-#ifdef ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME
-  { "ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME", ONIG_SYN_ALLOW_MULTIPLEX_DEFINITION_NAME },
-#endif
-#ifdef ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY
-  { "ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY",   ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY },
-#endif
-#ifdef ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC
-  { "ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC",      ONIG_SYN_NOT_NEWLINE_IN_NEGATIVE_CC },
-#endif
-#ifdef ONIG_SYN_BACKSLASH_ESCAPE_IN_CC
-  { "ONIG_SYN_BACKSLASH_ESCAPE_IN_CC",          ONIG_SYN_BACKSLASH_ESCAPE_IN_CC },
-#endif
-#ifdef ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC
-  { "ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC",         ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC },
-#endif
-#ifdef ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC
-  { "ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC",     ONIG_SYN_ALLOW_DOUBLE_RANGE_OP_IN_CC },
-#endif
-#ifdef ONIG_SYN_WARN_CC_OP_NOT_ESCAPED
-  { "ONIG_SYN_WARN_CC_OP_NOT_ESCAPED",          ONIG_SYN_WARN_CC_OP_NOT_ESCAPED },
-#endif
-#ifdef ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT
-  { "ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT",    ONIG_SYN_WARN_REDUNDANT_NESTED_REPEAT },
-#endif
-#ifdef ONIG_META_CHAR_ESCAPE
-  { "ONIG_META_CHAR_ESCAPE",                    ONIG_META_CHAR_ESCAPE },
-#endif
-#ifdef ONIG_META_CHAR_ANYCHAR
-  { "ONIG_META_CHAR_ANYCHAR",                   ONIG_META_CHAR_ANYCHAR },
-#endif
-#ifdef ONIG_META_CHAR_ANYTIME
-  { "ONIG_META_CHAR_ANYTIME",                   ONIG_META_CHAR_ANYTIME },
-#endif
-#ifdef ONIG_META_CHAR_ZERO_OR_ONE_TIME
-  { "ONIG_META_CHAR_ZERO_OR_ONE_TIME",          ONIG_META_CHAR_ZERO_OR_ONE_TIME },
-#endif
-#ifdef ONIG_META_CHAR_ONE_OR_MORE_TIME
-  { "ONIG_META_CHAR_ONE_OR_MORE_TIME",          ONIG_META_CHAR_ONE_OR_MORE_TIME },
-#endif
-#ifdef ONIG_META_CHAR_ANYCHAR_ANYTIME
-  { "ONIG_META_CHAR_ANYCHAR_ANYTIME",           ONIG_META_CHAR_ANYCHAR_ANYTIME },
-#endif
-#ifdef ONIG_INEFFECTIVE_META_CHAR
-  { "ONIG_INEFFECTIVE_META_CHAR",               ONIG_INEFFECTIVE_META_CHAR },
-#endif
-#ifdef ONIG_NORMAL
-  { "ONIG_NORMAL",                              ONIG_NORMAL },
-#endif
-#ifdef ONIG_MISMATCH
-  { "ONIG_MISMATCH",                            ONIG_MISMATCH },
-#endif
-#ifdef ONIG_NO_SUPPORT_CONFIG
-  { "ONIG_NO_SUPPORT_CONFIG",                   ONIG_NO_SUPPORT_CONFIG },
-#endif
-#ifdef ONIG_MAX_CAPTURE_HISTORY_GROUP
-  { "ONIG_MAX_CAPTURE_HISTORY_GROUP",           ONIG_MAX_CAPTURE_HISTORY_GROUP },
-#endif
-#ifdef ONIG_TRAVERSE_CALLBACK_AT_FIRST
-  { "ONIG_TRAVERSE_CALLBACK_AT_FIRST",          ONIG_TRAVERSE_CALLBACK_AT_FIRST },
-#endif
-#ifdef ONIG_TRAVERSE_CALLBACK_AT_LAST
-  { "ONIG_TRAVERSE_CALLBACK_AT_LAST",           ONIG_TRAVERSE_CALLBACK_AT_LAST },
-#endif
-#ifdef ONIG_TRAVERSE_CALLBACK_AT_BOTH
-  { "ONIG_TRAVERSE_CALLBACK_AT_BOTH",           ONIG_TRAVERSE_CALLBACK_AT_BOTH },
-#endif
-#ifdef ONIG_REGION_NOTPOS
-  { "ONIG_REGION_NOTPOS",                       ONIG_REGION_NOTPOS },
-#endif
-#ifdef ONIG_CHAR_TABLE_SIZE
-  { "ONIG_CHAR_TABLE_SIZE",                     ONIG_CHAR_TABLE_SIZE },
-#endif
-#ifdef ONIG_STATE_NORMAL
-  { "ONIG_STATE_NORMAL",                        ONIG_STATE_NORMAL },
-#endif
-#ifdef ONIG_STATE_SEARCHING
-  { "ONIG_STATE_SEARCHING",                     ONIG_STATE_SEARCHING },
-#endif
-#ifdef ONIG_STATE_COMPILING
-  { "ONIG_STATE_COMPILING",                     ONIG_STATE_COMPILING },
-#endif
-#ifdef ONIG_STATE_MODIFY
-  { "ONIG_STATE_MODIFY",                        ONIG_STATE_MODIFY },
-#endif
-  { NULL, 0 }
-};
-
-static flag_pair onig_error_flags[] = {
-#ifdef ONIGERR_MEMORY
-  { "ONIGERR_MEMORY",                                       ONIGERR_MEMORY },
-#endif
-#ifdef ONIGERR_TYPE_BUG
-  { "ONIGERR_TYPE_BUG",                                     ONIGERR_TYPE_BUG },
-#endif
-#ifdef ONIGERR_PARSER_BUG
-  { "ONIGERR_PARSER_BUG",                                   ONIGERR_PARSER_BUG },
-#endif
-#ifdef ONIGERR_STACK_BUG
-  { "ONIGERR_STACK_BUG",                                    ONIGERR_STACK_BUG },
-#endif
-#ifdef ONIGERR_UNDEFINED_BYTECODE
-  { "ONIGERR_UNDEFINED_BYTECODE",                           ONIGERR_UNDEFINED_BYTECODE },
-#endif
-#ifdef ONIGERR_UNEXPECTED_BYTECODE
-  { "ONIGERR_UNEXPECTED_BYTECODE",                          ONIGERR_UNEXPECTED_BYTECODE },
-#endif
-#ifdef ONIGERR_MATCH_STACK_LIMIT_OVER
-  { "ONIGERR_MATCH_STACK_LIMIT_OVER",                       ONIGERR_MATCH_STACK_LIMIT_OVER },
-#endif
-#ifdef ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED
-  { "ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED",               ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED },
-#endif
-#ifdef ONIGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR
-  { "ONIGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR", ONIGERR_SPECIFIED_ENCODING_CANT_CONVERT_TO_WIDE_CHAR },
-#endif
-#ifdef ONIGERR_INVALID_ARGUMENT
-  { "ONIGERR_INVALID_ARGUMENT",                             ONIGERR_INVALID_ARGUMENT },
-#endif
-#ifdef ONIGERR_END_PATTERN_AT_LEFT_BRACE
-  { "ONIGERR_END_PATTERN_AT_LEFT_BRACE",                    ONIGERR_END_PATTERN_AT_LEFT_BRACE },
-#endif
-#ifdef ONIGERR_END_PATTERN_AT_LEFT_BRACKET
-  { "ONIGERR_END_PATTERN_AT_LEFT_BRACKET",                  ONIGERR_END_PATTERN_AT_LEFT_BRACKET },
-#endif
-#ifdef ONIGERR_EMPTY_CHAR_CLASS
-  { "ONIGERR_EMPTY_CHAR_CLASS",                             ONIGERR_EMPTY_CHAR_CLASS },
-#endif
-#ifdef ONIGERR_PREMATURE_END_OF_CHAR_CLASS
-  { "ONIGERR_PREMATURE_END_OF_CHAR_CLASS",                  ONIGERR_PREMATURE_END_OF_CHAR_CLASS },
-#endif
-#ifdef ONIGERR_END_PATTERN_AT_ESCAPE
-  { "ONIGERR_END_PATTERN_AT_ESCAPE",                        ONIGERR_END_PATTERN_AT_ESCAPE },
-#endif
-#ifdef ONIGERR_END_PATTERN_AT_META
-  { "ONIGERR_END_PATTERN_AT_META",                          ONIGERR_END_PATTERN_AT_META },
-#endif
-#ifdef ONIGERR_END_PATTERN_AT_CONTROL
-  { "ONIGERR_END_PATTERN_AT_CONTROL",                       ONIGERR_END_PATTERN_AT_CONTROL },
-#endif
-#ifdef ONIGERR_META_CODE_SYNTAX
-  { "ONIGERR_META_CODE_SYNTAX",                             ONIGERR_META_CODE_SYNTAX },
-#endif
-#ifdef ONIGERR_CONTROL_CODE_SYNTAX
-  { "ONIGERR_CONTROL_CODE_SYNTAX",                          ONIGERR_CONTROL_CODE_SYNTAX },
-#endif
-#ifdef ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE
-  { "ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE",             ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE },
-#endif
-#ifdef ONIGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE
-  { "ONIGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE",           ONIGERR_CHAR_CLASS_VALUE_AT_START_OF_RANGE },
-#endif
-#ifdef ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS
-  { "ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS",      ONIGERR_UNMATCHED_RANGE_SPECIFIER_IN_CHAR_CLASS },
-#endif
-#ifdef ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED
-  { "ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED",      ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED },
-#endif
-#ifdef ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID
-  { "ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID",            ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID },
-#endif
-#ifdef ONIGERR_NESTED_REPEAT_OPERATOR
-  { "ONIGERR_NESTED_REPEAT_OPERATOR",                       ONIGERR_NESTED_REPEAT_OPERATOR },
-#endif
-#ifdef ONIGERR_UNMATCHED_CLOSE_PARENTHESIS
-  { "ONIGERR_UNMATCHED_CLOSE_PARENTHESIS",                  ONIGERR_UNMATCHED_CLOSE_PARENTHESIS },
-#endif
-#ifdef ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS
-  { "ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS",       ONIGERR_END_PATTERN_WITH_UNMATCHED_PARENTHESIS },
-#endif
-#ifdef ONIGERR_END_PATTERN_IN_GROUP
-  { "ONIGERR_END_PATTERN_IN_GROUP",                         ONIGERR_END_PATTERN_IN_GROUP },
-#endif
-#ifdef ONIGERR_UNDEFINED_GROUP_OPTION
-  { "ONIGERR_UNDEFINED_GROUP_OPTION",                       ONIGERR_UNDEFINED_GROUP_OPTION },
-#endif
-#ifdef ONIGERR_INVALID_POSIX_BRACKET_TYPE
-  { "ONIGERR_INVALID_POSIX_BRACKET_TYPE",                   ONIGERR_INVALID_POSIX_BRACKET_TYPE },
-#endif
-#ifdef ONIGERR_INVALID_LOOK_BEHIND_PATTERN
-  { "ONIGERR_INVALID_LOOK_BEHIND_PATTERN",                  ONIGERR_INVALID_LOOK_BEHIND_PATTERN },
-#endif
-#ifdef ONIGERR_INVALID_REPEAT_RANGE_PATTERN
-  { "ONIGERR_INVALID_REPEAT_RANGE_PATTERN",                 ONIGERR_INVALID_REPEAT_RANGE_PATTERN },
-#endif
-#ifdef ONIGERR_TOO_BIG_NUMBER
-  { "ONIGERR_TOO_BIG_NUMBER",                               ONIGERR_TOO_BIG_NUMBER },
-#endif
-#ifdef ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE
-  { "ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE",              ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE },
-#endif
-#ifdef ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE
-  { "ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE",     ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE },
-#endif
-#ifdef ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS
-  { "ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS",                    ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS },
-#endif
-#ifdef ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE
-  { "ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE",          ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE },
-#endif
-#ifdef ONIGERR_TOO_MANY_MULTI_BYTE_RANGES
-  { "ONIGERR_TOO_MANY_MULTI_BYTE_RANGES",                   ONIGERR_TOO_MANY_MULTI_BYTE_RANGES },
-#endif
-#ifdef ONIGERR_TOO_SHORT_MULTI_BYTE_STRING
-  { "ONIGERR_TOO_SHORT_MULTI_BYTE_STRING",                  ONIGERR_TOO_SHORT_MULTI_BYTE_STRING },
-#endif
-#ifdef ONIGERR_TOO_BIG_BACKREF_NUMBER
-  { "ONIGERR_TOO_BIG_BACKREF_NUMBER",                       ONIGERR_TOO_BIG_BACKREF_NUMBER },
-#endif
-#ifdef ONIGERR_INVALID_BACKREF
-  { "ONIGERR_INVALID_BACKREF",                              ONIGERR_INVALID_BACKREF },
-#endif
-#ifdef ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED
-  { "ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED",         ONIGERR_NUMBERED_BACKREF_OR_CALL_NOT_ALLOWED },
-#endif
-#ifdef ONIGERR_TOO_LONG_WIDE_CHAR_VALUE
-  { "ONIGERR_TOO_LONG_WIDE_CHAR_VALUE",                     ONIGERR_TOO_LONG_WIDE_CHAR_VALUE },
-#endif
-#ifdef ONIGERR_EMPTY_GROUP_NAME
-  { "ONIGERR_EMPTY_GROUP_NAME",                             ONIGERR_EMPTY_GROUP_NAME },
-#endif
-#ifdef ONIGERR_INVALID_GROUP_NAME
-  { "ONIGERR_INVALID_GROUP_NAME",                           ONIGERR_INVALID_GROUP_NAME },
-#endif
-#ifdef ONIGERR_INVALID_CHAR_IN_GROUP_NAME
-  { "ONIGERR_INVALID_CHAR_IN_GROUP_NAME",                   ONIGERR_INVALID_CHAR_IN_GROUP_NAME },
-#endif
-#ifdef ONIGERR_UNDEFINED_NAME_REFERENCE
-  { "ONIGERR_UNDEFINED_NAME_REFERENCE",                     ONIGERR_UNDEFINED_NAME_REFERENCE },
-#endif
-#ifdef ONIGERR_UNDEFINED_GROUP_REFERENCE
-  { "ONIGERR_UNDEFINED_GROUP_REFERENCE",                    ONIGERR_UNDEFINED_GROUP_REFERENCE },
-#endif
-#ifdef ONIGERR_MULTIPLEX_DEFINED_NAME
-  { "ONIGERR_MULTIPLEX_DEFINED_NAME",                       ONIGERR_MULTIPLEX_DEFINED_NAME },
-#endif
-#ifdef ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL
-  { "ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL",               ONIGERR_MULTIPLEX_DEFINITION_NAME_CALL },
-#endif
-#ifdef ONIGERR_NEVER_ENDING_RECURSION
-  { "ONIGERR_NEVER_ENDING_RECURSION",                       ONIGERR_NEVER_ENDING_RECURSION },
-#endif
-#ifdef ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY
-  { "ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY",        ONIGERR_GROUP_NUMBER_OVER_FOR_CAPTURE_HISTORY },
-#endif
-#ifdef ONIGERR_INVALID_CHAR_PROPERTY_NAME
-  { "ONIGERR_INVALID_CHAR_PROPERTY_NAME",                   ONIGERR_INVALID_CHAR_PROPERTY_NAME },
-#endif
-#ifdef ONIGERR_INVALID_CODE_POINT_VALUE
-  { "ONIGERR_INVALID_CODE_POINT_VALUE",                     ONIGERR_INVALID_CODE_POINT_VALUE },
-#endif
-#ifdef ONIGERR_INVALID_WIDE_CHAR_VALUE
-  { "ONIGERR_INVALID_WIDE_CHAR_VALUE",                      ONIGERR_INVALID_WIDE_CHAR_VALUE },
-#endif
-#ifdef ONIGERR_TOO_BIG_WIDE_CHAR_VALUE
-  { "ONIGERR_TOO_BIG_WIDE_CHAR_VALUE",                      ONIGERR_TOO_BIG_WIDE_CHAR_VALUE },
-#endif
-#ifdef ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION
-  { "ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION",           ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION },
-#endif
-#ifdef ONIGERR_INVALID_COMBINATION_OF_OPTIONS
-  { "ONIGERR_INVALID_COMBINATION_OF_OPTIONS",               ONIGERR_INVALID_COMBINATION_OF_OPTIONS },
-#endif
-#ifdef ONIGERR_OVER_THREAD_PASS_LIMIT_COUNT
-  { "ONIGERR_OVER_THREAD_PASS_LIMIT_COUNT",                 ONIGERR_OVER_THREAD_PASS_LIMIT_COUNT },
-#endif
-  { NULL, 0 }
-};
-
-int LOnig_get_flags (lua_State *L) {
-  const flag_pair* fps[] = { onig_flags, onig_error_flags, NULL };
-  return get_flags (L, fps);
-}
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pcre/lpcre.c src/src/pcre/lpcre.c
--- upstream/src/pcre/lpcre.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/pcre/lpcre.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,485 +0,0 @@
-/* lpcre.c - Lua binding of PCRE library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <locale.h>
-#include <ctype.h>
-#include <stdint.h>
-#include <pcre.h>
-
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-extern int Lpcre_get_flags (lua_State *L);
-extern int Lpcre_config (lua_State *L);
-extern flag_pair pcre_error_flags[];
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_pcre"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_pcre
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT 0
-#define ALG_EFLAGS_DFLT 0
-
-static int getcflags (lua_State *L, int pos);
-#define ALG_GETCFLAGS(L,pos)  getcflags(L, pos)
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC);
-#define ALG_GETCARGS(a,b,c)  checkarg_compile(a,b,c)
-
-#define ALG_NOMATCH(res)   ((res) == PCRE_ERROR_NOMATCH)
-#define ALG_ISMATCH(res)   ((res) >= 0)
-#define ALG_SUBBEG(ud,n)   ud->match[n+n]
-#define ALG_SUBEND(ud,n)   ud->match[n+n+1]
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND(ud,n) - ALG_SUBBEG(ud,n))
-#define ALG_SUBVALID(ud,n) (ALG_SUBBEG(ud,n) >= 0)
-#define ALG_NSUB(ud)       ((int)ud->ncapt)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG(ud,n), ALG_SUBLEN(ud,n))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)  0
-#define ALG_PULL
-
-typedef struct {
-  pcre       * pr;
-  pcre_extra * extra;
-  int        * match;
-  int          ncapt;
-  const unsigned char * tables;
-  int          freed;
-} TPcre;
-
-#define TUserdata TPcre
-
-#if PCRE_MAJOR >= 4
-static void do_named_subpatterns (lua_State *L, TPcre *ud, const char *text);
-#  define DO_NAMED_SUBPATTERNS do_named_subpatterns
-#endif
-
-#include "../algo.h"
-
-/* Locations of the 2 permanent tables in the function environment */
-#define INDEX_CHARTABLES_META  1      /* chartables type's metatable */
-#define INDEX_CHARTABLES_LINK  2      /* link chartables to compiled regex */
-
-const char chartables_typename[] = "chartables";
-
-/*  Functions
- ******************************************************************************
- */
-
-static int getcflags (lua_State *L, int pos) {
-  switch (lua_type (L, pos)) {
-    case LUA_TNONE:
-    case LUA_TNIL:
-      return ALG_CFLAGS_DFLT;
-    case LUA_TNUMBER:
-      return lua_tointeger (L, pos);
-    case LUA_TSTRING: {
-      const char *s = lua_tostring (L, pos);
-      int res = 0, ch;
-      while ((ch = *s++) != '\0') {
-        if (ch == 'i') res |= PCRE_CASELESS;
-        else if (ch == 'm') res |= PCRE_MULTILINE;
-        else if (ch == 's') res |= PCRE_DOTALL;
-        else if (ch == 'x') res |= PCRE_EXTENDED;
-        else if (ch == 'U') res |= PCRE_UNGREEDY;
-        else if (ch == 'X') res |= PCRE_EXTRA;
-      }
-      return res;
-    }
-    default:
-      return luaL_typerror (L, pos, "number or string");
-  }
-}
-
-static int generate_error (lua_State *L, const TPcre *ud, int errcode) {
-  const char *key = get_flag_key (pcre_error_flags, errcode);
-  (void) ud;
-  if (key)
-    return luaL_error (L, "error PCRE_%s", key);
-  else
-    return luaL_error (L, "PCRE error code %d", errcode);
-}
-
-#if PCRE_MAJOR >= 6
-/* method r:dfa_exec (s, [st], [ef], [ovecsize], [wscount]) */
-static void checkarg_dfa_exec (lua_State *L, TArgExec *argE, TPcre **ud) {
-  *ud = check_ud (L);
-  argE->text = luaL_checklstring (L, 2, &argE->textlen);
-  argE->startoffset = get_startoffset (L, 3, argE->textlen);
-  argE->eflags = (int)luaL_optinteger (L, 4, ALG_EFLAGS_DFLT);
-  argE->ovecsize = (size_t)luaL_optinteger (L, 5, 100);
-  argE->wscount = (size_t)luaL_optinteger (L, 6, 50);
-}
-#endif
-
-static void push_chartables_meta (lua_State *L) {
-  lua_pushinteger (L, INDEX_CHARTABLES_META);
-  lua_rawget (L, ALG_ENVIRONINDEX);
-}
-
-static int Lpcre_maketables (lua_State *L) {
-  *(const void**)lua_newuserdata (L, sizeof(void*)) = pcre_maketables();
-  push_chartables_meta (L);
-  lua_setmetatable (L, -2);
-  return 1;
-}
-
-static void **check_chartables (lua_State *L, int pos) {
-  void **q;
-  /* Compare the metatable against the C function environment. */
-  if (lua_getmetatable(L, pos)) {
-    push_chartables_meta (L);
-    if (lua_rawequal(L, -1, -2) &&
-        (q = (void **)lua_touserdata(L, pos)) != NULL) {
-      lua_pop(L, 2);
-      return q;
-    }
-  }
-  luaL_argerror(L, pos, lua_pushfstring (L, "not a %s", chartables_typename));
-  return NULL;
-}
-
-static int chartables_gc (lua_State *L) {
-  void **ud = check_chartables (L, 1);
-  if (*ud) {
-    pcre_free (*ud);
-    *ud = NULL;
-  }
-  return 0;
-}
-
-static int chartables_tostring (lua_State *L) {
-  void **ud = check_chartables (L, 1);
-  lua_pushfstring (L, "%s (%p)", chartables_typename, ud);
-  return 1;
-}
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC) {
-  argC->locale = NULL;
-  argC->tables = NULL;
-  if (!lua_isnoneornil (L, pos)) {
-    if (lua_isstring (L, pos))
-      argC->locale = lua_tostring (L, pos);
-    else {
-      argC->tablespos = pos;
-      argC->tables = (const unsigned char*) *check_chartables (L, pos);
-    }
-  }
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TPcre **pud) {
-  const char *error;
-  int erroffset;
-  TPcre *ud;
-  const unsigned char *tables = NULL;
-
-  ud = (TPcre*)lua_newuserdata (L, sizeof (TPcre));
-  memset (ud, 0, sizeof (TPcre));           /* initialize all members to 0 */
-  lua_pushvalue (L, ALG_ENVIRONINDEX);
-  lua_setmetatable (L, -2);
-
-  if (argC->locale) {
-    char old_locale[256];
-    strcpy (old_locale, setlocale (LC_CTYPE, NULL));  /* store the locale */
-    if (NULL == setlocale (LC_CTYPE, argC->locale))   /* set new locale */
-      return luaL_error (L, "cannot set locale");
-    ud->tables = tables = pcre_maketables ();  /* make tables with new locale */
-    setlocale (LC_CTYPE, old_locale);          /* restore the old locale */
-  }
-  else if (argC->tables) {
-    tables = argC->tables;
-    lua_pushinteger (L, INDEX_CHARTABLES_LINK);
-    lua_rawget (L, ALG_ENVIRONINDEX);
-    lua_pushvalue (L, -2);
-    lua_pushvalue (L, argC->tablespos);
-    lua_rawset (L, -3);
-    lua_pop (L, 1);
-  }
-
-  ud->pr = pcre_compile (argC->pattern, argC->cflags, &error, &erroffset, tables);
-  if (!ud->pr)
-    return luaL_error (L, "%s (pattern offset: %d)", error, erroffset + 1);
-
-  ud->extra = pcre_study (ud->pr, 0, &error);
-  if (error) return luaL_error (L, "%s", error);
-
-  pcre_fullinfo (ud->pr, ud->extra, PCRE_INFO_CAPTURECOUNT, &ud->ncapt);
-  /* need (2 ints per capture, plus one for substring match) * 3/2 */
-  ud->match = (int *) Lmalloc (L, (ALG_NSUB(ud) + 1) * 3 * sizeof (int));
-  if (!ud->match)
-    luaL_error (L, "malloc failed");
-
-  if (pud) *pud = ud;
-  return 1;
-}
-
-#if PCRE_MAJOR >= 4
-/* the target table must be on lua stack top */
-static void do_named_subpatterns (lua_State *L, TPcre *ud, const char *text) {
-  int i, namecount, name_entry_size;
-  unsigned char *name_table, *tabptr;
-
-  /* do named subpatterns - NJG */
-  pcre_fullinfo (ud->pr, ud->extra, PCRE_INFO_NAMECOUNT, &namecount);
-  if (namecount <= 0)
-    return;
-  pcre_fullinfo (ud->pr, ud->extra, PCRE_INFO_NAMETABLE, &name_table);
-  pcre_fullinfo (ud->pr, ud->extra, PCRE_INFO_NAMEENTRYSIZE, &name_entry_size);
-  tabptr = name_table;
-  for (i = 0; i < namecount; i++) {
-    int n = (tabptr[0] << 8) | tabptr[1]; /* number of the capturing parenthesis */
-    if (n > 0 && n <= ALG_NSUB(ud)) {   /* check range */
-      lua_pushstring (L, (char *)tabptr + 2); /* name of the capture, zero terminated */
-      ALG_PUSHSUB_OR_FALSE (L, ud, text, n);
-      lua_rawset (L, -3);
-    }
-    tabptr += name_entry_size;
-  }
-}
-#endif /* #if PCRE_MAJOR >= 4 */
-
-#if PCRE_MAJOR >= 6
-static int Lpcre_dfa_exec (lua_State *L)
-{
-  TArgExec argE;
-  TPcre *ud;
-  int res;
-  int *buf, *ovector, *wspace;
-  size_t bufsize;
-
-  checkarg_dfa_exec (L, &argE, &ud);
-  bufsize = (argE.ovecsize + argE.wscount) * sizeof(int);
-  buf = (int*) Lmalloc (L, bufsize);
-  if (!buf)
-    luaL_error (L, "malloc failed");
-  ovector = buf;
-  wspace = buf + argE.ovecsize;
-
-  res = pcre_dfa_exec (ud->pr, ud->extra, argE.text, (int)argE.textlen,
-    argE.startoffset, argE.eflags, ovector, argE.ovecsize, wspace, argE.wscount);
-
-  if (ALG_ISMATCH (res) || res == PCRE_ERROR_PARTIAL) {
-    int i;
-    int max = (res>0) ? res : (res==0) ? (int)argE.ovecsize/2 : 1;
-    lua_pushinteger (L, ovector[0] + 1);         /* 1-st return value */
-    lua_newtable (L);                            /* 2-nd return value */
-    for (i=0; i<max; i++) {
-      lua_pushinteger (L, ovector[i+i+1]);
-      lua_rawseti (L, -2, i+1);
-    }
-    lua_pushinteger (L, res);                    /* 3-rd return value */
-    Lfree (L, buf, bufsize);
-    return 3;
-  }
-  else {
-    Lfree (L, buf, bufsize);
-    if (ALG_NOMATCH (res))
-      return lua_pushnil (L), 1;
-    else
-      return generate_error (L, ud, res);
-  }
-}
-#endif /* #if PCRE_MAJOR >= 6 */
-
-static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
-  return pcre_exec (ud->pr, ud->extra, argE->text, argE->textlen,
-    argE->startoffset, argE->eflags, ud->match, (ALG_NSUB(ud) + 1) * 3);
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int findmatch_exec (TPcre *ud, TArgExec *argE) {
-  return pcre_exec (ud->pr, ud->extra, argE->text, argE->textlen,
-    argE->startoffset, argE->eflags, ud->match, (ALG_NSUB(ud) + 1) * 3);
-}
-
-static int gsub_exec (TPcre *ud, TArgExec *argE, int st) {
-  return pcre_exec (ud->pr, ud->extra, argE->text, argE->textlen,
-    st, argE->eflags, ud->match, (ALG_NSUB(ud) + 1) * 3);
-}
-
-static int split_exec (TPcre *ud, TArgExec *argE, int offset) {
-  return pcre_exec (ud->pr, ud->extra, argE->text, argE->textlen, offset,
-                    argE->eflags, ud->match, (ALG_NSUB(ud) + 1) * 3);
-}
-
-static int Lpcre_gc (lua_State *L) {
-  TPcre *ud = check_ud (L);
-  if (ud->freed == 0) {           /* precaution against "manual" __gc calling */
-    ud->freed = 1;
-    if (ud->pr)      pcre_free (ud->pr);
-    if (ud->extra)   pcre_free (ud->extra);
-    if (ud->tables)  pcre_free ((void *)ud->tables);
-    Lfree (L, ud->match, (ALG_NSUB(ud) + 1) * 3 * sizeof (int));
-  }
-  return 0;
-}
-
-static int Lpcre_tostring (lua_State *L) {
-  TPcre *ud = check_ud (L);
-  if (ud->freed == 0)
-    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
-  else
-    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
-  return 1;
-}
-
-static int Lpcre_version (lua_State *L) {
-  lua_pushstring (L, pcre_version ());
-  return 1;
-}
-
-#define SET_INFO_FIELD(L,ud,what,name,valtype) { \
-  valtype val; \
-  if (0 == pcre_fullinfo (ud->pr, ud->extra, what, &val)) { \
-    lua_pushnumber (L, val); \
-    lua_setfield (L, -2, name); \
-  } \
-}
-
-static int Lpcre_fullinfo (lua_State *L) {
-  TPcre *ud = check_ud (L);
-  lua_newtable(L);
-
-  SET_INFO_FIELD (L, ud, PCRE_INFO_BACKREFMAX,          "BACKREFMAX",          int)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_CAPTURECOUNT,        "CAPTURECOUNT",        int)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_FIRSTBYTE,           "FIRSTBYTE",           int)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_HASCRORLF,           "HASCRORLF",           int)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_JCHANGED,            "JCHANGED",            int)
-#ifdef PCRE_INFO_JIT
-  SET_INFO_FIELD (L, ud, PCRE_INFO_JIT,                 "JIT",                 int)
-#endif
-#ifdef PCRE_INFO_JITSIZE
-  SET_INFO_FIELD (L, ud, PCRE_INFO_JITSIZE,             "JITSIZE",             size_t);
-#endif
-#ifdef PCRE_INFO_MATCH_EMPTY
-  SET_INFO_FIELD (L, ud, PCRE_INFO_MATCH_EMPTY,         "MATCH_EMPTY",         int)
-#endif
-#ifdef PCRE_INFO_MATCHLIMIT
-  SET_INFO_FIELD (L, ud, PCRE_INFO_MATCHLIMIT,          "MATCHLIMIT",          uint32_t)
-#endif
-#ifdef PCRE_INFO_MAXLOOKBEHIND
-  SET_INFO_FIELD (L, ud, PCRE_INFO_MAXLOOKBEHIND,       "MAXLOOKBEHIND",       int) /* int ? */
-#endif
-#ifdef PCRE_INFO_MINLENGTH
-  SET_INFO_FIELD (L, ud, PCRE_INFO_MINLENGTH,           "MINLENGTH",           int)
-#endif
-  SET_INFO_FIELD (L, ud, PCRE_INFO_OKPARTIAL,           "OKPARTIAL",           int)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_OPTIONS,             "OPTIONS",             unsigned long)
-#ifdef PCRE_INFO_RECURSIONLIMIT
-  SET_INFO_FIELD (L, ud, PCRE_INFO_RECURSIONLIMIT,      "RECURSIONLIMIT",      uint32_t)
-#endif
-  SET_INFO_FIELD (L, ud, PCRE_INFO_SIZE,                "SIZE",                size_t)
-  SET_INFO_FIELD (L, ud, PCRE_INFO_STUDYSIZE,           "STUDYSIZE",           size_t)
-#ifdef PCRE_INFO_FIRSTCHARACTERFLAGS
-  SET_INFO_FIELD (L, ud, PCRE_INFO_FIRSTCHARACTERFLAGS, "FIRSTCHARACTERFLAGS", int)
-#endif
-#ifdef PCRE_INFO_FIRSTCHARACTER
-  SET_INFO_FIELD (L, ud, PCRE_INFO_FIRSTCHARACTER,      "FIRSTCHARACTER",      uint32_t)
-#endif
-#ifdef PCRE_INFO_REQUIREDCHARFLAGS
-  SET_INFO_FIELD (L, ud, PCRE_INFO_REQUIREDCHARFLAGS,   "REQUIREDCHARFLAGS",   int)
-#endif
-#ifdef PCRE_INFO_REQUIREDCHAR
-  SET_INFO_FIELD (L, ud, PCRE_INFO_REQUIREDCHAR,        "REQUIREDCHAR",        uint32_t)
-#endif
-
-  return 1;
-}
-
-static const luaL_Reg chartables_meta[] = {
-  { "__gc",        chartables_gc },
-  { "__tostring",  chartables_tostring },
-  { NULL, NULL }
-};
-
-static const luaL_Reg r_methods[] = {
-  { "exec",        algm_exec },
-  { "tfind",       algm_tfind },    /* old name: match */
-  { "find",        algm_find },
-  { "match",       algm_match },
-#if PCRE_MAJOR >= 6
-  { "dfa_exec",    Lpcre_dfa_exec },
-#endif
-  { "fullinfo",    Lpcre_fullinfo },
-  { "__gc",        Lpcre_gc },
-  { "__tostring",  Lpcre_tostring },
-  { NULL, NULL }
-};
-
-static const luaL_Reg r_functions[] = {
-  { "match",       algf_match },
-  { "find",        algf_find },
-  { "gmatch",      algf_gmatch },
-  { "gsub",        algf_gsub },
-  { "count",       algf_count },
-  { "split",       algf_split },
-  { "new",         algf_new },
-  { "flags",       Lpcre_get_flags },
-  { "version",     Lpcre_version },
-  { "maketables",  Lpcre_maketables },
-#if PCRE_MAJOR >= 4
-  { "config",      Lpcre_config },
-#endif
-  { NULL, NULL }
-};
-
-/* Open the library */
-REX_API int REX_OPENLIB (lua_State *L) {
-  if (PCRE_MAJOR > atoi (pcre_version ())) {
-    return luaL_error (L, "%s requires at least version %d of PCRE library",
-      REX_LIBNAME, (int)PCRE_MAJOR);
-  }
-
-  alg_register(L, r_methods, r_functions, "PCRE");
-
-  /* create a table and register it as a metatable for "chartables" userdata */
-  lua_newtable (L);
-  lua_pushliteral (L, "access denied");
-  lua_setfield (L, -2, "__metatable");
-#if LUA_VERSION_NUM == 501
-  luaL_register (L, NULL, chartables_meta);
-  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_META);
-#else
-  lua_pushvalue(L, -3);
-  luaL_setfuncs (L, chartables_meta, 1);
-  lua_rawseti (L, -3, INDEX_CHARTABLES_META);
-#endif
-
-  /* create a table for connecting "chartables" userdata to "regex" userdata */
-  lua_newtable (L);
-  lua_pushliteral (L, "k");         /* weak keys */
-  lua_setfield (L, -2, "__mode");
-  lua_pushvalue (L, -1);            /* setmetatable (tb, tb) */
-  lua_setmetatable (L, -2);
-#if LUA_VERSION_NUM == 501
-  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_LINK);
-#else
-  lua_rawseti (L, -3, INDEX_CHARTABLES_LINK);
-#endif
-
-  return 1;
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pcre/lpcre_f.c src/src/pcre/lpcre_f.c
--- upstream/src/pcre/lpcre_f.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/pcre/lpcre_f.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,228 +0,0 @@
-/* lpcre.c - PCRE regular expression library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <pcre.h>
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-#define VERSION_PCRE (PCRE_MAJOR*100 + PCRE_MINOR)
-
-static flag_pair pcre_flags[] = {
-  { "MAJOR",                         PCRE_MAJOR },
-  { "MINOR",                         PCRE_MINOR },
-/*---------------------------------------------------------------------------*/
-  { "CASELESS",                      PCRE_CASELESS },
-  { "MULTILINE",                     PCRE_MULTILINE },
-  { "DOTALL",                        PCRE_DOTALL },
-  { "EXTENDED",                      PCRE_EXTENDED },
-  { "ANCHORED",                      PCRE_ANCHORED },
-  { "DOLLAR_ENDONLY",                PCRE_DOLLAR_ENDONLY },
-  { "EXTRA",                         PCRE_EXTRA },
-  { "NOTBOL",                        PCRE_NOTBOL },
-  { "NOTEOL",                        PCRE_NOTEOL },
-  { "UNGREEDY",                      PCRE_UNGREEDY },
-  { "NOTEMPTY",                      PCRE_NOTEMPTY },
-  { "UTF8",                          PCRE_UTF8 },
-#if VERSION_PCRE >= 400
-  { "NO_AUTO_CAPTURE",               PCRE_NO_AUTO_CAPTURE },
-  { "NO_UTF8_CHECK",                 PCRE_NO_UTF8_CHECK },
-#endif
-#if VERSION_PCRE >= 500
-  { "AUTO_CALLOUT",                  PCRE_AUTO_CALLOUT },
-  { "PARTIAL",                       PCRE_PARTIAL },
-#endif
-#ifdef PCRE_PARTIAL_SOFT
-  { "PARTIAL_SOFT",                  PCRE_PARTIAL_SOFT },
-#endif
-#if VERSION_PCRE >= 600
-  { "DFA_SHORTEST",                  PCRE_DFA_SHORTEST },
-  { "DFA_RESTART",                   PCRE_DFA_RESTART },
-  { "FIRSTLINE",                     PCRE_FIRSTLINE },
-#endif
-#if VERSION_PCRE >= 607
-  { "DUPNAMES",                      PCRE_DUPNAMES },
-  { "NEWLINE_CR",                    PCRE_NEWLINE_CR },
-  { "NEWLINE_LF",                    PCRE_NEWLINE_LF },
-  { "NEWLINE_CRLF",                  PCRE_NEWLINE_CRLF },
-#endif
-#if VERSION_PCRE >= 700
-  { "NEWLINE_ANY",                   PCRE_NEWLINE_ANY },
-#endif
-#if VERSION_PCRE >= 701
-  { "NEWLINE_ANYCRLF",               PCRE_NEWLINE_ANYCRLF },
-#endif
-#if VERSION_PCRE >= 704
-  { "BSR_ANYCRLF",                   PCRE_BSR_ANYCRLF },
-  { "BSR_UNICODE",                   PCRE_BSR_UNICODE },
-#endif
-#if VERSION_PCRE >= 707
-  { "JAVASCRIPT_COMPAT",             PCRE_JAVASCRIPT_COMPAT },
-#endif
-#ifdef PCRE_NO_START_OPTIMIZE
-  { "NO_START_OPTIMIZE",             PCRE_NO_START_OPTIMIZE },
-#endif
-#ifdef PCRE_NO_START_OPTIMISE
-  { "NO_START_OPTIMISE",             PCRE_NO_START_OPTIMISE },
-#endif
-#ifdef PCRE_PARTIAL_HARD
-  { "PARTIAL_HARD",                  PCRE_PARTIAL_HARD },
-#endif
-#ifdef PCRE_NOTEMPTY_ATSTART
-  { "NOTEMPTY_ATSTART",              PCRE_NOTEMPTY_ATSTART },
-#endif
-#ifdef PCRE_UCP
-  { "UCP",                           PCRE_UCP },
-#endif
-/*---------------------------------------------------------------------------*/
-  { "INFO_OPTIONS",                  PCRE_INFO_OPTIONS },
-  { "INFO_SIZE",                     PCRE_INFO_SIZE },
-  { "INFO_CAPTURECOUNT",             PCRE_INFO_CAPTURECOUNT },
-  { "INFO_BACKREFMAX",               PCRE_INFO_BACKREFMAX },
-#if VERSION_PCRE >= 400
-  { "INFO_FIRSTBYTE",                PCRE_INFO_FIRSTBYTE },
-#endif
-  { "INFO_FIRSTCHAR",                PCRE_INFO_FIRSTCHAR },
-  { "INFO_FIRSTTABLE",               PCRE_INFO_FIRSTTABLE },
-  { "INFO_LASTLITERAL",              PCRE_INFO_LASTLITERAL },
-#if VERSION_PCRE >= 400
-  { "INFO_NAMEENTRYSIZE",            PCRE_INFO_NAMEENTRYSIZE },
-  { "INFO_NAMECOUNT",                PCRE_INFO_NAMECOUNT },
-  { "INFO_NAMETABLE",                PCRE_INFO_NAMETABLE },
-  { "INFO_STUDYSIZE",                PCRE_INFO_STUDYSIZE },
-#endif
-#if VERSION_PCRE >= 500
-  { "INFO_DEFAULT_TABLES",           PCRE_INFO_DEFAULT_TABLES },
-#endif
-#ifdef PCRE_INFO_OKPARTIAL
-  { "INFO_OKPARTIAL",                PCRE_INFO_OKPARTIAL },
-#endif
-#ifdef PCRE_INFO_JCHANGED
-  { "INFO_JCHANGED",                 PCRE_INFO_JCHANGED },
-#endif
-#ifdef PCRE_INFO_HASCRORLF
-  { "INFO_HASCRORLF",                PCRE_INFO_HASCRORLF },
-#endif
-#ifdef PCRE_INFO_MINLENGTH
-  { "INFO_MINLENGTH",                PCRE_INFO_MINLENGTH },
-#endif
-#ifdef PCRE_INFO_JIT
-  { "INFO_JIT",                      PCRE_INFO_JIT },
-#endif
-#ifdef PCRE_INFO_JITSIZE
-  { "INFO_JITSIZE",                  PCRE_INFO_JITSIZE },
-#endif
-/*---------------------------------------------------------------------------*/
-#if VERSION_PCRE >= 400
-  { "EXTRA_STUDY_DATA",              PCRE_EXTRA_STUDY_DATA },
-  { "EXTRA_MATCH_LIMIT",             PCRE_EXTRA_MATCH_LIMIT },
-  { "EXTRA_CALLOUT_DATA",            PCRE_EXTRA_CALLOUT_DATA },
-#endif
-#if VERSION_PCRE >= 500
-  { "EXTRA_TABLES",                  PCRE_EXTRA_TABLES },
-#endif
-#ifdef PCRE_EXTRA_MATCH_LIMIT_RECURSION
-  { "EXTRA_MATCH_LIMIT_RECURSION",   PCRE_EXTRA_MATCH_LIMIT_RECURSION },
-#endif
-#ifdef PCRE_EXTRA_MARK
-  { "EXTRA_MARK",                    PCRE_EXTRA_MARK },
-#endif
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-flag_pair pcre_error_flags[] = {
-  { "ERROR_NOMATCH",                 PCRE_ERROR_NOMATCH },
-  { "ERROR_NULL",                    PCRE_ERROR_NULL },
-  { "ERROR_BADOPTION",               PCRE_ERROR_BADOPTION },
-  { "ERROR_BADMAGIC",                PCRE_ERROR_BADMAGIC },
-#if VERSION_PCRE >= 700
-  { "ERROR_UNKNOWN_OPCODE",          PCRE_ERROR_UNKNOWN_OPCODE },
-#endif
-  { "ERROR_UNKNOWN_NODE",            PCRE_ERROR_UNKNOWN_NODE },
-  { "ERROR_NOMEMORY",                PCRE_ERROR_NOMEMORY },
-  { "ERROR_NOSUBSTRING",             PCRE_ERROR_NOSUBSTRING },
-#if VERSION_PCRE >= 400
-  { "ERROR_MATCHLIMIT",              PCRE_ERROR_MATCHLIMIT },
-  { "ERROR_CALLOUT",                 PCRE_ERROR_CALLOUT },
-  { "ERROR_BADUTF8",                 PCRE_ERROR_BADUTF8 },
-  { "ERROR_BADUTF8_OFFSET",          PCRE_ERROR_BADUTF8_OFFSET },
-#endif
-#if VERSION_PCRE >= 500
-  { "ERROR_PARTIAL",                 PCRE_ERROR_PARTIAL },
-  { "ERROR_BADPARTIAL",              PCRE_ERROR_BADPARTIAL },
-  { "ERROR_INTERNAL",                PCRE_ERROR_INTERNAL },
-  { "ERROR_BADCOUNT",                PCRE_ERROR_BADCOUNT },
-#endif
-#if VERSION_PCRE >= 600
-  { "ERROR_DFA_UITEM",               PCRE_ERROR_DFA_UITEM },
-  { "ERROR_DFA_UCOND",               PCRE_ERROR_DFA_UCOND },
-  { "ERROR_DFA_UMLIMIT",             PCRE_ERROR_DFA_UMLIMIT },
-  { "ERROR_DFA_WSSIZE",              PCRE_ERROR_DFA_WSSIZE },
-  { "ERROR_DFA_RECURSE",             PCRE_ERROR_DFA_RECURSE },
-#endif
-#if VERSION_PCRE >= 607
-  { "ERROR_RECURSIONLIMIT",          PCRE_ERROR_RECURSIONLIMIT },
-#endif
-#if VERSION_PCRE >= 700
-  { "ERROR_BADNEWLINE",              PCRE_ERROR_BADNEWLINE },
-#endif
-#ifdef PCRE_ERROR_NULLWSLIMIT
-  { "ERROR_NULLWSLIMIT",             PCRE_ERROR_NULLWSLIMIT },
-#endif
-#ifdef PCRE_ERROR_BADOFFSET
-  { "ERROR_BADOFFSET",               PCRE_ERROR_BADOFFSET },
-#endif
-#ifdef PCRE_ERROR_SHORTUTF8
-  { "ERROR_SHORTUTF8",               PCRE_ERROR_SHORTUTF8 },
-#endif
-#ifdef PCRE_ERROR_RECURSELOOP
-  { "ERROR_RECURSELOOP",             PCRE_ERROR_RECURSELOOP },
-#endif
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-#if VERSION_PCRE >= 400
-static flag_pair pcre_config_flags[] = {
-  { "CONFIG_UTF8",                   PCRE_CONFIG_UTF8 },
-  { "CONFIG_NEWLINE",                PCRE_CONFIG_NEWLINE },
-  { "CONFIG_LINK_SIZE",              PCRE_CONFIG_LINK_SIZE },
-  { "CONFIG_POSIX_MALLOC_THRESHOLD", PCRE_CONFIG_POSIX_MALLOC_THRESHOLD },
-  { "CONFIG_MATCH_LIMIT",            PCRE_CONFIG_MATCH_LIMIT },
-  { "CONFIG_STACKRECURSE",           PCRE_CONFIG_STACKRECURSE },
-#if VERSION_PCRE >= 500
-  { "CONFIG_UNICODE_PROPERTIES",     PCRE_CONFIG_UNICODE_PROPERTIES },
-#endif
-#if VERSION_PCRE >= 650
-  { "CONFIG_MATCH_LIMIT_RECURSION",  PCRE_CONFIG_MATCH_LIMIT_RECURSION },
-#endif
-#if VERSION_PCRE >= 704
-  { "CONFIG_BSR",                    PCRE_CONFIG_BSR },
-#endif
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-int Lpcre_config (lua_State *L) {
-  int val;
-  flag_pair *fp;
-  if (lua_istable (L, 1))
-    lua_settop (L, 1);
-  else
-    lua_newtable (L);
-  for (fp = pcre_config_flags; fp->key; ++fp) {
-    if (0 == pcre_config (fp->val, &val)) {
-      lua_pushinteger (L, val);
-      lua_setfield (L, -2, fp->key);
-    }
-  }
-  return 1;
-}
-#endif /* #if VERSION_PCRE >= 400 */
-
-int Lpcre_get_flags (lua_State *L) {
-  const flag_pair* fps[] = { pcre_flags, pcre_error_flags, NULL };
-  return get_flags (L, fps);
-}
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/pcre2/lpcre2.c src/src/pcre2/lpcre2.c
--- upstream/src/pcre2/lpcre2.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/pcre2/lpcre2.c	2025-08-18 08:15:02.086524935 +0000
@@ -1,502 +1,502 @@
-/* lpcre2.c - Lua binding of PCRE2 library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <locale.h>
-#include <ctype.h>
-#include <stdint.h>
-#include <pcre2.h>
-
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-extern int Lpcre2_get_flags (lua_State *L);
-extern int Lpcre2_config (lua_State *L);
-extern flag_pair pcre2_error_flags[];
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_pcre2"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_pcre2
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT 0
-#define ALG_EFLAGS_DFLT 0
-
-static int getcflags (lua_State *L, int pos);
-#define ALG_GETCFLAGS(L,pos)  getcflags(L, pos)
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC);
-#define ALG_GETCARGS(a,b,c)  checkarg_compile(a,b,c)
-
-#define ALG_NOMATCH(res)   ((res) == PCRE2_ERROR_NOMATCH)
-#define ALG_ISMATCH(res)   ((res) >= 0)
-#define ALG_SUBBEG(ud,n)   ((int)(ud)->ovector[(n)+(n)])
-#define ALG_SUBEND(ud,n)   ((int)(ud)->ovector[(n)+(n)+1])
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND((ud),(n)) - ALG_SUBBEG((ud),(n)))
-#define ALG_SUBVALID(ud,n) (0 == pcre2_substring_length_bynumber((ud)->match_data, (n), NULL))
-#define ALG_NSUB(ud)       ((int)(ud)->ncapt)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG((ud),(n)), ALG_SUBLEN((ud),(n)))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)  0
-#define ALG_PULL
-
-typedef struct {
-  pcre2_code *pr;
-  pcre2_compile_context *ccontext;
-  pcre2_match_data *match_data;
-  PCRE2_SIZE *ovector;
-  int ncapt;
-  const unsigned char *tables;
-  int freed;
-} TPcre2;
-
-#define TUserdata TPcre2
-
-static void do_named_subpatterns (lua_State *L, TPcre2 *ud, const char *text);
-#  define DO_NAMED_SUBPATTERNS do_named_subpatterns
-
-#include "../algo.h"
-
-/* Locations of the 2 permanent tables in the function environment */
-#define INDEX_CHARTABLES_META  1      /* chartables type's metatable */
-#define INDEX_CHARTABLES_LINK  2      /* link chartables to compiled regex */
-
-const char chartables_typename[] = "chartables";
-
-/*  Functions
- ******************************************************************************
- */
-
-static int push_error_message (lua_State *L, int errorcode) //### is this function needed?
-{
-  PCRE2_UCHAR buf[256];
-  if (pcre2_get_error_message(errorcode, buf, 256) > 0)
-  {
-    lua_pushstring(L, (const char*)buf);
-    return 1;
-  }
-  return 0;
-}
-
-static int getcflags (lua_State *L, int pos) {
-  switch (lua_type (L, pos)) {
-    case LUA_TNONE:
-    case LUA_TNIL:
-      return ALG_CFLAGS_DFLT;
-    case LUA_TNUMBER:
-      return lua_tointeger (L, pos);
-    case LUA_TSTRING: {
-      const char *s = lua_tostring (L, pos);
-      int res = 0, ch;
-      while ((ch = *s++) != '\0') {
-        if (ch == 'i') res |= PCRE2_CASELESS;
-        else if (ch == 'm') res |= PCRE2_MULTILINE;
-        else if (ch == 's') res |= PCRE2_DOTALL;
-        else if (ch == 'x') res |= PCRE2_EXTENDED;
-        else if (ch == 'U') res |= PCRE2_UNGREEDY;
-        //else if (ch == 'X') res |= PCRE2_EXTRA; //### does not exist in PCRE2 -> reflect in manual
-      }
-      return res;
-    }
-    default:
-      return luaL_typerror (L, pos, "number or string");
-  }
-}
-
-static int generate_error (lua_State *L, const TPcre2 *ud, int errcode) {
-  const char *key = get_flag_key (pcre2_error_flags, errcode);
-  (void) ud;
-  if (key)
-    return luaL_error (L, "error PCRE2_%s", key);
-  else
-    return luaL_error (L, "PCRE2 error code %d", errcode);
-}
-
-/* method r:dfa_exec (s, [st], [ef], [ovecsize], [wscount]) */
-static void checkarg_dfa_exec (lua_State *L, TArgExec *argE, TPcre2 **ud) {
-  *ud = check_ud (L);
-  argE->text = luaL_checklstring (L, 2, &argE->textlen);
-  argE->startoffset = get_startoffset (L, 3, argE->textlen);
-  argE->eflags = (int)luaL_optinteger (L, 4, ALG_EFLAGS_DFLT);
-  argE->ovecsize = (size_t)luaL_optinteger (L, 5, 100);
-  argE->wscount = (size_t)luaL_optinteger (L, 6, 50);
-}
-
-static void push_chartables_meta (lua_State *L) {
-  lua_pushinteger (L, INDEX_CHARTABLES_META);
-  lua_rawget (L, ALG_ENVIRONINDEX);
-}
-
-static int Lpcre2_maketables (lua_State *L) {
-  *(const void**)lua_newuserdata (L, sizeof(void*)) = pcre2_maketables(NULL); //### argument NULL
-  push_chartables_meta (L);
-  lua_setmetatable (L, -2);
-  return 1;
-}
-
-static void **check_chartables (lua_State *L, int pos) {
-  void **q;
-  /* Compare the metatable against the C function environment. */
-  if (lua_getmetatable(L, pos)) {
-    push_chartables_meta (L);
-    if (lua_rawequal(L, -1, -2) &&
-        (q = (void **)lua_touserdata(L, pos)) != NULL) {
-      lua_pop(L, 2);
-      return q;
-    }
-  }
-  luaL_argerror(L, pos, lua_pushfstring (L, "not a %s", chartables_typename));
-  return NULL;
-}
-
-static int chartables_gc (lua_State *L) {
-  void **ud = check_chartables (L, 1);
-  if (*ud) {
-    free (*ud); //### free() should be called only if pcre2_maketables was called with NULL argument
-    *ud = NULL;
-  }
-  return 0;
-}
-
-static int chartables_tostring (lua_State *L) {
-  void **ud = check_chartables (L, 1);
-  lua_pushfstring (L, "%s (%p)", chartables_typename, ud);
-  return 1;
-}
-
-static void checkarg_compile (lua_State *L, int pos, TArgComp *argC) {
-  argC->locale = NULL;
-  argC->tables = NULL;
-  if (!lua_isnoneornil (L, pos)) {
-    if (lua_isstring (L, pos))
-      argC->locale = lua_tostring (L, pos);
-    else {
-      argC->tablespos = pos;
-      argC->tables = (const unsigned char*) *check_chartables (L, pos);
-    }
-  }
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TPcre2 **pud) {
-  int errcode;
-  PCRE2_SIZE erroffset;
-  TPcre2 *ud;
-
-  ud = (TPcre2*)lua_newuserdata (L, sizeof (TPcre2));
-  memset (ud, 0, sizeof (TPcre2));           /* initialize all members to 0 */
-  lua_pushvalue (L, ALG_ENVIRONINDEX);
-  lua_setmetatable (L, -2);
-
-  ud->ccontext = pcre2_compile_context_create(NULL);
-  if (ud->ccontext == NULL)
-    return luaL_error (L, "malloc failed");
-
-  if (argC->locale) {
-    char old_locale[256];
-    strcpy (old_locale, setlocale (LC_CTYPE, NULL));  /* store the locale */
-    if (NULL == setlocale (LC_CTYPE, argC->locale))   /* set new locale */
-      return luaL_error (L, "cannot set locale");
-    ud->tables = pcre2_maketables (NULL); /* make tables with new locale */ //### argument NULL
-    pcre2_set_character_tables(ud->ccontext, ud->tables);
-    setlocale (LC_CTYPE, old_locale);          /* restore the old locale */
-  }
-  else if (argC->tables) {
-    pcre2_set_character_tables(ud->ccontext, argC->tables);
-    lua_pushinteger (L, INDEX_CHARTABLES_LINK);
-    lua_rawget (L, ALG_ENVIRONINDEX);
-    lua_pushvalue (L, -2);
-    lua_pushvalue (L, argC->tablespos);
-    lua_rawset (L, -3);
-    lua_pop (L, 1);
-  }
-
-  ud->pr = pcre2_compile ((PCRE2_SPTR)argC->pattern, argC->patlen, argC->cflags, &errcode,
-                          &erroffset, ud->ccontext); //### DOUBLE-CHECK ALL ARGUMENTS
-  if (!ud->pr) {
-    if (push_error_message(L, errcode))
-      return luaL_error (L, "%s (pattern offset: %d)", lua_tostring(L,-1), erroffset + 1);
-    else
-      return luaL_error (L, "%s (pattern offset: %d)", "pattern compile error", erroffset + 1);
-  }
-
-  if (0 != pcre2_pattern_info (ud->pr, PCRE2_INFO_CAPTURECOUNT, &ud->ncapt)) //###
-    return luaL_error (L, "could not get pattern info");
-
-  /* need (2 ints per capture, plus one for substring match) * 3/2 */
-  ud->match_data = pcre2_match_data_create(ud->ncapt+1, NULL); //### CHECK ALL
-  if (!ud->match_data)
-    return luaL_error (L, "malloc failed");
-
-  ud->ovector = pcre2_get_ovector_pointer(ud->match_data);
-
-  if (pud) *pud = ud;
-  return 1;
-}
-
-/* the target table must be on lua stack top */
-static void do_named_subpatterns (lua_State *L, TPcre2 *ud, const char *text) {
-  int i, namecount, name_entry_size;
-  unsigned char *name_table;
-  PCRE2_SPTR tabptr;
-
-  /* do named subpatterns - NJG */
-  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMECOUNT, &namecount);
-  if (namecount <= 0)
-    return;
-  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMETABLE, &name_table);
-  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size);
-  tabptr = name_table;
-  for (i = 0; i < namecount; i++) {
-    int n = (tabptr[0] << 8) | tabptr[1]; /* number of the capturing parenthesis */
-    if (n > 0 && n <= ALG_NSUB(ud)) {   /* check range */
-      lua_pushstring (L, (char *)tabptr + 2); /* name of the capture, zero terminated */
-      ALG_PUSHSUB_OR_FALSE (L, ud, text, n);
-      lua_rawset (L, -3);
-    }
-    tabptr += name_entry_size;
-  }
-}
-
-static int Lpcre2_dfa_exec (lua_State *L)
-{
-  TArgExec argE;
-  TPcre2 *ud;
-  int res;
-  int *wspace;
-  size_t wsize;
-
-  checkarg_dfa_exec (L, &argE, &ud);
-  wsize = argE.wscount * sizeof(int);
-  wspace = (int*) Lmalloc (L, wsize);
-  if (!wspace)
-    luaL_error (L, "malloc failed");
-
-  ud->match_data = pcre2_match_data_create(argE.ovecsize/2, NULL); //### CHECK ALL
-  if (!ud->match_data)
-    return luaL_error (L, "malloc failed");
-
-  res = pcre2_dfa_match (ud->pr, (PCRE2_SPTR)argE.text, argE.textlen, argE.startoffset,
-    argE.eflags, ud->match_data, NULL, wspace, argE.wscount); //### CHECK ALL
-
-  if (ALG_ISMATCH (res) || res == PCRE2_ERROR_PARTIAL) {
-    int i;
-    int max = (res>0) ? res : (res==0) ? (int)argE.ovecsize/2 : 1;
-    PCRE2_SIZE* ovector = pcre2_get_ovector_pointer(ud->match_data);
-
-    lua_pushinteger (L, ovector[0] + 1);         /* 1-st return value */
-    lua_newtable (L);                            /* 2-nd return value */
-    for (i=0; i<max; i++) {
-      lua_pushinteger (L, ovector[i+i+1]);
-      lua_rawseti (L, -2, i+1);
-    }
-    lua_pushinteger (L, res);                    /* 3-rd return value */
-    Lfree (L, wspace, wsize);
-    return 3;
-  }
-  else {
-    Lfree (L, wspace, wsize);
-    if (ALG_NOMATCH (res))
-      return lua_pushnil (L), 1;
-    else
-      return generate_error (L, ud, res);
-  }
-}
-
-static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
-  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
-    argE->startoffset, argE->eflags, ud->match_data, NULL); //###
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int findmatch_exec (TPcre2 *ud, TArgExec *argE) {
-  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
-    argE->startoffset, argE->eflags, ud->match_data, NULL); //###
-}
-
-static int gsub_exec (TPcre2 *ud, TArgExec *argE, int st) {
-  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
-    st, argE->eflags, ud->match_data, NULL); //###
-}
-
-static int split_exec (TPcre2 *ud, TArgExec *argE, int offset) {
-  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
-    offset, argE->eflags, ud->match_data, NULL); //###
-}
-
-static int Lpcre2_gc (lua_State *L) {
-  TPcre2 *ud = check_ud (L);
-  if (ud->freed == 0) {           /* precaution against "manual" __gc calling */
-    ud->freed = 1;
-    if (ud->pr) pcre2_code_free (ud->pr);
-    //if (ud->tables)  pcre_free ((void *)ud->tables); //###
-    if (ud->ccontext) pcre2_compile_context_free (ud->ccontext);
-    if (ud->match_data) pcre2_match_data_free (ud->match_data);
-  }
-  return 0;
-}
-
-static int Lpcre2_tostring (lua_State *L) {
-  TPcre2 *ud = check_ud (L);
-  if (ud->freed == 0)
-    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
-  else
-    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
-  return 1;
-}
-
-static int Lpcre2_version (lua_State *L) {
-  char buf[64];
-  pcre2_config(PCRE2_CONFIG_VERSION, buf);
-  lua_pushstring (L, buf);
-  return 1;
-}
-
-//### TODO: document this method.
-//### TODO: write tests for this method.
-static int Lpcre2_jit_compile (lua_State *L) {
-  TPcre2 *ud = check_ud (L);
-  uint32_t options = (uint32_t) luaL_optinteger (L, 2, PCRE2_JIT_COMPLETE);
-  int errcode = pcre2_jit_compile (ud->pr, options);
-  if (errcode == 0) {
-    lua_pushboolean(L, 1);
-    return 1;
-  }
-  lua_pushboolean(L, 0);
-  return 1 + push_error_message(L, errcode);
-}
-
-#define SET_INFO_FIELD(L,ud,what,name,valtype) { \
-  valtype val; \
-  if (0 == pcre2_pattern_info (ud->pr, what, &val)) { \
-    lua_pushnumber (L, val); \
-    lua_setfield (L, -2, name); \
-  } \
-}
-
-static int Lpcre2_pattern_info (lua_State *L) {
-  TPcre2 *ud = check_ud (L);
-  lua_newtable(L);
-
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_ALLOPTIONS,          "ALLOPTIONS",          uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_ARGOPTIONS,          "ARGOPTIONS",          uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_BACKREFMAX,          "BACKREFMAX",          uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_BSR,                 "BSR",                 uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_CAPTURECOUNT,        "CAPTURECOUNT",        uint32_t)
-  //### SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTBITMAP,   "FIRSTBITMAP",         ???)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTCODETYPE,       "FIRSTCODETYPE",       uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTCODEUNIT,       "FIRSTCODEUNIT",       uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_HASBACKSLASHC,       "HASBACKSLASHC",       uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_HASCRORLF,           "HASCRORLF",           uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_JCHANGED,            "JCHANGED",            uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_JITSIZE,             "JITSIZE",             size_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_LASTCODETYPE,        "LASTCODETYPE",        uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_LASTCODEUNIT,        "LASTCODEUNIT",        uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_MATCHEMPTY,          "MATCHEMPTY",          uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_MATCHLIMIT,          "MATCHLIMIT",          uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_MAXLOOKBEHIND,       "MAXLOOKBEHIND",       uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_MINLENGTH,           "MINLENGTH",           uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMECOUNT,           "NAMECOUNT",           uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMEENTRYSIZE,       "NAMEENTRYSIZE",       uint32_t)
-  //### SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMETABLE,     "NAMETABLE",           ???)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_NEWLINE,             "NEWLINE",             uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_RECURSIONLIMIT,      "RECURSIONLIMIT",      uint32_t)
-  SET_INFO_FIELD (L, ud, PCRE2_INFO_SIZE,                "SIZE",                size_t)
-
-  return 1;
-}
-
-static const luaL_Reg chartables_meta[] = {
-  { "__gc",        chartables_gc },
-  { "__tostring",  chartables_tostring },
-  { NULL, NULL }
-};
-
-static const luaL_Reg r_methods[] = {
-  { "exec",        algm_exec },
-  { "tfind",       algm_tfind },    /* old name: match */
-  { "find",        algm_find },
-  { "match",       algm_match },
-  { "dfa_exec",    Lpcre2_dfa_exec },
-  { "patterninfo", Lpcre2_pattern_info }, //### document name change: fullinfo -> patterninfo
-  { "fullinfo",    Lpcre2_pattern_info }, //### compatibility name
-  { "jit_compile", Lpcre2_jit_compile },
-  { "__gc",        Lpcre2_gc },
-  { "__tostring",  Lpcre2_tostring },
-  { NULL, NULL }
-};
-
-static const luaL_Reg r_functions[] = {
-  { "match",       algf_match },
-  { "find",        algf_find },
-  { "gmatch",      algf_gmatch },
-  { "gsub",        algf_gsub },
-  { "count",       algf_count },
-  { "split",       algf_split },
-  { "new",         algf_new },
-  { "flags",       Lpcre2_get_flags },
-  { "version",     Lpcre2_version },
-  { "maketables",  Lpcre2_maketables },
-  { "config",      Lpcre2_config },
-  { NULL, NULL }
-};
-
-/* Open the library */
-REX_API int REX_OPENLIB (lua_State *L) {
-  char buf_ver[64];
-  pcre2_config(PCRE2_CONFIG_VERSION, buf_ver);
-  if (PCRE2_MAJOR > atoi (buf_ver)) {
-    return luaL_error (L, "%s requires at least version %d of PCRE2 library",
-      REX_LIBNAME, (int)PCRE2_MAJOR);
-  }
-
-  alg_register(L, r_methods, r_functions, "PCRE2");
-
-  /* create a table and register it as a metatable for "chartables" userdata */
-  lua_newtable (L);
-  lua_pushliteral (L, "access denied");
-  lua_setfield (L, -2, "__metatable");
-#if LUA_VERSION_NUM == 501
-  luaL_register (L, NULL, chartables_meta);
-  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_META);
-#else
-  lua_pushvalue(L, -3);
-  luaL_setfuncs (L, chartables_meta, 1);
-  lua_rawseti (L, -3, INDEX_CHARTABLES_META);
-#endif
-
-  /* create a table for connecting "chartables" userdata to "regex" userdata */
-  lua_newtable (L);
-  lua_pushliteral (L, "k");         /* weak keys */
-  lua_setfield (L, -2, "__mode");
-  lua_pushvalue (L, -1);            /* setmetatable (tb, tb) */
-  lua_setmetatable (L, -2);
-#if LUA_VERSION_NUM == 501
-  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_LINK);
-#else
-  lua_rawseti (L, -3, INDEX_CHARTABLES_LINK);
-#endif
-
-  return 1;
-}
+/* lpcre2.c - Lua binding of PCRE2 library */
+/* See Copyright Notice in the file LICENSE */
+
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+#include <ctype.h>
+#include <stdint.h>
+#include <pcre2.h>
+
+#include "lua.h"
+#include "lauxlib.h"
+#include "../common.h"
+
+extern int Lpcre2_get_flags (lua_State *L);
+extern int Lpcre2_config (lua_State *L);
+extern flag_pair pcre2_error_flags[];
+
+/* These 2 settings may be redefined from the command-line or the makefile.
+ * They should be kept in sync between themselves and with the target name.
+ */
+#ifndef REX_LIBNAME
+#  define REX_LIBNAME "rex_pcre2"
+#endif
+#ifndef REX_OPENLIB
+#  define REX_OPENLIB luaopen_rex_pcre2
+#endif
+
+#define REX_TYPENAME REX_LIBNAME"_regex"
+
+#define ALG_CFLAGS_DFLT 0
+#define ALG_EFLAGS_DFLT 0
+
+static int getcflags (lua_State *L, int pos);
+#define ALG_GETCFLAGS(L,pos)  getcflags(L, pos)
+
+static void checkarg_compile (lua_State *L, int pos, TArgComp *argC);
+#define ALG_GETCARGS(a,b,c)  checkarg_compile(a,b,c)
+
+#define ALG_NOMATCH(res)   ((res) == PCRE2_ERROR_NOMATCH)
+#define ALG_ISMATCH(res)   ((res) >= 0)
+#define ALG_SUBBEG(ud,n)   ((int)(ud)->ovector[(n)+(n)])
+#define ALG_SUBEND(ud,n)   ((int)(ud)->ovector[(n)+(n)+1])
+#define ALG_SUBLEN(ud,n)   (ALG_SUBEND((ud),(n)) - ALG_SUBBEG((ud),(n)))
+#define ALG_SUBVALID(ud,n) (0 == pcre2_substring_length_bynumber((ud)->match_data, (n), NULL))
+#define ALG_NSUB(ud)       ((int)(ud)->ncapt)
+
+#define ALG_PUSHSUB(L,ud,text,n) \
+  lua_pushlstring (L, (text) + ALG_SUBBEG((ud),(n)), ALG_SUBLEN((ud),(n)))
+
+#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
+  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
+
+#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
+#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
+#define ALG_PUSHOFFSETS(L,ud,offs,n) \
+  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
+
+#define ALG_BASE(st)  0
+#define ALG_PULL
+
+typedef struct {
+  pcre2_code *pr;
+  pcre2_compile_context *ccontext;
+  pcre2_match_data *match_data;
+  PCRE2_SIZE *ovector;
+  int ncapt;
+  const unsigned char *tables;
+  int freed;
+} TPcre2;
+
+#define TUserdata TPcre2
+
+static void do_named_subpatterns (lua_State *L, TPcre2 *ud, const char *text);
+#  define DO_NAMED_SUBPATTERNS do_named_subpatterns
+
+#include "../algo.h"
+
+/* Locations of the 2 permanent tables in the function environment */
+#define INDEX_CHARTABLES_META  1      /* chartables type's metatable */
+#define INDEX_CHARTABLES_LINK  2      /* link chartables to compiled regex */
+
+const char chartables_typename[] = "chartables";
+
+/*  Functions
+ ******************************************************************************
+ */
+
+static int push_error_message (lua_State *L, int errorcode) //### is this function needed?
+{
+  PCRE2_UCHAR buf[256];
+  if (pcre2_get_error_message(errorcode, buf, 256) > 0)
+  {
+    lua_pushstring(L, (const char*)buf);
+    return 1;
+  }
+  return 0;
+}
+
+static int getcflags (lua_State *L, int pos) {
+  switch (lua_type (L, pos)) {
+    case LUA_TNONE:
+    case LUA_TNIL:
+      return ALG_CFLAGS_DFLT;
+    case LUA_TNUMBER:
+      return lua_tointeger (L, pos);
+    case LUA_TSTRING: {
+      const char *s = lua_tostring (L, pos);
+      int res = 0, ch;
+      while ((ch = *s++) != '\0') {
+        if (ch == 'i') res |= PCRE2_CASELESS;
+        else if (ch == 'm') res |= PCRE2_MULTILINE;
+        else if (ch == 's') res |= PCRE2_DOTALL;
+        else if (ch == 'x') res |= PCRE2_EXTENDED;
+        else if (ch == 'U') res |= PCRE2_UNGREEDY;
+        //else if (ch == 'X') res |= PCRE2_EXTRA; //### does not exist in PCRE2 -> reflect in manual
+      }
+      return res;
+    }
+    default:
+      return luaL_typerror (L, pos, "number or string");
+  }
+}
+
+static int generate_error (lua_State *L, const TPcre2 *ud, int errcode) {
+  const char *key = get_flag_key (pcre2_error_flags, errcode);
+  (void) ud;
+  if (key)
+    return luaL_error (L, "error PCRE2_%s", key);
+  else
+    return luaL_error (L, "PCRE2 error code %d", errcode);
+}
+
+/* method r:dfa_exec (s, [st], [ef], [ovecsize], [wscount]) */
+static void checkarg_dfa_exec (lua_State *L, TArgExec *argE, TPcre2 **ud) {
+  *ud = check_ud (L);
+  argE->text = luaL_checklstring (L, 2, &argE->textlen);
+  argE->startoffset = get_startoffset (L, 3, argE->textlen);
+  argE->eflags = (int)luaL_optinteger (L, 4, ALG_EFLAGS_DFLT);
+  argE->ovecsize = (size_t)luaL_optinteger (L, 5, 100);
+  argE->wscount = (size_t)luaL_optinteger (L, 6, 50);
+}
+
+static void push_chartables_meta (lua_State *L) {
+  lua_pushinteger (L, INDEX_CHARTABLES_META);
+  lua_rawget (L, ALG_ENVIRONINDEX);
+}
+
+static int Lpcre2_maketables (lua_State *L) {
+  *(const void**)lua_newuserdata (L, sizeof(void*)) = pcre2_maketables(NULL); //### argument NULL
+  push_chartables_meta (L);
+  lua_setmetatable (L, -2);
+  return 1;
+}
+
+static void **check_chartables (lua_State *L, int pos) {
+  void **q;
+  /* Compare the metatable against the C function environment. */
+  if (lua_getmetatable(L, pos)) {
+    push_chartables_meta (L);
+    if (lua_rawequal(L, -1, -2) &&
+        (q = (void **)lua_touserdata(L, pos)) != NULL) {
+      lua_pop(L, 2);
+      return q;
+    }
+  }
+  luaL_argerror(L, pos, lua_pushfstring (L, "not a %s", chartables_typename));
+  return NULL;
+}
+
+static int chartables_gc (lua_State *L) {
+  void **ud = check_chartables (L, 1);
+  if (*ud) {
+    free (*ud); //### free() should be called only if pcre2_maketables was called with NULL argument
+    *ud = NULL;
+  }
+  return 0;
+}
+
+static int chartables_tostring (lua_State *L) {
+  void **ud = check_chartables (L, 1);
+  lua_pushfstring (L, "%s (%p)", chartables_typename, ud);
+  return 1;
+}
+
+static void checkarg_compile (lua_State *L, int pos, TArgComp *argC) {
+  argC->locale = NULL;
+  argC->tables = NULL;
+  if (!lua_isnoneornil (L, pos)) {
+    if (lua_isstring (L, pos))
+      argC->locale = lua_tostring (L, pos);
+    else {
+      argC->tablespos = pos;
+      argC->tables = (const unsigned char*) *check_chartables (L, pos);
+    }
+  }
+}
+
+static int compile_regex (lua_State *L, const TArgComp *argC, TPcre2 **pud) {
+  int errcode;
+  PCRE2_SIZE erroffset;
+  TPcre2 *ud;
+
+  ud = (TPcre2*)lua_newuserdata (L, sizeof (TPcre2));
+  memset (ud, 0, sizeof (TPcre2));           /* initialize all members to 0 */
+  lua_pushvalue (L, ALG_ENVIRONINDEX);
+  lua_setmetatable (L, -2);
+
+  ud->ccontext = pcre2_compile_context_create(NULL);
+  if (ud->ccontext == NULL)
+    return luaL_error (L, "malloc failed");
+
+  if (argC->locale) {
+    char old_locale[256];
+    strcpy (old_locale, setlocale (LC_CTYPE, NULL));  /* store the locale */
+    if (NULL == setlocale (LC_CTYPE, argC->locale))   /* set new locale */
+      return luaL_error (L, "cannot set locale");
+    ud->tables = pcre2_maketables (NULL); /* make tables with new locale */ //### argument NULL
+    pcre2_set_character_tables(ud->ccontext, ud->tables);
+    setlocale (LC_CTYPE, old_locale);          /* restore the old locale */
+  }
+  else if (argC->tables) {
+    pcre2_set_character_tables(ud->ccontext, argC->tables);
+    lua_pushinteger (L, INDEX_CHARTABLES_LINK);
+    lua_rawget (L, ALG_ENVIRONINDEX);
+    lua_pushvalue (L, -2);
+    lua_pushvalue (L, argC->tablespos);
+    lua_rawset (L, -3);
+    lua_pop (L, 1);
+  }
+
+  ud->pr = pcre2_compile ((PCRE2_SPTR)argC->pattern, argC->patlen, argC->cflags, &errcode,
+                          &erroffset, ud->ccontext); //### DOUBLE-CHECK ALL ARGUMENTS
+  if (!ud->pr) {
+    if (push_error_message(L, errcode))
+      return luaL_error (L, "%s (pattern offset: %d)", lua_tostring(L,-1), erroffset + 1);
+    else
+      return luaL_error (L, "%s (pattern offset: %d)", "pattern compile error", erroffset + 1);
+  }
+
+  if (0 != pcre2_pattern_info (ud->pr, PCRE2_INFO_CAPTURECOUNT, &ud->ncapt)) //###
+    return luaL_error (L, "could not get pattern info");
+
+  /* need (2 ints per capture, plus one for substring match) * 3/2 */
+  ud->match_data = pcre2_match_data_create(ud->ncapt+1, NULL); //### CHECK ALL
+  if (!ud->match_data)
+    return luaL_error (L, "malloc failed");
+
+  ud->ovector = pcre2_get_ovector_pointer(ud->match_data);
+
+  if (pud) *pud = ud;
+  return 1;
+}
+
+/* the target table must be on lua stack top */
+static void do_named_subpatterns (lua_State *L, TPcre2 *ud, const char *text) {
+  int i, namecount, name_entry_size;
+  unsigned char *name_table;
+  PCRE2_SPTR tabptr;
+
+  /* do named subpatterns - NJG */
+  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMECOUNT, &namecount);
+  if (namecount <= 0)
+    return;
+  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMETABLE, &name_table);
+  pcre2_pattern_info (ud->pr, PCRE2_INFO_NAMEENTRYSIZE, &name_entry_size);
+  tabptr = name_table;
+  for (i = 0; i < namecount; i++) {
+    int n = (tabptr[0] << 8) | tabptr[1]; /* number of the capturing parenthesis */
+    if (n > 0 && n <= ALG_NSUB(ud)) {   /* check range */
+      lua_pushstring (L, (char *)tabptr + 2); /* name of the capture, zero terminated */
+      ALG_PUSHSUB_OR_FALSE (L, ud, text, n);
+      lua_rawset (L, -3);
+    }
+    tabptr += name_entry_size;
+  }
+}
+
+static int Lpcre2_dfa_exec (lua_State *L)
+{
+  TArgExec argE;
+  TPcre2 *ud;
+  int res;
+  int *wspace;
+  size_t wsize;
+
+  checkarg_dfa_exec (L, &argE, &ud);
+  wsize = argE.wscount * sizeof(int);
+  wspace = (int*) Lmalloc (L, wsize);
+  if (!wspace)
+    luaL_error (L, "malloc failed");
+
+  ud->match_data = pcre2_match_data_create(argE.ovecsize/2, NULL); //### CHECK ALL
+  if (!ud->match_data)
+    return luaL_error (L, "malloc failed");
+
+  res = pcre2_dfa_match (ud->pr, (PCRE2_SPTR)argE.text, argE.textlen, argE.startoffset,
+    argE.eflags, ud->match_data, NULL, wspace, argE.wscount); //### CHECK ALL
+
+  if (ALG_ISMATCH (res) || res == PCRE2_ERROR_PARTIAL) {
+    int i;
+    int max = (res>0) ? res : (res==0) ? (int)argE.ovecsize/2 : 1;
+    PCRE2_SIZE* ovector = pcre2_get_ovector_pointer(ud->match_data);
+
+    lua_pushinteger (L, ovector[0] + 1);         /* 1-st return value */
+    lua_newtable (L);                            /* 2-nd return value */
+    for (i=0; i<max; i++) {
+      lua_pushinteger (L, ovector[i+i+1]);
+      lua_rawseti (L, -2, i+1);
+    }
+    lua_pushinteger (L, res);                    /* 3-rd return value */
+    Lfree (L, wspace, wsize);
+    return 3;
+  }
+  else {
+    Lfree (L, wspace, wsize);
+    if (ALG_NOMATCH (res))
+      return lua_pushnil (L), 1;
+    else
+      return generate_error (L, ud, res);
+  }
+}
+
+static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
+  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
+    argE->startoffset, argE->eflags, ud->match_data, NULL); //###
+}
+
+static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
+  lua_pushlstring (L, argE->text, argE->textlen);
+}
+
+static int findmatch_exec (TPcre2 *ud, TArgExec *argE) {
+  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
+    argE->startoffset, argE->eflags, ud->match_data, NULL); //###
+}
+
+static int gsub_exec (TPcre2 *ud, TArgExec *argE, int st) {
+  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
+    st, argE->eflags, ud->match_data, NULL); //###
+}
+
+static int split_exec (TPcre2 *ud, TArgExec *argE, int offset) {
+  return pcre2_match (ud->pr, (PCRE2_SPTR)argE->text, argE->textlen,
+    offset, argE->eflags, ud->match_data, NULL); //###
+}
+
+static int Lpcre2_gc (lua_State *L) {
+  TPcre2 *ud = check_ud (L);
+  if (ud->freed == 0) {           /* precaution against "manual" __gc calling */
+    ud->freed = 1;
+    if (ud->pr) pcre2_code_free (ud->pr);
+    //if (ud->tables)  pcre_free ((void *)ud->tables); //###
+    if (ud->ccontext) pcre2_compile_context_free (ud->ccontext);
+    if (ud->match_data) pcre2_match_data_free (ud->match_data);
+  }
+  return 0;
+}
+
+static int Lpcre2_tostring (lua_State *L) {
+  TPcre2 *ud = check_ud (L);
+  if (ud->freed == 0)
+    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
+  else
+    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
+  return 1;
+}
+
+static int Lpcre2_version (lua_State *L) {
+  char buf[64];
+  pcre2_config(PCRE2_CONFIG_VERSION, buf);
+  lua_pushstring (L, buf);
+  return 1;
+}
+
+//### TODO: document this method.
+//### TODO: write tests for this method.
+static int Lpcre2_jit_compile (lua_State *L) {
+  TPcre2 *ud = check_ud (L);
+  uint32_t options = (uint32_t) luaL_optinteger (L, 2, PCRE2_JIT_COMPLETE);
+  int errcode = pcre2_jit_compile (ud->pr, options);
+  if (errcode == 0) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  lua_pushboolean(L, 0);
+  return 1 + push_error_message(L, errcode);
+}
+
+#define SET_INFO_FIELD(L,ud,what,name,valtype) { \
+  valtype val; \
+  if (0 == pcre2_pattern_info (ud->pr, what, &val)) { \
+    lua_pushnumber (L, val); \
+    lua_setfield (L, -2, name); \
+  } \
+}
+
+static int Lpcre2_pattern_info (lua_State *L) {
+  TPcre2 *ud = check_ud (L);
+  lua_newtable(L);
+
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_ALLOPTIONS,          "ALLOPTIONS",          uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_ARGOPTIONS,          "ARGOPTIONS",          uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_BACKREFMAX,          "BACKREFMAX",          uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_BSR,                 "BSR",                 uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_CAPTURECOUNT,        "CAPTURECOUNT",        uint32_t)
+  //### SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTBITMAP,   "FIRSTBITMAP",         ???)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTCODETYPE,       "FIRSTCODETYPE",       uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_FIRSTCODEUNIT,       "FIRSTCODEUNIT",       uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_HASBACKSLASHC,       "HASBACKSLASHC",       uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_HASCRORLF,           "HASCRORLF",           uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_JCHANGED,            "JCHANGED",            uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_JITSIZE,             "JITSIZE",             size_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_LASTCODETYPE,        "LASTCODETYPE",        uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_LASTCODEUNIT,        "LASTCODEUNIT",        uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_MATCHEMPTY,          "MATCHEMPTY",          uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_MATCHLIMIT,          "MATCHLIMIT",          uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_MAXLOOKBEHIND,       "MAXLOOKBEHIND",       uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_MINLENGTH,           "MINLENGTH",           uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMECOUNT,           "NAMECOUNT",           uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMEENTRYSIZE,       "NAMEENTRYSIZE",       uint32_t)
+  //### SET_INFO_FIELD (L, ud, PCRE2_INFO_NAMETABLE,     "NAMETABLE",           ???)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_NEWLINE,             "NEWLINE",             uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_RECURSIONLIMIT,      "RECURSIONLIMIT",      uint32_t)
+  SET_INFO_FIELD (L, ud, PCRE2_INFO_SIZE,                "SIZE",                size_t)
+
+  return 1;
+}
+
+static const luaL_Reg chartables_meta[] = {
+  { "__gc",        chartables_gc },
+  { "__tostring",  chartables_tostring },
+  { NULL, NULL }
+};
+
+static const luaL_Reg r_methods[] = {
+  { "exec",        algm_exec },
+  { "tfind",       algm_tfind },    /* old name: match */
+  { "find",        algm_find },
+  { "match",       algm_match },
+  { "dfa_exec",    Lpcre2_dfa_exec },
+  { "patterninfo", Lpcre2_pattern_info }, //### document name change: fullinfo -> patterninfo
+  { "fullinfo",    Lpcre2_pattern_info }, //### compatibility name
+  { "jit_compile", Lpcre2_jit_compile },
+  { "__gc",        Lpcre2_gc },
+  { "__tostring",  Lpcre2_tostring },
+  { NULL, NULL }
+};
+
+static const luaL_Reg r_functions[] = {
+  { "match",       algf_match },
+  { "find",        algf_find },
+  { "gmatch",      algf_gmatch },
+  { "gsub",        algf_gsub },
+  { "count",       algf_count },
+  { "split",       algf_split },
+  { "new",         algf_new },
+  { "flags",       Lpcre2_get_flags },
+  { "version",     Lpcre2_version },
+  { "maketables",  Lpcre2_maketables },
+  { "config",      Lpcre2_config },
+  { NULL, NULL }
+};
+
+/* Open the library */
+REX_API int REX_OPENLIB (lua_State *L) {
+  char buf_ver[64];
+  pcre2_config(PCRE2_CONFIG_VERSION, buf_ver);
+  if (PCRE2_MAJOR > atoi (buf_ver)) {
+    return luaL_error (L, "%s requires at least version %d of PCRE2 library",
+      REX_LIBNAME, (int)PCRE2_MAJOR);
+  }
+
+  alg_register(L, r_methods, r_functions, "PCRE2");
+
+  /* create a table and register it as a metatable for "chartables" userdata */
+  lua_newtable (L);
+  lua_pushliteral (L, "access denied");
+  lua_setfield (L, -2, "__metatable");
+#if LUA_VERSION_NUM == 501
+  luaL_register (L, NULL, chartables_meta);
+  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_META);
+#else
+  lua_pushvalue(L, -3);
+  luaL_setfuncs (L, chartables_meta, 1);
+  lua_rawseti (L, -3, INDEX_CHARTABLES_META);
+#endif
+
+  /* create a table for connecting "chartables" userdata to "regex" userdata */
+  lua_newtable (L);
+  lua_pushliteral (L, "k");         /* weak keys */
+  lua_setfield (L, -2, "__mode");
+  lua_pushvalue (L, -1);            /* setmetatable (tb, tb) */
+  lua_setmetatable (L, -2);
+#if LUA_VERSION_NUM == 501
+  lua_rawseti (L, LUA_ENVIRONINDEX, INDEX_CHARTABLES_LINK);
+#else
+  lua_rawseti (L, -3, INDEX_CHARTABLES_LINK);
+#endif
+
+  return 1;
+}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/tre/ltre.c src/src/tre/ltre.c
--- upstream/src/tre/ltre.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/tre/ltre.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,351 +0,0 @@
-/* ltre.c - Lua binding of TRE regular expressions library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-extern void add_wide_lib (lua_State *L);
-
-#include <tre/tre.h>
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_tre"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_tre
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT REG_EXTENDED
-#define ALG_EFLAGS_DFLT 0
-
-#define ALG_NOMATCH(res)   ((res) == REG_NOMATCH)
-#define ALG_ISMATCH(res)   ((res) == 0)
-#define ALG_SUBBEG(ud,n)   ud->match[n].rm_so
-#define ALG_SUBEND(ud,n)   ud->match[n].rm_eo
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND(ud,n) - ALG_SUBBEG(ud,n))
-#define ALG_SUBVALID(ud,n) (ALG_SUBBEG(ud,n) >= 0)
-#define ALG_NSUB(ud)       ((int)ud->r.re_nsub)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG(ud,n), ALG_SUBLEN(ud,n))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, (offs) + ALG_SUBBEG(ud,n) + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, (offs) + ALG_SUBEND(ud,n))
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)                  (st)
-#define ALG_GETCFLAGS(L,pos)          (int)luaL_optinteger(L, pos, ALG_CFLAGS_DFLT)
-
-typedef struct {
-  regex_t      r;
-  regmatch_t * match;
-  int          freed;
-} TPosix;
-
-#define TUserdata TPosix
-
-#include "../algo.h"
-
-/*  Functions
- ******************************************************************************
- */
-
-static void checkarg_regaparams (lua_State *L, int stackpos,  regaparams_t *argP) {
-  if (lua_type (L, stackpos) != LUA_TTABLE) /* allow for userdata? */
-    luaL_argerror (L, stackpos, "table expected");
-  lua_pushvalue (L, stackpos);
-  argP->cost_ins   = get_int_field (L, "cost_ins");
-  argP->cost_del   = get_int_field (L, "cost_del");
-  argP->cost_subst = get_int_field (L, "cost_subst");
-  argP->max_cost   = get_int_field (L, "max_cost");
-  argP->max_ins    = get_int_field (L, "max_ins");
-  argP->max_del    = get_int_field (L, "max_del");
-  argP->max_subst  = get_int_field (L, "max_subst");
-  argP->max_err    = get_int_field (L, "max_err");
-  lua_pop (L, 1);
-}
-
-/* method r:atfind (s, params, [st], [ef]) */
-/* method r:aexec  (s, params, [st], [ef]) */
-static void checkarg_atfind (lua_State *L, TArgExec *argE, TPosix **ud,
-                             regaparams_t *argP) {
-  *ud = check_ud (L);
-  argE->text = luaL_checklstring (L, 2, &argE->textlen);
-  checkarg_regaparams (L, 3, argP);
-  argE->startoffset = get_startoffset (L, 4, argE->textlen);
-  argE->eflags = (int)luaL_optinteger (L, 5, ALG_EFLAGS_DFLT);
-}
-
-static int generate_error (lua_State *L, const TPosix *ud, int errcode) {
-  char errbuf[80];
-  tre_regerror (errcode, &ud->r, errbuf, sizeof (errbuf));
-  return luaL_error (L, "%s", errbuf);
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TPosix **pud) {
-  int res;
-  TPosix *ud;
-
-  ud = (TPosix *)lua_newuserdata (L, sizeof (TPosix));
-  memset (ud, 0, sizeof (TPosix));          /* initialize all members to 0 */
-
-  res = tre_regncomp (&ud->r, argC->pattern, argC->patlen, argC->cflags);
-  if (res != 0)
-    return generate_error (L, ud, res);
-
-  if (argC->cflags & REG_NOSUB)
-    ud->r.re_nsub = 0;
-  ud->match = (regmatch_t *) Lmalloc (L, (ALG_NSUB(ud) + 1) * sizeof (regmatch_t));
-  if (!ud->match)
-    luaL_error (L, "malloc failed");
-  lua_pushvalue (L, ALG_ENVIRONINDEX);
-  lua_setmetatable (L, -2);
-
-  if (pud) *pud = ud;
-  return 1;
-}
-
-static int generic_atfind (lua_State *L, int tfind) {
-  int res;
-  TArgExec argE;
-  TPosix *ud;
-  regaparams_t argP;
-  regamatch_t res_match;
-
-  checkarg_atfind (L, &argE, &ud, &argP);
-  if (argE.startoffset > (int)argE.textlen)
-    return lua_pushnil(L), 1;
-
-  argE.text += argE.startoffset;
-  res_match.nmatch = ALG_NSUB(ud) + 1;
-  res_match.pmatch = ud->match;
-
-  /* execute the search */
-  res = tre_reganexec (&ud->r, argE.text, argE.textlen - argE.startoffset,
-                   &res_match, argP, argE.eflags);
-  if (ALG_ISMATCH (res)) {
-    ALG_PUSHOFFSETS (L, ud, argE.startoffset, 0);
-    if (tfind)
-      push_substring_table (L, ud, argE.text);
-    else
-      push_offset_table (L, ud, argE.startoffset);
-    /* set values in the dictionary part of the table */
-    set_int_field (L, "cost", res_match.cost);
-    set_int_field (L, "num_ins", res_match.num_ins);
-    set_int_field (L, "num_del", res_match.num_del);
-    set_int_field (L, "num_subst", res_match.num_subst);
-    return 3;
-  }
-  else if (ALG_NOMATCH (res))
-    return lua_pushnil (L), 1;
-  else
-    return generate_error (L, ud, res);
-}
-
-static int Ltre_atfind (lua_State *L) {
-  return generic_atfind (L, 1);
-}
-
-static int Ltre_aexec (lua_State *L) {
-  return generic_atfind (L, 0);
-}
-
-static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
-  if (argE->startoffset > 0)
-    argE->eflags |= REG_NOTBOL;
-  argE->text += argE->startoffset;
-  return tre_regnexec (&ud->r, argE->text, argE->textlen - argE->startoffset,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int findmatch_exec (TPosix *ud, TArgExec *argE) {
-  argE->text += argE->startoffset;
-  return tre_regnexec (&ud->r, argE->text, argE->textlen - argE->startoffset,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static int gsub_exec (TPosix *ud, TArgExec *argE, int st) {
-  if (st > 0)
-    argE->eflags |= REG_NOTBOL;
-  return tre_regnexec (&ud->r, argE->text+st, argE->textlen-st, ALG_NSUB(ud)+1,
-                    ud->match, argE->eflags);
-}
-
-static int split_exec (TPosix *ud, TArgExec *argE, int offset) {
-  if (offset > 0)
-    argE->eflags |= REG_NOTBOL;
-  return tre_regnexec (&ud->r, argE->text + offset, argE->textlen - offset,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static int Ltre_have_backrefs (lua_State *L) {
-  TPosix *ud = check_ud (L);
-  lua_pushboolean (L, tre_have_backrefs (&ud->r));
-  return 1;
-}
-
-static int Ltre_have_approx (lua_State *L) {
-  TPosix *ud = check_ud (L);
-  lua_pushboolean (L, tre_have_approx (&ud->r));
-  return 1;
-}
-
-static int Ltre_gc (lua_State *L) {
-  TPosix *ud = check_ud (L);
-  if (ud->freed == 0) {           /* precaution against "manual" __gc calling */
-    ud->freed = 1;
-    tre_regfree (&ud->r);
-    Lfree (L, ud->match, (ALG_NSUB(ud) + 1) * sizeof (regmatch_t));
-  }
-  return 0;
-}
-
-static int Ltre_tostring (lua_State *L) {
-  TPosix *ud = check_ud (L);
-  if (ud->freed == 0)
-    lua_pushfstring (L, "%s (%p)", REX_TYPENAME, (void*)ud);
-  else
-    lua_pushfstring (L, "%s (deleted)", REX_TYPENAME);
-  return 1;
-}
-
-static flag_pair tre_flags[] =
-{
-  { "BASIC",    REG_BASIC },
-  { "NOSPEC",   REG_NOSPEC },
-  { "EXTENDED", REG_EXTENDED },
-  { "ICASE",    REG_ICASE },
-  { "NOSUB",    REG_NOSUB },
-  { "NEWLINE",  REG_NEWLINE },
-  { "NOTBOL",   REG_NOTBOL },
-  { "NOTEOL",   REG_NOTEOL },
-  /* TRE-specific flags */
-  { "LITERAL",              REG_LITERAL },
-  { "RIGHT_ASSOC",          REG_RIGHT_ASSOC },
-  { "UNGREEDY",             REG_UNGREEDY },
-  { "APPROX_MATCHER",       REG_APPROX_MATCHER },
-  { "BACKTRACKING_MATCHER", REG_BACKTRACKING_MATCHER },
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-static flag_pair tre_error_flags[] = {
-  { "OK",       REG_OK }, /* TRE-specific */
-  { "NOMATCH",  REG_NOMATCH },
-  { "BADPAT",   REG_BADPAT },
-  { "ECOLLATE", REG_ECOLLATE },
-  { "ECTYPE",   REG_ECTYPE },
-  { "EESCAPE",  REG_EESCAPE },
-  { "ESUBREG",  REG_ESUBREG },
-  { "EBRACK",   REG_EBRACK },
-  { "EPAREN",   REG_EPAREN },
-  { "EBRACE",   REG_EBRACE },
-  { "BADBR",    REG_BADBR },
-  { "ERANGE",   REG_ERANGE },
-  { "ESPACE",   REG_ESPACE },
-  { "BADRPT",   REG_BADRPT },
-/*---------------------------------------------------------------------------*/
-  { NULL, 0 }
-};
-
-/* config. flags with integer value */
-static flag_pair tre_config_flags_int[] = {
-  { "CONFIG_APPROX",     TRE_CONFIG_APPROX },
-  { "CONFIG_WCHAR",      TRE_CONFIG_WCHAR },
-  { "CONFIG_MULTIBYTE",  TRE_CONFIG_MULTIBYTE },
-  { "CONFIG_SYSTEM_ABI", TRE_CONFIG_SYSTEM_ABI },
-  { NULL, 0 }
-};
-
-/* config. flags with string value */
-static flag_pair tre_config_flags_str[] = {
-  { "CONFIG_VERSION",    TRE_CONFIG_VERSION },
-  { NULL, 0 }
-};
-
-static int Ltre_get_flags (lua_State *L) {
-  const flag_pair* fps[] = { tre_flags, tre_error_flags, NULL };
-  return get_flags (L, fps);
-}
-
-static int Ltre_config (lua_State *L) {
-  int intval;
-  const char *strval;
-  flag_pair *fp;
-  if (lua_istable (L, 1))
-    lua_settop (L, 1);
-  else
-    lua_newtable (L);
-  for (fp = tre_config_flags_int; fp->key; ++fp) {
-    if (0 == tre_config (fp->val, &intval)) {
-      lua_pushinteger (L, intval);
-      lua_setfield (L, -2, fp->key);
-    }
-  }
-  for (fp = tre_config_flags_str; fp->key; ++fp) {
-    if (0 == tre_config (fp->val, &strval)) {
-      lua_pushstring (L, strval);
-      lua_setfield (L, -2, fp->key);
-    }
-  }
-  return 1;
-}
-
-static int Ltre_version (lua_State *L) {
-  lua_pushstring (L, tre_version ());
-  return 1;
-}
-
-static const luaL_Reg r_methods[] = {
-  { "exec",          algm_exec },
-  { "find",          algm_find },
-  { "match",         algm_match },
-  { "tfind",         algm_tfind },
-  { "aexec",         Ltre_aexec },
-  { "atfind",        Ltre_atfind },
-  { "have_approx",   Ltre_have_approx },
-  { "have_backrefs", Ltre_have_backrefs },
-  { "__gc",          Ltre_gc },
-  { "__tostring",    Ltre_tostring },
-  { NULL, NULL}
-};
-
-static const luaL_Reg r_functions[] = {
-  { "new",           algf_new },
-  { "find",          algf_find },
-  { "gmatch",        algf_gmatch },
-  { "gsub",          algf_gsub },
-  { "count",         algf_count },
-  { "match",         algf_match },
-  { "split",         algf_split },
-  { "config",        Ltre_config },
-  { "flags",         Ltre_get_flags },
-  { "version",       Ltre_version },
-  { NULL, NULL }
-};
-
-/* Open the library */
-REX_API int REX_OPENLIB (lua_State *L)
-{
-  alg_register(L, r_methods, r_functions, "TRE regexes");
-#ifdef REX_ADDWIDECHARFUNCS
-  add_wide_lib (L);
-#endif
-  return 1;
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/src/tre/ltre_w.c src/src/tre/ltre_w.c
--- upstream/src/tre/ltre_w.c	2021-12-28 20:05:16.000000000 +0000
+++ src/src/tre/ltre_w.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,274 +0,0 @@
-/* ltre.c - Lua binding of TRE regular expressions library */
-/* See Copyright Notice in the file LICENSE */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "lua.h"
-#include "lauxlib.h"
-#include "../common.h"
-
-#include <tre/tre.h>
-
-void bufferZ_putrepstringW (TBuffer *BufRep, int reppos, int nsub);
-
-/* These 2 settings may be redefined from the command-line or the makefile.
- * They should be kept in sync between themselves and with the target name.
- */
-#ifndef REX_LIBNAME
-#  define REX_LIBNAME "rex_tre"
-#endif
-#ifndef REX_OPENLIB
-#  define REX_OPENLIB luaopen_rex_tre
-#endif
-
-#define REX_TYPENAME REX_LIBNAME"_regex"
-
-#define ALG_CFLAGS_DFLT REG_EXTENDED
-#define ALG_EFLAGS_DFLT 0
-#define ALG_CHARSIZE 2
-#define BUFFERZ_PUTREPSTRING bufferZ_putrepstringW
-
-#define ALG_NOMATCH(res)   ((res) == REG_NOMATCH)
-#define ALG_ISMATCH(res)   ((res) == 0)
-#define ALG_SUBBEG(ud,n)   (ALG_CHARSIZE * ud->match[n].rm_so)
-#define ALG_SUBEND(ud,n)   (ALG_CHARSIZE * ud->match[n].rm_eo)
-#define ALG_SUBLEN(ud,n)   (ALG_SUBEND(ud,n) - ALG_SUBBEG(ud,n))
-#define ALG_SUBVALID(ud,n) (ALG_SUBBEG(ud,n) >= 0)
-#define ALG_NSUB(ud)       ((int)ud->r.re_nsub)
-
-#define ALG_PUSHSUB(L,ud,text,n) \
-  lua_pushlstring (L, (text) + ALG_SUBBEG(ud,n), ALG_SUBLEN(ud,n))
-
-#define ALG_PUSHSUB_OR_FALSE(L,ud,text,n) \
-  (ALG_SUBVALID(ud,n) ? (void) ALG_PUSHSUB (L,ud,text,n) : lua_pushboolean (L,0))
-
-#define ALG_PUSHSTART(L,ud,offs,n)   lua_pushinteger(L, ((offs) + ALG_SUBBEG(ud,n))/ALG_CHARSIZE + 1)
-#define ALG_PUSHEND(L,ud,offs,n)     lua_pushinteger(L, ((offs) + ALG_SUBEND(ud,n))/ALG_CHARSIZE)
-#define ALG_PUSHOFFSETS(L,ud,offs,n) \
-  (ALG_PUSHSTART(L,ud,offs,n), ALG_PUSHEND(L,ud,offs,n))
-
-#define ALG_BASE(st)                  (st)
-#define ALG_GETCFLAGS(L,pos)          (int)luaL_optinteger(L, pos, ALG_CFLAGS_DFLT)
-
-typedef struct {
-  regex_t      r;
-  regmatch_t * match;
-  int          freed;
-} TPosix;
-
-#define TUserdata TPosix
-
-#include "../algo.h"
-
-/*  Functions
- ******************************************************************************
- */
-
-static void checkarg_regaparams (lua_State *L, int stackpos,  regaparams_t *argP) {
-  if (lua_type (L, stackpos) != LUA_TTABLE) /* allow for userdata? */
-    luaL_argerror (L, stackpos, "table expected");
-  lua_pushvalue (L, stackpos);
-  argP->cost_ins   = get_int_field (L, "cost_ins");
-  argP->cost_del   = get_int_field (L, "cost_del");
-  argP->cost_subst = get_int_field (L, "cost_subst");
-  argP->max_cost   = get_int_field (L, "max_cost");
-  argP->max_ins    = get_int_field (L, "max_ins");
-  argP->max_del    = get_int_field (L, "max_del");
-  argP->max_subst  = get_int_field (L, "max_subst");
-  argP->max_err    = get_int_field (L, "max_err");
-  lua_pop (L, 1);
-}
-
-/* method r:atfind (s, params, [st], [ef]) */
-/* method r:aexec  (s, params, [st], [ef]) */
-static void checkarg_atfind (lua_State *L, TArgExec *argE, TPosix **ud,
-                             regaparams_t *argP) {
-  *ud = check_ud (L);
-  argE->text = luaL_checklstring (L, 2, &argE->textlen);
-  checkarg_regaparams (L, 3, argP);
-  argE->startoffset = get_startoffset (L, 4, argE->textlen);
-  argE->eflags = (int)luaL_optinteger (L, 5, ALG_EFLAGS_DFLT);
-}
-
-static int generate_error (lua_State *L, const TPosix *ud, int errcode) {
-  char errbuf[80];
-  tre_regerror (errcode, &ud->r, errbuf, sizeof (errbuf));
-  return luaL_error (L, "%s", errbuf);
-}
-
-static int compile_regex (lua_State *L, const TArgComp *argC, TPosix **pud) {
-  int res;
-  TPosix *ud;
-
-  ud = (TPosix *)lua_newuserdata (L, sizeof (TPosix));
-  memset (ud, 0, sizeof (TPosix));          /* initialize all members to 0 */
-
-  res = tre_regwncomp (&ud->r, (const wchar_t*)argC->pattern, argC->patlen/ALG_CHARSIZE, argC->cflags);
-  if (res != 0)
-    return generate_error (L, ud, res);
-
-  if (argC->cflags & REG_NOSUB)
-    ud->r.re_nsub = 0;
-  ud->match = (regmatch_t *) Lmalloc (L, (ALG_NSUB(ud) + 1) * sizeof (regmatch_t));
-  if (!ud->match)
-    luaL_error (L, "malloc failed");
-  lua_pushvalue (L, ALG_ENVIRONINDEX);
-  lua_setmetatable (L, -2);
-
-  if (pud) *pud = ud;
-  return 1;
-}
-
-static int generic_atfind (lua_State *L, int tfind) {
-  int res;
-  TArgExec argE;
-  TPosix *ud;
-  regaparams_t argP;
-  regamatch_t res_match;
-
-  checkarg_atfind (L, &argE, &ud, &argP);
-  if (argE.startoffset > (int)argE.textlen)
-    return lua_pushnil(L), 1;
-
-  argE.text += argE.startoffset;
-  res_match.nmatch = ALG_NSUB(ud) + 1;
-  res_match.pmatch = ud->match;
-
-  /* execute the search */
-  res = tre_regawnexec (&ud->r, (const wchar_t*)argE.text,
-    (argE.textlen - argE.startoffset)/ALG_CHARSIZE, &res_match, argP, argE.eflags);
-  if (ALG_ISMATCH (res)) {
-    ALG_PUSHOFFSETS (L, ud, argE.startoffset, 0);
-    if (tfind)
-      push_substring_table (L, ud, argE.text);
-    else
-      push_offset_table (L, ud, argE.startoffset);
-    /* set values in the dictionary part of the table */
-    set_int_field (L, "cost", res_match.cost);
-    set_int_field (L, "num_ins", res_match.num_ins);
-    set_int_field (L, "num_del", res_match.num_del);
-    set_int_field (L, "num_subst", res_match.num_subst);
-    return 3;
-  }
-  else if (ALG_NOMATCH (res))
-    return lua_pushnil (L), 1;
-  else
-    return generate_error (L, ud, res);
-}
-
-static int Ltre_atfind (lua_State *L) {
-  return generic_atfind (L, 1);
-}
-
-static int Ltre_aexec (lua_State *L) {
-  return generic_atfind (L, 0);
-}
-
-static int gmatch_exec (TUserdata *ud, TArgExec *argE) {
-  if (argE->startoffset > 0)
-    argE->eflags |= REG_NOTBOL;
-  argE->text += argE->startoffset;
-  return tre_regwnexec (&ud->r, (const wchar_t*)argE->text, (argE->textlen - argE->startoffset)/ALG_CHARSIZE,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static void gmatch_pushsubject (lua_State *L, TArgExec *argE) {
-  lua_pushlstring (L, argE->text, argE->textlen);
-}
-
-static int findmatch_exec (TPosix *ud, TArgExec *argE) {
-  argE->text += argE->startoffset;
-  return tre_regwnexec (&ud->r, (const wchar_t*)argE->text, (argE->textlen - argE->startoffset)/ALG_CHARSIZE,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static int gsub_exec (TPosix *ud, TArgExec *argE, int st) {
-  if (st > 0)
-    argE->eflags |= REG_NOTBOL;
-  return tre_regwnexec (&ud->r, (const wchar_t*)(argE->text+st), (argE->textlen-st)/ALG_CHARSIZE, ALG_NSUB(ud)+1,
-                    ud->match, argE->eflags);
-}
-
-static int split_exec (TPosix *ud, TArgExec *argE, int offset) {
-  if (offset > 0)
-    argE->eflags |= REG_NOTBOL;
-  return tre_regwnexec (&ud->r, (const wchar_t*)(argE->text + offset), (argE->textlen - offset)/ALG_CHARSIZE,
-                   ALG_NSUB(ud) + 1, ud->match, argE->eflags);
-}
-
-static const luaL_Reg r_methods[] = {
-  { "wexec",         algm_exec },
-  { "wfind",         algm_find },
-  { "wmatch",        algm_match },
-  { "wtfind",        algm_tfind },
-  { "waexec",        Ltre_aexec },
-  { "watfind",       Ltre_atfind },
-  { NULL, NULL}
-};
-
-static const luaL_Reg r_functions[] = {
-  { "wnew",          algf_new },
-  { "wfind",         algf_find },
-  { "wgmatch",       algf_gmatch },
-  { "wgsub",         algf_gsub },
-  { "wcount",        algf_count },
-  { "wmatch",        algf_match },
-  { "wsplit",        algf_split },
-  { NULL, NULL }
-};
-
-/* Add the library */
-void add_wide_lib (lua_State *L)
-{
-  (void)alg_register;
-  lua_pushvalue(L, -2);
-#if LUA_VERSION_NUM == 501
-  luaL_register(L, NULL, r_methods);
-  lua_pop(L, 1);
-  luaL_register(L, NULL, r_functions);
-#else
-  lua_pushvalue(L, -1);
-  luaL_setfuncs(L, r_methods, 1);
-  luaL_setfuncs(L, r_functions, 1);
-#endif
-}
-
-/* 1. When called repeatedly on the same TBuffer, its existing data
-      is discarded and overwritten by the new data.
-   2. The TBuffer's array is never shrunk by this function.
-*/
-void bufferZ_putrepstringW (TBuffer *BufRep, int reppos, int nsub) {
-  wchar_t dbuf[] = { 0, 0 };
-  size_t replen;
-  const wchar_t *p = (const wchar_t*) lua_tolstring (BufRep->L, reppos, &replen);
-  replen /= sizeof(wchar_t);
-  const wchar_t *end = p + replen;
-  BufRep->top = 0;
-  while (p < end) {
-    const wchar_t *q;
-    for (q = p; q < end && *q != L'%'; ++q)
-      {}
-    if (q != p)
-      bufferZ_addlstring (BufRep, p, (q - p) * sizeof(wchar_t));
-    if (q < end) {
-      if (++q < end) {  /* skip % */
-        if (iswdigit (*q)) {
-          int num;
-          *dbuf = *q;
-          num = wcstol (dbuf, NULL, 10);
-          if (num == 1 && nsub == 0)
-            num = 0;
-          else if (num > nsub) {
-            freelist_free (BufRep->freelist);
-            luaL_error (BufRep->L, "invalid capture index");
-          }
-          bufferZ_addnum (BufRep, num);
-        }
-        else bufferZ_addlstring (BufRep, q, 1 * sizeof(wchar_t));
-      }
-      p = q + 1;
-    }
-    else break;
-  }
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/README src/test/README
--- upstream/test/README	2021-12-28 20:05:16.000000000 +0000
+++ src/test/README	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-To test Lrexlib, execute the following command line:
-
-  lua ./runtest.lua [-a] [-v] LIBRARY...
-
--a use the external "Alien" library for "buffer subject" tests,
-   rather than the internal function
--v gives verbose output
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/common_sets.lua src/test/common_sets.lua
--- upstream/test/common_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/common_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,333 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
--- This file should contain only test sets that behave identically
--- when being run with pcre or posix regex libraries.
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function get_gsub (lib)
-  return lib.gsub or
-    function (subj, pattern, repl, n)
-      return lib.new (pattern) : gsub (subj, repl, n)
-    end
-end
-
-local function set_f_gmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt         results }
-    { {"ab",            lib.new"."}, {{"a",N}, {"b",N} } },
-    { {("abcd"):rep(3), "(.)b.(d)"}, {{"a","d"},{"a","d"},{"a","d"}} },
-    { {"abcd",          ".*" },      {{"abcd",N} } },--zero-length match
-    { {"abc",           "^." },      {{"a",N}} },--anchored pattern
-  }
-end
-
-local function set_f_count (lib, flg)
-  return {
-    Name = "Function count",
-    Func = lib.count,
-  --{  subj             patt         results }
-    { {"ab",            lib.new"."}, { 2 } },
-    { {("abcd"):rep(3), "(.)b.(d)"}, { 3 } },
-    { {"abcd",          ".*" },      { 1 } },
-    { {"abc",           "^." },      { 1 } },
-  }
-end
-
-local function set_f_split (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_split (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.split (subj, patt) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function split",
-    Func = test_split,
-  --{  subj             patt      results }
-    { {"ab",     lib.new","},     {{"ab",N,N},                           } },
-    { {"ab",            ","},     {{"ab",N,N},                           } },
-    { {",",             ","},     {{"",",",N},     {"", N, N},           } },
-    { {",,",            ","},     {{"",",",N},     {"",",",N},  {"",N,N} } },
-    { {"a,b",           ","},     {{"a",",",N},    {"b",N,N},            } },
-    { {",a,b",          ","},     {{"",",",N},     {"a",",",N}, {"b",N,N}} },
-    { {"a,b,",          ","},     {{"a",",",N},    {"b",",",N}, {"",N,N} } },
-    { {"a,,b",          ","},     {{"a",",",N},    {"",",",N},  {"b",N,N}} },
-    { {"ab<78>c", "<(.)(.)>"},    {{"ab","7","8"}, {"c",N,N},            } },
-    { {"abc",          "^."},     {{"", "a",N},    {"bc",N,N},           } },--anchored pattern
-    { {"abc",           "^"},     {{"", "", N},    {"abc",N,N},          } },
---  { {"abc",           "$"},     {{"abc","",N},   {"",N,N},             } },
---  { {"abc",         "^|$"},     {{"", "", N},    {"abc","",N},{"",N,N},} },
-  }
-end
-
-local function set_f_find (lib, flg)
-  return {
-    Name = "Function find",
-    Func = lib.find,
-  --  {subj, patt, st},         { results }
-    { {"abcd", lib.new".+"},    { 1,4 }   },      -- [none]
-    { {"abcd", ".+"},           { 1,4 }   },      -- [none]
-    { {"abcd", ".+", 2},        { 2,4 }   },      -- positive st
-    { {"abcd", ".+", -2},       { 3,4 }   },      -- negative st
-    { {"abcd", ".*"},           { 1,4 }   },      -- [none]
-    { {"abc",  "bc"},           { 2,3 }   },      -- [none]
-    { {"abcd", "(.)b.(d)"},     { 1,4,"a","d" }}, -- [captures]
-  }
-end
-
-local function set_f_match (lib, flg)
-  return {
-    Name = "Function match",
-    Func = lib.match,
-  --  {subj, patt, st},         { results }
-    { {"abcd", lib.new".+"},    {"abcd"}  }, -- [none]
-    { {"abcd", ".+"},           {"abcd"}  }, -- [none]
-    { {"abcd", ".+", 2},        {"bcd"}   }, -- positive st
-    { {"abcd", ".+", -2},       {"cd"}    }, -- negative st
-    { {"abcd", ".*"},           {"abcd"}  }, -- [none]
-    { {"abc",  "bc"},           {"bc"}    }, -- [none]
-    { {"abcd", "(.)b.(d)"},     {"a","d"} }, -- [captures]
-  }
-end
-
-local function set_m_exec (lib, flg)
-  return {
-    Name = "Method exec",
-    Method = "exec",
-  --{patt},                 {subj, st}           { results }
-    { {".+"},               {"abcd"},            {1,4,{}}  }, -- [none]
-    { {".+"},               {"abcd",2},          {2,4,{}}  }, -- positive st
-    { {".+"},               {"abcd",-2},         {3,4,{}}  }, -- negative st
-    { {".*"},               {"abcd"},            {1,4,{}}  }, -- [none]
-    { {"bc"},               {"abc"},             {2,3,{}}  }, -- [none]
-    { { "(.)b.(d)"},        {"abcd"},            {1,4,{1,1,4,4}}},--[captures]
-    { {"(a+)6+(b+)"},       {"Taa66bbT",2},      {2,7,{2,3,6,7}}},--[st+captures]
-  }
-end
-
-local function set_m_tfind (lib, flg)
-  return {
-    Name = "Method tfind",
-    Method = "tfind",
-  --{patt},                 {subj, st}           { results }
-    { {".+"},               {"abcd"},            {1,4,{}}  }, -- [none]
-    { {".+"},               {"abcd",2},          {2,4,{}}  }, -- positive st
-    { {".+"},               {"abcd",-2},         {3,4,{}}  }, -- negative st
-    { {".*"},               {"abcd"},            {1,4,{}}  }, -- [none]
-    { {"bc"},               {"abc"},             {2,3,{}}  }, -- [none]
-    { {"(.)b.(d)"},         {"abcd"},            {1,4,{"a","d"}}},--[captures]
-  }
-end
-
-local function set_m_find (lib, flg)
-  return {
-    Name = "Method find",
-    Method = "find",
-  --{patt},                 {subj, st}           { results }
-    { {".+"},               {"abcd"},            {1,4}  }, -- [none]
-    { {".+"},               {"abcd",2},          {2,4}  }, -- positive st
-    { {".+"},               {"abcd",-2},         {3,4}  }, -- negative st
-    { {".*"},               {"abcd"},            {1,4}  }, -- [none]
-    { {"bc"},               {"abc"},             {2,3}  }, -- [none]
-    { {"(.)b.(d)"},         {"abcd"},            {1,4,"a","d"}},--[captures]
-  }
-end
-
-local function set_m_match (lib, flg)
-  return {
-    Name = "Method match",
-    Method = "match",
-  --{patt},                 {subj, st}           { results }
-    { {".+"},               {"abcd"},            {"abcd"}  }, -- [none]
-    { {".+"},               {"abcd",2},          {"bcd" }  }, -- positive st
-    { {".+"},               {"abcd",-2},         {"cd"  }  }, -- negative st
-    { {".*"},               {"abcd"},            {"abcd"}  }, -- [none]
-    { {"bc"},               {"abc"},             {"bc"  }  }, -- [none]
-    {{ "(.)b.(d)"},         {"abcd"},            {"a","d"} }, --[captures]
-  }
-end
-
-local function set_f_gsub1 (lib, flg)
-  local subj, pat = "abcdef", "[abef]+"
-  local cpat = lib.new(pat)
-  return {
-    Name = "Function gsub, set1",
-    Func = get_gsub (lib),
-  --{ s,       p,    f,   n,    res1,  res2, res3 },
-    { {subj,  cpat,  "",  0},   {subj,    0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  "",  0},   {subj,    0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  "", -1},   {subj,    0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  "",  1},   {"cdef",  1, 1} },
-    { {subj,   pat,  "",  2},   {"cd",    2, 2} },
-    { {subj,   pat,  "",  3},   {"cd",    2, 2} },
-    { {subj,   pat,  ""    },   {"cd",    2, 2} },
-    { {subj,   pat,  "#", 0},   {subj,    0, 0} }, -- test "n" + non-empty_replace
-    { {subj,   pat,  "#", 1},   {"#cdef", 1, 1} },
-    { {subj,   pat,  "#", 2},   {"#cd#",  2, 2} },
-    { {subj,   pat,  "#", 3},   {"#cd#",  2, 2} },
-    { {subj,   pat,  "#"   },   {"#cd#",  2, 2} },
-    { {"abc",  "^.", "#"   },   {"#bc",   1, 1} }, -- anchored pattern
-  }
-end
-
-local function set_f_gsub2 (lib, flg)
-  local subj, pat = "abc", "([ac])"
-  return {
-    Name = "Function gsub, set2",
-    Func = get_gsub (lib),
-  --{ s,     p,   f,   n,     res1,    res2, res3 },
-    { {subj, pat, "<%1>" },   {"<a>b<c>", 2, 2} }, -- test non-escaped chars in f
-    { {subj, pat, "%<%1%>" }, {"<a>b<c>", 2, 2} }, -- test escaped chars in f
-    { {subj, pat, "" },       {"b",       2, 2} }, -- test empty replace
-    { {subj, pat, "1" },      {"1b1",     2, 2} }, -- test odd and even %'s in f
-    { {subj, pat, "%1" },     {"abc",     2, 2} },
-    { {subj, pat, "%%1" },    {"%1b%1",   2, 2} },
-    { {subj, pat, "%%%1" },   {"%ab%c",   2, 2} },
-    { {subj, pat, "%%%%1" },  {"%%1b%%1", 2, 2} },
-    { {subj, pat, "%%%%%1" }, {"%%ab%%c", 2, 2} },
-  }
-end
-
-local function set_f_gsub3 (lib, flg)
-  return {
-    Name = "Function gsub, set3",
-    Func = get_gsub (lib),
-  --{ s,      p,      f,  n,   res1,res2,res3 },
-    { {"abc", "a",    "%0" }, {"abc", 1, 1} }, -- test (in)valid capture index
-    { {"abc", "a",    "%1" }, {"abc", 1, 1} },
-    { {"abc", "[ac]", "%1" }, {"abc", 2, 2} },
-    { {"abc", "(a)",  "%1" }, {"abc", 1, 1} },
-    { {"abc", "(a)",  "%2" }, "invalid capture index" },
-  }
-end
-
-local function set_f_gsub4 (lib, flg)
-  return {
-    Name = "Function gsub, set4",
-    Func = get_gsub (lib),
-  --{ s,           p,              f, n,  res1,      res2, res3 },
-    { {"a2c3",     ".",            "#" }, {"####",      4, 4} }, -- test .
-    { {"a2c3",     ".+",           "#" }, {"#",         1, 1} }, -- test .+
-    { {"a2c3",     ".*",           "#" }, {"#",         1, 1} }, -- test .*
-    { {"/* */ */", "\\/\\*(.*)\\*\\/", "#" }, {"#",     1, 1} },
-    { {"a2c3",     "[0-9]",        "#" }, {"a#c#",      2, 2} }, -- test %d
-    { {"a2c3",     "[^0-9]",       "#" }, {"#2#3",      2, 2} }, -- test %D
-    { {"a \t\nb",  "[ \t\n]",      "#" }, {"a###b",     3, 3} }, -- test %s
-    { {"a \t\nb",  "[^ \t\n]",     "#" }, {"# \t\n#",   2, 2} }, -- test %S
-  }
-end
-
-local function set_f_gsub5 (lib, flg)
-  local function frep1 () end                       -- returns nothing
-  local function frep2 () return "#" end            -- ignores arguments
-  local function frep3 (...) return table.concat({...}, ",") end -- "normal"
-  local function frep4 () return {} end             -- invalid return type
-  local function frep5 () return "7", "a" end       -- 2-nd return is "a"
-  local function frep6 () return "7", "break" end   -- 2-nd return is "break"
-  local subj = "a2c3"
-  return {
-    Name = "Function gsub, set5",
-    Func = get_gsub (lib),
-  --{ s,     p,          f,   n,   res1,     res2, res3 },
-    { {subj, "a(.)c(.)", frep1 }, {subj,        1, 0} },
-    { {subj, "a(.)c(.)", frep2 }, {"#",         1, 1} },
-    { {subj, "a(.)c(.)", frep3 }, {"2,3",       1, 1} },
-    { {subj, "a.c.",     frep3 }, {subj,        1, 1} },
-    { {subj, "z*",       frep1 }, {subj,        5, 0} },
-    { {subj, "z*",       frep2 }, {"#a#2#c#3#", 5, 5} },
-    { {subj, "z*",       frep3 }, {subj,        5, 5} },
-    { {subj, subj,       frep4 }, "invalid return type" },
-    { {"abc",".",        frep5 }, {"777",       3, 3} },
-    { {"abc",".",        frep6 }, {"777",       3, 3} },
-  }
-end
-
-local function set_f_gsub6 (lib, flg)
-  local tab1, tab2, tab3 = {}, { ["2"] = 56 }, { ["2"] = {} }
-  local subj = "a2c3"
-  return {
-    Name = "Function gsub, set6",
-    Func = get_gsub (lib),
-  --{ s,     p,          f, n,   res1,res2,res3 },
-    { {subj, "a(.)c(.)", tab1 }, {subj,  1, 0} },
-    { {subj, "a(.)c(.)", tab2 }, {"56",  1, 1} },
-    { {subj, "a(.)c(.)", tab3 }, "invalid replacement type" },
-    { {subj, "a.c.",     tab1 }, {subj,  1, 0} },
-    { {subj, "a.c.",     tab2 }, {subj,  1, 0} },
-    { {subj, "a.c.",     tab3 }, {subj,  1, 0} },
-  }
-end
-
-local function set_f_gsub8 (lib, flg)
-  local subj, patt, repl = "abcdef", "..", "*"
-  return {
-    Name = "Function gsub, set8",
-    Func = get_gsub (lib),
-  --{ s,     p,       f, n,                                    res1,  res2, res3 },
-    { {subj, patt, repl, function() end },                    {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil end },         {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return false end },       {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return true end },        {"***",    3, 3} },
-    { {subj, patt, repl, function() return {} end },          {"***",    3, 3} },
-    { {subj, patt, repl, function() return "#" end },         {"###",    3, 3} },
-    { {subj, patt, repl, function() return 57 end },          {"575757", 3, 3} },
-    { {subj, patt, repl, function (from) return from end },   {"135",    3, 3} },
-    { {subj, patt, repl, function (from, to) return to end }, {"246",    3, 3} },
-    { {subj, patt, repl, function (from,to,rep) return rep end },
-                                                              {"***",    3, 3} },
-    { {subj, patt, repl, function (from, to, rep) return rep..to..from end },
-                                                           {"*21*43*65", 3, 3} },
-    { {subj, patt, repl, function() return nil end },         {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, nil end },    {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, false end },  {"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, true end },   {"ab**",   3, 2} },
-    { {subj, patt, repl, function() return true, true end },  {"***",    3, 3} },
-    { {subj, patt, repl, function() return nil, 0 end },      {"abcdef", 1, 0} },
-    { {subj, patt, repl, function() return true, 0 end },     {"*cdef",  1, 1} },
-    { {subj, patt, repl, function() return nil, 1 end },      {"ab*ef",  2, 1} },
-    { {subj, patt, repl, function() return true, 1 end },     {"**ef",   2, 2} },
-  }
-end
-
-return function (libname)
-  local lib = require (libname)
-  return {
-    set_f_gmatch    (lib),
-    set_f_split     (lib),
-    set_f_find      (lib),
-    set_f_match     (lib),
-    set_m_exec      (lib),
-    set_m_tfind     (lib),
-    set_m_find      (lib),
-    set_m_match     (lib),
-    set_f_count     (lib),
-    set_f_gsub1     (lib),
-    set_f_gsub2     (lib),
-    set_f_gsub3     (lib),
-    set_f_gsub4     (lib),
-    set_f_gsub5     (lib),
-    set_f_gsub6     (lib),
-    set_f_gsub8     (lib),
-  }
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/emacs_sets.lua src/test/emacs_sets.lua
--- upstream/test/emacs_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/emacs_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,54 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function set_f_gmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt, flg.SYNTAX_EMACS, nil) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt         results }
-    { {("abcd"):rep(3), "\\(.\\)b.\\(d\\)"}, {{"a","d"},{"a","d"},{"a","d"}} },
-  }
-end
-
-local function set_f_split (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_split (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.split (subj, patt, flg.SYNTAX_EMACS, nil) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function split",
-    Func = test_split,
-  --{  subj             patt      results }
-    { {"ab<78>c", "<\\(.\\)\\(.\\)>"},    {{"ab","7","8"}, {"c",N,N},            } },
-  }
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  return {
-    set_f_gmatch    (lib, flags),
-    set_f_split     (lib, flags),
-  }
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/gnu_sets.lua src/test/gnu_sets.lua
--- upstream/test/gnu_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/gnu_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,52 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function set_f_gmatch (lib, flg)
-  local downcase = {}
-  for i = 0, 255 do -- 255 == UCHAR_MAX
-    downcase[i] = string.gsub(string.char (i), ".", function (s) return string.lower(s) end)
-  end
-  -- gmatch (s, p, [cf], [ef], [tr])
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt, nil, nil, downcase) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt         results }
-    { {"abA",           "a"},        {{"a",N}, {"A",N} } },
-  }
-end
-
-local function set_f_match (lib, flg)
-return {
-  Name = "Function match",
-  Func = lib.match,
-  --{subj,   patt,      st,cf,ef},           { results }
-  { {"abcd", ".+",      5},                  { N }    }, -- failing st
-  { {"abc",  "^abc"},                        {"abc" } }, -- anchor
-  { {"abc",  "^abc",    N,N,flg.not_bol},    { N }    }, -- anchor + ef
-  { {"abc",  "abc$",    N,N,flg.not_eol},    { N }    }, -- anchor + ef
-  { {"cabcaab", "ca+b", N,N,flg.backward},    {"caab" }  }, -- reverse search
-}
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  return {
-    set_f_match     (lib, flags),
-    set_f_gmatch    (lib),
-  }
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/luatest.lua src/test/luatest.lua
--- upstream/test/luatest.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/luatest.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,152 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
--- arrays: deep comparison
-local function eq (t1, t2, lut)
-  if t1 == t2 then return true end
-  if type(t1) ~= "table" or type(t2) ~= "table" or #t1 ~= #t2 then
-    return false
-  end
-
-  lut = lut or {} -- look-up table: are these 2 arrays already compared?
-  lut[t1] = lut[t1] or {}
-  if lut[t1][t2] then return true end
-  lut[t2] = lut[t2] or {}
-  lut[t1][t2], lut[t2][t1] = true, true
-
-  for k,v in ipairs (t1) do
-    if not eq (t2[k], v, lut) then return false end -- recursion
-  end
-  return true
-end
-
--- a "nil GUID", to be used instead of nils in datasets
-local NT = "b5f74fe5-46f4-483a-8321-e58ba2fa0e17"
-
--- pack vararg in table, replacing nils with "NT" items
-local function packNT (...)
-  local t = {}
-  for i=1, select ("#", ...) do
-    local v = select (i, ...)
-    t[i] = (v == nil) and NT or v
-  end
-  return t
-end
-
--- unpack table into vararg, replacing "NT" items with nils
-local function unpackNT (t)
-  local len = #t
-  local function unpack_from (i)
-    local v = t[i]
-    if v == NT then v = nil end
-    if i == len then return v end
-    return v, unpack_from (i+1)
-  end
-  if len > 0 then return unpack_from (1) end
-end
-
--- print results (deep into arrays)
-local function print_results (val, indent, lut)
-  indent = indent or ""
-  lut = lut or {} -- look-up table
-  local str = tostring (val)
-  if type (val) == "table" then
-    if lut[val] then
-      io.write (indent, str, "\n")
-    else
-      lut[val] = true
-      io.write (indent, str, "\n")
-      for i,v in ipairs (val) do
-        print_results (v, "  " .. indent, lut) -- recursion
-      end
-    end
-  else
-    io.write (indent, val == NT and "nil" or str, "\n")
-  end
-end
-
--- returns:
---  1) true, if success; false, if failure
---  2) test results table or error_message
-local function test_function (test, func, newmembuffer)
-  local res
-  local t = packNT (pcall (func, unpackNT (test[1])))
-  if t[1] then
-    table.remove (t, 1)
-    res = t
-    if newmembuffer then
-      test[1][1] = newmembuffer (test[1][1])
-      local t = packNT (pcall (func, unpackNT (test[1])))
-      if t[1] then
-        table.remove (t, 1)
-        res = t
-      else
-        print "buffer subjects test failed"
-        res = t[2] --> error_message
-      end
-    end
-  else
-    res = t[2] --> error_message
-  end
-  local how = (type (res) == type (test[2])) and
-    (type (res) == "string" or eq (res, test[2])) -- allow error messages to differ
-  return how, res
-end
-
--- returns:
---  1) true, if success; false, if failure
---  2) test results table or error_message
---  3) test results table or error_message
-local function test_method (test, constructor, name)
-  local res1, res2
-  local subject = test[2][1]
-  local ok, r = pcall (constructor, unpackNT (test[1]))
-  if ok then
-    local t = packNT (pcall (r[name], r, unpackNT (test[2])))
-    if t[1] then
-      table.remove (t, 1)
-      res1, res2 = t
-    else
-      res1, res2 = 2, t[2] --> 2, error_message
-    end
-  else
-    res1, res2 = 1, r  --> 1, error_message
-  end
-  return eq (res1, test[3]), res1, res2
-end
-
--- returns: a list of failed tests
-local function test_set (set, lib, newmembuffer)
-  local list = {}
-
-  if type (set.Func) == "function" then
-    local func = set.Func
-    for i,test in ipairs (set) do
-      local ok, res = test_function (test, func, newmembuffer)
-      if not ok then
-        table.insert (list, {i=i, res})
-      end
-    end
-
-  elseif type (set.Method) == "string" then
-    for i,test in ipairs (set) do
-      local ok, res1, res2 = test_method (test, lib.new, set.Method)
-      if not ok then
-        table.insert (list, {i=i, res1, res2})
-      end
-    end
-
-  else
-    error ("neither set.Func nor set.Method is valid")
-  end
-
-  return list
-end
-
-return {
-  eq = eq,
-  NT = NT,
-  print_results = print_results,
-  test_function = test_function,
-  test_method = test_method,
-  test_set = test_set,
-}
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/oniguruma_sets.lua src/test/oniguruma_sets.lua
--- upstream/test/oniguruma_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/oniguruma_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,177 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function fill (n, m)
-  local t = {}
-  for i = n, m, -1 do table.insert (t, i) end
-  return t
-end
-
-local function set_named_subpatterns (lib, flg)
-  return {
-    Name = "Named Subpatterns",
-    Func = function (subj, methodname, patt, name1, name2)
-      local r = lib.new (patt)
-      local _,_,caps = r[methodname] (r, subj)
-      return norm(caps[name1]), norm(caps[name2])
-    end,
-    --{} N.B. subject is always first element
-    { {"abcd", "tfind", "(?<dog>.)b.(?<cat>d)", "dog", "cat"},  {"a","d"} },
-    { {"abcd", "exec",  "(?<dog>.)b.(?<cat>d)", "dog", "cat"},  {"a","d"} },
-  }
-end
-
-local function set_f_find (lib, flg)
-  local cp1251 =
-    ""
-  local loc = "CP1251"
-  return {
-  Name = "Function find",
-  Func = lib.find,
-  --{subj,   patt,      st,cf,ef,lo},        { results }
-  { {"abcd", ".+",      5},                  { N   } }, -- failing st
-  { {"abcd", ".*?"},                         { 1,0 } }, -- non-greedy
-  { {"abc",  "aBC",     N,flg.IGNORECASE},   { 1,3 } }, -- cf
-  { {"abc",  "aBC",     N,"i"         },     { 1,3 } }, -- cf
-  { {cp1251, "[[:upper:]]+", N,N,N, loc},    { 1,33} }, -- locale
-  { {cp1251, "[[:lower:]]+", N,N,N, loc},    {34,66} }, -- locale
-  { {cp1251, "\\w+",         N,N,N, loc},    {1, 66} }, -- locale
-}
-end
-
-local function set_f_match (lib, flg)
-  return {
-  Name = "Function match",
-  Func = lib.match,
-  --{subj,   patt,      st,cf,ef,lo},        { results }
-  { {"abcd", ".+",      5},                  { N    }}, -- failing st
-  { {"abcd", ".*?"},                         { ""   }}, -- non-greedy
-  { {"abc",  "aBC",     N,flg.IGNORECASE},   {"abc" }}, -- cf
-  { {"abc",  "aBC",     N,"i"         },     {"abc" }}, -- cf
-}
-end
-
-local function set_f_gmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local pCSV = "[^,]*"
-  local F = false
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt    results }
-    { {"a\0c",          "." },  {{"a",N},{"\0",N},{"c",N}} },--nuls in subj
-    { {"",              pCSV},  {{"",N}} },
-    { {"12",            pCSV},  {{"12",N}} },
-    { {",",             pCSV},  {{"", N},{"", N}} },
-    { {"12,,45",        pCSV},  {{"12",N},{"",N},{"45",N}} },
-    { {",,12,45,,ab,",  pCSV},  {{"",N},{"",N},{"12",N},{"45",N},{"",N},{"ab",N},{"",N}} },
-    { {"12345",     "(.)(.)"},  {{"1","2"},{"3","4"}} },
-    { {"12345",     "(.)(.?)"}, {{"1","2"},{"3","4"},{"5",""}} },
-  }
-end
-
-local function set_f_split (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_split (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.split (subj, patt) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function split",
-    Func = test_split,
-  --{  subj             patt      results }
-    { {"a,\0,c",       ","},     {{"a",",",N},{"\0",",",N},{"c",N,N},   } },--nuls in subj
-    { {"ab",           "$"},     {{"ab","",N}, {"",N,N}                } },
-    { {"ab",         "^|$"},     {{"", "", N}, {"ab","",N}, {"",N,N}   } },
-    { {"ab45ab","(?<=ab).*?"},   {{"ab","",N}, {"45ab","",N}, {"",N,N} } },
-    { {"ab",         "\\b"},     {{"", "", N}, {"ab","",N}, {"",N,N}   } },
-    { {"ab",         ".*" },     {{"","ab",N}, {"",N,N}                } },
-    { {"ab",         ".*?" },    {{"","",N}, {"a","",N}, {"b","",N}, {"",N,N} } },
-    { {"ab;de",      ";*" },     {{"","",N},{"a","",N},{"b",";",N},{"d","",N},{"e","",N},{"",N,N} }},
-  }
-end
-
-local function set_f_internal_test (lib, flg)
-  return {
-    Name = "Function internal_test",
-    Func = lib.internal_test,
-  --{ params      results }
-    { {""},       {true} },
-  }
-end
-
-local function set_m_exec (lib, flg)
-  return {
-  Name = "Method exec",
-  Method = "exec",
---{patt,cf,lo},           {subj,st,ef}              { results }
-  { {".+"},               {"abcd",5},               { N }    }, -- failing st
-  { {".*?"},              {"abcd"},                 {1,0,{}} }, -- non-greedy
-  { {"aBC",flg.IGNORECASE}, {"abc"},                {1,3,{}} }, -- cf
-  { {"aBC","i"         }, {"abc"},                  {1,3,{}} }, -- cf
-}
-end
-
-local function set_m_tfind (lib, flg)
-  return {
-  Name = "Method tfind",
-  Method = "tfind",
---{patt,cf,lo},           {subj,st,ef}              { results }
-  { {".+"},               {"abcd",5},               { N }    }, -- failing st
-  { {".*?"},              {"abcd"},                 {1,0,{}} }, -- non-greedy
-  { {"aBC",flg.IGNORECASE}, {"abc"},                {1,3,{}} }, -- cf
-  { {"aBC","i"         }, {"abc"},                  {1,3,{}} }, -- cf
-}
-end
-
-local function set_m_capturecount (lib, flg)
-  return {
-  Name = "Method capturecount",
-  Method = "capturecount",
---{patt,cf,lo},           {subj,st,ef}              { results }
-  { {"a"},                {},                       { 0 }  },
-  { {"(a)"},              {},                       { 1 }  },
-  { {"(a)(a)"},           {},                       { 2 }  },
-  { {"((a)a)"},           {},                       { 2 }  },
-  { {"((?i)a)(?:a)"},     {},                       { 1 }  },
-}
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  local sets = {
-    set_f_internal_test (lib, flags),
-    set_f_match  (lib, flags),
-    set_f_find   (lib, flags),
-    set_f_gmatch (lib, flags),
-    set_f_split  (lib, flags),
-    set_m_exec   (lib, flags),
-    set_m_tfind  (lib, flags),
-    set_m_capturecount (lib, flags),
-  }
-  local MAJOR = tonumber(lib.version():match("%d+"))
-  if MAJOR >= 0 then
-    table.insert (sets, set_named_subpatterns (lib, flags))
-  end
-  return sets
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/pat2pcre.lua src/test/pat2pcre.lua
--- upstream/test/pat2pcre.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/pat2pcre.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,83 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
--- Convert Lua regex pattern to its PCRE equivalent.
-
-local t_esc = {
-  a = "[:alpha:]",
-  A = "[:^alpha:]",
-  c = "[:cntrl:]",
-  C = "[:^cntrl:]",
-  l = "[:lower:]",
-  L = "[:^lower:]",
-  p = "[:punct:]",
-  P = "[:^punct:]",
-  u = "[:upper:]",
-  U = "[:^upper:]",
-  w = "[:alnum:]",
-  W = "[:^alnum:]",
-  x = "[:xdigit:]",
-  X = "[:^xdigit:]",
-  z = "\\x00",
-  Z = "\\x01-\\xFF",
-}
-
-local function rep_normal (ch)
-  assert (ch ~= "b", "\"%b\" subpattern is not supported")
-  assert (ch ~= "0", "invalid capture index")
-  local v = t_esc[ch]
-  return v and ("[" .. v .. "]") or ("\\" .. ch)
-end
-
-local function rep_charclass (ch)
-  return t_esc[ch] or ("\\" .. ch)
-end
-
-function pat2pcre (s)
-  local ind = 0
-
-  local function getc ()
-    ind = ind + 1
-    return string.sub (s, ind, ind)
-  end
-
-  local function getnum ()
-    local num = string.match (s, "^\\(%d%d?%d?)", ind)
-    if num then
-      ind = ind + #num
-      return string.format ("\\x%02X", num)
-    end
-  end
-
-  local out, state = "", "normal"
-  while ind < #s do
-    local ch = getc ()
-    if state == "normal" then
-      if ch == "%" then
-        out = out .. rep_normal (getc ())
-      elseif ch == "-" then
-        out = out .. "*?"
-      elseif ch == "." then
-        out = out .. "\\C"
-      elseif ch == "[" then
-        out = out .. ch
-        state = "charclass"
-      else
-        local num = getnum ()
-        out = num and (out .. num) or (out .. ch)
-      end
-    elseif state == "charclass" then
-      if ch == "%" then
-        out = out .. rep_charclass (getc ())
-      elseif ch == "]" then
-        out = out .. ch
-        state = "normal"
-      else
-        local num = getnum ()
-        out = num and (out .. num) or (out .. ch)
-      end
-    end
-  end
-  return out
-end
-
-return pat2pcre
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/pcre_sets.lua src/test/pcre_sets.lua
--- upstream/test/pcre_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/pcre_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,195 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function fill (n, m)
-  local t = {}
-  for i = n, m, -1 do table.insert (t, i) end
-  return t
-end
-
-local function set_named_subpatterns (lib, flg)
-  return {
-    Name = "Named Subpatterns",
-    Func = function (subj, methodname, patt, name1, name2)
-      local r = lib.new (patt)
-      local _,_,caps = r[methodname] (r, subj)
-      return norm(caps[name1]), norm(caps[name2])
-    end,
-    --{} N.B. subject is always first element
-    { {"abcd", "tfind", "(?P<dog>.)b.(?P<cat>d)", "dog", "cat"},  {"a","d"} },
-    { {"abcd", "exec",  "(?P<dog>.)b.(?P<cat>d)", "dog", "cat"},  {"a","d"} },
-  }
-end
-
-local function set_f_find (lib, flg)
-  local cp1251 =
-    ""
-  local loc = "Russian_Russia.1251"
-  return {
-  Name = "Function find",
-  Func = lib.find,
-  --{subj,   patt,      st,cf,ef,lo},        { results }
-  { {"abcd", ".+",      5},                  { N   } }, -- failing st
-  { {"abcd", ".*?"},                         { 1,0 } }, -- non-greedy
-  { {"abc",  "aBC",     N,flg.CASELESS},     { 1,3 } }, -- cf
-  { {"abc",  "aBC",     N,"i"         },     { 1,3 } }, -- cf
-  { {"abc",  "bc",      N,flg.ANCHORED},     { N   } }, -- cf
-  { {"abc",  "bc",      N,N,flg.ANCHORED},   { N   } }, -- ef
---{ {cp1251, "[[:upper:]]+", N,N,N, loc},    { 1,33} }, -- locale
---{ {cp1251, "[[:lower:]]+", N,N,N, loc},    {34,66} }, -- locale
-}
-end
-
-local function set_f_match (lib, flg)
-  return {
-  Name = "Function match",
-  Func = lib.match,
-  --{subj,   patt,      st,cf,ef,lo},        { results }
-  { {"abcd", ".+",      5},                  { N    }}, -- failing st
-  { {"abcd", ".*?"},                         { ""   }}, -- non-greedy
-  { {"abc",  "aBC",     N,flg.CASELESS},     {"abc" }}, -- cf
-  { {"abc",  "aBC",     N,"i"         },     {"abc" }}, -- cf
-  { {"abc",  "bc",      N,flg.ANCHORED},     { N    }}, -- cf
-  { {"abc",  "bc",      N,N,flg.ANCHORED},   { N    }}, -- ef
-}
-end
-
-local function set_f_gmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local pCSV = "[^,]*"
-  local F = false
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt    results }
-    { {"a\0c",          "." },  {{"a",N},{"\0",N},{"c",N}} },--nuls in subj
-    { {"",              pCSV},  {{"",N}} },
-    { {"12",            pCSV},  {{"12",N}} },
-    { {",",             pCSV},  {{"", N},{"", N}} },
-    { {"12,,45",        pCSV},  {{"12",N},{"",N},{"45",N}} },
-    { {",,12,45,,ab,",  pCSV},  {{"",N},{"",N},{"12",N},{"45",N},{"",N},{"ab",N},{"",N}} },
-    { {"12345",     "(.)(.)"},  {{"1","2"},{"3","4"}} },
-    { {"12345",     "(.)(.?)"}, {{"1","2"},{"3","4"},{"5",""}} },
-  }
-end
-
-local function set_f_split (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_split (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.split (subj, patt) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function split",
-    Func = test_split,
-  --{  subj             patt      results }
-    { {"a,\0,c",       ","},     {{"a",",",N},{"\0",",",N},{"c",N,N},   } },--nuls in subj
-    { {"ab",           "$"},     {{"ab","",N}, {"",N,N}                } },
-    { {"ab",         "^|$"},     {{"", "", N}, {"ab","",N}, {"",N,N}   } },
-    { {"ab45ab","(?<=ab).*?"},   {{"ab","",N}, {"45ab","",N}, {"",N,N} } },
-    { {"ab",         "\\b"},     {{"", "", N}, {"ab","",N}, {"",N,N}   } },
-    { {"ab",         ".*" },     {{"","ab",N}, {"",N,N}                } },
-    { {"ab",         ".*?" },    {{"","",N}, {"a","",N}, {"b","",N}, {"",N,N} } },
-    { {"ab;de",      ";*" },     {{"","",N},{"a","",N},{"b",";",N},{"d","",N},{"e","",N},{"",N,N} }},
-  }
-end
-
-local function set_m_exec (lib, flg)
-  return {
-  Name = "Method exec",
-  Method = "exec",
---{patt,cf,lo},           {subj,st,ef}              { results }
-  { {".+"},               {"abcd",5},               { N }    }, -- failing st
-  { {".*?"},              {"abcd"},                 {1,0,{}} }, -- non-greedy
-  { {"aBC",flg.CASELESS}, {"abc"},                  {1,3,{}} }, -- cf
-  { {"aBC","i"         }, {"abc"},                  {1,3,{}} }, -- cf
-  { {"bc",flg.ANCHORED},  {"abc"},                  { N }    }, -- cf
-  { {"bc"},               {"abc",N, flg.ANCHORED},  { N }    }, -- ef
-}
-end
-
-local function set_m_tfind (lib, flg)
-  return {
-  Name = "Method tfind",
-  Method = "tfind",
---{patt,cf,lo},           {subj,st,ef}              { results }
-  { {".+"},               {"abcd",5},               { N }    }, -- failing st
-  { {".*?"},              {"abcd"},                 {1,0,{}} }, -- non-greedy
-  { {"aBC",flg.CASELESS}, {"abc"},                  {1,3,{}} }, -- cf
-  { {"aBC","i"         }, {"abc"},                  {1,3,{}} }, -- cf
-  { {"bc",flg.ANCHORED},  {"abc"},                  { N }    }, -- cf
-  { {"bc"},               {"abc",N, flg.ANCHORED},  { N }    }, -- ef
-}
-end
-
-local function set_m_dfa_exec (lib, flg)
-  local ver = tonumber(lib.version():match("%d+%.%d+"))
-  local NAP = ver < 8.34 and "" or "(*NO_AUTO_POSSESS)"
-  local flag_partial = ver < 10.0 and flg.PARTIAL or flg.PARTIAL_SOFT
-  return {
-  Name = "Method dfa_exec",
-  Method = "dfa_exec",
---{patt,cf,lo},           {subj,st,ef,os,ws}        { results }
-  { {NAP..".+"},          {"abcd"},                 {1,{4,3,2,1},4} }, -- [none]
-  { {NAP..".+"},          {"abcd",2},               {2,{4,3,2},  3} }, -- positive st
-  { {NAP..".+"},          {"abcd",-2},              {3,{4,3},    2} }, -- negative st
-  { {".+"},               {"abcd",5},               {N }            }, -- failing st
-  { {NAP..".*"},          {"abcd"},                 {1,{4,3,2,1,0},5}}, -- [none]
-  { {".*?"},              {"abcd"},                 {1,{4,3,2,1,0},5}}, -- non-greedy
-  { {"aBC",flg.CASELESS}, {"abc"},                  {1,{3},1}  }, -- cf
-  { {"aBC","i"         }, {"abc"},                  {1,{3},1}  }, -- cf
-  { {"bc"},               {"abc"},                  {2,{3},1}  }, -- [none]
-  { {"bc",flg.ANCHORED},  {"abc"},                  {N }       }, -- cf
-  { {"bc"},               {"abc",N, flg.ANCHORED},  {N }       }, -- ef
-  { { "(.)b.(d)"},        {"abcd"},                 {1,{4},1}  }, --[captures]
-  { {"abc"},              {"ab"},                   {N }       },
-  { {"abc"},              {"ab",N,flag_partial},    {1,{2},flg.ERROR_PARTIAL} },
-  { {NAP..".+"}, {string.rep("a",50),N,N,50,50},    {1, fill(50,26), 0}},-- small ovecsize
-}
-end
-
-local function set_m_fullinfo (lib, flg)
-  local r = lib.new("(foo)(bar)")
-  local info = r:fullinfo()
-  assert(info.CAPTURECOUNT == 2)
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  local sets = {
-    set_f_match  (lib, flags),
-    set_f_find   (lib, flags),
-    set_f_gmatch (lib, flags),
-    set_f_split  (lib, flags),
-    set_m_exec   (lib, flags),
-    set_m_tfind  (lib, flags),
-    set_m_fullinfo (lib, flags),
-  }
-  if flags.MAJOR >= 4 then
-    table.insert (sets, set_named_subpatterns (lib, flags))
-  end
-  if flags.MAJOR >= 6 then
-    table.insert (sets, set_m_dfa_exec (lib, flags))
-  end
-  return sets
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/pcre_sets2.lua src/test/pcre_sets2.lua
--- upstream/test/pcre_sets2.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/pcre_sets2.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,200 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local pat2pcre = require "pat2pcre"
-local unpack = unpack or table.unpack
-
-local function get_gsub (lib)
-  return lib.gsub or
-    function (subj, pattern, repl, n)
-      return lib.new (pattern) : gsub (subj, repl, n)
-    end
-end
-
-local function set_f_gsub1 (lib, flg)
-  local subj, pat = "abcdef", "[abef]+"
-  return {
-    Name = "Function gsub, set1",
-    Func = get_gsub (lib),
-  --{ s,       p,    f,   n,    res1,  res2, res3 },
-    { {"a\0c", ".",  "#"   },   {"###",   3, 3} }, -- subj contains nuls
-  }
-end
-
-local function set_f_gsub4 (lib, flg)
-  local pCSV = "(^[^,]*)|,([^,]*)"
-  local fCSV = function (a,b) return "["..(a or b).."]" end
-  local set = {
-    Name = "Function gsub, set4",
-    Func = get_gsub (lib),
-  --{ s,           p,              f, n,  res1,      res2, res3 },
-    { {"/* */ */", "%/%*(.*)%*%/", "#" }, {"#",         1, 1} },
-    { {"a2c3",     ".-",           "#" }, {"#a#2#c#3#", 5, 5} }, -- test .-
-    { {"/**/",     "%/%*(.-)%*%/", "#" }, {"#",         1, 1} },
-    { {"/* */ */", "%/%*(.-)%*%/", "#" }, {"# */",      1, 1} },
-    { {"a2c3",     "%d",           "#" }, {"a#c#",      2, 2} }, -- test %d
-    { {"a2c3",     "%D",           "#" }, {"#2#3",      2, 2} }, -- test %D
-    { {"a \t\nb",  "%s",           "#" }, {"a###b",     3, 3} }, -- test %s
-    { {"a \t\nb",  "%S",           "#" }, {"# \t\n#",   2, 2} }, -- test %S
-    { {"abcd",     "\\b",          "%1"}, {"abcd",      2, 2} },
-    { {"",                    pCSV,fCSV}, {"[]",        1, 1} },
-    { {"123",                 pCSV,fCSV}, {"[123]",     1, 1} },
-    { {",",                   pCSV,fCSV}, {"[],",       1, 1} },
-    { {"123,,456",            pCSV,fCSV}, {"[123][][456]", 3, 3}},
-    { {",,123,456,,abc,789,", pCSV,fCSV}, {"[],[123][456][][abc][789][]", 7, 7}},
-  }
-  -- convert patterns: lua -> pcre
-  for _, test in ipairs (set) do
-    test[1][2] = pat2pcre (test[1][2])
-  end
-  return set
-end
-
-local function set_f_gsub7 (lib, flg)
-  local subj = ""
-  for i = 0, 255 do
-    subj = subj .. string.char (i)
-  end
-
-  -- This set requires calling prepare_set before calling gsub_test
-  local set = {
-    Name = "Function gsub, set7",
-    Func = get_gsub (lib),
-  --{ s,     p,    f, n, },
-    { {subj, "%a", "" }, },
-    { {subj, "%A", "" }, },
-    { {subj, "%c", "" }, },
-    { {subj, "%C", "" }, },
-    { {subj, "%l", "" }, },
-    { {subj, "%L", "" }, },
-    { {subj, "%p", "" }, },
-    { {subj, "%P", "" }, },
-    { {subj, "%u", "" }, },
-    { {subj, "%U", "" }, },
-    { {subj, "%w", "" }, },
-    { {subj, "%W", "" }, },
-    { {subj, "%x", "" }, },
-    { {subj, "%X", "" }, },
-    { {subj, "%z", "" }, },
-    { {subj, "%Z", "" }, },
-
-    { {subj, "[%a]", "" }, },
-    { {subj, "[%A]", "" }, },
-    { {subj, "[%c]", "" }, },
-    { {subj, "[%C]", "" }, },
-    { {subj, "[%l]", "" }, },
-    { {subj, "[%L]", "" }, },
-    { {subj, "[%p]", "" }, },
-    { {subj, "[%P]", "" }, },
-    { {subj, "[%u]", "" }, },
-    { {subj, "[%U]", "" }, },
-    { {subj, "[%w]", "" }, },
-    { {subj, "[%W]", "" }, },
-    { {subj, "[%x]", "" }, },
-    { {subj, "[%X]", "" }, },
-    { {subj, "[%z]", "" }, },
-    { {subj, "[%Z]", "" }, },
-
-    { {subj, "[%a_]", "" }, },
-    { {subj, "[%A_]", "" }, },
-    { {subj, "[%c_]", "" }, },
-    { {subj, "[%C_]", "" }, },
-    { {subj, "[%l_]", "" }, },
-    { {subj, "[%L_]", "" }, },
-    { {subj, "[%p_]", "" }, },
-    { {subj, "[%P_]", "" }, },
-    { {subj, "[%u_]", "" }, },
-    { {subj, "[%U_]", "" }, },
-    { {subj, "[%w_]", "" }, },
-    { {subj, "[%W_]", "" }, },
-    { {subj, "[%x_]", "" }, },
-    { {subj, "[%X_]", "" }, },
-    { {subj, "[%z_]", "" }, },
-    { {subj, "[%Z_]", "" }, },
-
-    { {subj, "[%a%d]", "" }, },
-    { {subj, "[%A%d]", "" }, },
-    { {subj, "[%c%d]", "" }, },
-    { {subj, "[%C%d]", "" }, },
-    { {subj, "[%l%d]", "" }, },
-    { {subj, "[%L%d]", "" }, },
-    { {subj, "[%p%d]", "" }, },
-    { {subj, "[%P%d]", "" }, },
-    { {subj, "[%u%d]", "" }, },
-    { {subj, "[%U%d]", "" }, },
-    { {subj, "[%w%d]", "" }, },
-    { {subj, "[%W%d]", "" }, },
-    { {subj, "[%x%d]", "" }, },
-    { {subj, "[%X%d]", "" }, },
-    { {subj, "[%z%d]", "" }, },
-    { {subj, "[%Z%d]", "" }, },
-
-    { {subj, "[^%a%d]", "" }, },
-    { {subj, "[^%A%d]", "" }, },
-    { {subj, "[^%c%d]", "" }, },
-    { {subj, "[^%C%d]", "" }, },
-    { {subj, "[^%l%d]", "" }, },
-    { {subj, "[^%L%d]", "" }, },
-    { {subj, "[^%p%d]", "" }, },
-    { {subj, "[^%P%d]", "" }, },
-    { {subj, "[^%u%d]", "" }, },
-    { {subj, "[^%U%d]", "" }, },
-    { {subj, "[^%w%d]", "" }, },
-    { {subj, "[^%W%d]", "" }, },
-    { {subj, "[^%x%d]", "" }, },
-    { {subj, "[^%X%d]", "" }, },
-    { {subj, "[^%z%d]", "" }, },
-    { {subj, "[^%Z%d]", "" }, },
-
-    { {subj, "[^%a_]", "" }, },
-    { {subj, "[^%A_]", "" }, },
-    { {subj, "[^%c_]", "" }, },
-    { {subj, "[^%C_]", "" }, },
-    { {subj, "[^%l_]", "" }, },
-    { {subj, "[^%L_]", "" }, },
-    { {subj, "[^%p_]", "" }, },
-    { {subj, "[^%P_]", "" }, },
-    { {subj, "[^%u_]", "" }, },
-    { {subj, "[^%U_]", "" }, },
-    { {subj, "[^%w_]", "" }, },
-    { {subj, "[^%W_]", "" }, },
-    { {subj, "[^%x_]", "" }, },
-    { {subj, "[^%X_]", "" }, },
-    { {subj, "[^%z_]", "" }, },
-    { {subj, "[^%Z_]", "" }, },
-
-    { {subj, "\100",          "" }, },
-    { {subj, "[\100]",        "" }, },
-    { {subj, "[^\100]",       "" }, },
-    { {subj, "[\100-\200]",   "" }, },
-    { {subj, "[^\100-\200]",  "" }, },
-    { {subj, "\100a",         "" }, },
-    { {subj, "[\100a]",       "" }, },
-    { {subj, "[^\100a]",      "" }, },
-    { {subj, "[\100-\200a]",  "" }, },
-    { {subj, "[^\100-\200a]", "" }, },
-  }
-  -- fill in reference results
-  for _,v in ipairs(set) do
-    local r0, r1, r2 = pcall (string.gsub, unpack (v[1]))
-    v[2] = r0 and { r1, r2, r2 } or { r0, r1 }
-  end
-  -- convert patterns: lua -> pcre
-  for _, test in ipairs (set) do
-    test[1][2] = pat2pcre (test[1][2])
-  end
-  return set
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags and lib.flags ()
-  local sets = {
-    set_f_gsub1 (lib, flags),
-    set_f_gsub4 (lib, flags),
-  }
-  if flags.MAJOR*100 + flags.MINOR > 405 then
-    table.insert (sets, set_f_gsub7 (lib, flags))
-  end
-  return sets
-end
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/posix_sets.lua src/test/posix_sets.lua
--- upstream/test/posix_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/posix_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-
-local function set_f_find (lib, flg)
-return {
-  Name = "Function find",
-  Func = lib.find,
-  --{subj,   patt,      st,cf,ef},           { results }
-  { {"abcd", ".+",      5},                  { N }     }, -- failing st
-  { {"abc",  "aBC",     N, flg.ICASE},       { 1,3 }   }, -- cf
-  { {"abc",  "^abc"},                        { 1,3 }   }, -- anchor
-  { {"abc",  "^abc",    N,N,flg.NOTBOL},     { N }     }, -- anchor + ef
-}
-end
-
-local function set_f_match (lib, flg)
-return {
-  Name = "Function match",
-  Func = lib.match,
-  --{subj,   patt,      st,cf,ef},           { results }
-  { {"abcd", ".+",      5},                  { N }    }, -- failing st
-  { {"abc",  "aBC",     N, flg.ICASE},       {"abc" } }, -- cf
-  { {"abc",  "^abc"},                        {"abc" } }, -- anchor
-  { {"abc",  "^abc",    N,N,flg.NOTBOL},     { N }    }, -- anchor + ef
-}
-end
-
-local function set_m_exec (lib, flg)
-return {
-  Name = "Method exec",
-  Method = "exec",
---  {patt,cf},         {subj,st,ef}           { results }
-  { {".+"},            {"abcd",5},            { N }    }, -- failing st
-  { {"aBC",flg.ICASE}, {"abc"},               {1,3,{}} }, -- cf
-  { {"^abc"},          {"abc"},               {1,3,{}} }, -- anchor
-  { {"^abc"},          {"abc",N,flg.NOTBOL},  { N }    }, -- anchor + ef
-}
-end
-
-local function set_m_tfind (lib, flg)
-return {
-  Name = "Method tfind",
-  Method = "tfind",
---  {patt,cf},         {subj,st,ef}           { results }
-  { {".+"},            {"abcd",5},            { N }    }, -- failing st
-  { {"aBC",flg.ICASE}, {"abc"},               {1,3,{}} }, -- cf
-  { {"^abc"},          {"abc"},               {1,3,{}} }, -- anchor
-  { {"^abc"},          {"abc",N,flg.NOTBOL},  { N }    }, -- anchor + ef
-}
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  return {
-    set_f_match  (lib, flags),
-    set_f_find   (lib, flags),
-    set_m_exec   (lib, flags),
-    set_m_tfind  (lib, flags),
-  }
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/runtest.lua src/test/runtest.lua
--- upstream/test/runtest.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/runtest.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,116 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-do
-  local path = "./?.lua;"
-  if package.path:sub(1, #path) ~= path then
-    package.path = path .. package.path
-  end
-end
-local luatest = require "luatest"
-
-local function newalienbuffer (str)
-  local alien = require "alien"
-  local buf = alien.buffer (#str)
-  if #str > 0 then
-    alien.memmove (buf:topointer (), str, #str)
-  end
-  return buf
-end
-
--- returns: number of failures
-local function test_library (libname, setfile, verbose, use_alien)
-  if verbose then
-    print (("[lib: %s; file: %s]"):format (libname, setfile))
-  end
-  local lib = require (libname)
-  local f = require (setfile)
-  local sets = f (libname)
-
-  local newmembuffer = use_alien and newalienbuffer or lib._newmembuffer
-  if newmembuffer then
-    if libname == "rex_posix" and not lib.flags ().STARTEND then
-      newmembuffer = nil
-      io.stderr:write ("Cannot run posix tests with buffer subjects without REG_STARTEND\n")
-    end
-  else
-    io.stderr:write ("Warning: cannot run tests with buffer subjects\n")
-  end
-
-  local n = 0 -- number of failures
-  for _, set in ipairs (sets) do
-    if verbose then
-      print (set.Name or "Unnamed set")
-    end
-    local err = luatest.test_set (set, lib, newmembuffer)
-    if verbose then
-      for _,v in ipairs (err) do
-        print ("  Test " .. v.i)
-        luatest.print_results (v, "  ")
-      end
-    end
-    n = n + #err
-  end
-  if verbose then
-    print ""
-  end
-  return n
-end
-
-local avail_tests = {
-  posix     = { lib = "rex_posix",   "common_sets", "posix_sets" },
-  gnu       = { lib = "rex_gnu",     "common_sets", "emacs_sets", "gnu_sets" },
-  oniguruma = { lib = "rex_onig",    "common_sets", "oniguruma_sets", },
-  pcre      = { lib = "rex_pcre",    "common_sets", "pcre_sets", "pcre_sets2", },
-  pcre2     = { lib = "rex_pcre2",   "common_sets", "pcre_sets", "pcre_sets2", },
-  spencer   = { lib = "rex_spencer", "common_sets", "posix_sets", "spencer_sets" },
-  tre       = { lib = "rex_tre",     "common_sets", "posix_sets", "spencer_sets", --[["tre_sets"]] },
-}
-
-do
-  local verbose, tests, nerr = false, {}, 0
-  local dir
-  local use_alien
-  -- check arguments
-  for i = 1, select ("#", ...) do
-    local arg = select (i, ...)
-    if arg:sub(1,1) == "-" then
-      if arg == "-v" then
-        verbose = true
-      elseif arg == "-a" then
-        use_alien = true
-      elseif arg:sub(1,2) == "-d" then
-        dir = arg:sub(3)
-      else
-        error ("invalid argument: [" .. arg .. "]")
-      end
-    else
-      if avail_tests[arg] then
-        tests[#tests+1] = avail_tests[arg]
-      else
-        error ("invalid argument: [" .. arg .. "]")
-      end
-    end
-  end
-  assert (#tests > 0, "no library specified")
-  -- give priority to libraries located in the specified directory
-  if dir then
-    dir = dir:gsub("[/\\]+$", "")
-    for _, ext in ipairs {"dll", "so", "dylib"} do
-      if package.cpath:match ("%?%." .. ext) then
-        local cpath = dir .. "/?." .. ext .. ";"
-        if package.cpath:sub(1, #cpath) ~= cpath then
-          package.cpath = cpath .. package.cpath
-        end
-        break
-      end
-    end
-  end
-  -- do tests
-  for _, test in ipairs (tests) do
-    package.loaded[test.lib] = nil -- to force-reload the tested library
-    for _, setfile in ipairs (test) do
-      nerr = nerr + test_library (test.lib, setfile, verbose, use_alien)
-    end
-  end
-  print ("Total number of failures: " .. nerr)
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/scite.properties src/test/scite.properties
--- upstream/test/scite.properties	2021-12-28 20:05:16.000000000 +0000
+++ src/test/scite.properties	1970-01-01 00:00:00.000000000 +0000
@@ -1,2 +0,0 @@
-eol.mode=LF
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/spencer_sets.lua src/test/spencer_sets.lua
--- upstream/test/spencer_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/spencer_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,116 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local function norm(a) return a==nil and N or a end
-
-local function get_gsub (lib)
-  return lib.gsub or
-    function (subj, pattern, repl, n)
-      return lib.new (pattern) : gsub (subj, repl, n)
-    end
-end
-
-local function set_f_gsub1 (lib, flg)
-  local subj, pat = "abcdef", "[abef]+"
-  return {
-    Name = "Function gsub, set1",
-    Func = get_gsub (lib),
-  --{ s,       p,    f,   n,    res1,  res2, res3 },
-    { {"a\0c", ".",  "#"   },   {"###",   3, 3} }, -- subj contains nuls
-  }
-end
-
-local function set_f_find (lib, flg)
-return {
-  Name = "Function find",
-  Func = lib.find,
-  --{subj,   patt,      st,cf,ef},           { results }
-  { {"a\0c", ".+"},                          { 1,3 }   }, -- subj contains nul
-  { {"a\0c", "a\0c",    N,flg.PEND},         { 1,3 }   }, -- subj and patt contain nul
-}
-end
-
-local function set_f_match (lib, flg)
-return {
-  Name = "Function match",
-  Func = lib.match,
-  --{subj,   patt,      st,cf,ef},           { results }
-  { {"a\0c", ".+"},                          {"a\0c"} }, -- subj contains nul
-  { {"a\0c", "a\0c",    N,flg.PEND},         {"a\0c"} }, -- subj and patt contain nul
-}
-end
-
-local function set_f_gmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local function test_gmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.gmatch (subj, patt) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function gmatch",
-    Func = test_gmatch,
-  --{  subj             patt         results }
-    { {"a\0c",          "." },       {{"a",N},{"\0",N},{"c",N}} },--nuls in subj
-  }
-end
-
-local function set_f_split (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_split (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.split (subj, patt) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function split",
-    Func = test_split,
-  --{  subj             patt      results }
-    { {"a,\0,c",        ","},     {{"a",",",N},{"\0",",",N},{"c",N,N},   } },--nuls in subj
-  }
-end
-
-local function set_m_exec (lib, flg)
-return {
-  Name = "Method exec",
-  Method = "exec",
---  {patt,cf},         {subj,st,ef}           { results }
-  { {".+"},            {"a\0c"},              {1,3,{}} }, -- subj contains nul
-  { {"a\0c",flg.PEND}, {"a\0c"},              {1,3,{}} }, -- subj and patt contain nul
-}
-end
-
-local function set_m_tfind (lib, flg)
-return {
-  Name = "Method tfind",
-  Method = "tfind",
---  {patt,cf},         {subj,st,ef}           { results }
-  { {".+"},            {"a\0c"},              {1,3,{}} }, -- subj contains nul
-  { {"a\0c",flg.PEND}, {"a\0c"},              {1,3,{}} }, -- subj and patt contain nul
-}
-end
-
-return function (libname)
-  local lib = require (libname)
-  local flags = lib.flags ()
-  return {
-    set_f_match  (lib, flags),
-    set_f_find   (lib, flags),
-    set_f_gmatch (lib, flags),
-    set_f_gsub1  (lib, flags),
-    set_m_exec   (lib, flags),
-    set_m_tfind  (lib, flags),
-  }
-end
-
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/test/tre_sets.lua src/test/tre_sets.lua
--- upstream/test/tre_sets.lua	2021-12-28 20:05:16.000000000 +0000
+++ src/test/tre_sets.lua	1970-01-01 00:00:00.000000000 +0000
@@ -1,354 +0,0 @@
--- See Copyright Notice in the file LICENSE
-
--- This file should contain only test sets that behave identically
--- when being run with pcre or posix regex libraries.
-
-local luatest = require "luatest"
-local N = luatest.NT
-local unpack = unpack or table.unpack
-
-local L = function(s) return (string.gsub(s, ".", "%0\0")) end
-
-local function norm(a) return a==nil and N or a end
-
-local function get_wgsub (lib)
-  return lib.wgsub or
-    function (subj, pattern, repl, n)
-      return lib.wnew (pattern) : wgsub (subj, repl, n)
-    end
-end
-
-local function set_f_wgmatch (lib, flg)
-  -- gmatch (s, p, [cf], [ef])
-  local function test_wgmatch (subj, patt)
-    local out, guard = {}, 10
-    for a, b in lib.wgmatch (subj, patt) do
-      table.insert (out, { norm(a), norm(b) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function wgmatch",
-    Func = test_wgmatch,
-  --{  subj              patt             results }
-    { {L"ab",            lib.wnew(L".")}, {{L"a",N}, {L"b",N} } },
-    { {(L"abcd"):rep(3), L"(.)b.(d)"},    {{L"a",L"d"},{L"a",L"d"},{L"a",L"d"}} },
-    { {L"abcd",          L".*" },         {{L"abcd",N},{L"",N}  } },--zero-length match
-    { {L"abc",           L"^." },         {{L"a",N}} },--anchored pattern
-  }
-end
-
-local function set_f_wsplit (lib, flg)
-  -- split (s, p, [cf], [ef])
-  local function test_wsplit (subj, patt)
-    local out, guard = {}, 10
-    for a, b, c in lib.wsplit (subj, patt) do
-      table.insert (out, { norm(a), norm(b), norm(c) })
-      guard = guard - 1
-      if guard == 0 then break end
-    end
-    return unpack (out)
-  end
-  return {
-    Name = "Function wsplit",
-    Func = test_wsplit,
-  --{  subj              patt       results }
-    { {L"ab",     lib.wnew(L",")},  {{L"ab",N,N},                           } },
-    { {L"ab",            L","},     {{L"ab",N,N},                           } },
-    { {L",",             L","},     {{L"",L",",N},     {L"", N, N},           } },
-    { {L",,",            L","},     {{L"",L",",N},     {L"",L",",N},  {L"",N,N} } },
-    { {L"a,b",           L","},     {{L"a",L",",N},    {L"b",N,N},            } },
-    { {L",a,b",          L","},     {{L"",L",",N},     {L"a",L",",N}, {L"b",N,N}} },
-    { {L"a,b,",          L","},     {{L"a",L",",N},    {L"b",L",",N}, {L"",N,N} } },
-    { {L"a,,b",          L","},     {{L"a",L",",N},    {L"",L",",N},  {L"b",N,N}} },
-    { {L"ab<78>c", L"<(.)(.)>"},    {{L"ab",L"7",L"8"}, {L"c",N,N},            } },
-    { {L"abc",           L"^."},    {{L"", L"a",N},    {L"bc",N,N},           } },--anchored pattern
-    { {L"abc",           L"^"},     {{L"", L"", N},    {L"abc",N,N},          } },
---  { {"abc",           "$"},     {{"abc","",N},   {"",N,N},             } },
---  { {"abc",         "^|$"},     {{"", "", N},    {"abc","",N},{"",N,N},} },
-  }
-end
-
-local function set_f_wfind (lib, flg)
-  return {
-    Name = "Function wfind",
-    Func = lib.wfind,
-  --  {subj, patt, st},         { results }
-    { {L"abcd", lib.wnew(L".+")}, { 1,4 }   },      -- [none]
-    { {L"abcd", L".+"},           { 1,4 }   },      -- [none]
-    { {L"abcd", L".+", 2},        { 2,4 }   },      -- positive st
-    { {L"abcd", L".+", -2},       { 3,4 }   },      -- negative st
-    { {L"abcd", L".*"},           { 1,4 }   },      -- [none]
-    { {L"abc",  L"bc"},           { 2,3 }   },      -- [none]
-    { {L"abcd", L"(.)b.(d)"},     { 1,4,L"a",L"d" }}, -- [captures]
-  }
-end
-
-local function set_f_wmatch (lib, flg)
-  return {
-    Name = "Function wmatch",
-    Func = lib.wmatch,
-  --  {subj, patt, st},           { results }
-    { {L"abcd", lib.wnew(L".+")}, {L"abcd"}  }, -- [none]
-    { {L"abcd", L".+"},           {L"abcd"}  }, -- [none]
-    { {L"abcd", L".+", 2},        {L"bcd"}   }, -- positive st
-    { {L"abcd", L".+", -2},       {L"cd"}    }, -- negative st
-    { {L"abcd", L".*"},           {L"abcd"}  }, -- [none]
-    { {L"abc",  L"bc"},           {L"bc"}    }, -- [none]
-    { {L"abcd", L"(.)b.(d)"},     {L"a",L"d"} }, -- [captures]
-  }
-end
-
-local function set_m_wexec (lib, flg)
-  return {
-    Name = "Method wexec",
-    Method = "wexec",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd"},            {1,4,{}}  }, -- [none]
-    { {L".+"},              {L"abcd",2},          {2,4,{}}  }, -- positive st
-    { {L".+"},              {L"abcd",-2},         {3,4,{}}  }, -- negative st
-    { {L".*"},              {L"abcd"},            {1,4,{}}  }, -- [none]
-    { {L"bc"},              {L"abc"},             {2,3,{}}  }, -- [none]
-    { {L "(.)b.(d)"},       {L"abcd"},            {1,4,{1,1,4,4}}},--[captures]
-    { {L"(a+)6+(b+)"},      {L"Taa66bbT",2},      {2,7,{2,3,6,7}}},--[st+captures]
-  }
-end
-
-local function set_m_waexec (lib, flg)
-  return {
-    Name = "Method waexec",
-    Method = "waexec",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd",{}},        {1,4,{}}  }, -- [none]
-    { {L".+"},              {L"abcd",{},2},      {2,4,{}}  }, -- positive st
-    { {L".+"},              {L"abcd",{},-2},     {3,4,{}}  }, -- negative st
-    { {L".*"},              {L"abcd",{}},        {1,4,{}}  }, -- [none]
-    { {L"bc"},              {L"abc", {}},        {2,3,{}}  }, -- [none]
-    { {L "(.)b.(d)"},       {L"abcd",{}},        {1,4,{1,1,4,4}}},--[captures]
-    { {L"(a+)6+(b+)"},      {L"Taa66bbT",{},2},  {2,7,{2,3,6,7}}},--[st+captures]
-  }
-end
-
-local function set_m_wtfind (lib, flg)
-  return {
-    Name = "Method wtfind",
-    Method = "wtfind",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd"},           {1,4,{}}  }, -- [none]
-    { {L".+"},              {L"abcd",2},         {2,4,{}}  }, -- positive st
-    { {L".+"},              {L"abcd",-2},        {3,4,{}}  }, -- negative st
-    { {L".*"},              {L"abcd"},           {1,4,{}}  }, -- [none]
-    { {L"bc"},              {L"abc"},            {2,3,{}}  }, -- [none]
-    { {L"(.)b.(d)"},        {L"abcd"},           {1,4,{L"a",L"d"}}},--[captures]
-  }
-end
-
-local function set_m_watfind (lib, flg)
-  return {
-    Name = "Method watfind",
-    Method = "watfind",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd",{}},        {1,4,{}}  }, -- [none]
-    { {L".+"},              {L"abcd",{},2},      {2,4,{}}  }, -- positive st
-    { {L".+"},              {L"abcd",{},-2},     {3,4,{}}  }, -- negative st
-    { {L".*"},              {L"abcd",{}},        {1,4,{}}  }, -- [none]
-    { {L"bc"},              {L"abc", {}},        {2,3,{}}  }, -- [none]
-    { {L"(.)b.(d)"},        {L"abcd",{}},        {1,4,{L"a",L"d"}}},--[captures]
-  }
-end
-
-local function set_m_wfind (lib, flg)
-  return {
-    Name = "Method wfind",
-    Method = "wfind",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd"},           {1,4}  }, -- [none]
-    { {L".+"},              {L"abcd",2},         {2,4}  }, -- positive st
-    { {L".+"},              {L"abcd",-2},        {3,4}  }, -- negative st
-    { {L".*"},              {L"abcd"},           {1,4}  }, -- [none]
-    { {L"bc"},              {L"abc"},            {2,3}  }, -- [none]
-    { {L"(.)b.(d)"},        {L"abcd"},           {1,4,L"a",L"d"}},--[captures]
-  }
-end
-
-local function set_m_wmatch (lib, flg)
-  return {
-    Name = "Method wmatch",
-    Method = "wmatch",
-  --{patt},                 {subj, st}           { results }
-    { {L".+"},              {L"abcd"},           {L"abcd"}  }, -- [none]
-    { {L".+"},              {L"abcd",2},         {L"bcd" }  }, -- positive st
-    { {L".+"},              {L"abcd",-2},        {L"cd"  }  }, -- negative st
-    { {L".*"},              {L"abcd"},           {L"abcd"}  }, -- [none]
-    { {L"bc"},              {L"abc"},            {L"bc"  }  }, -- [none]
-    {{ L"(.)b.(d)"},        {L"abcd"},           {L"a",L"d"} }, --[captures]
-  }
-end
-
-local function set_f_wgsub1 (lib, flg)
-  local subj, pat = L"abcdef", L"[abef]+"
-  local cpat = lib.wnew(pat)
-  return {
-    Name = "Function wgsub, set1",
-    Func = get_wgsub (lib),
-  --{ s,       p,    f,    n,    res1,   res2, res3 },
-    { {subj,  cpat,  L"",  0},   {subj,     0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  L"",  0},   {subj,     0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  L"", -1},   {subj,     0, 0} }, -- test "n" + empty_replace
-    { {subj,   pat,  L"",  1},   {L"cdef",  1, 1} },
-    { {subj,   pat,  L"",  2},   {L"cd",    2, 2} },
-    { {subj,   pat,  L"",  3},   {L"cd",    2, 2} },
-    { {subj,   pat,  L""    },   {L"cd",    2, 2} },
-    { {subj,   pat,  L"#", 0},   {subj,     0, 0} }, -- test "n" + non-empty_replace
-    { {subj,   pat,  L"#", 1},   {L"#cdef", 1, 1} },
-    { {subj,   pat,  L"#", 2},   {L"#cd#",  2, 2} },
-    { {subj,   pat,  L"#", 3},   {L"#cd#",  2, 2} },
-    { {subj,   pat,  L"#"   },   {L"#cd#",  2, 2} },
-    { {L"abc", L"^.",L"#"   },   {L"#bc",   1, 1} }, -- anchored pattern
-  }
-end
-
-local function set_f_wgsub2 (lib, flg)
-  local subj, pat = L"abc", L"([ac])"
-  return {
-    Name = "Function wgsub, set2",
-    Func = get_wgsub (lib),
-  --{ s,     p,   f,   n,      res1,     res2, res3 },
-    { {subj, pat, L"<%1>" },   {L"<a>b<c>", 2, 2} }, -- test non-escaped chars in f
-    { {subj, pat, L"%<%1%>" }, {L"<a>b<c>", 2, 2} }, -- test escaped chars in f
-    { {subj, pat, L"" },       {L"b",       2, 2} }, -- test empty replace
-    { {subj, pat, L"1" },      {L"1b1",     2, 2} }, -- test odd and even %'s in f
-    { {subj, pat, L"%1" },     {L"abc",     2, 2} },
-    { {subj, pat, L"%%1" },    {L"%1b%1",   2, 2} },
-    { {subj, pat, L"%%%1" },   {L"%ab%c",   2, 2} },
-    { {subj, pat, L"%%%%1" },  {L"%%1b%%1", 2, 2} },
-    { {subj, pat, L"%%%%%1" }, {L"%%ab%%c", 2, 2} },
-  }
-end
-
-local function set_f_wgsub3 (lib, flg)
-  return {
-    Name = "Function wgsub, set3",
-    Func = get_wgsub (lib),
-  --{ s,       p,       f,  n,    res1,res2,res3 },
-    { {L"abc", L"a",    L"%0" }, {L"abc", 1, 1} }, -- test (in)valid capture index
-    { {L"abc", L"a",    L"%1" }, {L"abc", 1, 1} },
-    { {L"abc", L"[ac]", L"%1" }, {L"abc", 2, 2} },
-    { {L"abc", L"(a)",  L"%1" }, {L"abc", 1, 1} },
-    { {L"abc", L"(a)",  L"%2" }, "invalid capture index" },
-  }
-end
-
-local function set_f_wgsub4 (lib, flg)
-  return {
-    Name = "Function wgsub, set4",
-    Func = get_wgsub (lib),
-  --{ s,           p,                f, n,   res1,       res2, res3 },
-    { {L"a2c3",     L".",            L"#" }, {L"####",      4, 4} }, -- test .
-    { {L"a2c3",     L".+",           L"#" }, {L"#",         1, 1} }, -- test .+
-    { {L"a2c3",     L".*",           L"#" }, {L"##",        2, 2} }, -- test .*
-    { {L"/* */ */", L"\\/\\*(.*)\\*\\/", L"#" }, {L"#",     1, 1} },
-    { {L"a2c3",     L"[0-9]",        L"#" }, {L"a#c#",      2, 2} }, -- test %d
-    { {L"a2c3",     L"[^0-9]",       L"#" }, {L"#2#3",      2, 2} }, -- test %D
-    { {L"a \t\nb",  L"[ \t\n]",      L"#" }, {L"a###b",     3, 3} }, -- test %s
-    { {L"a \t\nb",  L"[^ \t\n]",     L"#" }, {L"# \t\n#",   2, 2} }, -- test %S
-  }
-end
-
-local function set_f_wgsub5 (lib, flg)
-  local function frep1 () end                       -- returns nothing
-  local function frep2 () return L"#" end           -- ignores arguments
-  local function frep3 (...) return table.concat({...}, L",") end -- "normal"
-  local function frep4 () return {} end             -- invalid return type
-  local function frep5 () return L"7", L"a" end     -- 2-nd return is "a"
-  local function frep6 () return L"7", "break" end  -- 2-nd return is "break"
-  local subj = L"a2c3"
-  return {
-    Name = "Function wgsub, set5",
-    Func = get_wgsub (lib),
-  --{ s,     p,          f,   n,   res1,       res2, res3 },
-    { {subj, L"a(.)c(.)", frep1 }, {subj,         1, 0} },
-    { {subj, L"a(.)c(.)", frep2 }, {L"#",         1, 1} },
-    { {subj, L"a(.)c(.)", frep3 }, {L"2,3",       1, 1} },
-    { {subj, L"a.c.",     frep3 }, {subj,         1, 1} },
-    { {subj, L"z*",       frep1 }, {subj,         5, 0} },
-    { {subj, L"z*",       frep2 }, {L"#a#2#c#3#", 5, 5} },
-    { {subj, L"z*",       frep3 }, {subj,         5, 5} },
-    { {subj, subj,        frep4 }, "invalid return type" },
-    { {L"abc",L".",       frep5 }, {L"777",       3, 3} },
-    { {L"abc",L".",       frep6 }, {L"777",       3, 3} },
-  }
-end
-
-local function set_f_wgsub6 (lib, flg)
-  local tab1, tab2, tab3 = {}, { [L"2"] = 56 }, { [L"2"] = {} }
-  local subj = L"a2c3"
-  return {
-    Name = "Function wgsub, set6",
-    Func = get_wgsub (lib),
-  --{ s,     p,           f, n,    res1,res2,res3 },
-    { {subj, L"a(.)c(.)", tab1 }, {subj,  1, 0} },
-    { {subj, L"a(.)c(.)", tab2 }, {"56",  1, 1} },
-    { {subj, L"a(.)c(.)", tab3 }, "invalid replacement type" },
-    { {subj, L"a.c.",     tab1 }, {subj,  1, 0} },
-    { {subj, L"a.c.",     tab2 }, {subj,  1, 0} },
-    { {subj, L"a.c.",     tab3 }, {subj,  1, 0} },
-  }
-end
-
-local function set_f_wgsub8 (lib, flg)
-  local subj, patt, repl = L"abcdef", L"..", L"*"
-  return {
-    Name = "Function wgsub, set8",
-    Func = get_wgsub (lib),
-  --{ s,     p,       f, n,                                    res1,  res2, res3 },
-    { {subj, patt, repl, function() end },                    {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil end },         {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return false end },       {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return true end },        {L"***",    3, 3} },
-    { {subj, patt, repl, function() return {} end },          {L"***",    3, 3} },
-    { {subj, patt, repl, function() return L"#" end },        {L"###",    3, 3} },
-    { {subj, patt, repl, function() return 57 end },          {"575757",  3, 3} },
-    { {subj, patt, repl, function (from) return from end },   {"135",     3, 3} },
-    { {subj, patt, repl, function (from, to) return to end }, {"246",     3, 3} },
-    { {subj, patt, repl, function (from,to,rep) return rep end },
-                                                              {L"***",    3, 3} },
-    { {subj, patt, repl, function (from, to, rep) return rep..to..from end },
-                                     {L"*".."21"..L"*".."43"..L"*".."65", 3, 3} },
-    { {subj, patt, repl, function() return nil end },         {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, nil end },    {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, false end },  {L"abcdef", 3, 0} },
-    { {subj, patt, repl, function() return nil, true end },   {L"ab**",   3, 2} },
-    { {subj, patt, repl, function() return true, true end },  {L"***",    3, 3} },
-    { {subj, patt, repl, function() return nil, 0 end },      {L"abcdef", 1, 0} },
-    { {subj, patt, repl, function() return true, 0 end },     {L"*cdef",  1, 1} },
-    { {subj, patt, repl, function() return nil, 1 end },      {L"ab*ef",  2, 1} },
-    { {subj, patt, repl, function() return true, 1 end },     {L"**ef",   2, 2} },
-  }
-end
-
-return function (libname)
-  local lib = require (libname)
-  lib.new = lib.wnew
-  return {
-    set_f_wgmatch    (lib),
-    set_f_wsplit     (lib),
-    set_f_wfind      (lib),
-    set_f_wmatch     (lib),
-    set_m_wexec      (lib),
-    set_m_waexec     (lib),
-    set_m_wtfind     (lib),
-    set_m_watfind    (lib),
-    set_m_wfind      (lib),
-    set_m_wmatch     (lib),
-    set_f_wgsub1     (lib),
-    set_f_wgsub2     (lib),
-    set_f_wgsub3     (lib),
-    set_f_wgsub4     (lib),
-    set_f_wgsub5     (lib),
-    set_f_wgsub6     (lib),
-    set_f_wgsub8     (lib),
-  }
-end
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/Makefile src/windows/mingw/Makefile
--- upstream/windows/mingw/Makefile	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,35 +0,0 @@
-# Makefile for lrexlib
-
-ifeq ($(DIRBIT),64)
-MKFILES = \
-  rex_onig.mak    \
-  rex_pcre.mak    \
-  rex_pcre2.mak   \
-  rex_tre.mak
-else
-MKFILES = \
-  rex_gnu.mak     \
-  rex_onig.mak    \
-  rex_pcre.mak    \
-  rex_pcre2.mak   \
-  rex_spencer.mak \
-  rex_tre.mak
-endif
-
-LOOP = @for %%d in ($(MKFILES)) do $(MAKE) -f %%d
-
-all: build test
-
-build:
-	$(LOOP)
-
-test:
-	$(LOOP) test
-
-install:
-	$(LOOP) install
-
-clean:
-	del *.o *.def *.dll
-
-.PHONY: all build test install clean
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/_mingw.mak src/windows/mingw/_mingw.mak
--- upstream/windows/mingw/_mingw.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/_mingw.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,81 +0,0 @@
-# Use with GNU Make.
-
-# Lrexlib version
-VERSION = 2.9.1
-
-# User Settings ------------------------------------------------------------
-
-# Target Lua version (51 for Lua 5.1, etc.)
-LUAVERSION = 51
-LUADOTVERSION = $(subst 5,5.,$(LUAVERSION))
-
-# Target bitness: 32 or 64
-DIRBIT = 32
-# GCC location (GCC32 and GCC64 are defined environment variables)
-PATH = $(GCC$(DIRBIT))
-
-# INSTALLPATH : Path to install the built DLL.
-# LUADLL      : Lua DLL to link to (.dll should be omitted).
-# LUAEXE      : Lua interpreter.
-# LUAINC      : Path of Lua include files.
-# LIBPATH     : Path of lua51.dll, lua52.dll, pcre.dll, etc.
-
-INSTALLPATH = S:\Progr\Exe\lib$(DIRBIT)\lua\$(LUADOTVERSION)
-LUADLL      = lua$(LUAVERSION)
-LUAINC      = $(PATH_SYSTEM)\include\lua\$(LUADOTVERSION)
-LIBPATH     = $(CROOT)\Programs\EXE$(DIRBIT)
-
-ifeq ($(LUAVERSION),51)
-  LUAEXE = $(LIBPATH)\lua.exe
-  CREATEGLOBAL = -DREX_CREATEGLOBALVAR
-else
-  LUAEXE = $(LIBPATH)\lua$(LUAVERSION).exe
-endif
-# --------------------------------------------------------------------------
-
-BIN        = $(PROJECT).dll
-BININSTALL = $(INSTALLPATH)\$(BIN)
-CC         = gcc
-AR         = ar rcu
-RANLIB     = ranlib
-CFLAGS     = -W -Wall -O2 $(INCS) -DREX_OPENLIB=luaopen_$(PROJECT) \
-             -DREX_LIBNAME=\"$(PROJECT)\" -DVERSION=\"$(VERSION)\" \
-             -m$(DIRBIT) $(CREATEGLOBAL) $(MYCFLAGS)
-DEFFILE    = $(PROJECT).def
-EXPORTED   = luaopen_$(PROJECT)
-INCS       = -I$(LUAINC) $(MYINCS)
-LIBS       = -l$(LUADLL) -m$(DIRBIT) -s $(MYLIBS)
-SRCPATH    = ..\..\src
-TESTPATH   = ..\..\test
-
-.PHONY: all install test vtest clean
-
-vpath %.c $(SRCPATH);$(SRCPATH)\$(PROJDIR)
-vpath %.h $(SRCPATH);$(SRCPATH)\$(PROJDIR)
-
-all: $(BIN)
-
-clean:
-	del $(OBJ) $(BIN) $(DEFFILE)
-
-install: $(BININSTALL)
-
-test:
-	cd $(TESTPATH) && $(LUAEXE) runtest.lua $(TESTNAME) -d$(CURDIR)
-
-vtest:
-	cd $(TESTPATH) && $(LUAEXE) runtest.lua -v $(TESTNAME) -d$(CURDIR)
-
-$(BIN): $(OBJ) $(DEFFILE)
-	$(CC) $(DEFFILE) $(OBJ) -L$(LIBPATH) $(LIBS) -o $@ -shared
-
-lib$(PROJECT)$(LUAVERSION).a: $(OBJ)
-	$(AR) $@ $?
-	$(RANLIB) $@
-
-$(DEFFILE):
-	echo EXPORTS > $@
-	for %%d in ($(EXPORTED)) do echo   %%d>> $@
-
-$(BININSTALL): $(BIN)
-	copy /Y $< $@
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/docs.mak src/windows/mingw/docs.mak
--- upstream/windows/mingw/docs.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/docs.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,13 +0,0 @@
-# Documentation Makefile
-
-APP = rst2html.py
-CP  = "copy /y"
-RM  = del
-IDX = ..\README.rst
-
-ALLVAR = APP=$(APP) CP=$(CP) RM=$(RM) IDX=$(IDX)
-
-.PHONY: all clean
-
-all clean:
-	cd ..\..\doc && $(MAKE) $(ALLVAR) $@
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_gnu.mak src/windows/mingw/rex_gnu.mak
--- upstream/windows/mingw/rex_gnu.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_gnu.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-# Project: rex_gnu
-
-# User Settings ------------------------------------------------------------
-# path of GNU include files
-REGEXINC = $(PATH_WORK)\system\include\gnuregex
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_gnu
-MYINCS   = -I$(REGEXINC)
-MYLIBS   = -lregex2
-OBJ      = lgnu.o common.o
-PROJDIR  = gnu
-TESTNAME = gnu
-
-include _mingw.mak
-
-lgnu.o    : common.h algo.h
-common.o  : common.h
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_onig.mak src/windows/mingw/rex_onig.mak
--- upstream/windows/mingw/rex_onig.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_onig.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-# Project: rex_onig
-
-# User Settings ------------------------------------------------------------
-# path of Oniguruma include files
-REGEXINC = $(PATH_WORK)\system\include\oniguruma
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_onig
-MYINCS   = -I$(REGEXINC)
-MYLIBS   = -lonig -Wl,--enable-auto-import
-OBJ      = lonig.o lonig_f.o common.o
-PROJDIR  = oniguruma
-TESTNAME = oniguruma
-
-include _mingw.mak
-
-lonig.o   : common.h algo.h
-lonig_f.o : common.h
-common.o  : common.h
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_pcre.mak src/windows/mingw/rex_pcre.mak
--- upstream/windows/mingw/rex_pcre.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_pcre.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,19 +0,0 @@
-# Project: rex_pcre
-
-# User Settings ------------------------------------------------------------
-# path of PCRE include files
-REGEXINC = $(PATH_WORK)\system\include\pcre
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_pcre
-MYINCS   = -I$(REGEXINC)
-MYLIBS   = -lpcre
-OBJ      = lpcre.o lpcre_f.o common.o
-PROJDIR  = pcre
-TESTNAME = pcre
-
-include _mingw.mak
-
-lpcre.o   : common.h algo.h
-lpcre_f.o : common.h
-common.o  : common.h
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_pcre2.mak src/windows/mingw/rex_pcre2.mak
--- upstream/windows/mingw/rex_pcre2.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_pcre2.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-# Project: rex_pcre2
-
-# User Settings ------------------------------------------------------------
-# path of PCRE2 include files
-REGEXINC = $(PATH_WORK)\system\include\pcre2
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_pcre2
-MYINCS   = -I$(REGEXINC)
-MYCFLAGS = -DPCRE2_CODE_UNIT_WIDTH=8
-MYLIBS   = -lpcre2
-OBJ      = lpcre2.o lpcre2_f.o common.o
-PROJDIR  = pcre2
-TESTNAME = pcre2
-
-include _mingw.mak
-
-lpcre2.o   : common.h algo.h
-lpcre2_f.o : common.h
-common.o   : common.h
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_spencer.mak src/windows/mingw/rex_spencer.mak
--- upstream/windows/mingw/rex_spencer.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_spencer.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-# Project: rex_spencer
-
-# User Settings ------------------------------------------------------------
-# path of Spencer's include files
-REGEXINC = $(PATH_WORK)\system\include\rxspencer
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_spencer
-MYINCS   = -I$(REGEXINC)
-MYLIBS   = -lrxspencer
-OBJ      = lposix.o common.o
-PROJDIR  = posix
-TESTNAME = spencer
-
-include _mingw.mak
-
-lposix.o  : common.h algo.h
-common.o  : common.h
diff --recursive --unified --new-file --no-dereference --exclude .gitver upstream/windows/mingw/rex_tre.mak src/windows/mingw/rex_tre.mak
--- upstream/windows/mingw/rex_tre.mak	2021-12-28 20:05:16.000000000 +0000
+++ src/windows/mingw/rex_tre.mak	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-# Project: rex_tre
-
-# User Settings ------------------------------------------------------------
-# path of TRE include files
-REGEXINC = $(PATH_WORK)\system\include
-# --------------------------------------------------------------------------
-
-PROJECT  = rex_tre
-MYINCS   = -I$(REGEXINC)
-MYLIBS   = -ltre
-OBJ      = ltre.o common.o
-PROJDIR  = tre
-TESTNAME = tre
-
-# Uncomment the following line to add wide-character functions (in alpha state).
-# ADDWIDECHARFUNCS = 1
-ifdef ADDWIDECHARFUNCS
-  OBJ += ltre_w.o
-  MYCFLAGS += -DREX_ADDWIDECHARFUNCS
-endif
-
-include _mingw.mak
-
-ltre.o    : common.h algo.h
-ltre_w.o  : common.h algo.h
-common.o  : common.h
