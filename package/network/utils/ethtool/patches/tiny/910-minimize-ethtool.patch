--- a/ethtool.c
+++ b/ethtool.c
@@ -168,11 +168,6 @@ static int get_int(char *str, int base)
 	return get_int_range(str, base, INT_MIN, INT_MAX);
 }
 
-static u32 get_u32(char *str, int base)
-{
-	return get_uint_range(str, base, 0xffffffff);
-}
-
 static void get_mac_addr(char *src, unsigned char *dest)
 {
 	int count;
@@ -347,32 +342,6 @@ static void flag_to_cmdline_info(const c
 	cli->seen_val = mask;
 }
 
-static int rxflow_str_to_type(const char *str)
-{
-	int flow_type = 0;
-
-	if (!strcmp(str, "tcp4"))
-		flow_type = TCP_V4_FLOW;
-	else if (!strcmp(str, "udp4"))
-		flow_type = UDP_V4_FLOW;
-	else if (!strcmp(str, "ah4") || !strcmp(str, "esp4"))
-		flow_type = AH_ESP_V4_FLOW;
-	else if (!strcmp(str, "sctp4"))
-		flow_type = SCTP_V4_FLOW;
-	else if (!strcmp(str, "tcp6"))
-		flow_type = TCP_V6_FLOW;
-	else if (!strcmp(str, "udp6"))
-		flow_type = UDP_V6_FLOW;
-	else if (!strcmp(str, "ah6") || !strcmp(str, "esp6"))
-		flow_type = AH_ESP_V6_FLOW;
-	else if (!strcmp(str, "sctp6"))
-		flow_type = SCTP_V6_FLOW;
-	else if (!strcmp(str, "ether"))
-		flow_type = ETHER_FLOW;
-
-	return flow_type;
-}
-
 static int do_version(struct cmd_context *ctx __maybe_unused)
 {
 	fprintf(stdout,
@@ -886,33 +855,6 @@ dump_link_usettings(const struct ethtool
 	return 0;
 }
 
-static int dump_drvinfo(struct ethtool_drvinfo *info)
-{
-	fprintf(stdout,
-		"driver: %.*s\n"
-		"version: %.*s\n"
-		"firmware-version: %.*s\n"
-		"expansion-rom-version: %.*s\n"
-		"bus-info: %.*s\n"
-		"supports-statistics: %s\n"
-		"supports-test: %s\n"
-		"supports-eeprom-access: %s\n"
-		"supports-register-dump: %s\n"
-		"supports-priv-flags: %s\n",
-		(int)sizeof(info->driver), info->driver,
-		(int)sizeof(info->version), info->version,
-		(int)sizeof(info->fw_version), info->fw_version,
-		(int)sizeof(info->erom_version), info->erom_version,
-		(int)sizeof(info->bus_info), info->bus_info,
-		info->n_stats ? "yes" : "no",
-		info->testinfo_len ? "yes" : "no",
-		info->eedump_len ? "yes" : "no",
-		info->regdump_len ? "yes" : "no",
-		info->n_priv_flags ? "yes" : "no");
-
-	return 0;
-}
-
 static int parse_wolopts(char *optstr, u32 *data)
 {
 	*data = 0;
@@ -953,182 +895,6 @@ static int parse_wolopts(char *optstr, u
 	return 0;
 }
 
-static int parse_rxfhashopts(char *optstr, u32 *data)
-{
-	*data = 0;
-	while (*optstr) {
-		switch (*optstr) {
-		case 'm':
-			*data |= RXH_L2DA;
-			break;
-		case 'v':
-			*data |= RXH_VLAN;
-			break;
-		case 't':
-			*data |= RXH_L3_PROTO;
-			break;
-		case 's':
-			*data |= RXH_IP_SRC;
-			break;
-		case 'd':
-			*data |= RXH_IP_DST;
-			break;
-		case 'f':
-			*data |= RXH_L4_B_0_1;
-			break;
-		case 'n':
-			*data |= RXH_L4_B_2_3;
-			break;
-		case 'r':
-			*data |= RXH_DISCARD;
-			break;
-		default:
-			return -1;
-		}
-		optstr++;
-	}
-	return 0;
-}
-
-static char *unparse_rxfhashopts(u64 opts)
-{
-	static char buf[300];
-
-	memset(buf, 0, sizeof(buf));
-
-	if (opts) {
-		if (opts & RXH_L2DA)
-			strcat(buf, "L2DA\n");
-		if (opts & RXH_VLAN)
-			strcat(buf, "VLAN tag\n");
-		if (opts & RXH_L3_PROTO)
-			strcat(buf, "L3 proto\n");
-		if (opts & RXH_IP_SRC)
-			strcat(buf, "IP SA\n");
-		if (opts & RXH_IP_DST)
-			strcat(buf, "IP DA\n");
-		if (opts & RXH_L4_B_0_1)
-			strcat(buf, "L4 bytes 0 & 1 [TCP/UDP src port]\n");
-		if (opts & RXH_L4_B_2_3)
-			strcat(buf, "L4 bytes 2 & 3 [TCP/UDP dst port]\n");
-	} else {
-		sprintf(buf, "None");
-	}
-
-	return buf;
-}
-
-static int convert_string_to_hashkey(char *rss_hkey, u32 key_size,
-				     const char *rss_hkey_string)
-{
-	u32 i = 0;
-	int hex_byte, len;
-
-	do {
-		if (i > (key_size - 1)) {
-			fprintf(stderr,
-				"Key is too long for device (%u > %u)\n",
-				i + 1, key_size);
-			goto err;
-		}
-
-		if (sscanf(rss_hkey_string, "%2x%n", &hex_byte, &len) < 1 ||
-		    len != 2) {
-			fprintf(stderr, "Invalid RSS hash key format\n");
-			goto err;
-		}
-
-		rss_hkey[i++] = hex_byte;
-		rss_hkey_string += 2;
-
-		if (*rss_hkey_string == ':') {
-			rss_hkey_string++;
-		} else if (*rss_hkey_string != '\0') {
-			fprintf(stderr, "Invalid RSS hash key format\n");
-			goto err;
-		}
-
-	} while (*rss_hkey_string);
-
-	if (i != key_size) {
-		fprintf(stderr, "Key is too short for device (%u < %u)\n",
-			i, key_size);
-		goto err;
-	}
-
-	return 0;
-err:
-	return 2;
-}
-
-static int parse_hkey(char **rss_hkey, u32 key_size,
-		      const char *rss_hkey_string)
-{
-	if (!key_size) {
-		fprintf(stderr,
-			"Cannot set RX flow hash configuration:\n"
-			" Hash key setting not supported\n");
-		return 1;
-	}
-
-	*rss_hkey = malloc(key_size);
-	if (!(*rss_hkey)) {
-		perror("Cannot allocate memory for RSS hash key");
-		return 1;
-	}
-
-	if (convert_string_to_hashkey(*rss_hkey, key_size,
-				      rss_hkey_string)) {
-		free(*rss_hkey);
-		*rss_hkey = NULL;
-		return 2;
-	}
-	return 0;
-}
-
-static const struct {
-	const char *name;
-	int (*func)(struct ethtool_drvinfo *info, struct ethtool_regs *regs);
-
-} driver_list[] = {
-#ifdef ETHTOOL_ENABLE_PRETTY_DUMP
-	{ "8139cp", realtek_dump_regs },
-	{ "8139too", realtek_dump_regs },
-	{ "r8169", realtek_dump_regs },
-	{ "de2104x", de2104x_dump_regs },
-	{ "e1000", e1000_dump_regs },
-	{ "e1000e", e1000_dump_regs },
-	{ "igb", igb_dump_regs },
-	{ "ixgb", ixgb_dump_regs },
-	{ "ixgbe", ixgbe_dump_regs },
-	{ "ixgbevf", ixgbevf_dump_regs },
-	{ "natsemi", natsemi_dump_regs },
-	{ "e100", e100_dump_regs },
-	{ "amd8111e", amd8111e_dump_regs },
-	{ "pcnet32", pcnet32_dump_regs },
-	{ "fec_8xx", fec_8xx_dump_regs },
-	{ "ibm_emac", ibm_emac_dump_regs },
-	{ "tg3", tg3_dump_regs },
-	{ "skge", skge_dump_regs },
-	{ "sky2", sky2_dump_regs },
-	{ "vioc", vioc_dump_regs },
-	{ "smsc911x", smsc911x_dump_regs },
-	{ "at76c50x-usb", at76c50x_usb_dump_regs },
-	{ "sfc", sfc_dump_regs },
-	{ "st_mac100", st_mac100_dump_regs },
-	{ "st_gmac", st_gmac_dump_regs },
-	{ "et131x", et131x_dump_regs },
-	{ "altera_tse", altera_tse_dump_regs },
-	{ "vmxnet3", vmxnet3_dump_regs },
-	{ "fjes", fjes_dump_regs },
-	{ "lan78xx", lan78xx_dump_regs },
-	{ "dsa", dsa_dump_regs },
-	{ "fec", fec_dump_regs },
-	{ "igc", igc_dump_regs },
-	{ "bnxt_en", bnxt_dump_regs },
-#endif
-};
-
 void dump_hex(FILE *file, const u8 *data, int len, int offset)
 {
 	int i;
@@ -1143,129 +909,6 @@ void dump_hex(FILE *file, const u8 *data
 	fprintf(file, "\n");
 }
 
-static int dump_regs(int gregs_dump_raw, int gregs_dump_hex,
-		     struct ethtool_drvinfo *info, struct ethtool_regs *regs)
-{
-	unsigned int i;
-
-	if (gregs_dump_raw) {
-		fwrite(regs->data, regs->len, 1, stdout);
-		goto nested;
-	}
-
-	if (!gregs_dump_hex)
-		for (i = 0; i < ARRAY_SIZE(driver_list); i++)
-			if (!strncmp(driver_list[i].name, info->driver,
-				     ETHTOOL_BUSINFO_LEN)) {
-				if (driver_list[i].func(info, regs) == 0)
-					goto nested;
-				/* This version (or some other
-				 * variation in the dump format) is
-				 * not handled; fall back to hex
-				 */
-				break;
-			}
-
-	dump_hex(stdout, regs->data, regs->len, 0);
-
-nested:
-	/* Recurse dump if some drvinfo and regs structures are nested */
-	if (info->regdump_len > regs->len + sizeof(*info) + sizeof(*regs)) {
-		info = (struct ethtool_drvinfo *)(&regs->data[0] + regs->len);
-		regs = (struct ethtool_regs *)(&regs->data[0] + regs->len + sizeof(*info));
-
-		return dump_regs(gregs_dump_raw, gregs_dump_hex, info, regs);
-	}
-
-	return 0;
-}
-
-static int dump_eeprom(int geeprom_dump_raw,
-		       struct ethtool_drvinfo *info __maybe_unused,
-		       struct ethtool_eeprom *ee)
-{
-	if (geeprom_dump_raw) {
-		fwrite(ee->data, 1, ee->len, stdout);
-		return 0;
-	}
-#ifdef ETHTOOL_ENABLE_PRETTY_DUMP
-	if (!strncmp("natsemi", info->driver, ETHTOOL_BUSINFO_LEN)) {
-		return natsemi_dump_eeprom(info, ee);
-	} else if (!strncmp("tg3", info->driver, ETHTOOL_BUSINFO_LEN)) {
-		return tg3_dump_eeprom(info, ee);
-	}
-#endif
-	dump_hex(stdout, ee->data, ee->len, ee->offset);
-
-	return 0;
-}
-
-static int dump_test(struct ethtool_test *test,
-		     struct ethtool_gstrings *strings)
-{
-	unsigned int i;
-	int rc;
-
-	rc = test->flags & ETH_TEST_FL_FAILED;
-	fprintf(stdout, "The test result is %s\n", rc ? "FAIL" : "PASS");
-
-	if (test->flags & ETH_TEST_FL_EXTERNAL_LB)
-		fprintf(stdout, "External loopback test was %sexecuted\n",
-			(test->flags & ETH_TEST_FL_EXTERNAL_LB_DONE) ?
-			"" : "not ");
-
-	if (strings->len)
-		fprintf(stdout, "The test extra info:\n");
-
-	for (i = 0; i < strings->len; i++) {
-		fprintf(stdout, "%s\t %d\n",
-			(char *)(strings->data + i * ETH_GSTRING_LEN),
-			(u32) test->data[i]);
-	}
-
-	fprintf(stdout, "\n");
-	return rc;
-}
-
-static int dump_pause(const struct ethtool_pauseparam *epause,
-		      u32 advertising, u32 lp_advertising)
-{
-	fprintf(stdout,
-		"Autonegotiate:	%s\n"
-		"RX:		%s\n"
-		"TX:		%s\n",
-		epause->autoneg ? "on" : "off",
-		epause->rx_pause ? "on" : "off",
-		epause->tx_pause ? "on" : "off");
-
-	if (lp_advertising) {
-		int an_rx = 0, an_tx = 0;
-
-		/* Work out negotiated pause frame usage per
-		 * IEEE 802.3-2005 table 28B-3.
-		 */
-		if (advertising & lp_advertising & ADVERTISED_Pause) {
-			an_tx = 1;
-			an_rx = 1;
-		} else if (advertising & lp_advertising &
-			   ADVERTISED_Asym_Pause) {
-			if (advertising & ADVERTISED_Pause)
-				an_rx = 1;
-			else if (lp_advertising & ADVERTISED_Pause)
-				an_tx = 1;
-		}
-
-		fprintf(stdout,
-			"RX negotiated:	%s\n"
-			"TX negotiated:	%s\n",
-			an_rx ? "on" : "off",
-			an_tx ? "on" : "off");
-	}
-
-	fprintf(stdout, "\n");
-	return 0;
-}
-
 static int dump_ring(const struct ethtool_ringparam *ering)
 {
 	fprintf(stdout,
@@ -1294,117 +937,6 @@ static int dump_ring(const struct ethtoo
 	return 0;
 }
 
-static int dump_channels(const struct ethtool_channels *echannels)
-{
-	fprintf(stdout,
-		"Pre-set maximums:\n"
-		"RX:		%u\n"
-		"TX:		%u\n"
-		"Other:		%u\n"
-		"Combined:	%u\n",
-		echannels->max_rx, echannels->max_tx,
-		echannels->max_other,
-		echannels->max_combined);
-
-	fprintf(stdout,
-		"Current hardware settings:\n"
-		"RX:		%u\n"
-		"TX:		%u\n"
-		"Other:		%u\n"
-		"Combined:	%u\n",
-		echannels->rx_count, echannels->tx_count,
-		echannels->other_count,
-		echannels->combined_count);
-
-	fprintf(stdout, "\n");
-	return 0;
-}
-
-static int dump_coalesce(const struct ethtool_coalesce *ecoal)
-{
-	fprintf(stdout, "Adaptive RX: %s  TX: %s\n",
-		ecoal->use_adaptive_rx_coalesce ? "on" : "off",
-		ecoal->use_adaptive_tx_coalesce ? "on" : "off");
-
-	fprintf(stdout,
-		"stats-block-usecs: %u\n"
-		"sample-interval: %u\n"
-		"pkt-rate-low: %u\n"
-		"pkt-rate-high: %u\n"
-		"\n"
-		"rx-usecs: %u\n"
-		"rx-frames: %u\n"
-		"rx-usecs-irq: %u\n"
-		"rx-frames-irq: %u\n"
-		"\n"
-		"tx-usecs: %u\n"
-		"tx-frames: %u\n"
-		"tx-usecs-irq: %u\n"
-		"tx-frames-irq: %u\n"
-		"\n"
-		"rx-usecs-low: %u\n"
-		"rx-frames-low: %u\n"
-		"tx-usecs-low: %u\n"
-		"tx-frames-low: %u\n"
-		"\n"
-		"rx-usecs-high: %u\n"
-		"rx-frames-high: %u\n"
-		"tx-usecs-high: %u\n"
-		"tx-frames-high: %u\n"
-		"\n",
-		ecoal->stats_block_coalesce_usecs,
-		ecoal->rate_sample_interval,
-		ecoal->pkt_rate_low,
-		ecoal->pkt_rate_high,
-
-		ecoal->rx_coalesce_usecs,
-		ecoal->rx_max_coalesced_frames,
-		ecoal->rx_coalesce_usecs_irq,
-		ecoal->rx_max_coalesced_frames_irq,
-
-		ecoal->tx_coalesce_usecs,
-		ecoal->tx_max_coalesced_frames,
-		ecoal->tx_coalesce_usecs_irq,
-		ecoal->tx_max_coalesced_frames_irq,
-
-		ecoal->rx_coalesce_usecs_low,
-		ecoal->rx_max_coalesced_frames_low,
-		ecoal->tx_coalesce_usecs_low,
-		ecoal->tx_max_coalesced_frames_low,
-
-		ecoal->rx_coalesce_usecs_high,
-		ecoal->rx_max_coalesced_frames_high,
-		ecoal->tx_coalesce_usecs_high,
-		ecoal->tx_max_coalesced_frames_high);
-
-	return 0;
-}
-
-void dump_per_queue_coalesce(struct ethtool_per_queue_op *per_queue_opt,
-			     __u32 *queue_mask, int n_queues)
-{
-	struct ethtool_coalesce *ecoal;
-	int i, idx = 0;
-
-	ecoal = (struct ethtool_coalesce *)(per_queue_opt + 1);
-	for (i = 0; i < __KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32); i++) {
-		int queue = i * 32;
-		__u32 mask = queue_mask[i];
-
-		while (mask > 0) {
-			if (mask & 0x1) {
-				fprintf(stdout, "Queue: %d\n", queue);
-				dump_coalesce(ecoal + idx);
-				idx++;
-			}
-			mask = mask >> 1;
-			queue++;
-		}
-		if (idx == n_queues)
-			break;
-	}
-}
-
 struct feature_state {
 	u32 off_flags;
 	struct ethtool_gfeatures features;
@@ -1508,104 +1040,6 @@ static void dump_features(const struct f
 					 state, ref_state, j);
 }
 
-static int dump_rxfhash(int fhash, u64 val)
-{
-	switch (fhash & ~FLOW_RSS) {
-	case TCP_V4_FLOW:
-		fprintf(stdout, "TCP over IPV4 flows");
-		break;
-	case UDP_V4_FLOW:
-		fprintf(stdout, "UDP over IPV4 flows");
-		break;
-	case SCTP_V4_FLOW:
-		fprintf(stdout, "SCTP over IPV4 flows");
-		break;
-	case AH_ESP_V4_FLOW:
-	case AH_V4_FLOW:
-	case ESP_V4_FLOW:
-		fprintf(stdout, "IPSEC AH/ESP over IPV4 flows");
-		break;
-	case TCP_V6_FLOW:
-		fprintf(stdout, "TCP over IPV6 flows");
-		break;
-	case UDP_V6_FLOW:
-		fprintf(stdout, "UDP over IPV6 flows");
-		break;
-	case SCTP_V6_FLOW:
-		fprintf(stdout, "SCTP over IPV6 flows");
-		break;
-	case AH_ESP_V6_FLOW:
-	case AH_V6_FLOW:
-	case ESP_V6_FLOW:
-		fprintf(stdout, "IPSEC AH/ESP over IPV6 flows");
-		break;
-	default:
-		break;
-	}
-
-	if (val & RXH_DISCARD) {
-		fprintf(stdout, " - All matching flows discarded on RX\n");
-		return 0;
-	}
-	fprintf(stdout, " use these fields for computing Hash flow key:\n");
-
-	fprintf(stdout, "%s\n", unparse_rxfhashopts(val));
-
-	return 0;
-}
-
-static void dump_eeecmd(struct ethtool_eee *ep)
-{
-	ETHTOOL_DECLARE_LINK_MODE_MASK(link_mode);
-
-	fprintf(stdout, "	EEE status: ");
-	if (!ep->supported) {
-		fprintf(stdout, "not supported\n");
-		return;
-	} else if (!ep->eee_enabled) {
-		fprintf(stdout, "disabled\n");
-	} else {
-		fprintf(stdout, "enabled - ");
-		if (ep->eee_active)
-			fprintf(stdout, "active\n");
-		else
-			fprintf(stdout, "inactive\n");
-	}
-
-	fprintf(stdout, "	Tx LPI:");
-	if (ep->tx_lpi_enabled)
-		fprintf(stdout, " %d (us)\n", ep->tx_lpi_timer);
-	else
-		fprintf(stdout, " disabled\n");
-
-	ethtool_link_mode_zero(link_mode);
-
-	link_mode[0] = ep->supported;
-	dump_link_caps("Supported EEE", "", link_mode, 1);
-
-	link_mode[0] = ep->advertised;
-	dump_link_caps("Advertised EEE", "", link_mode, 1);
-
-	link_mode[0] = ep->lp_advertised;
-	dump_link_caps("Link partner advertised EEE", "", link_mode, 1);
-}
-
-static void dump_fec(u32 fec)
-{
-	if (fec & ETHTOOL_FEC_NONE)
-		fprintf(stdout, " None");
-	if (fec & ETHTOOL_FEC_AUTO)
-		fprintf(stdout, " Auto");
-	if (fec & ETHTOOL_FEC_OFF)
-		fprintf(stdout, " Off");
-	if (fec & ETHTOOL_FEC_BASER)
-		fprintf(stdout, " BaseR");
-	if (fec & ETHTOOL_FEC_RS)
-		fprintf(stdout, " RS");
-	if (fec & ETHTOOL_FEC_LLRS)
-		fprintf(stdout, " LLRS");
-}
-
 #define N_SOTS 7
 
 static char *so_timestamping_labels[N_SOTS] = {
@@ -1812,56 +1246,6 @@ static struct feature_defs *get_feature_
 	return defs;
 }
 
-static int do_gdrv(struct cmd_context *ctx)
-{
-	int err;
-	struct ethtool_drvinfo drvinfo;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	drvinfo.cmd = ETHTOOL_GDRVINFO;
-	err = send_ioctl(ctx, &drvinfo);
-	if (err < 0) {
-		perror("Cannot get driver information");
-		return 71;
-	}
-	return dump_drvinfo(&drvinfo);
-}
-
-static int do_gpause(struct cmd_context *ctx)
-{
-	struct ethtool_pauseparam epause;
-	struct ethtool_cmd ecmd;
-	int err;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	fprintf(stdout, "Pause parameters for %s:\n", ctx->devname);
-
-	epause.cmd = ETHTOOL_GPAUSEPARAM;
-	err = send_ioctl(ctx, &epause);
-	if (err) {
-		perror("Cannot get device pause settings");
-		return 76;
-	}
-
-	if (epause.autoneg) {
-		ecmd.cmd = ETHTOOL_GSET;
-		err = send_ioctl(ctx, &ecmd);
-		if (err) {
-			perror("Cannot get device settings");
-			return 1;
-		}
-		dump_pause(&epause, ecmd.advertising, ecmd.lp_advertising);
-	} else {
-		dump_pause(&epause, 0, 0);
-	}
-
-	return 0;
-}
-
 static void do_generic_set1(struct cmdline_info *info, int *changed_out)
 {
 	int wanted, *v1, *v2;
@@ -1891,62 +1275,6 @@ static void do_generic_set(struct cmdlin
 		do_generic_set1(&info[i], changed_out);
 }
 
-static int do_spause(struct cmd_context *ctx)
-{
-	struct ethtool_pauseparam epause;
-	int gpause_changed = 0;
-	int pause_autoneg_wanted = -1;
-	int pause_rx_wanted = -1;
-	int pause_tx_wanted = -1;
-	struct cmdline_info cmdline_pause[] = {
-		{
-			.name		= "autoneg",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &pause_autoneg_wanted,
-			.ioctl_val	= &epause.autoneg,
-		},
-		{
-			.name		= "rx",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &pause_rx_wanted,
-			.ioctl_val	= &epause.rx_pause,
-		},
-		{
-			.name		= "tx",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &pause_tx_wanted,
-			.ioctl_val	= &epause.tx_pause,
-		},
-	};
-	int err, changed = 0;
-
-	parse_generic_cmdline(ctx, &gpause_changed,
-			      cmdline_pause, ARRAY_SIZE(cmdline_pause));
-
-	epause.cmd = ETHTOOL_GPAUSEPARAM;
-	err = send_ioctl(ctx, &epause);
-	if (err) {
-		perror("Cannot get device pause settings");
-		return 77;
-	}
-
-	do_generic_set(cmdline_pause, ARRAY_SIZE(cmdline_pause), &changed);
-
-	if (!changed) {
-		fprintf(stderr, "no pause parameters changed, aborting\n");
-		return 78;
-	}
-
-	epause.cmd = ETHTOOL_SPAUSEPARAM;
-	err = send_ioctl(ctx, &epause);
-	if (err) {
-		perror("Cannot set device pause parameters");
-		return 79;
-	}
-
-	return 0;
-}
-
 static int do_sring(struct cmd_context *ctx)
 {
 	struct ethtool_ringparam ering;
@@ -2034,318 +1362,6 @@ static int do_gring(struct cmd_context *
 	return 0;
 }
 
-static int do_schannels(struct cmd_context *ctx)
-{
-	struct ethtool_channels echannels;
-	int gchannels_changed;
-	s32 channels_rx_wanted = -1;
-	s32 channels_tx_wanted = -1;
-	s32 channels_other_wanted = -1;
-	s32 channels_combined_wanted = -1;
-	struct cmdline_info cmdline_channels[] = {
-		{
-			.name		= "rx",
-			.type		= CMDL_S32,
-			.wanted_val	= &channels_rx_wanted,
-			.ioctl_val	= &echannels.rx_count,
-		},
-		{
-			.name		= "tx",
-			.type		= CMDL_S32,
-			.wanted_val	= &channels_tx_wanted,
-			.ioctl_val	= &echannels.tx_count,
-		},
-		{
-			.name		= "other",
-			.type		= CMDL_S32,
-			.wanted_val	= &channels_other_wanted,
-			.ioctl_val	= &echannels.other_count,
-		},
-		{
-			.name		= "combined",
-			.type		= CMDL_S32,
-			.wanted_val	= &channels_combined_wanted,
-			.ioctl_val	= &echannels.combined_count,
-		},
-	};
-	int err, changed = 0;
-
-	parse_generic_cmdline(ctx, &gchannels_changed,
-			      cmdline_channels, ARRAY_SIZE(cmdline_channels));
-
-	echannels.cmd = ETHTOOL_GCHANNELS;
-	err = send_ioctl(ctx, &echannels);
-	if (err) {
-		perror("Cannot get device channel parameters");
-		return 1;
-	}
-
-	do_generic_set(cmdline_channels, ARRAY_SIZE(cmdline_channels),
-			&changed);
-
-	if (!changed) {
-		fprintf(stderr, "no channel parameters changed.\n");
-		fprintf(stderr, "current values: rx %u tx %u other %u"
-			" combined %u\n", echannels.rx_count,
-			echannels.tx_count, echannels.other_count,
-			echannels.combined_count);
-		return 0;
-	}
-
-	echannels.cmd = ETHTOOL_SCHANNELS;
-	err = send_ioctl(ctx, &echannels);
-	if (err) {
-		perror("Cannot set device channel parameters");
-		return 1;
-	}
-
-	return 0;
-}
-
-static int do_gchannels(struct cmd_context *ctx)
-{
-	struct ethtool_channels echannels;
-	int err;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	fprintf(stdout, "Channel parameters for %s:\n", ctx->devname);
-
-	echannels.cmd = ETHTOOL_GCHANNELS;
-	err = send_ioctl(ctx, &echannels);
-	if (err == 0) {
-		err = dump_channels(&echannels);
-		if (err)
-			return err;
-	} else {
-		perror("Cannot get device channel parameters\n");
-		return 1;
-	}
-	return 0;
-
-}
-
-static int do_gcoalesce(struct cmd_context *ctx)
-{
-	struct ethtool_coalesce ecoal = {};
-	int err;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	fprintf(stdout, "Coalesce parameters for %s:\n", ctx->devname);
-
-	ecoal.cmd = ETHTOOL_GCOALESCE;
-	err = send_ioctl(ctx, &ecoal);
-	if (err == 0) {
-		err = dump_coalesce(&ecoal);
-		if (err)
-			return err;
-	} else {
-		perror("Cannot get device coalesce settings");
-		return 82;
-	}
-
-	return 0;
-}
-
-#define DECLARE_COALESCE_OPTION_VARS()		\
-	s32 coal_stats_wanted = -1;		\
-	int coal_adaptive_rx_wanted = -1;	\
-	int coal_adaptive_tx_wanted = -1;	\
-	s32 coal_sample_rate_wanted = -1;	\
-	s32 coal_pkt_rate_low_wanted = -1;	\
-	s32 coal_pkt_rate_high_wanted = -1;	\
-	s32 coal_rx_usec_wanted = -1;		\
-	s32 coal_rx_frames_wanted = -1;		\
-	s32 coal_rx_usec_irq_wanted = -1;	\
-	s32 coal_rx_frames_irq_wanted = -1;	\
-	s32 coal_tx_usec_wanted = -1;		\
-	s32 coal_tx_frames_wanted = -1;		\
-	s32 coal_tx_usec_irq_wanted = -1;	\
-	s32 coal_tx_frames_irq_wanted = -1;	\
-	s32 coal_rx_usec_low_wanted = -1;	\
-	s32 coal_rx_frames_low_wanted = -1;	\
-	s32 coal_tx_usec_low_wanted = -1;	\
-	s32 coal_tx_frames_low_wanted = -1;	\
-	s32 coal_rx_usec_high_wanted = -1;	\
-	s32 coal_rx_frames_high_wanted = -1;	\
-	s32 coal_tx_usec_high_wanted = -1;	\
-	s32 coal_tx_frames_high_wanted = -1
-
-#define COALESCE_CMDLINE_INFO(__ecoal)					\
-{									\
-	{								\
-		.name		= "adaptive-rx",			\
-		.type		= CMDL_BOOL,				\
-		.wanted_val	= &coal_adaptive_rx_wanted,		\
-		.ioctl_val	= &__ecoal.use_adaptive_rx_coalesce,	\
-	},								\
-	{								\
-		.name		= "adaptive-tx",			\
-		.type		= CMDL_BOOL,				\
-		.wanted_val	= &coal_adaptive_tx_wanted,		\
-		.ioctl_val	= &__ecoal.use_adaptive_tx_coalesce,	\
-	},								\
-	{								\
-		.name		= "sample-interval",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_sample_rate_wanted,		\
-		.ioctl_val	= &__ecoal.rate_sample_interval,	\
-	},								\
-	{								\
-		.name		= "stats-block-usecs",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_stats_wanted,			\
-		.ioctl_val	= &__ecoal.stats_block_coalesce_usecs,	\
-	},								\
-	{								\
-		.name		= "pkt-rate-low",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_pkt_rate_low_wanted,		\
-		.ioctl_val	= &__ecoal.pkt_rate_low,		\
-	},								\
-	{								\
-		.name		= "pkt-rate-high",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_pkt_rate_high_wanted,		\
-		.ioctl_val	= &__ecoal.pkt_rate_high,		\
-	},								\
-	{								\
-		.name		= "rx-usecs",				\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_usec_wanted,			\
-		.ioctl_val	= &__ecoal.rx_coalesce_usecs,		\
-	},								\
-	{								\
-		.name		= "rx-frames",				\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_frames_wanted,		\
-		.ioctl_val	= &__ecoal.rx_max_coalesced_frames,	\
-	},								\
-	{								\
-		.name		= "rx-usecs-irq",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_usec_irq_wanted,		\
-		.ioctl_val	= &__ecoal.rx_coalesce_usecs_irq,	\
-	},								\
-	{								\
-		.name		= "rx-frames-irq",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_frames_irq_wanted,		\
-		.ioctl_val	= &__ecoal.rx_max_coalesced_frames_irq,	\
-	},								\
-	{								\
-		.name		= "tx-usecs",				\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_usec_wanted,			\
-		.ioctl_val	= &__ecoal.tx_coalesce_usecs,		\
-	},								\
-	{								\
-		.name		= "tx-frames",				\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_frames_wanted,		\
-		.ioctl_val	= &__ecoal.tx_max_coalesced_frames,	\
-	},								\
-	{								\
-		.name		= "tx-usecs-irq",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_usec_irq_wanted,		\
-		.ioctl_val	= &__ecoal.tx_coalesce_usecs_irq,	\
-	},								\
-	{								\
-		.name		= "tx-frames-irq",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_frames_irq_wanted,		\
-		.ioctl_val	= &__ecoal.tx_max_coalesced_frames_irq,	\
-	},								\
-	{								\
-		.name		= "rx-usecs-low",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_usec_low_wanted,		\
-		.ioctl_val	= &__ecoal.rx_coalesce_usecs_low,	\
-	},								\
-	{								\
-		.name		= "rx-frames-low",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_frames_low_wanted,		\
-		.ioctl_val	= &__ecoal.rx_max_coalesced_frames_low,	\
-	},								\
-	{								\
-		.name		= "tx-usecs-low",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_usec_low_wanted,		\
-		.ioctl_val	= &__ecoal.tx_coalesce_usecs_low,	\
-	},								\
-	{								\
-		.name		= "tx-frames-low",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_frames_low_wanted,		\
-		.ioctl_val	= &__ecoal.tx_max_coalesced_frames_low,	\
-	},								\
-	{								\
-		.name		= "rx-usecs-high",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_usec_high_wanted,		\
-		.ioctl_val	= &__ecoal.rx_coalesce_usecs_high,	\
-	},								\
-	{								\
-		.name		= "rx-frames-high",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_rx_frames_high_wanted,		\
-		.ioctl_val	= &__ecoal.rx_max_coalesced_frames_high,\
-	},								\
-	{								\
-		.name		= "tx-usecs-high",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_usec_high_wanted,		\
-		.ioctl_val	= &__ecoal.tx_coalesce_usecs_high,	\
-	},								\
-	{								\
-		.name		= "tx-frames-high",			\
-		.type		= CMDL_S32,				\
-		.wanted_val	= &coal_tx_frames_high_wanted,		\
-		.ioctl_val	= &__ecoal.tx_max_coalesced_frames_high,\
-	},								\
-}
-
-static int do_scoalesce(struct cmd_context *ctx)
-{
-	struct ethtool_coalesce ecoal;
-	int gcoalesce_changed = 0;
-	DECLARE_COALESCE_OPTION_VARS();
-	struct cmdline_info cmdline_coalesce[] = COALESCE_CMDLINE_INFO(ecoal);
-	int err, changed = 0;
-
-	parse_generic_cmdline(ctx, &gcoalesce_changed,
-			      cmdline_coalesce, ARRAY_SIZE(cmdline_coalesce));
-
-	ecoal.cmd = ETHTOOL_GCOALESCE;
-	err = send_ioctl(ctx, &ecoal);
-	if (err) {
-		perror("Cannot get device coalesce settings");
-		return 76;
-	}
-
-	do_generic_set(cmdline_coalesce, ARRAY_SIZE(cmdline_coalesce),
-		       &changed);
-
-	if (!changed) {
-		fprintf(stderr, "no coalesce parameters changed, aborting\n");
-		return 80;
-	}
-
-	ecoal.cmd = ETHTOOL_SCOALESCE;
-	err = send_ioctl(ctx, &ecoal);
-	if (err) {
-		perror("Cannot set device coalesce parameters");
-		return 81;
-	}
-
-	return 0;
-}
-
 static struct feature_state *
 get_features(struct cmd_context *ctx, const struct feature_defs *defs)
 {
@@ -3297,100 +2313,6 @@ static int do_sset(struct cmd_context *c
 	return 0;
 }
 
-static int do_gregs(struct cmd_context *ctx)
-{
-	int gregs_changed = 0;
-	int gregs_dump_raw = 0;
-	int gregs_dump_hex = 0;
-	char *gregs_dump_file = NULL;
-	struct cmdline_info cmdline_gregs[] = {
-		{
-			.name		= "raw",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &gregs_dump_raw,
-		},
-		{
-			.name		= "hex",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &gregs_dump_hex,
-		},
-		{
-			.name		= "file",
-			.type		= CMDL_STR,
-			.wanted_val	= &gregs_dump_file,
-		},
-	};
-	int err;
-	struct ethtool_drvinfo drvinfo;
-	struct ethtool_regs *regs;
-
-	parse_generic_cmdline(ctx, &gregs_changed,
-			      cmdline_gregs, ARRAY_SIZE(cmdline_gregs));
-
-	drvinfo.cmd = ETHTOOL_GDRVINFO;
-	err = send_ioctl(ctx, &drvinfo);
-	if (err < 0) {
-		perror("Cannot get driver information");
-		return 72;
-	}
-
-	regs = calloc(1, sizeof(*regs)+drvinfo.regdump_len);
-	if (!regs) {
-		perror("Cannot allocate memory for register dump");
-		return 73;
-	}
-	regs->cmd = ETHTOOL_GREGS;
-	regs->len = drvinfo.regdump_len;
-	err = send_ioctl(ctx, regs);
-	if (err < 0) {
-		perror("Cannot get register dump");
-		free(regs);
-		return 74;
-	}
-
-	if (!gregs_dump_raw && gregs_dump_file != NULL) {
-		/* overwrite reg values from file dump */
-		FILE *f = fopen(gregs_dump_file, "r");
-		struct ethtool_regs *nregs;
-		struct stat st;
-		size_t nread;
-
-		if (!f || fstat(fileno(f), &st) < 0) {
-			fprintf(stderr, "Can't open '%s': %s\n",
-				gregs_dump_file, strerror(errno));
-			if (f)
-				fclose(f);
-			free(regs);
-			return 75;
-		}
-
-		nregs = realloc(regs, sizeof(*regs) + st.st_size);
-		if (!nregs) {
-			perror("Cannot allocate memory for register dump");
-			free(regs); /* was not freed by realloc */
-			return 73;
-		}
-		regs = nregs;
-		regs->len = st.st_size;
-		nread = fread(regs->data, regs->len, 1, f);
-		fclose(f);
-		if (nread != 1) {
-			free(regs);
-			return 75;
-		}
-	}
-
-	if (dump_regs(gregs_dump_raw, gregs_dump_hex,
-		      &drvinfo, regs) < 0) {
-		fprintf(stderr, "Cannot dump registers\n");
-		free(regs);
-		return 75;
-	}
-	free(regs);
-
-	return 0;
-}
-
 static int do_nway_rst(struct cmd_context *ctx)
 {
 	struct ethtool_value edata;
@@ -3407,229 +2329,6 @@ static int do_nway_rst(struct cmd_contex
 	return err;
 }
 
-static int do_geeprom(struct cmd_context *ctx)
-{
-	int geeprom_changed = 0;
-	int geeprom_dump_raw = 0;
-	u32 geeprom_offset = 0;
-	u32 geeprom_length = 0;
-	int geeprom_length_seen = 0;
-	struct cmdline_info cmdline_geeprom[] = {
-		{
-			.name		= "offset",
-			.type		= CMDL_U32,
-			.wanted_val	= &geeprom_offset,
-		},
-		{
-			.name		= "length",
-			.type		= CMDL_U32,
-			.wanted_val	= &geeprom_length,
-			.seen_val	= &geeprom_length_seen,
-		},
-		{
-			.name		= "raw",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &geeprom_dump_raw,
-		},
-	};
-	int err;
-	struct ethtool_drvinfo drvinfo;
-	struct ethtool_eeprom *eeprom;
-
-	parse_generic_cmdline(ctx, &geeprom_changed,
-			      cmdline_geeprom, ARRAY_SIZE(cmdline_geeprom));
-
-	drvinfo.cmd = ETHTOOL_GDRVINFO;
-	err = send_ioctl(ctx, &drvinfo);
-	if (err < 0) {
-		perror("Cannot get driver information");
-		return 74;
-	}
-
-	if (!geeprom_length_seen)
-		geeprom_length = drvinfo.eedump_len;
-
-	if (drvinfo.eedump_len < geeprom_offset + geeprom_length)
-		geeprom_length = drvinfo.eedump_len - geeprom_offset;
-
-	eeprom = calloc(1, sizeof(*eeprom)+geeprom_length);
-	if (!eeprom) {
-		perror("Cannot allocate memory for EEPROM data");
-		return 75;
-	}
-	eeprom->cmd = ETHTOOL_GEEPROM;
-	eeprom->len = geeprom_length;
-	eeprom->offset = geeprom_offset;
-	err = send_ioctl(ctx, eeprom);
-	if (err < 0) {
-		perror("Cannot get EEPROM data");
-		free(eeprom);
-		return 74;
-	}
-	err = dump_eeprom(geeprom_dump_raw, &drvinfo, eeprom);
-	free(eeprom);
-
-	return err;
-}
-
-static int do_seeprom(struct cmd_context *ctx)
-{
-	int seeprom_changed = 0;
-	u32 seeprom_magic = 0;
-	u32 seeprom_length = 0;
-	u32 seeprom_offset = 0;
-	u8 seeprom_value = 0;
-	int seeprom_length_seen = 0;
-	int seeprom_value_seen = 0;
-	struct cmdline_info cmdline_seeprom[] = {
-		{
-			.name		= "magic",
-			.type		= CMDL_U32,
-			.wanted_val	= &seeprom_magic,
-		},
-		{
-			.name		= "offset",
-			.type		= CMDL_U32,
-			.wanted_val	= &seeprom_offset,
-		},
-		{
-			.name		= "length",
-			.type		= CMDL_U32,
-			.wanted_val	= &seeprom_length,
-			.seen_val	= &seeprom_length_seen,
-		},
-		{
-			.name		= "value",
-			.type		= CMDL_U8,
-			.wanted_val	= &seeprom_value,
-			.seen_val	= &seeprom_value_seen,
-		},
-	};
-	int err;
-	struct ethtool_drvinfo drvinfo;
-	struct ethtool_eeprom *eeprom;
-
-	parse_generic_cmdline(ctx, &seeprom_changed,
-			      cmdline_seeprom, ARRAY_SIZE(cmdline_seeprom));
-
-	drvinfo.cmd = ETHTOOL_GDRVINFO;
-	err = send_ioctl(ctx, &drvinfo);
-	if (err < 0) {
-		perror("Cannot get driver information");
-		return 74;
-	}
-
-	if (seeprom_value_seen)
-		seeprom_length = 1;
-
-	if (!seeprom_length_seen)
-		seeprom_length = drvinfo.eedump_len;
-
-	if (drvinfo.eedump_len < seeprom_offset + seeprom_length) {
-		fprintf(stderr, "offset & length out of bounds\n");
-		return 1;
-	}
-
-	eeprom = calloc(1, sizeof(*eeprom)+seeprom_length);
-	if (!eeprom) {
-		perror("Cannot allocate memory for EEPROM data");
-		return 75;
-	}
-
-	eeprom->cmd = ETHTOOL_SEEPROM;
-	eeprom->len = seeprom_length;
-	eeprom->offset = seeprom_offset;
-	eeprom->magic = seeprom_magic;
-	eeprom->data[0] = seeprom_value;
-
-	/* Multi-byte write: read input from stdin */
-	if (!seeprom_value_seen) {
-		if (fread(eeprom->data, eeprom->len, 1, stdin) != 1) {
-			fprintf(stderr, "not enough data from stdin\n");
-			free(eeprom);
-			return 75;
-		}
-		if ((fgetc(stdin) != EOF) || !feof(stdin)) {
-			fprintf(stderr, "too much data from stdin\n");
-			free(eeprom);
-			return 75;
-		}
-	}
-
-	err = send_ioctl(ctx, eeprom);
-	if (err < 0) {
-		perror("Cannot set EEPROM data");
-		err = 87;
-	}
-	free(eeprom);
-
-	return err;
-}
-
-static int do_test(struct cmd_context *ctx)
-{
-	enum {
-		ONLINE = 0,
-		OFFLINE,
-		EXTERNAL_LB,
-	} test_type;
-	int err;
-	struct ethtool_test *test;
-	struct ethtool_gstrings *strings;
-
-	if (ctx->argc > 1)
-		exit_bad_args();
-	if (ctx->argc == 1) {
-		if (!strcmp(ctx->argp[0], "online"))
-			test_type = ONLINE;
-		else if (!strcmp(*ctx->argp, "offline"))
-			test_type = OFFLINE;
-		else if (!strcmp(*ctx->argp, "external_lb"))
-			test_type = EXTERNAL_LB;
-		else
-			exit_bad_args();
-	} else {
-		test_type = OFFLINE;
-	}
-
-	strings = get_stringset(ctx, ETH_SS_TEST,
-				offsetof(struct ethtool_drvinfo, testinfo_len),
-				1);
-	if (!strings) {
-		perror("Cannot get strings");
-		return 74;
-	}
-
-	test = calloc(1, sizeof(*test) + strings->len * sizeof(u64));
-	if (!test) {
-		perror("Cannot allocate memory for test info");
-		free(strings);
-		return 73;
-	}
-	memset(test->data, 0, strings->len * sizeof(u64));
-	test->cmd = ETHTOOL_TEST;
-	test->len = strings->len;
-	if (test_type == EXTERNAL_LB)
-		test->flags = (ETH_TEST_FL_OFFLINE | ETH_TEST_FL_EXTERNAL_LB);
-	else if (test_type == OFFLINE)
-		test->flags = ETH_TEST_FL_OFFLINE;
-	else
-		test->flags = 0;
-	err = send_ioctl(ctx, test);
-	if (err < 0) {
-		perror("Cannot test");
-		free(test);
-		free(strings);
-		return 74;
-	}
-
-	err = dump_test(test, strings);
-	free(test);
-	free(strings);
-
-	return err;
-}
-
 static void dump_link_caps_simplified(const u32 *mask)
 {
 	unsigned int i;
@@ -3739,28 +2438,6 @@ static int get_link_stats(struct cmd_con
 	return 0;
 }
 
-static int do_phys_id(struct cmd_context *ctx)
-{
-	int err;
-	struct ethtool_value edata;
-	int phys_id_time;
-
-	if (ctx->argc > 1)
-		exit_bad_args();
-	if (ctx->argc == 1)
-		phys_id_time = get_int(*ctx->argp, 0);
-	else
-		phys_id_time = 0;
-
-	edata.cmd = ETHTOOL_PHYS_ID;
-	edata.data = phys_id_time;
-	err = send_ioctl(ctx, &edata);
-	if (err < 0)
-		perror("Cannot identify NIC");
-
-	return err;
-}
-
 static int do_gstats(struct cmd_context *ctx, int cmd, int stringset,
 		    const char *name)
 {
@@ -3830,674 +2507,6 @@ static int do_gphystats(struct cmd_conte
 	return do_gstats(ctx, ETHTOOL_GPHYSTATS, ETH_SS_PHY_STATS, "PHY");
 }
 
-static int do_srxntuple(struct cmd_context *ctx,
-			struct ethtool_rx_flow_spec *rx_rule_fs);
-
-static int do_srxclass(struct cmd_context *ctx)
-{
-	int err;
-
-	if (ctx->argc < 2)
-		exit_bad_args();
-
-	if (!strcmp(ctx->argp[0], "rx-flow-hash")) {
-		int rx_fhash_set;
-		u32 rx_fhash_val;
-		struct ethtool_rxnfc nfccmd;
-		bool flow_rss = false;
-
-		if (ctx->argc == 5) {
-			if (strcmp(ctx->argp[3], "context"))
-				exit_bad_args();
-			flow_rss = true;
-			nfccmd.rss_context = get_u32(ctx->argp[4], 0);
-		} else if (ctx->argc != 3) {
-			exit_bad_args();
-		}
-		rx_fhash_set = rxflow_str_to_type(ctx->argp[1]);
-		if (!rx_fhash_set)
-			exit_bad_args();
-		if (parse_rxfhashopts(ctx->argp[2], &rx_fhash_val) < 0)
-			exit_bad_args();
-
-		nfccmd.cmd = ETHTOOL_SRXFH;
-		nfccmd.flow_type = rx_fhash_set;
-		nfccmd.data = rx_fhash_val;
-		if (flow_rss)
-			nfccmd.flow_type |= FLOW_RSS;
-
-		err = send_ioctl(ctx, &nfccmd);
-		if (err < 0)
-			perror("Cannot change RX network flow hashing options");
-	} else if (!strcmp(ctx->argp[0], "flow-type")) {
-		struct ethtool_rx_flow_spec rx_rule_fs;
-		__u32 rss_context = 0;
-
-		ctx->argc--;
-		ctx->argp++;
-		if (rxclass_parse_ruleopts(ctx, &rx_rule_fs, &rss_context) < 0)
-			exit_bad_args();
-
-		/* attempt to add rule via N-tuple specifier */
-		err = do_srxntuple(ctx, &rx_rule_fs);
-		if (!err)
-			return 0;
-
-		/* attempt to add rule via network flow classifier */
-		err = rxclass_rule_ins(ctx, &rx_rule_fs, rss_context);
-		if (err < 0) {
-			fprintf(stderr, "Cannot insert"
-				" classification rule\n");
-			return 1;
-		}
-	} else if (!strcmp(ctx->argp[0], "delete")) {
-		int rx_class_rule_del =
-			get_uint_range(ctx->argp[1], 0, INT_MAX);
-
-		err = rxclass_rule_del(ctx, rx_class_rule_del);
-
-		if (err < 0) {
-			fprintf(stderr, "Cannot delete"
-				" classification rule\n");
-			return 1;
-		}
-	} else {
-		exit_bad_args();
-	}
-
-	return 0;
-}
-
-static int do_grxclass(struct cmd_context *ctx)
-{
-	struct ethtool_rxnfc nfccmd;
-	int err;
-
-	if (ctx->argc > 0 && !strcmp(ctx->argp[0], "rx-flow-hash")) {
-		int rx_fhash_get;
-		bool flow_rss = false;
-
-		if (ctx->argc == 4) {
-			if (strcmp(ctx->argp[2], "context"))
-				exit_bad_args();
-			flow_rss = true;
-			nfccmd.rss_context = get_u32(ctx->argp[3], 0);
-		} else if (ctx->argc != 2) {
-			exit_bad_args();
-		}
-
-		rx_fhash_get = rxflow_str_to_type(ctx->argp[1]);
-		if (!rx_fhash_get)
-			exit_bad_args();
-
-		nfccmd.cmd = ETHTOOL_GRXFH;
-		nfccmd.flow_type = rx_fhash_get;
-		if (flow_rss)
-			nfccmd.flow_type |= FLOW_RSS;
-		err = send_ioctl(ctx, &nfccmd);
-		if (err < 0) {
-			perror("Cannot get RX network flow hashing options");
-		} else {
-			if (flow_rss)
-				fprintf(stdout, "For RSS context %u:\n",
-					nfccmd.rss_context);
-			dump_rxfhash(rx_fhash_get, nfccmd.data);
-		}
-	} else if (ctx->argc == 2 && !strcmp(ctx->argp[0], "rule")) {
-		int rx_class_rule_get =
-			get_uint_range(ctx->argp[1], 0, INT_MAX);
-
-		err = rxclass_rule_get(ctx, rx_class_rule_get);
-		if (err < 0)
-			fprintf(stderr, "Cannot get RX classification rule\n");
-	} else if (ctx->argc == 0) {
-		nfccmd.cmd = ETHTOOL_GRXRINGS;
-		err = send_ioctl(ctx, &nfccmd);
-		if (err < 0)
-			perror("Cannot get RX rings");
-		else
-			fprintf(stdout, "%d RX rings available\n",
-				(int)nfccmd.data);
-
-		err = rxclass_rule_getall(ctx);
-		if (err < 0)
-			fprintf(stderr, "RX classification rule retrieval failed\n");
-
-	} else {
-		exit_bad_args();
-	}
-
-	return err ? 1 : 0;
-}
-
-static void print_indir_table(struct cmd_context *ctx,
-			      struct ethtool_rxnfc *ring_count,
-			      u32 indir_size, u32 *indir)
-{
-	u32 i;
-
-	printf("RX flow hash indirection table for %s with %llu RX ring(s):\n",
-	       ctx->devname, ring_count->data);
-
-	if (!indir_size)
-		printf("Operation not supported\n");
-
-	for (i = 0; i < indir_size; i++) {
-		if (i % 8 == 0)
-			printf("%5u: ", i);
-		printf(" %5u", indir[i]);
-		if (i % 8 == 7 || i == indir_size - 1)
-			fputc('\n', stdout);
-	}
-}
-
-static int do_grxfhindir(struct cmd_context *ctx,
-			 struct ethtool_rxnfc *ring_count)
-{
-	struct ethtool_rxfh_indir indir_head;
-	struct ethtool_rxfh_indir *indir;
-	int err;
-
-	indir_head.cmd = ETHTOOL_GRXFHINDIR;
-	indir_head.size = 0;
-	err = send_ioctl(ctx, &indir_head);
-	if (err < 0) {
-		perror("Cannot get RX flow hash indirection table size");
-		return 1;
-	}
-
-	indir = malloc(sizeof(*indir) +
-		       indir_head.size * sizeof(*indir->ring_index));
-	if (!indir) {
-		perror("Cannot allocate memory for indirection table");
-		return 1;
-	}
-
-	indir->cmd = ETHTOOL_GRXFHINDIR;
-	indir->size = indir_head.size;
-	err = send_ioctl(ctx, indir);
-	if (err < 0) {
-		perror("Cannot get RX flow hash indirection table");
-		free(indir);
-		return 1;
-	}
-
-	print_indir_table(ctx, ring_count, indir->size, indir->ring_index);
-
-	free(indir);
-	return 0;
-}
-
-static int do_grxfh(struct cmd_context *ctx)
-{
-	struct ethtool_gstrings *hfuncs = NULL;
-	struct ethtool_rxfh rss_head = {0};
-	struct ethtool_rxnfc ring_count;
-	struct ethtool_rxfh *rss;
-	u32 rss_context = 0;
-	u32 i, indir_bytes;
-	unsigned int arg_num = 0;
-	char *hkey;
-	int err;
-
-	while (arg_num < ctx->argc) {
-		if (!strcmp(ctx->argp[arg_num], "context")) {
-			++arg_num;
-			rss_context = get_int_range(ctx->argp[arg_num], 0, 1,
-						    ETH_RXFH_CONTEXT_ALLOC - 1);
-			++arg_num;
-		} else {
-			exit_bad_args();
-		}
-	}
-
-	ring_count.cmd = ETHTOOL_GRXRINGS;
-	err = send_ioctl(ctx, &ring_count);
-	if (err < 0) {
-		perror("Cannot get RX ring count");
-		return 1;
-	}
-
-	rss_head.cmd = ETHTOOL_GRSSH;
-	rss_head.rss_context = rss_context;
-	err = send_ioctl(ctx, &rss_head);
-	if (err < 0 && errno == EOPNOTSUPP && !rss_context) {
-		return do_grxfhindir(ctx, &ring_count);
-	} else if (err < 0) {
-		perror("Cannot get RX flow hash indir size and/or key size");
-		return 1;
-	}
-
-	rss = calloc(1, sizeof(*rss) +
-			rss_head.indir_size * sizeof(rss_head.rss_config[0]) +
-			rss_head.key_size);
-	if (!rss) {
-		perror("Cannot allocate memory for RX flow hash config");
-		return 1;
-	}
-
-	rss->cmd = ETHTOOL_GRSSH;
-	rss->rss_context = rss_context;
-	rss->indir_size = rss_head.indir_size;
-	rss->key_size = rss_head.key_size;
-	err = send_ioctl(ctx, rss);
-	if (err < 0) {
-		perror("Cannot get RX flow hash configuration");
-		free(rss);
-		return 1;
-	}
-
-	print_indir_table(ctx, &ring_count, rss->indir_size, rss->rss_config);
-
-	indir_bytes = rss->indir_size * sizeof(rss->rss_config[0]);
-	hkey = ((char *)rss->rss_config + indir_bytes);
-
-	printf("RSS hash key:\n");
-	if (!rss->key_size)
-		printf("Operation not supported\n");
-
-	for (i = 0; i < rss->key_size; i++) {
-		if (i == (rss->key_size - 1))
-			printf("%02x\n", (u8) hkey[i]);
-		else
-			printf("%02x:", (u8) hkey[i]);
-	}
-
-	printf("RSS hash function:\n");
-	if (!rss->hfunc) {
-		printf("    Operation not supported\n");
-		goto out;
-	}
-
-	hfuncs = get_stringset(ctx, ETH_SS_RSS_HASH_FUNCS, 0, 1);
-	if (!hfuncs) {
-		perror("Cannot get hash functions names");
-		free(rss);
-		return 1;
-	}
-
-	for (i = 0; i < hfuncs->len; i++)
-		printf("    %s: %s\n",
-		       (const char *)hfuncs->data + i * ETH_GSTRING_LEN,
-		       (rss->hfunc & (1 << i)) ? "on" : "off");
-
-out:
-	free(hfuncs);
-	free(rss);
-	return 0;
-}
-
-static int fill_indir_table(u32 *indir_size, u32 *indir, int rxfhindir_default,
-			    int rxfhindir_start, int rxfhindir_equal,
-			    char **rxfhindir_weight, u32 num_weights)
-{
-	u32 i;
-
-	if (rxfhindir_equal) {
-		for (i = 0; i < *indir_size; i++)
-			indir[i] = rxfhindir_start + (i % rxfhindir_equal);
-	} else if (rxfhindir_weight) {
-		u32 j, weight, sum = 0, partial = 0;
-
-		for (j = 0; j < num_weights; j++) {
-			weight = get_u32(rxfhindir_weight[j], 0);
-			sum += weight;
-		}
-
-		if (sum == 0) {
-			fprintf(stderr,
-				"At least one weight must be non-zero\n");
-			return 2;
-		}
-
-		if (sum > *indir_size) {
-			fprintf(stderr,
-				"Total weight exceeds the size of the "
-				"indirection table\n");
-			return 2;
-		}
-
-		j = -1;
-		for (i = 0; i < *indir_size; i++) {
-			while (i >= (*indir_size) * partial / sum) {
-				j += 1;
-				weight = get_u32(rxfhindir_weight[j], 0);
-				partial += weight;
-			}
-			indir[i] = rxfhindir_start + j;
-		}
-	} else if (rxfhindir_default) {
-		/* "*indir_size == 0" ==> reset indir to default */
-		*indir_size = 0;
-	} else {
-		*indir_size = ETH_RXFH_INDIR_NO_CHANGE;
-	}
-
-	return 0;
-}
-
-static int do_srxfhindir(struct cmd_context *ctx, int rxfhindir_default,
-			 int rxfhindir_start, int rxfhindir_equal,
-			 char **rxfhindir_weight, u32 num_weights)
-{
-	struct ethtool_rxfh_indir indir_head;
-	struct ethtool_rxfh_indir *indir;
-	int err;
-
-	indir_head.cmd = ETHTOOL_GRXFHINDIR;
-	indir_head.size = 0;
-	err = send_ioctl(ctx, &indir_head);
-	if (err < 0) {
-		perror("Cannot get RX flow hash indirection table size");
-		return 1;
-	}
-
-	indir = malloc(sizeof(*indir) +
-		       indir_head.size * sizeof(*indir->ring_index));
-
-	if (!indir) {
-		perror("Cannot allocate memory for indirection table");
-		return 1;
-	}
-
-	indir->cmd = ETHTOOL_SRXFHINDIR;
-	indir->size = indir_head.size;
-
-	if (fill_indir_table(&indir->size, indir->ring_index,
-			     rxfhindir_default, rxfhindir_start,
-			     rxfhindir_equal, rxfhindir_weight, num_weights)) {
-		free(indir);
-		return 1;
-	}
-
-	err = send_ioctl(ctx, indir);
-	if (err < 0) {
-		perror("Cannot set RX flow hash indirection table");
-		free(indir);
-		return 1;
-	}
-
-	free(indir);
-	return 0;
-}
-
-static int do_srxfh(struct cmd_context *ctx)
-{
-	struct ethtool_rxfh rss_head = {0};
-	struct ethtool_rxfh *rss = NULL;
-	struct ethtool_rxnfc ring_count;
-	int rxfhindir_equal = 0, rxfhindir_default = 0, rxfhindir_start = 0;
-	struct ethtool_gstrings *hfuncs = NULL;
-	char **rxfhindir_weight = NULL;
-	char *rxfhindir_key = NULL;
-	char *req_hfunc_name = NULL;
-	char *hfunc_name = NULL;
-	char *hkey = NULL;
-	int err = 0;
-	unsigned int i;
-	u32 arg_num = 0, indir_bytes = 0;
-	u32 req_hfunc = 0;
-	u32 entry_size = sizeof(rss_head.rss_config[0]);
-	u32 num_weights = 0;
-	u32 rss_context = 0;
-	int delete = 0;
-
-	if (ctx->argc < 1)
-		exit_bad_args();
-
-	while (arg_num < ctx->argc) {
-		if (!strcmp(ctx->argp[arg_num], "equal")) {
-			++arg_num;
-			rxfhindir_equal = get_int_range(ctx->argp[arg_num],
-							0, 1, INT_MAX);
-			++arg_num;
-		} else if (!strcmp(ctx->argp[arg_num], "start")) {
-			++arg_num;
-			rxfhindir_start = get_int_range(ctx->argp[arg_num],
-							0, 0, INT_MAX);
-			++arg_num;
-		} else if (!strcmp(ctx->argp[arg_num], "weight")) {
-			++arg_num;
-			rxfhindir_weight = ctx->argp + arg_num;
-			while (arg_num < ctx->argc &&
-			       isdigit((unsigned char)ctx->argp[arg_num][0])) {
-				++arg_num;
-				++num_weights;
-			}
-			if (!num_weights)
-				exit_bad_args();
-		} else if (!strcmp(ctx->argp[arg_num], "hkey")) {
-			++arg_num;
-			rxfhindir_key = ctx->argp[arg_num];
-			if (!rxfhindir_key)
-				exit_bad_args();
-			++arg_num;
-		} else if (!strcmp(ctx->argp[arg_num], "default")) {
-			++arg_num;
-			rxfhindir_default = 1;
-		} else if (!strcmp(ctx->argp[arg_num], "hfunc")) {
-			++arg_num;
-			req_hfunc_name = ctx->argp[arg_num];
-			if (!req_hfunc_name)
-				exit_bad_args();
-			++arg_num;
-		} else if (!strcmp(ctx->argp[arg_num], "context")) {
-			++arg_num;
-			if(!strcmp(ctx->argp[arg_num], "new"))
-				rss_context = ETH_RXFH_CONTEXT_ALLOC;
-			else
-				rss_context = get_int_range(
-						ctx->argp[arg_num], 0, 1,
-						ETH_RXFH_CONTEXT_ALLOC - 1);
-			++arg_num;
-		} else if (!strcmp(ctx->argp[arg_num], "delete")) {
-			++arg_num;
-			delete = 1;
-		} else {
-			exit_bad_args();
-		}
-	}
-
-	if (rxfhindir_equal && rxfhindir_weight) {
-		fprintf(stderr,
-			"Equal and weight options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (rxfhindir_equal && rxfhindir_default) {
-		fprintf(stderr,
-			"Equal and default options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (rxfhindir_weight && rxfhindir_default) {
-		fprintf(stderr,
-			"Weight and default options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (rxfhindir_start && rxfhindir_default) {
-		fprintf(stderr,
-			"Start and default options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (rxfhindir_start && !(rxfhindir_equal || rxfhindir_weight)) {
-		fprintf(stderr,
-			"Start must be used with equal or weight options\n");
-		return 1;
-	}
-
-	if (rxfhindir_default && rss_context) {
-		fprintf(stderr,
-			"Default and context options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (delete && !rss_context) {
-		fprintf(stderr, "Delete option requires context option\n");
-		return 1;
-	}
-
-	if (delete && rxfhindir_weight) {
-		fprintf(stderr,
-			"Delete and weight options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (delete && rxfhindir_equal) {
-		fprintf(stderr,
-			"Delete and equal options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (delete && rxfhindir_default) {
-		fprintf(stderr,
-			"Delete and default options are mutually exclusive\n");
-		return 1;
-	}
-
-	if (delete && rxfhindir_key) {
-		fprintf(stderr,
-			"Delete and hkey options are mutually exclusive\n");
-		return 1;
-	}
-
-	ring_count.cmd = ETHTOOL_GRXRINGS;
-	err = send_ioctl(ctx, &ring_count);
-	if (err < 0) {
-		perror("Cannot get RX ring count");
-		return 1;
-	}
-
-	rss_head.cmd = ETHTOOL_GRSSH;
-	err = send_ioctl(ctx, &rss_head);
-	if (err < 0 && errno == EOPNOTSUPP && !rxfhindir_key &&
-	    !req_hfunc_name && !rss_context) {
-		return do_srxfhindir(ctx, rxfhindir_default, rxfhindir_start,
-				     rxfhindir_equal, rxfhindir_weight,
-				     num_weights);
-	} else if (err < 0) {
-		perror("Cannot get RX flow hash indir size and key size");
-		return 1;
-	}
-
-	if (rxfhindir_key) {
-		err = parse_hkey(&hkey, rss_head.key_size,
-				 rxfhindir_key);
-		if (err)
-			return err;
-	}
-
-	if (rxfhindir_equal || rxfhindir_weight)
-		indir_bytes = rss_head.indir_size * entry_size;
-
-	if (rss_head.hfunc && req_hfunc_name) {
-		hfuncs = get_stringset(ctx, ETH_SS_RSS_HASH_FUNCS, 0, 1);
-		if (!hfuncs) {
-			perror("Cannot get hash functions names");
-			err = 1;
-			goto free;
-		}
-
-		for (i = 0; i < hfuncs->len && !req_hfunc ; i++) {
-			hfunc_name = (char *)(hfuncs->data +
-					      i * ETH_GSTRING_LEN);
-			if (!strncmp(hfunc_name, req_hfunc_name,
-				     ETH_GSTRING_LEN))
-				req_hfunc = (u32)1 << i;
-		}
-
-		if (!req_hfunc) {
-			fprintf(stderr,
-				"Unknown hash function: %s\n", req_hfunc_name);
-			err = 1;
-			goto free;
-		}
-	}
-
-	rss = calloc(1, sizeof(*rss) + indir_bytes + rss_head.key_size);
-	if (!rss) {
-		perror("Cannot allocate memory for RX flow hash config");
-		err = 1;
-		goto free;
-	}
-	rss->cmd = ETHTOOL_SRSSH;
-	rss->rss_context = rss_context;
-	rss->hfunc = req_hfunc;
-	if (delete) {
-		rss->indir_size = rss->key_size = 0;
-	} else {
-		rss->indir_size = rss_head.indir_size;
-		rss->key_size = rss_head.key_size;
-		if (fill_indir_table(&rss->indir_size, rss->rss_config,
-				     rxfhindir_default, rxfhindir_start,
-				     rxfhindir_equal, rxfhindir_weight,
-				     num_weights)) {
-			err = 1;
-			goto free;
-		}
-	}
-
-	if (hkey)
-		memcpy((char *)rss->rss_config + indir_bytes,
-		       hkey, rss->key_size);
-	else
-		rss->key_size = 0;
-
-	err = send_ioctl(ctx, rss);
-	if (err < 0) {
-		perror("Cannot set RX flow hash configuration");
-		err = 1;
-	} else if (rss_context == ETH_RXFH_CONTEXT_ALLOC) {
-		printf("New RSS context is %d\n", rss->rss_context);
-	}
-
-free:
-	free(hkey);
-	free(rss);
-	free(hfuncs);
-	return err;
-}
-
-static int do_flash(struct cmd_context *ctx)
-{
-	char *flash_file;
-	int flash_region;
-	struct ethtool_flash efl;
-	int err;
-
-	if (ctx->argc < 1 || ctx->argc > 2)
-		exit_bad_args();
-	flash_file = ctx->argp[0];
-	if (ctx->argc == 2) {
-		flash_region = strtol(ctx->argp[1], NULL, 0);
-		if (flash_region < 0)
-			exit_bad_args();
-	} else {
-		flash_region = -1;
-	}
-
-	if (strlen(flash_file) > ETHTOOL_FLASH_MAX_FILENAME - 1) {
-		fprintf(stdout, "Filename too long\n");
-		return 99;
-	}
-
-	efl.cmd = ETHTOOL_FLASHDEV;
-	strcpy(efl.data, flash_file);
-
-	if (flash_region < 0)
-		efl.region = ETHTOOL_FLASH_ALL_REGIONS;
-	else
-		efl.region = flash_region;
-
-	err = send_ioctl(ctx, &efl);
-	if (err < 0)
-		perror("Flashing failed");
-
-	return err;
-}
-
 static int do_permaddr(struct cmd_context *ctx)
 {
 	unsigned int i;
@@ -4528,364 +2537,6 @@ static int do_permaddr(struct cmd_contex
 	return err;
 }
 
-static bool flow_type_is_ntuple_supported(__u32 flow_type)
-{
-	switch (flow_type) {
-	case TCP_V4_FLOW:
-	case UDP_V4_FLOW:
-	case SCTP_V4_FLOW:
-	case AH_V4_FLOW:
-	case ESP_V4_FLOW:
-	case IPV4_USER_FLOW:
-	case ETHER_FLOW:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static int flow_spec_to_ntuple(struct ethtool_rx_flow_spec *fsp,
-			       struct ethtool_rx_ntuple_flow_spec *ntuple)
-{
-	size_t i;
-
-	/* verify location is not specified */
-	if (fsp->location != RX_CLS_LOC_ANY)
-		return -1;
-
-	/* destination MAC address in L3/L4 rules is not supported by ntuple */
-	if (fsp->flow_type & FLOW_MAC_EXT)
-		return -1;
-
-	/* verify ring cookie can transfer to action */
-	if (fsp->ring_cookie > INT_MAX && fsp->ring_cookie < (u64)(-2))
-		return -1;
-
-	/* verify only one field is setting data field */
-	if ((fsp->flow_type & FLOW_EXT) &&
-	    (fsp->m_ext.data[0] || fsp->m_ext.data[1]) &&
-	    fsp->m_ext.vlan_etype)
-		return -1;
-
-	/* IPv6 flow types are not supported by ntuple */
-	if (!flow_type_is_ntuple_supported(fsp->flow_type & ~FLOW_EXT))
-		return -1;
-
-	/* Set entire ntuple to ~0 to guarantee all masks are set */
-	memset(ntuple, ~0, sizeof(*ntuple));
-
-	/* set non-filter values */
-	ntuple->flow_type = fsp->flow_type;
-	ntuple->action = fsp->ring_cookie;
-
-	/*
-	 * Copy over header union, they are identical in layout however
-	 * the ntuple union contains additional padding on the end
-	 */
-	memcpy(&ntuple->h_u, &fsp->h_u, sizeof(fsp->h_u));
-
-	/*
-	 * The same rule mentioned above applies to the mask union.  However,
-	 * in addition we need to invert the mask bits to match the ntuple
-	 * mask which is 1 for masked, versus 0 for masked as seen in nfc.
-	 */
-	memcpy(&ntuple->m_u, &fsp->m_u, sizeof(fsp->m_u));
-	for (i = 0; i < sizeof(fsp->m_u); i++)
-		ntuple->m_u.hdata[i] ^= 0xFF;
-
-	/* copy extended fields */
-	if (fsp->flow_type & FLOW_EXT) {
-		ntuple->vlan_tag =
-			ntohs(fsp->h_ext.vlan_tci);
-		ntuple->vlan_tag_mask =
-			~ntohs(fsp->m_ext.vlan_tci);
-		if (fsp->m_ext.vlan_etype) {
-			/*
-			 * vlan_etype and user data are mutually exclusive
-			 * in ntuple configuration as they occupy the same
-			 * space.
-			 */
-			if (fsp->m_ext.data[0] || fsp->m_ext.data[1])
-				return -1;
-			ntuple->data =
-				ntohl(fsp->h_ext.vlan_etype);
-			ntuple->data_mask =
-				~(u64)ntohl(fsp->m_ext.vlan_etype);
-		} else {
-			ntuple->data =
-				(u64)ntohl(fsp->h_ext.data[0]) << 32;
-			ntuple->data |=
-				(u64)ntohl(fsp->h_ext.data[1]);
-			ntuple->data_mask =
-				(u64)ntohl(~fsp->m_ext.data[0]) << 32;
-			ntuple->data_mask |=
-				(u64)ntohl(~fsp->m_ext.data[1]);
-		}
-	}
-
-	/* Mask out the extended bit, because ntuple does not know it! */
-	ntuple->flow_type &= ~FLOW_EXT;
-
-	return 0;
-}
-
-static int do_srxntuple(struct cmd_context *ctx,
-			struct ethtool_rx_flow_spec *rx_rule_fs)
-{
-	struct ethtool_rx_ntuple ntuplecmd;
-	struct ethtool_value eval;
-	int err;
-
-	/* attempt to convert the flow classifier to an ntuple classifier */
-	err = flow_spec_to_ntuple(rx_rule_fs, &ntuplecmd.fs);
-	if (err)
-		return -1;
-
-	/*
-	 * Check to see if the flag is set for N-tuple, this allows
-	 * us to avoid the possible EINVAL response for the N-tuple
-	 * flag not being set on the device
-	 */
-	eval.cmd = ETHTOOL_GFLAGS;
-	err = send_ioctl(ctx, &eval);
-	if (err || !(eval.data & ETH_FLAG_NTUPLE))
-		return -1;
-
-	/* send rule via N-tuple */
-	ntuplecmd.cmd = ETHTOOL_SRXNTUPLE;
-	err = send_ioctl(ctx, &ntuplecmd);
-
-	/*
-	 * Display error only if response is something other than op not
-	 * supported.  It is possible that the interface uses the network
-	 * flow classifier interface instead of N-tuple.
-	 */
-	if (err < 0) {
-		if (errno != EOPNOTSUPP)
-			perror("Cannot add new rule via N-tuple");
-		return -1;
-	}
-
-	return 0;
-}
-
-static int do_writefwdump(struct ethtool_dump *dump, const char *dump_file)
-{
-	int err = 0;
-	FILE *f;
-	size_t bytes;
-
-	f = fopen(dump_file, "wb+");
-
-	if (!f) {
-		fprintf(stderr, "Can't open file %s: %s\n",
-			dump_file, strerror(errno));
-		return 1;
-	}
-	bytes = fwrite(dump->data, 1, dump->len, f);
-	if (bytes != dump->len) {
-		fprintf(stderr, "Can not write all of dump data\n");
-		err = 1;
-	}
-	if (fclose(f)) {
-		fprintf(stderr, "Can't close file %s: %s\n",
-			dump_file, strerror(errno));
-		err = 1;
-	}
-	return err;
-}
-
-static int do_getfwdump(struct cmd_context *ctx)
-{
-	u32 dump_flag;
-	char *dump_file;
-	int err;
-	struct ethtool_dump edata;
-	struct ethtool_dump *data;
-
-	if (ctx->argc == 2 && !strcmp(ctx->argp[0], "data")) {
-		dump_flag = ETHTOOL_GET_DUMP_DATA;
-		dump_file = ctx->argp[1];
-	} else if (ctx->argc == 0) {
-		dump_flag = 0;
-		dump_file = NULL;
-	} else {
-		exit_bad_args();
-	}
-
-	edata.cmd = ETHTOOL_GET_DUMP_FLAG;
-
-	err = send_ioctl(ctx, &edata);
-	if (err < 0) {
-		perror("Can not get dump level\n");
-		return 1;
-	}
-	if (dump_flag != ETHTOOL_GET_DUMP_DATA) {
-		fprintf(stdout, "flag: %u, version: %u, length: %u\n",
-			edata.flag, edata.version, edata.len);
-		return 0;
-	}
-	data = calloc(1, offsetof(struct ethtool_dump, data) + edata.len);
-	if (!data) {
-		perror("Can not allocate enough memory\n");
-		return 1;
-	}
-	data->cmd = ETHTOOL_GET_DUMP_DATA;
-	data->len = edata.len;
-	err = send_ioctl(ctx, data);
-	if (err < 0) {
-		perror("Can not get dump data\n");
-		err = 1;
-		goto free;
-	}
-	err = do_writefwdump(data, dump_file);
-free:
-	free(data);
-	return err;
-}
-
-static int do_setfwdump(struct cmd_context *ctx)
-{
-	u32 dump_flag;
-	int err;
-	struct ethtool_dump dump;
-
-	if (ctx->argc != 1)
-		exit_bad_args();
-	dump_flag = get_u32(ctx->argp[0], 0);
-
-	dump.cmd = ETHTOOL_SET_DUMP;
-	dump.flag = dump_flag;
-	err = send_ioctl(ctx, &dump);
-	if (err < 0) {
-		perror("Can not set dump level\n");
-		return 1;
-	}
-	return 0;
-}
-
-static int do_gprivflags(struct cmd_context *ctx)
-{
-	struct ethtool_gstrings *strings;
-	struct ethtool_value flags;
-	unsigned int i;
-	int max_len = 0, cur_len, rc;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	strings = get_stringset(ctx, ETH_SS_PRIV_FLAGS,
-				offsetof(struct ethtool_drvinfo, n_priv_flags),
-				1);
-	if (!strings) {
-		perror("Cannot get private flag names");
-		return 1;
-	}
-	if (strings->len == 0) {
-		fprintf(stderr, "No private flags defined\n");
-		rc = 1;
-		goto err;
-	}
-	if (strings->len > 32) {
-		/* ETHTOOL_GPFLAGS can only cover 32 flags */
-		fprintf(stderr, "Only showing first 32 private flags\n");
-		strings->len = 32;
-	}
-
-	flags.cmd = ETHTOOL_GPFLAGS;
-	if (send_ioctl(ctx, &flags)) {
-		perror("Cannot get private flags");
-		rc = 1;
-		goto err;
-	}
-
-	/* Find longest string and align all strings accordingly */
-	for (i = 0; i < strings->len; i++) {
-		cur_len = strlen((const char *)strings->data +
-				 i * ETH_GSTRING_LEN);
-		if (cur_len > max_len)
-			max_len = cur_len;
-	}
-
-	printf("Private flags for %s:\n", ctx->devname);
-	for (i = 0; i < strings->len; i++)
-		printf("%-*s: %s\n",
-		       max_len,
-		       (const char *)strings->data + i * ETH_GSTRING_LEN,
-		       (flags.data & (1U << i)) ? "on" : "off");
-
-	rc = 0;
-
-err:
-	free(strings);
-	return rc;
-}
-
-static int do_sprivflags(struct cmd_context *ctx)
-{
-	struct ethtool_gstrings *strings;
-	struct cmdline_info *cmdline;
-	struct ethtool_value flags;
-	u32 wanted_flags = 0, seen_flags = 0;
-	int any_changed, rc;
-	unsigned int i;
-
-	strings = get_stringset(ctx, ETH_SS_PRIV_FLAGS,
-				offsetof(struct ethtool_drvinfo, n_priv_flags),
-				1);
-	if (!strings) {
-		perror("Cannot get private flag names");
-		return 1;
-	}
-	if (strings->len == 0) {
-		fprintf(stderr, "No private flags defined\n");
-		rc = 1;
-		goto err;
-	}
-	if (strings->len > 32) {
-		/* ETHTOOL_{G,S}PFLAGS can only cover 32 flags */
-		fprintf(stderr, "Only setting first 32 private flags\n");
-		strings->len = 32;
-	}
-
-	cmdline = calloc(strings->len, sizeof(*cmdline));
-	if (!cmdline) {
-		perror("Cannot parse arguments");
-		rc = 1;
-		goto err;
-	}
-	for (i = 0; i < strings->len; i++) {
-		cmdline[i].name = ((const char *)strings->data +
-				   i * ETH_GSTRING_LEN);
-		cmdline[i].type = CMDL_FLAG;
-		cmdline[i].wanted_val = &wanted_flags;
-		cmdline[i].flag_val = 1U << i;
-		cmdline[i].seen_val = &seen_flags;
-	}
-	parse_generic_cmdline(ctx, &any_changed, cmdline, strings->len);
-	free(cmdline);
-
-	flags.cmd = ETHTOOL_GPFLAGS;
-	if (send_ioctl(ctx, &flags)) {
-		perror("Cannot get private flags");
-		rc = 1;
-		goto err;
-	}
-
-	flags.cmd = ETHTOOL_SPFLAGS;
-	flags.data = (flags.data & ~seen_flags) | wanted_flags;
-	if (send_ioctl(ctx, &flags)) {
-		perror("Cannot set private flags");
-		rc = 1;
-		goto err;
-	}
-
-	rc = 0;
-err:
-	free(strings);
-	return rc;
-}
-
 static int do_tsinfo(struct cmd_context *ctx)
 {
 	struct ethtool_ts_info info;
@@ -4903,207 +2554,6 @@ static int do_tsinfo(struct cmd_context
 	return 0;
 }
 
-static int do_getmodule(struct cmd_context *ctx)
-{
-	struct ethtool_modinfo modinfo;
-	struct ethtool_eeprom *eeprom;
-	u32 geeprom_offset = 0;
-	u32 geeprom_length = 0;
-	int geeprom_changed = 0;
-	int geeprom_dump_raw = 0;
-	int geeprom_dump_hex = 0;
-	int geeprom_length_seen = 0;
-	int err;
-
-	struct cmdline_info cmdline_geeprom[] = {
-		{
-			.name		= "offset",
-			.type		= CMDL_U32,
-			.wanted_val	= &geeprom_offset,
-		},
-		{
-			.name		= "length",
-			.type		= CMDL_U32,
-			.wanted_val	= &geeprom_length,
-			.seen_val	= &geeprom_length_seen,
-		},
-		{
-			.name		= "raw",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &geeprom_dump_raw,
-		},
-		{
-			.name		= "hex",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &geeprom_dump_hex,
-		},
-	};
-
-	parse_generic_cmdline(ctx, &geeprom_changed,
-			      cmdline_geeprom, ARRAY_SIZE(cmdline_geeprom));
-
-	if (geeprom_dump_raw && geeprom_dump_hex) {
-		printf("Hex and raw dump cannot be specified together\n");
-		return 1;
-	}
-
-	modinfo.cmd = ETHTOOL_GMODULEINFO;
-	err = send_ioctl(ctx, &modinfo);
-	if (err < 0) {
-		perror("Cannot get module EEPROM information");
-		return 1;
-	}
-
-	if (!geeprom_length_seen)
-		geeprom_length = modinfo.eeprom_len;
-
-	if (modinfo.eeprom_len < geeprom_offset + geeprom_length)
-		geeprom_length = modinfo.eeprom_len - geeprom_offset;
-
-	eeprom = calloc(1, sizeof(*eeprom)+geeprom_length);
-	if (!eeprom) {
-		perror("Cannot allocate memory for Module EEPROM data");
-		return 1;
-	}
-
-	eeprom->cmd = ETHTOOL_GMODULEEEPROM;
-	eeprom->len = geeprom_length;
-	eeprom->offset = geeprom_offset;
-	err = send_ioctl(ctx, eeprom);
-	if (err < 0) {
-		int saved_errno = errno;
-
-		perror("Cannot get Module EEPROM data");
-		if (saved_errno == ENODEV || saved_errno == EIO ||
-		    saved_errno == ENXIO)
-			fprintf(stderr, "SFP module not in cage?\n");
-		free(eeprom);
-		return 1;
-	}
-
-	/*
-	 * SFF-8079 EEPROM layout contains the memory available at A0 address on
-	 * the PHY EEPROM.
-	 * SFF-8472 defines a virtual extension of the EEPROM, where the
-	 * microcontroller on the SFP/SFP+ generates a page at the A2 address,
-	 * which contains data relative to optical diagnostics.
-	 * The current kernel implementation returns a blob, which contains:
-	 *  - ETH_MODULE_SFF_8079 => The A0 page only.
-	 *  - ETH_MODULE_SFF_8472 => The A0 and A2 page concatenated.
-	 */
-	if (geeprom_dump_raw) {
-		fwrite(eeprom->data, 1, eeprom->len, stdout);
-	} else {
-		if (eeprom->offset != 0  ||
-		    (eeprom->len != modinfo.eeprom_len)) {
-			geeprom_dump_hex = 1;
-		} else if (!geeprom_dump_hex) {
-			switch (modinfo.type) {
-#ifdef ETHTOOL_ENABLE_PRETTY_DUMP
-			case ETH_MODULE_SFF_8079:
-				sff8079_show_all(eeprom->data);
-				break;
-			case ETH_MODULE_SFF_8472:
-				sff8079_show_all(eeprom->data);
-				sff8472_show_all(eeprom->data);
-				break;
-			case ETH_MODULE_SFF_8436:
-			case ETH_MODULE_SFF_8636:
-				sff8636_show_all(eeprom->data,
-						 modinfo.eeprom_len);
-				break;
-#endif
-			default:
-				geeprom_dump_hex = 1;
-				break;
-			}
-		}
-		if (geeprom_dump_hex)
-			dump_hex(stdout, eeprom->data,
-				 eeprom->len, eeprom->offset);
-	}
-
-	free(eeprom);
-
-	return 0;
-}
-
-static int do_geee(struct cmd_context *ctx)
-{
-	struct ethtool_eee eeecmd;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	eeecmd.cmd = ETHTOOL_GEEE;
-	if (send_ioctl(ctx, &eeecmd)) {
-		perror("Cannot get EEE settings");
-		return 1;
-	}
-
-	fprintf(stdout, "EEE Settings for %s:\n", ctx->devname);
-	dump_eeecmd(&eeecmd);
-
-	return 0;
-}
-
-static int do_seee(struct cmd_context *ctx)
-{
-	int adv_c = -1, lpi_c = -1, lpi_time_c = -1, eee_c = -1;
-	int change = -1, change2 = 0;
-	struct ethtool_eee eeecmd;
-	struct cmdline_info cmdline_eee[] = {
-		{
-			.name		= "advertise",
-			.type		= CMDL_U32,
-			.wanted_val	= &adv_c,
-			.ioctl_val	= &eeecmd.advertised,
-		},
-		{
-			.name		= "tx-lpi",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &lpi_c,
-			.ioctl_val	= &eeecmd.tx_lpi_enabled,
-		},
-		{
-			.name		= "tx-timer",
-			.type		= CMDL_U32,
-			.wanted_val	= &lpi_time_c,
-			.ioctl_val	= &eeecmd.tx_lpi_timer,
-		},
-		{
-			.name		= "eee",
-			.type		= CMDL_BOOL,
-			.wanted_val	= &eee_c,
-			.ioctl_val	= &eeecmd.eee_enabled,
-		},
-	};
-
-	if (ctx->argc == 0)
-		exit_bad_args();
-
-	parse_generic_cmdline(ctx, &change, cmdline_eee,
-			      ARRAY_SIZE(cmdline_eee));
-
-	eeecmd.cmd = ETHTOOL_GEEE;
-	if (send_ioctl(ctx, &eeecmd)) {
-		perror("Cannot get EEE settings");
-		return 1;
-	}
-
-	do_generic_set(cmdline_eee, ARRAY_SIZE(cmdline_eee), &change2);
-
-	if (change2) {
-		eeecmd.cmd = ETHTOOL_SEEE;
-		if (send_ioctl(ctx, &eeecmd)) {
-			perror("Cannot set EEE settings");
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
 /* copy of net/ethtool/common.c */
 char
 tunable_strings[__ETHTOOL_TUNABLE_COUNT][ETH_GSTRING_LEN] = {
@@ -5133,232 +2583,6 @@ struct ethtool_tunable_info {
 	int seen;
 };
 
-static struct ethtool_tunable_info tunables_info[] = {
-	{ .t_id		= ETHTOOL_RX_COPYBREAK,
-	  .t_type_id	= ETHTOOL_TUNABLE_U32,
-	  .size		= sizeof(u32),
-	  .type		= CMDL_U32,
-	},
-	{ .t_id		= ETHTOOL_TX_COPYBREAK,
-	  .t_type_id	= ETHTOOL_TUNABLE_U32,
-	  .size		= sizeof(u32),
-	  .type		= CMDL_U32,
-	},
-	{ .t_id		= ETHTOOL_PFC_PREVENTION_TOUT,
-	  .t_type_id	= ETHTOOL_TUNABLE_U16,
-	  .size		= sizeof(u16),
-	  .type		= CMDL_U16,
-	},
-};
-#define TUNABLES_INFO_SIZE	ARRAY_SIZE(tunables_info)
-
-static int do_stunable(struct cmd_context *ctx)
-{
-	struct cmdline_info cmdline_tunable[TUNABLES_INFO_SIZE];
-	struct ethtool_tunable_info *tinfo = tunables_info;
-	int changed = 0;
-	unsigned int i;
-
-	for (i = 0; i < TUNABLES_INFO_SIZE; i++) {
-		cmdline_tunable[i].name = tunable_strings[tinfo[i].t_id];
-		cmdline_tunable[i].type = tinfo[i].type;
-		cmdline_tunable[i].wanted_val = &tinfo[i].wanted;
-		cmdline_tunable[i].seen_val = &tinfo[i].seen;
-	}
-
-	parse_generic_cmdline(ctx, &changed, cmdline_tunable, TUNABLES_INFO_SIZE);
-	if (!changed)
-		exit_bad_args();
-
-	for (i = 0; i < TUNABLES_INFO_SIZE; i++) {
-		struct ethtool_tunable *tuna;
-		size_t size;
-		int ret;
-
-		if (!tinfo[i].seen)
-			continue;
-
-		size = sizeof(*tuna) + tinfo[i].size;
-		tuna = calloc(1, size);
-		if (!tuna) {
-			perror(tunable_strings[tinfo[i].t_id]);
-			return 1;
-		}
-		tuna->cmd = ETHTOOL_STUNABLE;
-		tuna->id = tinfo[i].t_id;
-		tuna->type_id = tinfo[i].t_type_id;
-		tuna->len = tinfo[i].size;
-		memcpy(tuna->data, &tinfo[i].wanted, tuna->len);
-		ret = send_ioctl(ctx, tuna);
-		if (ret) {
-			perror(tunable_strings[tuna->id]);
-			return ret;
-		}
-		free(tuna);
-	}
-	return 0;
-}
-
-static void print_tunable(struct ethtool_tunable *tuna)
-{
-	char *name = tunable_strings[tuna->id];
-	union ethtool_tunable_info_val *val;
-
-	val = (union ethtool_tunable_info_val *)tuna->data;
-	switch (tuna->type_id) {
-	case ETHTOOL_TUNABLE_U8:
-		fprintf(stdout, "%s: %" PRIu8 "\n", name, val->u8);
-		break;
-	case ETHTOOL_TUNABLE_U16:
-		fprintf(stdout, "%s: %" PRIu16 "\n", name, val->u16);
-		break;
-	case ETHTOOL_TUNABLE_U32:
-		fprintf(stdout, "%s: %" PRIu32 "\n", name, val->u32);
-		break;
-	case ETHTOOL_TUNABLE_U64:
-		fprintf(stdout, "%s: %" PRIu64 "\n", name, val->u64);
-		break;
-	case ETHTOOL_TUNABLE_S8:
-		fprintf(stdout, "%s: %" PRId8 "\n", name, val->s8);
-		break;
-	case ETHTOOL_TUNABLE_S16:
-		fprintf(stdout, "%s: %" PRId16 "\n", name, val->s16);
-		break;
-	case ETHTOOL_TUNABLE_S32:
-		fprintf(stdout, "%s: %" PRId32 "\n", name, val->s32);
-		break;
-	case ETHTOOL_TUNABLE_S64:
-		fprintf(stdout, "%s: %" PRId64 "\n", name, val->s64);
-		break;
-	default:
-		fprintf(stdout, "%s: Unknown format\n", name);
-	}
-}
-
-static int do_gtunable(struct cmd_context *ctx)
-{
-	struct ethtool_tunable_info *tinfo = tunables_info;
-	char **argp = ctx->argp;
-	unsigned int argc = ctx->argc;
-	unsigned int i, j;
-
-	if (argc < 1)
-		exit_bad_args();
-
-	for (i = 0; i < argc; i++) {
-		int valid = 0;
-
-		for (j = 0; j < TUNABLES_INFO_SIZE; j++) {
-			char *ts = tunable_strings[tinfo[j].t_id];
-			struct ethtool_tunable *tuna;
-			int ret;
-
-			if (strcmp(argp[i], ts))
-				continue;
-			valid = 1;
-
-			tuna = calloc(1, sizeof(*tuna) + tinfo[j].size);
-			if (!tuna) {
-				perror(ts);
-				return 1;
-			}
-			tuna->cmd = ETHTOOL_GTUNABLE;
-			tuna->id = tinfo[j].t_id;
-			tuna->type_id = tinfo[j].t_type_id;
-			tuna->len = tinfo[j].size;
-			ret = send_ioctl(ctx, tuna);
-			if (ret) {
-				fprintf(stderr, "%s: Cannot get tunable\n", ts);
-				return ret;
-			}
-			print_tunable(tuna);
-			free(tuna);
-		}
-		if (!valid)
-			exit_bad_args();
-	}
-	return 0;
-}
-
-static int do_get_phy_tunable(struct cmd_context *ctx)
-{
-	unsigned int argc = ctx->argc;
-	char **argp = ctx->argp;
-
-	if (argc < 1)
-		exit_bad_args();
-
-	if (!strcmp(argp[0], "downshift")) {
-		struct {
-			struct ethtool_tunable ds;
-			u8 count;
-		} cont;
-
-		cont.ds.cmd = ETHTOOL_PHY_GTUNABLE;
-		cont.ds.id = ETHTOOL_PHY_DOWNSHIFT;
-		cont.ds.type_id = ETHTOOL_TUNABLE_U8;
-		cont.ds.len = 1;
-		if (send_ioctl(ctx, &cont.ds) < 0) {
-			perror("Cannot Get PHY downshift count");
-			return 87;
-		}
-		if (cont.count)
-			fprintf(stdout, "Downshift count: %d\n", cont.count);
-		else
-			fprintf(stdout, "Downshift disabled\n");
-	} else if (!strcmp(argp[0], "fast-link-down")) {
-		struct {
-			struct ethtool_tunable fld;
-			u8 msecs;
-		} cont;
-
-		cont.fld.cmd = ETHTOOL_PHY_GTUNABLE;
-		cont.fld.id = ETHTOOL_PHY_FAST_LINK_DOWN;
-		cont.fld.type_id = ETHTOOL_TUNABLE_U8;
-		cont.fld.len = 1;
-		if (send_ioctl(ctx, &cont.fld) < 0) {
-			perror("Cannot Get PHY Fast Link Down value");
-			return 87;
-		}
-
-		if (cont.msecs == ETHTOOL_PHY_FAST_LINK_DOWN_ON)
-			fprintf(stdout, "Fast Link Down enabled\n");
-		else if (cont.msecs == ETHTOOL_PHY_FAST_LINK_DOWN_OFF)
-			fprintf(stdout, "Fast Link Down disabled\n");
-		else
-			fprintf(stdout, "Fast Link Down enabled, %d msecs\n",
-				cont.msecs);
-	} else if (!strcmp(argp[0], "energy-detect-power-down")) {
-		struct {
-			struct ethtool_tunable ds;
-			u16 msecs;
-		} cont;
-
-		cont.ds.cmd = ETHTOOL_PHY_GTUNABLE;
-		cont.ds.id = ETHTOOL_PHY_EDPD;
-		cont.ds.type_id = ETHTOOL_TUNABLE_U16;
-		cont.ds.len = 2;
-		if (send_ioctl(ctx, &cont.ds) < 0) {
-			perror("Cannot Get PHY Energy Detect Power Down value");
-			return 87;
-		}
-
-		if (cont.msecs == ETHTOOL_PHY_EDPD_DISABLE)
-			fprintf(stdout, "Energy Detect Power Down: disabled\n");
-		else if (cont.msecs == ETHTOOL_PHY_EDPD_NO_TX)
-			fprintf(stdout,
-				"Energy Detect Power Down: enabled, TX disabled\n");
-		else
-			fprintf(stdout,
-				"Energy Detect Power Down: enabled, TX %u msecs\n",
-				cont.msecs);
-	} else {
-		exit_bad_args();
-	}
-
-	return 0;
-}
-
 static __u32 parse_reset(char *val, __u32 bitset, char *arg, __u32 *data)
 {
 	__u32 bitval = 0;
@@ -5450,266 +2674,6 @@ static int do_reset(struct cmd_context *
 	return 0;
 }
 
-static int parse_named_bool(struct cmd_context *ctx, const char *name, u8 *on)
-{
-	if (ctx->argc < 2)
-		return 0;
-
-	if (strcmp(*ctx->argp, name))
-		return 0;
-
-	if (!strcmp(*(ctx->argp + 1), "on")) {
-		*on = 1;
-	} else if (!strcmp(*(ctx->argp + 1), "off")) {
-		*on = 0;
-	} else {
-		fprintf(stderr, "Invalid boolean\n");
-		exit_bad_args();
-	}
-
-	ctx->argc -= 2;
-	ctx->argp += 2;
-
-	return 1;
-}
-
-static int parse_named_uint(struct cmd_context *ctx,
-			    const char *name,
-			    unsigned long long *val,
-			    unsigned long long max)
-{
-	if (ctx->argc < 2)
-		return 0;
-
-	if (strcmp(*ctx->argp, name))
-		return 0;
-
-	*val = get_uint_range(*(ctx->argp + 1), 0, max);
-
-	ctx->argc -= 2;
-	ctx->argp += 2;
-
-	return 1;
-}
-
-static int parse_named_u8(struct cmd_context *ctx, const char *name, u8 *val)
-{
-	unsigned long long val1;
-	int ret;
-
-	ret = parse_named_uint(ctx, name, &val1, 0xff);
-	if (ret)
-		*val = val1;
-
-	return ret;
-}
-
-static int parse_named_u16(struct cmd_context *ctx, const char *name, u16 *val)
-{
-	unsigned long long val1;
-	int ret;
-
-	ret = parse_named_uint(ctx, name, &val1, 0xffff);
-	if (ret)
-		*val = val1;
-
-	return ret;
-}
-
-static int do_set_phy_tunable(struct cmd_context *ctx)
-{
-	int err = 0;
-	u8 ds_cnt = DOWNSHIFT_DEV_DEFAULT_COUNT;
-	u8 ds_changed = 0, ds_has_cnt = 0, ds_enable = 0;
-	u8 fld_changed = 0, fld_enable = 0;
-	u8 fld_msecs = ETHTOOL_PHY_FAST_LINK_DOWN_ON;
-	u8 edpd_changed = 0, edpd_enable = 0;
-	u16 edpd_tx_interval = ETHTOOL_PHY_EDPD_DFLT_TX_MSECS;
-
-	/* Parse arguments */
-	if (parse_named_bool(ctx, "downshift", &ds_enable)) {
-		ds_changed = 1;
-		ds_has_cnt = parse_named_u8(ctx, "count", &ds_cnt);
-	} else if (parse_named_bool(ctx, "fast-link-down", &fld_enable)) {
-		fld_changed = 1;
-		if (fld_enable)
-			parse_named_u8(ctx, "msecs", &fld_msecs);
-	} else if (parse_named_bool(ctx, "energy-detect-power-down",
-				    &edpd_enable)) {
-		edpd_changed = 1;
-		if (edpd_enable)
-			parse_named_u16(ctx, "msecs", &edpd_tx_interval);
-	} else {
-		exit_bad_args();
-	}
-
-	/* Validate parameters */
-	if (ds_changed) {
-		if (!ds_enable && ds_has_cnt) {
-			fprintf(stderr, "'count' may not be set when downshift "
-				        "is off.\n");
-			exit_bad_args();
-		}
-
-		if (ds_enable && ds_has_cnt && ds_cnt == 0) {
-			fprintf(stderr, "'count' may not be zero.\n");
-			exit_bad_args();
-		}
-
-		if (!ds_enable)
-			ds_cnt = DOWNSHIFT_DEV_DISABLE;
-	} else if (fld_changed) {
-		if (!fld_enable)
-			fld_msecs = ETHTOOL_PHY_FAST_LINK_DOWN_OFF;
-		else if (fld_msecs == ETHTOOL_PHY_FAST_LINK_DOWN_OFF)
-			exit_bad_args();
-	} else if (edpd_changed) {
-		if (!edpd_enable)
-			edpd_tx_interval = ETHTOOL_PHY_EDPD_DISABLE;
-		else if (edpd_tx_interval == 0)
-			edpd_tx_interval = ETHTOOL_PHY_EDPD_NO_TX;
-		else if (edpd_tx_interval > ETHTOOL_PHY_EDPD_NO_TX) {
-			fprintf(stderr, "'msecs' max value is %d.\n",
-				(ETHTOOL_PHY_EDPD_NO_TX - 1));
-			exit_bad_args();
-		}
-	}
-
-	/* Do it */
-	if (ds_changed) {
-		struct {
-			struct ethtool_tunable ds;
-			u8 count;
-		} cont;
-
-		cont.ds.cmd = ETHTOOL_PHY_STUNABLE;
-		cont.ds.id = ETHTOOL_PHY_DOWNSHIFT;
-		cont.ds.type_id = ETHTOOL_TUNABLE_U8;
-		cont.ds.len = 1;
-		cont.count = ds_cnt;
-		err = send_ioctl(ctx, &cont.ds);
-		if (err < 0) {
-			perror("Cannot Set PHY downshift count");
-			err = 87;
-		}
-	} else if (fld_changed) {
-		struct {
-			struct ethtool_tunable fld;
-			u8 msecs;
-		} cont;
-
-		cont.fld.cmd = ETHTOOL_PHY_STUNABLE;
-		cont.fld.id = ETHTOOL_PHY_FAST_LINK_DOWN;
-		cont.fld.type_id = ETHTOOL_TUNABLE_U8;
-		cont.fld.len = 1;
-		cont.msecs = fld_msecs;
-		err = send_ioctl(ctx, &cont.fld);
-		if (err < 0) {
-			perror("Cannot Set PHY Fast Link Down value");
-			err = 87;
-		}
-	} else if (edpd_changed) {
-		struct {
-			struct ethtool_tunable fld;
-			u16 msecs;
-		} cont;
-
-		cont.fld.cmd = ETHTOOL_PHY_STUNABLE;
-		cont.fld.id = ETHTOOL_PHY_EDPD;
-		cont.fld.type_id = ETHTOOL_TUNABLE_U16;
-		cont.fld.len = 2;
-		cont.msecs = edpd_tx_interval;
-		err = send_ioctl(ctx, &cont.fld);
-		if (err < 0) {
-			perror("Cannot Set PHY Energy Detect Power Down");
-			err = 87;
-		}
-	}
-
-	return err;
-}
-
-static int fecmode_str_to_type(const char *str)
-{
-	if (!strcasecmp(str, "auto"))
-		return ETHTOOL_FEC_AUTO;
-	if (!strcasecmp(str, "off"))
-		return ETHTOOL_FEC_OFF;
-	if (!strcasecmp(str, "rs"))
-		return ETHTOOL_FEC_RS;
-	if (!strcasecmp(str, "baser"))
-		return ETHTOOL_FEC_BASER;
-	if (!strcasecmp(str, "llrs"))
-		return ETHTOOL_FEC_LLRS;
-	return 0;
-}
-
-static int do_gfec(struct cmd_context *ctx)
-{
-	struct ethtool_fecparam feccmd = { 0 };
-	int rv;
-
-	if (ctx->argc != 0)
-		exit_bad_args();
-
-	feccmd.cmd = ETHTOOL_GFECPARAM;
-	rv = send_ioctl(ctx, &feccmd);
-	if (rv != 0) {
-		perror("Cannot get FEC settings");
-		return rv;
-	}
-
-	fprintf(stdout, "FEC parameters for %s:\n", ctx->devname);
-	fprintf(stdout, "Configured FEC encodings:");
-	dump_fec(feccmd.fec);
-	fprintf(stdout, "\n");
-
-	fprintf(stdout, "Active FEC encoding:");
-	dump_fec(feccmd.active_fec);
-	fprintf(stdout, "\n");
-
-	return 0;
-}
-
-static int do_sfec(struct cmd_context *ctx)
-{
-	enum { ARG_NONE, ARG_ENCODING } state = ARG_NONE;
-	struct ethtool_fecparam feccmd;
-	int fecmode = 0, newmode;
-	unsigned int i;
-	int rv;
-
-	for (i = 0; i < ctx->argc; i++) {
-		if (!strcmp(ctx->argp[i], "encoding")) {
-			state = ARG_ENCODING;
-			continue;
-		}
-		if (state == ARG_ENCODING) {
-			newmode = fecmode_str_to_type(ctx->argp[i]);
-			if (!newmode)
-				exit_bad_args();
-			fecmode |= newmode;
-			continue;
-		}
-		exit_bad_args();
-	}
-
-	if (!fecmode)
-		exit_bad_args();
-
-	feccmd.cmd = ETHTOOL_SFECPARAM;
-	feccmd.fec = fecmode;
-	rv = send_ioctl(ctx, &feccmd);
-	if (rv != 0) {
-		perror("Cannot set FEC settings");
-		return rv;
-	}
-
-	return 0;
-}
-
-static int do_perqueue(struct cmd_context *ctx);
-
 #ifndef TEST_ETHTOOL
 int send_ioctl(struct cmd_context *ctx, void *cmd)
 {
@@ -5749,55 +2713,6 @@ static const struct option args[] = {
 			  "		[ master-slave master-preferred|slave-preferred|master-force|slave-force ]\n"
 	},
 	{
-		.opts	= "-a|--show-pause",
-		.func	= do_gpause,
-		.nlfunc	= nl_gpause,
-		.help	= "Show pause options"
-	},
-	{
-		.opts	= "-A|--pause",
-		.func	= do_spause,
-		.nlfunc	= nl_spause,
-		.help	= "Set pause options",
-		.xhelp	= "		[ autoneg on|off ]\n"
-			  "		[ rx on|off ]\n"
-			  "		[ tx on|off ]\n"
-	},
-	{
-		.opts	= "-c|--show-coalesce",
-		.func	= do_gcoalesce,
-		.nlfunc	= nl_gcoalesce,
-		.help	= "Show coalesce options"
-	},
-	{
-		.opts	= "-C|--coalesce",
-		.func	= do_scoalesce,
-		.nlfunc	= nl_scoalesce,
-		.help	= "Set coalesce options",
-		.xhelp	= "		[adaptive-rx on|off]\n"
-			  "		[adaptive-tx on|off]\n"
-			  "		[rx-usecs N]\n"
-			  "		[rx-frames N]\n"
-			  "		[rx-usecs-irq N]\n"
-			  "		[rx-frames-irq N]\n"
-			  "		[tx-usecs N]\n"
-			  "		[tx-frames N]\n"
-			  "		[tx-usecs-irq N]\n"
-			  "		[tx-frames-irq N]\n"
-			  "		[stats-block-usecs N]\n"
-			  "		[pkt-rate-low N]\n"
-			  "		[rx-usecs-low N]\n"
-			  "		[rx-frames-low N]\n"
-			  "		[tx-usecs-low N]\n"
-			  "		[tx-frames-low N]\n"
-			  "		[pkt-rate-high N]\n"
-			  "		[rx-usecs-high N]\n"
-			  "		[rx-frames-high N]\n"
-			  "		[tx-usecs-high N]\n"
-			  "		[tx-frames-high N]\n"
-			  "		[sample-interval N]\n"
-	},
-	{
 		.opts	= "-g|--show-ring",
 		.func	= do_gring,
 		.nlfunc	= nl_gring,
@@ -5827,52 +2742,11 @@ static const struct option args[] = {
 		.xhelp	= "		FEATURE on|off ...\n"
 	},
 	{
-		.opts	= "-i|--driver",
-		.func	= do_gdrv,
-		.help	= "Show driver information"
-	},
-	{
-		.opts	= "-d|--register-dump",
-		.func	= do_gregs,
-		.help	= "Do a register dump",
-		.xhelp	= "		[ raw on|off ]\n"
-			  "		[ file FILENAME ]\n"
-	},
-	{
-		.opts	= "-e|--eeprom-dump",
-		.func	= do_geeprom,
-		.help	= "Do a EEPROM dump",
-		.xhelp	= "		[ raw on|off ]\n"
-			  "		[ offset N ]\n"
-			  "		[ length N ]\n"
-	},
-	{
-		.opts	= "-E|--change-eeprom",
-		.func	= do_seeprom,
-		.help	= "Change bytes in device EEPROM",
-		.xhelp	= "		[ magic N ]\n"
-			  "		[ offset N ]\n"
-			  "		[ length N ]\n"
-			  "		[ value N ]\n"
-	},
-	{
 		.opts	= "-r|--negotiate",
 		.func	= do_nway_rst,
 		.help	= "Restart N-WAY negotiation"
 	},
 	{
-		.opts	= "-p|--identify",
-		.func	= do_phys_id,
-		.help	= "Show visible port identification (e.g. blinking)",
-		.xhelp	= "               [ TIME-IN-SECONDS ]\n"
-	},
-	{
-		.opts	= "-t|--test",
-		.func	= do_test,
-		.help	= "Execute adapter self test",
-		.xhelp	= "               [ online | offline | external_lb ]\n"
-	},
-	{
 		.opts	= "-S|--statistics",
 		.func	= do_gnicstats,
 		.help	= "Show adapter statistics"
@@ -5892,174 +2766,18 @@ static const struct option args[] = {
 		.help	= "Show phy statistics"
 	},
 	{
-		.opts	= "-n|-u|--show-nfc|--show-ntuple",
-		.func	= do_grxclass,
-		.help	= "Show Rx network flow classification options or rules",
-		.xhelp	= "		[ rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|"
-			  "tcp6|udp6|ah6|esp6|sctp6 [context %d] |\n"
-			  "		  rule %d ]\n"
-	},
-	{
-		.opts	= "-N|-U|--config-nfc|--config-ntuple",
-		.func	= do_srxclass,
-		.help	= "Configure Rx network flow classification options or rules",
-		.xhelp	= "		rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|"
-			  "tcp6|udp6|ah6|esp6|sctp6 m|v|t|s|d|f|n|r... [context %d] |\n"
-			  "		flow-type ether|ip4|tcp4|udp4|sctp4|ah4|esp4|"
-			  "ip6|tcp6|udp6|ah6|esp6|sctp6\n"
-			  "			[ src %x:%x:%x:%x:%x:%x [m %x:%x:%x:%x:%x:%x] ]\n"
-			  "			[ dst %x:%x:%x:%x:%x:%x [m %x:%x:%x:%x:%x:%x] ]\n"
-			  "			[ proto %d [m %x] ]\n"
-			  "			[ src-ip IP-ADDRESS [m IP-ADDRESS] ]\n"
-			  "			[ dst-ip IP-ADDRESS [m IP-ADDRESS] ]\n"
-			  "			[ tos %d [m %x] ]\n"
-			  "			[ tclass %d [m %x] ]\n"
-			  "			[ l4proto %d [m %x] ]\n"
-			  "			[ src-port %d [m %x] ]\n"
-			  "			[ dst-port %d [m %x] ]\n"
-			  "			[ spi %d [m %x] ]\n"
-			  "			[ vlan-etype %x [m %x] ]\n"
-			  "			[ vlan %x [m %x] ]\n"
-			  "			[ user-def %x [m %x] ]\n"
-			  "			[ dst-mac %x:%x:%x:%x:%x:%x [m %x:%x:%x:%x:%x:%x] ]\n"
-			  "			[ action %d ] | [ vf %d queue %d ]\n"
-			  "			[ context %d ]\n"
-			  "			[ loc %d]] |\n"
-			  "		delete %d\n"
-	},
-	{
 		.opts	= "-T|--show-time-stamping",
 		.func	= do_tsinfo,
 		.nlfunc	= nl_tsinfo,
 		.help	= "Show time stamping capabilities"
 	},
 	{
-		.opts	= "-x|--show-rxfh-indir|--show-rxfh",
-		.func	= do_grxfh,
-		.help	= "Show Rx flow hash indirection table and/or RSS hash key",
-		.xhelp	= "		[ context %d ]\n"
-	},
-	{
-		.opts	= "-X|--set-rxfh-indir|--rxfh",
-		.func	= do_srxfh,
-		.help	= "Set Rx flow hash indirection table and/or RSS hash key",
-		.xhelp	= "		[ context %d|new ]\n"
-			  "		[ equal N | weight W0 W1 ... | default ]\n"
-			  "		[ hkey %x:%x:%x:%x:%x:.... ]\n"
-			  "		[ hfunc FUNC ]\n"
-			  "		[ delete ]\n"
-	},
-	{
-		.opts	= "-f|--flash",
-		.func	= do_flash,
-		.help	= "Flash firmware image from the specified file to a region on the device",
-		.xhelp	= "               FILENAME [ REGION-NUMBER-TO-FLASH ]\n"
-	},
-	{
 		.opts	= "-P|--show-permaddr",
 		.func	= do_permaddr,
 		.nlfunc	= nl_permaddr,
 		.help	= "Show permanent hardware address"
 	},
 	{
-		.opts	= "-w|--get-dump",
-		.func	= do_getfwdump,
-		.help	= "Get dump flag, data",
-		.xhelp	= "		[ data FILENAME ]\n"
-	},
-	{
-		.opts	= "-W|--set-dump",
-		.func	= do_setfwdump,
-		.help	= "Set dump flag of the device",
-		.xhelp	= "		N\n"
-	},
-	{
-		.opts	= "-l|--show-channels",
-		.func	= do_gchannels,
-		.nlfunc	= nl_gchannels,
-		.help	= "Query Channels"
-	},
-	{
-		.opts	= "-L|--set-channels",
-		.func	= do_schannels,
-		.nlfunc	= nl_schannels,
-		.help	= "Set Channels",
-		.xhelp	= "               [ rx N ]\n"
-			  "               [ tx N ]\n"
-			  "               [ other N ]\n"
-			  "               [ combined N ]\n"
-	},
-	{
-		.opts	= "--show-priv-flags",
-		.func	= do_gprivflags,
-		.nlfunc	= nl_gprivflags,
-		.help	= "Query private flags"
-	},
-	{
-		.opts	= "--set-priv-flags",
-		.func	= do_sprivflags,
-		.nlfunc	= nl_sprivflags,
-		.help	= "Set private flags",
-		.xhelp	= "		FLAG on|off ...\n"
-	},
-	{
-		.opts	= "-m|--dump-module-eeprom|--module-info",
-		.func	= do_getmodule,
-		.help	= "Query/Decode Module EEPROM information and optical diagnostics if available",
-		.xhelp	= "		[ raw on|off ]\n"
-			  "		[ hex on|off ]\n"
-			  "		[ offset N ]\n"
-			  "		[ length N ]\n"
-	},
-	{
-		.opts	= "--show-eee",
-		.func	= do_geee,
-		.nlfunc	= nl_geee,
-		.help	= "Show EEE settings",
-	},
-	{
-		.opts	= "--set-eee",
-		.func	= do_seee,
-		.nlfunc	= nl_seee,
-		.help	= "Set EEE settings",
-		.xhelp	= "		[ eee on|off ]\n"
-			  "		[ advertise %x ]\n"
-			  "		[ tx-lpi on|off ]\n"
-			  "		[ tx-timer %d ]\n"
-	},
-	{
-		.opts	= "--set-phy-tunable",
-		.func	= do_set_phy_tunable,
-		.help	= "Set PHY tunable",
-		.xhelp	= "		[ downshift on|off [count N] ]\n"
-			  "		[ fast-link-down on|off [msecs N] ]\n"
-			  "		[ energy-detect-power-down on|off [msecs N] ]\n"
-	},
-	{
-		.opts	= "--get-phy-tunable",
-		.func	= do_get_phy_tunable,
-		.help	= "Get PHY tunable",
-		.xhelp	= "		[ downshift ]\n"
-			  "		[ fast-link-down ]\n"
-			  "		[ energy-detect-power-down ]\n"
-	},
-	{
-		.opts	= "--get-tunable",
-		.func	= do_gtunable,
-		.help	= "Get tunable",
-		.xhelp	= "		[ rx-copybreak ]\n"
-			  "		[ tx-copybreak ]\n"
-			  "		[ pfc-precention-tout ]\n"
-	},
-	{
-		.opts	= "--set-tunable",
-		.func	= do_stunable,
-		.help	= "Set tunable",
-		.xhelp	= "		[ rx-copybreak N]\n"
-			  "		[ tx-copybreak N]\n"
-			  "		[ pfc-precention-tout N]\n"
-	},
-	{
 		.opts	= "--reset",
 		.func	= do_reset,
 		.help	= "Reset components",
@@ -6086,43 +2804,6 @@ static const struct option args[] = {
 			  "		[ all ]\n"
 	},
 	{
-		.opts	= "--show-fec",
-		.func	= do_gfec,
-		.help	= "Show FEC settings",
-	},
-	{
-		.opts	= "--set-fec",
-		.func	= do_sfec,
-		.help	= "Set FEC settings",
-		.xhelp	= "		[ encoding auto|off|rs|baser|llrs [...]]\n"
-	},
-	{
-		.opts	= "-Q|--per-queue",
-		.func	= do_perqueue,
-		.help	= "Apply per-queue command. ",
-		.xhelp	= "The supported sub commands include --show-coalesce, --coalesce"
-			  "             [queue_mask %x] SUB_COMMAND\n",
-	},
-	{
-		.opts	= "--cable-test",
-		.nlfunc	= nl_cable_test,
-		.help	= "Perform a cable test",
-	},
-	{
-		.opts	= "--cable-test-tdr",
-		.nlfunc	= nl_cable_test_tdr,
-		.help	= "Print cable test time domain reflectrometery data",
-		.xhelp	= "		[ first N ]\n"
-			  "		[ last N ]\n"
-			  "		[ step N ]\n"
-			  "		[ pair N ]\n"
-	},
-	{
-		.opts	= "--show-tunnels",
-		.nlfunc	= nl_gtunnels,
-		.help	= "Show NIC tunnel offload information",
-	},
-	{
 		.opts	= "-h|--help",
 		.no_dev	= true,
 		.func	= show_usage,
@@ -6190,175 +2871,6 @@ static int find_option(char *arg)
 
 #define MAX(x, y) (x > y ? x : y)
 
-static int find_max_num_queues(struct cmd_context *ctx)
-{
-	struct ethtool_channels echannels;
-
-	echannels.cmd = ETHTOOL_GCHANNELS;
-	if (send_ioctl(ctx, &echannels))
-		return -1;
-
-	return MAX(echannels.rx_count, echannels.tx_count) +
-		echannels.combined_count;
-}
-
-static struct ethtool_per_queue_op *
-get_per_queue_coalesce(struct cmd_context *ctx, __u32 *queue_mask, int n_queues)
-{
-	struct ethtool_per_queue_op *per_queue_opt;
-
-	per_queue_opt = malloc(sizeof(*per_queue_opt) + n_queues *
-			sizeof(struct ethtool_coalesce));
-	if (!per_queue_opt)
-		return NULL;
-
-	memcpy(per_queue_opt->queue_mask, queue_mask,
-	       __KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32) * sizeof(__u32));
-	per_queue_opt->cmd = ETHTOOL_PERQUEUE;
-	per_queue_opt->sub_command = ETHTOOL_GCOALESCE;
-	if (send_ioctl(ctx, per_queue_opt)) {
-		free(per_queue_opt);
-		perror("Cannot get device per queue parameters");
-		return NULL;
-	}
-
-	return per_queue_opt;
-}
-
-static void set_per_queue_coalesce(struct cmd_context *ctx,
-				   struct ethtool_per_queue_op *per_queue_opt,
-				   int n_queues)
-{
-	struct ethtool_coalesce ecoal;
-	DECLARE_COALESCE_OPTION_VARS();
-	struct cmdline_info cmdline_coalesce[] = COALESCE_CMDLINE_INFO(ecoal);
-	__u32 *queue_mask = per_queue_opt->queue_mask;
-	struct ethtool_coalesce *ecoal_q;
-	int gcoalesce_changed = 0;
-	int i, idx = 0;
-
-	parse_generic_cmdline(ctx, &gcoalesce_changed,
-			      cmdline_coalesce, ARRAY_SIZE(cmdline_coalesce));
-
-	ecoal_q = (struct ethtool_coalesce *)(per_queue_opt + 1);
-	for (i = 0; i < __KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32); i++) {
-		int queue = i * 32;
-		__u32 mask = queue_mask[i];
-
-		while (mask > 0) {
-			if (mask & 0x1) {
-				int changed = 0;
-
-				memcpy(&ecoal, ecoal_q + idx,
-				       sizeof(struct ethtool_coalesce));
-				do_generic_set(cmdline_coalesce,
-					       ARRAY_SIZE(cmdline_coalesce),
-					       &changed);
-				if (!changed)
-					fprintf(stderr,
-						"Queue %d, no coalesce parameters changed\n",
-						queue);
-				memcpy(ecoal_q + idx, &ecoal,
-				       sizeof(struct ethtool_coalesce));
-				idx++;
-			}
-			mask = mask >> 1;
-			queue++;
-		}
-		if (idx == n_queues)
-			break;
-	}
-
-	per_queue_opt->cmd = ETHTOOL_PERQUEUE;
-	per_queue_opt->sub_command = ETHTOOL_SCOALESCE;
-
-	if (send_ioctl(ctx, per_queue_opt))
-		perror("Cannot set device per queue parameters");
-}
-
-static int do_perqueue(struct cmd_context *ctx)
-{
-	struct ethtool_per_queue_op *per_queue_opt;
-	__u32 queue_mask[__KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32)] = {0};
-	int i, n_queues = 0;
-
-	if (ctx->argc == 0)
-		exit_bad_args();
-
-	/*
-	 * The sub commands will be applied to
-	 * all queues if no queue_mask set
-	 */
-	if (strncmp(*ctx->argp, "queue_mask", 11)) {
-		n_queues = find_max_num_queues(ctx);
-		if (n_queues < 0) {
-			perror("Cannot get number of queues");
-			return -EFAULT;
-		} else if (n_queues > MAX_NUM_QUEUE) {
-			n_queues = MAX_NUM_QUEUE;
-		}
-		for (i = 0; i < n_queues / 32; i++)
-			queue_mask[i] = ~0;
-		if (n_queues % 32)
-			queue_mask[i] = (1 << (n_queues - i * 32)) - 1;
-		fprintf(stdout,
-			"The sub commands will be applied to all %d queues\n",
-			n_queues);
-	} else {
-		if (ctx->argc <= 2)
-			exit_bad_args();
-		ctx->argc--;
-		ctx->argp++;
-		if (parse_hex_u32_bitmap(*ctx->argp, MAX_NUM_QUEUE,
-		    queue_mask)) {
-			fprintf(stdout, "Invalid queue mask\n");
-			return -1;
-		}
-		for (i = 0; i < __KERNEL_DIV_ROUND_UP(MAX_NUM_QUEUE, 32); i++) {
-			__u32 mask = queue_mask[i];
-
-			while (mask > 0) {
-				if (mask & 0x1)
-					n_queues++;
-				mask = mask >> 1;
-			}
-		}
-		ctx->argc--;
-		ctx->argp++;
-	}
-
-	i = find_option(ctx->argp[0]);
-	if (i < 0)
-		exit_bad_args();
-
-	if (strstr(args[i].opts, "--show-coalesce") != NULL) {
-		per_queue_opt = get_per_queue_coalesce(ctx, queue_mask,
-						       n_queues);
-		if (per_queue_opt == NULL) {
-			perror("Cannot get device per queue parameters");
-			return -EFAULT;
-		}
-		dump_per_queue_coalesce(per_queue_opt, queue_mask, n_queues);
-		free(per_queue_opt);
-	} else if (strstr(args[i].opts, "--coalesce") != NULL) {
-		ctx->argc--;
-		ctx->argp++;
-		per_queue_opt = get_per_queue_coalesce(ctx, queue_mask,
-						       n_queues);
-		if (per_queue_opt == NULL) {
-			perror("Cannot get device per queue parameters");
-			return -EFAULT;
-		}
-		set_per_queue_coalesce(ctx, per_queue_opt, n_queues);
-		free(per_queue_opt);
-	} else {
-		perror("The subcommand is not supported yet");
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
 static int ioctl_init(struct cmd_context *ctx, bool no_dev)
 {
 	if (no_dev) {
--- a/Makefile.am
+++ b/Makefile.am
@@ -7,7 +7,7 @@ EXTRA_DIST = LICENSE ethtool.8 ethtool.s
 
 sbin_PROGRAMS = ethtool
 ethtool_SOURCES = ethtool.c uapi/linux/ethtool.h internal.h \
-		  uapi/linux/net_tstamp.h rxclass.c common.c common.h \
+		  uapi/linux/net_tstamp.h common.c common.h \
 		  json_writer.c json_writer.h json_print.c json_print.h
 if ETHTOOL_ENABLE_PRETTY_DUMP
 ethtool_SOURCES += \
