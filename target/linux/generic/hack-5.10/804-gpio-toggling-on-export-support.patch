--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@ -21,6 +21,7 @@
 #include <linux/gpio/machine.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/delay.h>
 
 #include "gpiolib.h"
 #include "gpiolib-of.h"
@@ -1078,6 +1079,7 @@ static int of_gpio_export_probe(struct p
 		for (i = 0; i < max_gpio; i++) {
 			unsigned flags = 0;
 			enum of_gpio_flags of_flags;
+			int def_out_val = -1;
 
 			gpio = of_get_gpio_flags(cnp, i, &of_flags);
 			if (!gpio_is_valid(gpio))
@@ -1086,10 +1088,12 @@ static int of_gpio_export_probe(struct p
 			if (of_flags == OF_GPIO_ACTIVE_LOW)
 				flags |= GPIOF_ACTIVE_LOW;
 
-			if (!of_property_read_u32(cnp, "gpio-export,output", &val))
+			if (!of_property_read_u32(cnp, "gpio-export,output", &val)) {
 				flags |= val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
-			else
+				def_out_val = !!val;
+			} else {
 				flags |= GPIOF_IN;
+			}
 
 			if (devm_gpio_request_one(&pdev->dev, gpio, flags, name ? name : of_node_full_name(np)))
 				continue;
@@ -1101,6 +1105,14 @@ static int of_gpio_export_probe(struct p
 				dev_err(&pdev->dev, "Failed to export gpio with name %s, retrying\n", name);
 				return -EPROBE_DEFER;
 			}
+
+			if (def_out_val >= 0 && !of_property_read_u32(cnp, "gpio-export,toggle", &val)) {
+				dev_dbg(&pdev->dev, "Toggling gpio(%d) %s, with %d us waiting time\n", gpio, name, val);
+				gpiod_set_value_cansleep(gpio_to_desc(gpio), !def_out_val);
+				msleep(val);
+				gpiod_set_value_cansleep(gpio_to_desc(gpio), def_out_val);
+			}
+
 			nb++;
 		}
 	}
