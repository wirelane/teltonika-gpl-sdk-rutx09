net: netfilter: flowtables: add _net field for 'flow_offload' struct

With XFRM flow type, 'ct' field is no longer guaranteed to be non-null.
Since 'ct' was often used to get net namespace associated with the flow,
add '_net' field and helper functions to replace this use.

Also removes 'net' field from 'nf_flowtable' struct, as its use was
unclear, at least with xtables FLOWOFFLOAD.

--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -78,7 +78,6 @@ struct nf_flowtable {
 	unsigned int			flags;
 	struct flow_block		flow_block;
 	struct rw_semaphore		flow_block_lock; /* Guards flow_block */
-	possible_net_t			net;
 };
 
 static inline bool nf_flowtable_hw_offload(struct nf_flowtable *flowtable)
@@ -209,6 +208,7 @@ enum flow_offload_type {
 struct flow_offload {
 	struct flow_offload_tuple_rhash		tuplehash[FLOW_OFFLOAD_DIR_MAX];
 	struct hlist_node			list;
+	possible_net_t				_net;
 	struct nf_conn				*ct;
 	unsigned long				flags;
 	u16					type;
@@ -223,6 +223,11 @@ struct flow_offload {
 
 unsigned long flow_offload_get_timeout(struct flow_offload *flow);
 
+static inline struct net *flow_offload_net(struct flow_offload *flow)
+{
+	return read_pnet(&flow->_net);
+}
+
 static inline __s32 nf_flow_timeout_delta(unsigned int timeout)
 {
 	return (__s32)(timeout - nf_flowtable_time_stamp);
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@ -69,6 +69,7 @@ struct flow_offload *flow_offload_alloc(
 		goto err_ct_refcnt;
 
 	flow->ct = ct;
+	write_pnet(&flow->_net, nf_ct_net(ct));
 
 	flow_offload_fill_dir(flow, FLOW_OFFLOAD_DIR_ORIGINAL);
 	flow_offload_fill_dir(flow, FLOW_OFFLOAD_DIR_REPLY);
@@ -283,7 +284,7 @@ static const struct rhashtable_params nf
 unsigned long flow_offload_get_timeout(struct flow_offload *flow)
 {
 	unsigned long timeout = NF_FLOW_TIMEOUT;
-	struct net *net = nf_ct_net(flow->ct);
+	struct net *net = flow_offload_net(flow);
 	int l4num = nf_ct_protonum(flow->ct);
 
 	if (l4num == IPPROTO_TCP) {
@@ -673,7 +674,7 @@ static void nf_flow_table_do_cleanup(str
 		return;
 	}
 
-	if (net_eq(nf_ct_net(flow->ct), dev_net(dev)) &&
+	if (net_eq(flow_offload_net(flow), dev_net(dev)) &&
 	    (flow->tuplehash[0].tuple.iifidx == dev->ifindex ||
 	     flow->tuplehash[1].tuple.iifidx == dev->ifindex))
 		flow_offload_teardown(flow);
--- a/net/netfilter/nf_flow_table_ip.c
+++ b/net/netfilter/nf_flow_table_ip.c
@@ -342,7 +342,7 @@ unsigned int nf_flow_offload_ip_hook_tai
 {
 	struct net_device *outdev;
 	struct rtable *rt;
-	struct net *net = nf_ct_net(flow->ct);
+	struct net *net = flow_offload_net(flow);
 	__be32 nexthop;
 	int ret;
 
@@ -602,7 +602,7 @@ unsigned int nf_flow_offload_ipv6_hook_t
 {
 	struct net_device *outdev;
 	struct rt6_info *rt;
-	struct net *net = nf_ct_net(flow->ct);
+	struct net *net = flow_offload_net(flow);
 	const struct in6_addr *nexthop;
 	int ret;
 
--- a/net/netfilter/nf_flow_table_offload.c
+++ b/net/netfilter/nf_flow_table_offload.c
@@ -739,7 +739,7 @@ static void nf_flow_offload_destroy(stru
 static int nf_flow_offload_alloc(const struct flow_offload_work *offload,
 				 struct nf_flow_rule *flow_rule[])
 {
-	struct net *net = read_pnet(&offload->flowtable->net);
+	struct net *net = flow_offload_net(offload->flow);
 	struct flow_offload *flow = offload->flow;
 
 	if (flow_offload_has_orig(flow)) {
--- a/net/netfilter/xt_FLOWOFFLOAD.c
+++ b/net/netfilter/xt_FLOWOFFLOAD.c
@@ -630,7 +630,6 @@ flowoffload_tg(struct sk_buff *skb, cons
 	struct nf_flow_route route = {};
 	struct net_device *indev;
 	struct nf_conn *ct;
-	struct net *net;
 
 	if (xt_flowoffload_skip(skb, par))
 		return XT_CONTINUE;
@@ -680,10 +679,6 @@ flowoffload_tg(struct sk_buff *skb, cons
 
 	table = &flowtable[!!(info->flags & XT_FLOWOFFLOAD_HW)];
 
-	net = read_pnet(&table->ft.net);
-	if (!net)
-		write_pnet(&table->ft.net, xt_net(par));
-
 	if (flow_offload_add(&table->ft, ct, &route,
 			     (enum flow_offload_tuple_dir)dir))
 		goto err_route_free;
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -7252,7 +7252,6 @@ static int nf_tables_newflowtable(struct
 		}
 	}
 
-	write_pnet(&flowtable->data.net, net);
 	flowtable->data.type = type;
 	err = type->init(&flowtable->data);
 	if (err < 0)
