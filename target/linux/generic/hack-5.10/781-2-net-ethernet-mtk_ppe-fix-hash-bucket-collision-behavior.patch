This is based on a conjecture that the FOE table seems to be two-way or four-way set associative
to the flow hash, with 'hash_offset' in the current upstream mtk_ppe version specifying
the level of associativity.

mtk_ppe driver seems to have been incorrectly handling the case of a hash collision,
evicting all FOE entries with the same hash (as calculated by `mtk_ppe_hash_entry`),
even though some of these entries were taking up a different FOE table index
(confusingly also named `mtk_flow_entry->hash`).

--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -617,6 +617,9 @@ void __mtk_ppe_check_skb(struct mtk_ppe
 		goto out;
 
 	hlist_for_each_entry(entry, head, list) {
+		if (entry->hash != 0xffff && entry->hash != hash)
+			continue;
+
 		if (entry->type == MTK_FLOW_TYPE_L2_SUBFLOW) {
 			if (unlikely(FIELD_GET(MTK_FOE_IB1_STATE, hwe->ib1) ==
 				     MTK_FOE_STATE_BIND))
