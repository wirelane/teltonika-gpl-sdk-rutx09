
From e2d41a795acd54f38449b8b70ef0206947defd1f Mon Sep 17 00:00:00 2001
From: Joris Vaisvila <joris.vaisvila@teltonika.lt>
Date: Tue, 17 Sep 2024 12:51:19 +0300
Subject: [PATCH 1/1] dsa isolation for mt7530 support

---
 drivers/net/dsa/mt7530.c |  4 +--
 include/net/dsa.h        |  1 +
 net/dsa/dsa_priv.h       |  2 ++
 net/dsa/port.c           | 15 ++++++--
 net/dsa/slave.c          | 75 ++++++++++++++++++++++++++++++++++++++++
 net/dsa/switch.c         | 18 ++++++----
 6 files changed, 104 insertions(+), 11 deletions(-)

--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1171,7 +1171,7 @@ mt7530_port_bridge_join(struct dsa_switc
 		 * and not being setup until the port becomes enabled.
 		 */
 		if (dsa_is_user_port(ds, i) && i != port) {
-			if (dsa_to_port(ds, i)->bridge_dev != bridge)
+			if (dsa_to_port(ds, i)->bridge_dev != bridge || dsa_to_port(ds, i)->isolated)
 				continue;
 			if (priv->ports[i].enable)
 				mt7530_set(priv, MT7530_PCR_P(i),
@@ -1268,7 +1268,7 @@ mt7530_port_bridge_leave(struct dsa_swit
 		 * is kept and not being setup until the port becomes enabled.
 		 */
 		if (dsa_is_user_port(ds, i) && i != port) {
-			if (dsa_to_port(ds, i)->bridge_dev != bridge)
+			if (dsa_to_port(ds, i)->bridge_dev != bridge || dsa_to_port(ds, i)->isolated)
 				continue;
 			if (priv->ports[i].enable)
 				mt7530_clear(priv, MT7530_PCR_P(i),
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -214,6 +214,7 @@ struct dsa_port {
 	struct device_node	*dn;
 	unsigned int		ageing_time;
 	bool			vlan_filtering;
+	bool			isolated;
 	u8			stp_state;
 	struct net_device	*bridge_dev;
 	struct devlink_port	devlink_port;
--- a/net/dsa/dsa_priv.h
+++ b/net/dsa/dsa_priv.h
@@ -18,6 +18,7 @@ enum {
 	DSA_NOTIFIER_AGEING_TIME,
 	DSA_NOTIFIER_BRIDGE_JOIN,
 	DSA_NOTIFIER_BRIDGE_LEAVE,
+	DSA_NOTIFIER_BRIDGE_VLAN_SYNC,
 	DSA_NOTIFIER_FDB_ADD,
 	DSA_NOTIFIER_FDB_DEL,
 	DSA_NOTIFIER_MDB_ADD,
@@ -141,6 +142,7 @@ static inline struct net_device *dsa_mas
 }
 
 /* port.c */
+int dsa_broadcast(unsigned long e, void *v);
 int dsa_port_set_state(struct dsa_port *dp, u8 state,
 		       struct switchdev_trans *trans);
 int dsa_port_enable_rt(struct dsa_port *dp, struct phy_device *phy);
--- a/net/dsa/port.c
+++ b/net/dsa/port.c
@@ -13,7 +13,7 @@
 
 #include "dsa_priv.h"
 
-static int dsa_broadcast(unsigned long e, void *v)
+int dsa_broadcast(unsigned long e, void *v)
 {
 	struct dsa_switch_tree *dst;
 	int err = 0;
@@ -154,6 +154,9 @@ int dsa_port_bridge_join(struct dsa_port
 	 */
 	dp->bridge_dev = br;
 
+	if (dp->isolated)
+		return 0;
+
 	err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_JOIN, &info);
 
 	/* The bridging is rolled back on error */
@@ -180,9 +183,15 @@ void dsa_port_bridge_leave(struct dsa_po
 	 */
 	dp->bridge_dev = NULL;
 
-	err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);
+	if (!dp->isolated) {
+		err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);
+		if (err)
+			pr_err("DSA: failed to notify DSA_NOTIFIER_BRIDGE_LEAVE\n");
+	}
+
+	err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_VLAN_SYNC, &info);
 	if (err)
-		pr_err("DSA: failed to notify DSA_NOTIFIER_BRIDGE_LEAVE\n");
+		pr_err("DSA: failed to notify DSA_NOTIFIER_BRIDGE_VLAN_SYNC\n");
 
 	/* Port is leaving the bridge, disable flooding */
 	dsa_port_bridge_flags(dp, 0, NULL);
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -1830,6 +1830,72 @@ static void dsa_slave_notify(struct net_
 	call_dsa_notifiers(val, dev, &rinfo.info);
 }
 
+static ssize_t isolation_show(struct device *d, struct device_attribute *attr,
+			      char *buf)
+{
+	bool isolated;
+	struct net_device *dev = to_net_dev(d);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	if (!rtnl_trylock())
+		return restart_syscall();
+	isolated = dp->isolated;
+	rtnl_unlock();
+	return sprintf(buf, "%c\n", isolated ? 'Y' : 'N');
+}
+
+static ssize_t isolation_store(struct device *d, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	bool bv;
+	int err;
+	struct net_device *dev = to_net_dev(d);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_notifier_bridge_info info;
+
+	err = kstrtobool(buf, &bv);
+	if (err)
+		return err;
+
+	if (!rtnl_trylock())
+		return restart_syscall();
+
+	if (dp->isolated == bv)
+		goto out_unlock;
+
+	dp->isolated = bv;
+
+	if (!dp->bridge_dev)
+		goto out_unlock;
+
+	info.tree_index = dp->ds->dst->index;
+	info.sw_index = dp->ds->index;
+	info.port = dp->index;
+	info.br = dp->bridge_dev;
+
+	if (bv)
+		err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);
+	else
+		err = dsa_broadcast(DSA_NOTIFIER_BRIDGE_JOIN, &info);
+
+out_unlock:
+	rtnl_unlock();
+	if (err)
+		return err;
+	return count;
+}
+
+static DEVICE_ATTR_RW(isolation);
+
+static struct attribute *dsa_slave_attrs[] = {
+	&dev_attr_isolation.attr,
+	NULL
+};
+
+static const struct attribute_group port_group = {
+	.name = "dsa_port",
+	.attrs = dsa_slave_attrs,
+};
+
 int dsa_slave_create(struct dsa_port *port)
 {
 	const struct dsa_port *cpu_dp = port->cpu_dp;
@@ -1934,6 +2000,12 @@ int dsa_slave_create(struct dsa_port *po
 	if (ret)
 		goto out_unregister;
 
+	if (dsa_is_user_port(ds, port->index))
+		ret = sysfs_create_group(&slave_dev->dev.kobj, &port_group);
+
+	if (ret)
+		goto out_unregister;
+
 	return 0;
 
 out_unregister:
@@ -1958,6 +2030,9 @@ void dsa_slave_destroy(struct net_device
 	struct dsa_port *dp = dsa_slave_to_port(slave_dev);
 	struct dsa_slave_priv *p = netdev_priv(slave_dev);
 
+	if (dsa_is_user_port(dp->ds, dp->index))
+		sysfs_remove_group(&slave_dev->dev.kobj, &port_group);
+
 	netif_carrier_off(slave_dev);
 	rtnl_lock();
 	netdev_upper_dev_unlink(master, slave_dev);
--- a/net/dsa/switch.c
+++ b/net/dsa/switch.c
@@ -150,7 +150,6 @@ static int dsa_switch_bridge_leave(struc
 				   struct dsa_notifier_bridge_info *info)
 {
 	struct dsa_switch_tree *dst = ds->dst;
-	int err;
 
 	if (dst->index == info->tree_index && ds->index == info->sw_index &&
 	    ds->ops->port_bridge_leave)
@@ -161,12 +160,16 @@ static int dsa_switch_bridge_leave(struc
 		ds->ops->crosschip_bridge_leave(ds, info->tree_index,
 						info->sw_index, info->port,
 						info->br);
+	return 0;
+}
 
-	if (dst->index == info->tree_index && ds->index == info->sw_index) {
-		err = dsa_switch_sync_vlan_filtering(ds, info);
-		if (err)
-			return err;
-	}
+static int dsa_switch_vlan_sync(struct dsa_switch *ds,
+				struct dsa_notifier_bridge_info *info)
+{
+	struct dsa_switch_tree *dst = ds->dst;
+
+	if (dst->index == info->tree_index && ds->index == info->sw_index)
+		return dsa_switch_sync_vlan_filtering(ds, info);
 
 	return 0;
 }
@@ -334,6 +337,9 @@ static int dsa_switch_event(struct notif
 	case DSA_NOTIFIER_BRIDGE_LEAVE:
 		err = dsa_switch_bridge_leave(ds, info);
 		break;
+	case DSA_NOTIFIER_BRIDGE_VLAN_SYNC:
+		err = dsa_switch_vlan_sync(ds, info);
+		break;
 	case DSA_NOTIFIER_FDB_ADD:
 		err = dsa_switch_fdb_add(ds, info);
 		break;
