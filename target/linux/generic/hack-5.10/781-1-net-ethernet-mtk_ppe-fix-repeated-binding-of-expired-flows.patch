For offloaded flows that have a gap in transmission, hw will set ib1 state
field to MTK_FOE_STATE_UNBIND, as well as clobbering certain configuration
fields, like MTK_FOE_IB1_BIND_VLAN_LAYER.

Since mtk_flow_entry_update() causes entire ib1 value from hw table to be
sync'ed to the software entry, it can prevent that software entry from ever
establishing offloading again, since it will from then on try writing an
ib1 value for an unbound entry.

Fix this by only allowing mtk_flow_entry_update() to update
MTK_FOE_IB1_BIND_TIMESTAMP field of ib1. Also add a check for flow status,
since unbound entries have a different format for timestamps, though it
still would not make sense to use it, even if was read correctly.

--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -478,6 +478,7 @@ mtk_flow_entry_update(struct mtk_ppe *pp
 {
 	struct mtk_foe_entry *hwe;
 	struct mtk_foe_entry foe;
+	u32 ib1;
 
 	spin_lock_bh(&ppe_lock);
 
@@ -491,12 +492,15 @@ mtk_flow_entry_update(struct mtk_ppe *pp
 
 	hwe = &ppe->foe_table[entry->hash];
 	memcpy(&foe, hwe, sizeof(foe));
-	if (!mtk_flow_entry_match(entry, &foe)) {
+	ib1 = READ_ONCE(hwe->ib1);
+	if (!mtk_flow_entry_match(entry, &foe) ||
+	    FIELD_GET(MTK_FOE_IB1_STATE, ib1) != MTK_FOE_STATE_BIND) {
 		entry->hash = 0xffff;
 		goto out;
 	}
 
-	entry->data.ib1 = foe.ib1;
+	entry->data.ib1 &= ~MTK_FOE_IB1_BIND_TIMESTAMP;
+	entry->data.ib1 |= ib1 & MTK_FOE_IB1_BIND_TIMESTAMP;
 
 out:
 	spin_unlock_bh(&ppe_lock);
